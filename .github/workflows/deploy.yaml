name: Build and Deploy
on:
  push:
    branches: [ "main" ]
env:
  CPR_ADDR: cpr.kemosoft.com.br
  K8S_NAMESPACE: consigmais
  DEPLOYMENT_NAME: ${{ github.event.repository.name }}
  CONTAINER_PATH: cpr.kemosoft.com.br/${{ github.event.repository.name }}:${{ github.sha }}
jobs:
  build:
    runs-on: arc-runner-set
    container:
      image: gcr.io/kaniko-project/executor:v1.20.0-debug
    permissions:
      contents: read
    steps:
      - name: build and push image to cpr
        id: build
        run: |
          cat <<EOF > /kaniko/.docker/config.json
          {
            "auths": {
              "$CPR_ADDR": {
                "auth": "$(echo -n "$CPR_USERNAME:$CPR_PASSWORD" | base64 -w0)"
              }
            }
          }
          EOF
          /kaniko/executor --dockerfile="/Dockerfile" \
            --context="${{ github.repositoryUrl }}#${{ github.ref }}#${{ github.sha }}"  \
            --destination="${{ env.CONTAINER_PATH }}" \
            ${{ env.KANIKO_CACHE_ARGS }} \
            --push-retry 5 
        env:
          GIT_USERNAME: ${{ github.actor }}
          GIT_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
          CPR_USERNAME: ${{ secrets.CPR_USERNAME }}
          CPR_PASSWORD: ${{ secrets.CPR_PASSWORD }}
  
  deploy:
    needs:
      - build
    runs-on: k8s
    steps:
      - name: patch deployment
        id: deploy
        run: |
          kubectl -n $K8S_NAMESPACE set image deployment/$DEPLOYMENT_NAME $DEPLOYMENT_NAME=$CONTAINER_PATH --record
          DEPLOY_STATUS=$?
          kubectl -n $K8S_NAMESPACE rollout status deployment/$DEPLOYMENT_NAME
          ROLLOUT_STATUS=$?
          
          # Armazena o status para uso posterior
          if [ $DEPLOY_STATUS -eq 0 ] && [ $ROLLOUT_STATUS -eq 0 ]; then
            DEPLOY_RESULT="success"
          else
            DEPLOY_RESULT="failure"
          fi
          echo "DEPLOY_RESULT=$DEPLOY_RESULT" >> $GITHUB_ENV
          
          # Falha se algum dos comandos falhar
          if [ $DEPLOY_STATUS -ne 0 ] || [ $ROLLOUT_STATUS -ne 0 ]; then
            exit 1
          fi
          
      - name: Send to Discord notification
        if: always()
        run: |
          # Salva o webhook do Discord em uma vari√°vel
          WEBHOOK_URL="${{ secrets.DISCORD_WEBHOOK }}"
          
          # Extrai o host e o path do webhook
          DISCORD_HOST=$(echo $WEBHOOK_URL | sed -e 's|^https://||' -e 's|/.*$||')
          DISCORD_PATH=$(echo $WEBHOOK_URL | sed -e 's|^https://[^/]*||')
          
          # Prepara a mensagem
          if [ "${{ env.DEPLOY_RESULT }}" = "success" ]; then
            STATUS="‚úÖ Success"
          else
            STATUS="‚ùå Failed"
          fi
          
          # Cria a mensagem JSON - vers√£o simplificada
          JSON_DATA='{"content":"**üöÄ Deploy: ${{ github.event.repository.name }}**\n**Status:** '"$STATUS"'\n**Namespace:** ${{ env.K8S_NAMESPACE }}\n**Deployment:** ${{ env.DEPLOYMENT_NAME }}\n**Image:** ${{ env.CONTAINER_PATH }}\n**By:** ${{ github.actor }}"}'
          
          # Tenta usar netcat se dispon√≠vel
          if command -v nc > /dev/null; then
            {
              echo -e "POST $DISCORD_PATH HTTP/1.1"
              echo -e "Host: $DISCORD_HOST"
              echo -e "Content-Type: application/json"
              echo -e "Content-Length: ${#JSON_DATA}"
              echo -e "\r\n"
              echo -e "$JSON_DATA"
            } | nc $DISCORD_HOST 443 -N
          # Alternativa usando somente bash e /dev/tcp se dispon√≠vel
          elif [ -w /dev/tcp/$DISCORD_HOST/443 ]; then
            exec 3>/dev/tcp/$DISCORD_HOST/443
            
            echo -e "POST $DISCORD_PATH HTTP/1.1\r
            Host: $DISCORD_HOST\r
            Content-Type: application/json\r
            Content-Length: ${#JSON_DATA}\r
            \r
            $JSON_DATA" >&3
            
            exec 3>&-
          else
            echo "N√£o foi poss√≠vel enviar a notifica√ß√£o para o Discord. Nem nc nem /dev/tcp est√£o dispon√≠veis."
            echo "Deploy status: $STATUS"
          fi
