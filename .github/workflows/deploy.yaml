name: Build and Deploy

on:
  push:
    branches: ['main', 'development']
  pull_request:
    branches: ['main', 'development']

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  CPR_ADDR: cpr.kemosoft.com.br
  K8S_NAMESPACE: consigmais
  DEPLOYMENT_NAME: ${{ github.event.repository.name }}${{ github.ref_name == 'main' && '-prod' || '-dev' }}
  CONTAINER_PATH: cpr.kemosoft.com.br/${{ github.event.repository.name }}:${{ github.sha }}
  # Definir domínio baseado na branch
  DOMAIN: ${{ github.ref_name == 'main' && 'api-semtas-natal.pgben.com.br' || format('{0}.kemosoft.com.br', github.event.repository.name) }}

jobs:
  build:
    runs-on: ubuntu-latest  # Usar runner público com Docker
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.CPR_ADDR }}
          username: ${{ secrets.CPR_USERNAME }}
          password: ${{ secrets.CPR_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ env.CONTAINER_PATH }}

  deploy:
    needs:
      - build
    runs-on: k8s
    steps:
      - name: patch deployment
        run: |
          echo "Deploying to branch: ${{ github.ref_name }}"
          echo "Deployment name: $DEPLOYMENT_NAME"
          echo "Domain: $DOMAIN"
          
          if ! kubectl get deployment $DEPLOYMENT_NAME -n $K8S_NAMESPACE &>/dev/null; then
            echo "Deployment does not exist, creating..."
            kubectl create deployment $DEPLOYMENT_NAME -n $K8S_NAMESPACE --image=$CONTAINER_PATH
            
            # Adiciona o imagePullSecret logo após criar o deployment
            kubectl patch deployment $DEPLOYMENT_NAME -n $K8S_NAMESPACE -p '{"spec":{"template":{"spec":{"imagePullSecrets":[{"name":"cpr"}]}}}}'
          else
            echo "Deployment exists, updating image..."
            # Descobrir o nome real do container
            CONTAINER_NAME=$(kubectl -n $K8S_NAMESPACE get deployment $DEPLOYMENT_NAME -o jsonpath='{.spec.template.spec.containers[0].name}')
            echo "Container name found: $CONTAINER_NAME"
            kubectl -n $K8S_NAMESPACE set image deployment/$DEPLOYMENT_NAME $CONTAINER_NAME=$CONTAINER_PATH
          fi
          
          echo "Aguardando rollout do deployment (timeout aumentado para 15 minutos)..."
          kubectl -n $K8S_NAMESPACE rollout status deployment/$DEPLOYMENT_NAME --timeout=15m
          
          # Aplicar configurações de progressDeadlineSeconds e probes
          if [ "$?" -eq 0 ]; then
            echo "Aplicando configurações otimizadas de health checks e recursos..."
            # Descobrir o nome real do container para o patch
            CONTAINER_NAME=$(kubectl -n $K8S_NAMESPACE get deployment $DEPLOYMENT_NAME -o jsonpath='{.spec.template.spec.containers[0].name}')
            echo "Applying patch to container: $CONTAINER_NAME"
            kubectl -n $K8S_NAMESPACE patch deployment $DEPLOYMENT_NAME -p '
            {
              "spec": {
                "progressDeadlineSeconds": 1200,
                "strategy": {
                  "type": "RollingUpdate",
                  "rollingUpdate": {
                    "maxSurge": 1,
                    "maxUnavailable": 0
                  }
                },
                "template": {
                  "spec": {
                    "containers": [{
                      "name": "'"$CONTAINER_NAME"'",
                      "image": "'"$CONTAINER_PATH"'",
                      "resources": {
                        "requests": {
                          "memory": "512Mi",
                          "cpu": "500m"
                        },
                        "limits": {
                          "memory": "1Gi",
                          "cpu": "1000m"
                        }
                      },
                      "startupProbe": {
                        "httpGet": {
                          "path": "/health",
                          "port": 3000
                        },
                        "initialDelaySeconds": 60,
                        "periodSeconds": 15,
                        "timeoutSeconds": 10,
                        "failureThreshold": 40
                      },
                      "readinessProbe": {
                        "httpGet": {
                          "path": "/health/ready",
                          "port": 3000
                        },
                        "initialDelaySeconds": 90,
                        "periodSeconds": 15,
                        "timeoutSeconds": 10,
                        "failureThreshold": 5
                      },
                      "livenessProbe": {
                        "httpGet": {
                          "path": "/health",
                          "port": 3000
                        },
                        "initialDelaySeconds": 180,
                        "periodSeconds": 30,
                        "timeoutSeconds": 15,
                        "failureThreshold": 5
                      }
                    }]
                  }
                }
              }
            }'
          fi

  deploy-kubernetes-resources:
    needs:
      - deploy
    runs-on: k8s
    steps:
      - name: Deploy Kubernetes Resources
        run: |
          set -e
          # Parâmetros da linha de comando
          NAMESPACE="${{ env.K8S_NAMESPACE }}"
          APP_NAME="${{ env.DEPLOYMENT_NAME }}"
          PORT=80
          TARGET_PORT=3000  # Porta exposta no container
          DOMAIN="${{ env.DOMAIN }}"

          echo "Configurando recursos para: $APP_NAME"
          echo "Namespace: $NAMESPACE"
          echo "Branch: ${{ github.ref_name }}"
          echo "Porta externa: $PORT, Porta interna: $TARGET_PORT"
          echo "Domínio: $DOMAIN"

          # Verificar se o certificado já existe
          if ! kubectl get certificate ${APP_NAME}-cert -n ${NAMESPACE} &> /dev/null; then
            echo "Criando certificado ${APP_NAME}-cert..."
            cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: Certificate
          metadata:
            name: ${APP_NAME}-cert
            namespace: ${NAMESPACE}
          spec:
            secretName: ${APP_NAME}-cert
            issuerRef:
              name: letsencrypt-prod
              kind: Issuer
            dnsNames:
            - ${DOMAIN}
          EOF
            echo "Certificado ${APP_NAME}-cert criado com sucesso!"
          else
            echo "Certificado ${APP_NAME}-cert já existe. Pulando criação."
          fi

          # Verificar se o serviço já existe
          if ! kubectl get svc ${APP_NAME}-svc -n ${NAMESPACE} &> /dev/null; then
            echo "Criando serviço ${APP_NAME}-svc..."
            cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Service
          metadata:
            annotations: {}
            labels:
              app: ${APP_NAME}
            name: ${APP_NAME}-svc
            namespace: ${NAMESPACE}
          spec:
            ports:
            - name: ${APP_NAME}
              port: ${PORT}
              protocol: TCP
              targetPort: ${TARGET_PORT}  # Porta do container
            selector:
              app: ${APP_NAME}
            type: ClusterIP
          EOF
            echo "Serviço ${APP_NAME}-svc criado com sucesso!"
          else
            echo "Serviço ${APP_NAME}-svc já existe. Pulando criação."
          fi

          # Verificar se o ingress já existe
          if ! kubectl get ingress ${APP_NAME}-ingress -n ${NAMESPACE} &> /dev/null; then
            echo "Criando ingress ${APP_NAME}-ingress..."
            cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            annotations:
              cert-manager.io/issuer: letsencrypt-prod
              nginx.ingress.kubernetes.io/add-headers: |
                add_header 'Access-Control-Allow-Origin' '*';
                add_header 'Access-Control-Allow-Methods' '*';
                add_header 'Access-Control-Allow-Headers' '*';
              nginx.ingress.kubernetes.io/backend-protocol: HTTP
              nginx.ingress.kubernetes.io/proxy-body-size: 100M
            name: ${APP_NAME}-ingress
            namespace: ${NAMESPACE}
          spec:
            ingressClassName: nginx
            rules:
            - host: ${DOMAIN}
              http:
                paths:
                - backend:
                    service:
                      name: ${APP_NAME}-svc
                      port:
                        number: ${PORT}  # Esta é a porta do serviço
                  path: /
                  pathType: Prefix
            tls:
            - hosts:
              - ${DOMAIN}
              secretName: ${APP_NAME}-cert
          EOF
            echo "Ingress ${APP_NAME}-ingress criado com sucesso!"
            echo ""
            echo "============================================================"
            echo "ATENÇÃO: CONFIGURAÇÃO DE DNS NECESSÁRIA"
            echo "============================================================"
            echo "Para a branch ${{ github.ref_name }}: $DOMAIN"
            echo "============================================================"
            echo ""
          else
            echo "Ingress ${APP_NAME}-ingress já existe. Pulando criação."
          fi
          echo "Configuração concluída para a branch ${{ github.ref_name }}!"
