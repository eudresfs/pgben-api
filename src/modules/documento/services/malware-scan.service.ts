import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as NodeClam from 'clamscan';

/**
 * Serviço de verificação de malware
 *
 * Responsável por verificar arquivos em busca de malware
 * utilizando o ClamAV como engine de antivírus
 */
@Injectable()
export class MalwareScanService implements OnModuleInit {
  private readonly logger = new Logger(MalwareScanService.name);
  private scanner: any;
  private isInitialized = false;
  private initPromise: Promise<void>;

  constructor(private configService: ConfigService) {}

  /**
   * Inicializa o scanner ao iniciar o módulo
   */
  async onModuleInit() {
    this.initPromise = this.initScanner();
    await this.initPromise;
  }

  /**
   * Inicializa o scanner de malware
   */
  private async initScanner(): Promise<void> {
    try {
      // Configurações do ClamAV
      const clamConfig = {
        clamdscan: {
          socket: this.configService.get<string>(
            'CLAMAV_SOCKET',
            '/var/run/clamav/clamd.ctl',
          ),
          host: this.configService.get<string>('CLAMAV_HOST', '127.0.0.1'),
          port: this.configService.get<number>('CLAMAV_PORT', 3310),
        },
        preference: 'clamdscan',
      };

      this.logger.log('Inicializando scanner de malware...');
      this.scanner = await new NodeClam().init(clamConfig);
      this.isInitialized = true;
      this.logger.log('Scanner de malware inicializado com sucesso');
    } catch (error) {
      this.logger.error(
        `Erro ao inicializar scanner de malware: ${error.message}`,
      );
      this.logger.warn(
        'O sistema continuará funcionando sem verificação de malware',
      );
      this.isInitialized = false;
    }
  }

  /**
   * Verifica um buffer em busca de malware
   * @param buffer Buffer do arquivo a ser verificado
   * @param filename Nome do arquivo (usado apenas para logs)
   * @returns Resultado da verificação
   */
  async scanBuffer(
    buffer: Buffer,
    filename: string,
  ): Promise<{
    isInfected: boolean;
    viruses: string[];
    error?: string;
  }> {
    // Aguardar inicialização se ainda não estiver pronta
    if (!this.isInitialized && this.initPromise) {
      try {
        await this.initPromise;
      } catch (error) {
        // Continuar mesmo se a inicialização falhar
      }
    }

    // Se o scanner não estiver disponível, retornar sem verificação
    if (!this.isInitialized || !this.scanner) {
      this.logger.warn(
        `Verificação de malware ignorada para ${filename}: scanner não disponível`,
      );
      return {
        isInfected: false,
        viruses: [],
        error: 'Scanner de malware não disponível',
      };
    }

    try {
      this.logger.debug(
        `Verificando arquivo ${filename} em busca de malware...`,
      );
      const result = await this.scanner.scanBuffer(buffer);

      if (result.isInfected) {
        this.logger.warn(
          `Malware detectado em ${filename}: ${result.viruses.join(', ')}`,
        );
      } else {
        this.logger.debug(`Nenhum malware detectado em ${filename}`);
      }

      return {
        isInfected: result.isInfected,
        viruses: result.viruses || [],
      };
    } catch (error) {
      this.logger.error(
        `Erro ao verificar arquivo ${filename}: ${error.message}`,
      );
      return {
        isInfected: false,
        viruses: [],
        error: `Erro ao verificar arquivo: ${error.message}`,
      };
    }
  }

  /**
   * Verifica se o scanner está disponível
   * @returns true se o scanner está disponível, false caso contrário
   */
  isAvailable(): boolean {
    return this.isInitialized && !!this.scanner;
  }
}
