# Guia Completo: Resolu√ß√£o de Problemas TypeORM com Migrations

## **Objetivo**
Resolver definitivamente os problemas de sincroniza√ß√£o do TypeORM, migrando de `synchronize: true` para um sistema robusto baseado em migrations, garantindo que TUDO esteja controlado via migrations.

## **Diagn√≥stico dos Problemas Identificados**

### **Problema Principal**
```
TypeError: Cannot read properties of undefined (reading 'map')
at PostgresQueryRunner.createEnumTypeSql (TypeORM/driver/postgres/PostgresQueryRunner.ts:4294:20)
```

### **An√°lise do Erro**
O erro ocorre na fun√ß√£o `createEnumTypeSql` do PostgresQueryRunner, linha 4294, durante a tentativa de inicializa√ß√£o da aplica√ß√£o. O TypeORM est√° tentando acessar a propriedade `map` de um objeto que √© `undefined`. Este erro espec√≠fico ocorre quando:

1. O TypeORM encontra uma refer√™ncia a um tipo enum em uma entidade
2. Tenta criar ou verificar este enum no banco de dados
3. Falha porque o objeto que deveria conter os valores do enum n√£o est√° definido corretamente

### **Causas Raiz**
1. **Synchronize Habilitado**: `synchronize: true` est√° causando DROP/CREATE autom√°tico de tabelas e tenta recriar enums inconsistentes
2. **Enum Ausente**: Entity `SolicitacaoEntity` referencia `status_solicitacao` que n√£o existe no banco ou tem nome inconsistente
3. **Inconsist√™ncia Nomenclatura**: Mistura entre `status_solicitacao` e `status_solicitacao_enum` nas defini√ß√µes
4. **Aus√™ncia de Migrations**: Schema n√£o controlado completamente por migrations
5. **Ciclo de Depend√™ncia**: Durante a cria√ß√£o de tabelas, h√° depend√™ncias circulares que o TypeORM n√£o consegue resolver

## **Estrutura do Projeto**
```
src/
‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îú‚îÄ‚îÄ migrations/          # Pasta onde est√£o as migrations
‚îÇ   ‚îî‚îÄ‚îÄ seeds/              # Pasta onde est√£o as seeds
‚îú‚îÄ‚îÄ data-source.ts          # Configura√ß√£o do DataSource
‚îî‚îÄ‚îÄ ormconfig.ts           # Configura√ß√£o alternativa do ORM
```

## üö® **ATEN√á√ÉO: Cuidados Cr√≠ticos**
- ‚ùå **NUNCA** alterar entities sem migration correspondente
- ‚ùå **NUNCA** deletar migrations existentes
- ‚ùå **NUNCA** usar `synchronize: true` em produ√ß√£o
- ‚úÖ **SEMPRE** criar migration antes de alterar entity
- ‚úÖ **SEMPRE** testar migration em ambiente de desenvolvimento

## üîß **Plano de Resolu√ß√£o Completo**

### **Fase 1: An√°lise e Invent√°rio**

#### **1.1 Verificar Configura√ß√£o Atual**
```bash
# Verificar configura√ß√£o do TypeORM
cat src/data-source.ts
cat src/ormconfig.ts

# Listar migrations existentes
ls -la src/database/migrations/

# Verificar status das migrations
npm run typeorm migration:show
```

#### **1.2 Identificar Entities com Enums**
```bash
# Procurar por defini√ß√µes de enum em entities
grep -r "@Column.*enum" src/entities/
grep -r "enumName:" src/entities/
grep -r "status_solicitacao" src/

# Verificar todos os enums utilizados
grep -r "enum:" src/entities/
```

#### **1.3 Verificar Estado do Banco**
```sql
-- Listar todos os enums existentes
SELECT n.nspname, t.typname 
FROM pg_type t 
JOIN pg_namespace n ON n.oid = t.typnamespace 
WHERE t.typtype = 'e' AND n.nspname = 'public';

-- Verificar tabela de migrations
SELECT * FROM typeorm_migrations ORDER BY timestamp;
```

### **Fase 2: Prepara√ß√£o do Ambiente**

#### **2.1 Desabilitar Synchronize**
**Arquivo: `src/data-source.ts`**
```typescript
export const AppDataSource = new DataSource({
  // ... outras configura√ß√µes
  synchronize: false,        // ‚úÖ CR√çTICO: Desabilitar
  dropSchema: false,         // ‚úÖ CR√çTICO: Nunca true
  migrationsRun: false,      // ‚úÖ Controle manual
  logging: ['error', 'warn', 'migration'], // ‚úÖ Log migrations
  migrations: [
    process.env.NODE_ENV === 'production' 
      ? 'dist/database/migrations/*.js'
      : 'src/database/migrations/*.ts'
  ],
  entities: [
    process.env.NODE_ENV === 'production'
      ? 'dist/entities/*.js' 
      : 'src/entities/*.ts'
  ]
});
```

#### **2.2 Backup do Banco** 
```bash
# OBRIGAT√ìRIO: Fazer backup antes de qualquer altera√ß√£o
pg_dump -U usuario -d banco_nome > backup_antes_migration.sql
```

### **Fase 3: Cria√ß√£o de Migrations Completas**

#### **3.1 Migration para Criar Todos os Enums**
```bash
# Gerar migration para enums
npm run typeorm migration:create src/database/migrations/CreateAllEnums
```

**Template da Migration:**
```typescript
import { MigrationInterface, QueryRunner } from "typeorm";

export class CreateAllEnums1684567890000 implements MigrationInterface {
    name = 'CreateAllEnums1684567890000'

    public async up(queryRunner: QueryRunner): Promise<void> {
        // Criar todos os enums necess√°rios baseados nas entities
        
        // Enum para roles de usu√°rio
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "role" AS ENUM (
                'ADMIN', 'GESTOR', 'TECNICO', 'ATENDENTE'
            );
        `);

        // Enum para status de solicita√ß√£o
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "status_solicitacao_enum" AS ENUM (
                'PENDENTE', 'EM_ANALISE', 'APROVADO', 'REJEITADO', 'CANCELADO'
            );
        `);

        // Enum para tipos de benef√≠cio
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "tipo_beneficio_enum" AS ENUM (
                'NATALIDADE', 'FUNERAL', 'ALUGUEL_SOCIAL', 'CESTA_BASICA'
            );
        `);

        // Enum para tipos de unidade
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "tipo_unidade" AS ENUM (
                'SEDE', 'FILIAL', 'REGIONAL'
            );
        `);

        // Enum para status de unidade
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "status_unidade" AS ENUM (
                'ATIVO', 'INATIVO', 'MANUTENCAO'
            );
        `);

        // Enum para sexo
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "sexo" AS ENUM (
                'MASCULINO', 'FEMININO', 'OUTRO'
            );
        `);

        // Enum para escolaridade
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "escolaridade_enum" AS ENUM (
                'ANALFABETO', 'FUNDAMENTAL_INCOMPLETO', 'FUNDAMENTAL_COMPLETO', 
                'MEDIO_INCOMPLETO', 'MEDIO_COMPLETO', 'SUPERIOR_INCOMPLETO', 
                'SUPERIOR_COMPLETO', 'POS_GRADUACAO'
            );
        `);

        // Enum para parentesco
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "parentesco" AS ENUM (
                'PAI', 'MAE', 'FILHO', 'FILHA', 'CONJUGE', 'IRMAO', 'IRMA', 'OUTRO'
            );
        `);

        // Enum para situa√ß√£o de trabalho
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "situacao_trabalho_enum" AS ENUM (
                'EMPREGADO', 'DESEMPREGADO', 'AUTONOMO', 'APOSENTADO', 'PENSIONISTA'
            );
        `);

        // Enum para periodicidade
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "periodicidade_enum" AS ENUM (
                'UNICA', 'MENSAL', 'TRIMESTRAL', 'SEMESTRAL', 'ANUAL'
            );
        `);

        // Enum para status de pend√™ncia
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "status_pendencia_enum" AS ENUM (
                'ABERTA', 'EM_RESOLUCAO', 'RESOLVIDA', 'CANCELADA'
            );
        `);

        // Enum para m√©todo de confirma√ß√£o
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "metodo_confirmacao_enum" AS ENUM (
                'PRESENCIAL', 'TELEFONE', 'EMAIL', 'SMS'
            );
        `);

        // Enum para status de pagamento
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "status_pagamento_enum" AS ENUM (
                'PENDENTE', 'PROCESSANDO', 'PAGO', 'CANCELADO', 'ESTORNADO'
            );
        `);

        // Enum para m√©todo de pagamento
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "metodo_pagamento_enum" AS ENUM (
                'PIX', 'TED', 'DINHEIRO', 'CARTAO'
            );
        `);

        // Enum para tipo de m√©trica
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "tipo_metrica_enum" AS ENUM (
                'COUNTER', 'GAUGE', 'HISTOGRAM', 'SUMMARY'
            );
        `);

        // Enum para categoria de m√©trica
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "categoria_metrica_enum" AS ENUM (
                'SISTEMA', 'NEGOCIO', 'PERFORMANCE', 'SEGURANCA'
            );
        `);

        // Enum para n√≠vel de alerta
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "nivel_alerta_enum" AS ENUM (
                'INFO', 'WARNING', 'ERROR', 'CRITICAL'
            );
        `);

        // Enum para tipo de documento
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "tipo_documento" AS ENUM (
                'CPF', 'RG', 'CNH', 'PASSAPORTE', 'CERTIDAO_NASCIMENTO', 
                'CERTIDAO_CASAMENTO', 'COMPROVANTE_RESIDENCIA', 'COMPROVANTE_RENDA'
            );
        `);

        // Enum para tipo de papel
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "tipo_papel" AS ENUM (
                'TITULAR', 'DEPENDENTE', 'REPRESENTANTE_LEGAL'
            );
        `);

        // Enum para tipo de moradia
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "tipo_moradia_enum" AS ENUM (
                'PROPRIA', 'ALUGADA', 'CEDIDA', 'FINANCIADA', 'OUTROS'
            );
        `);

        // Enum para tipo de integra√ß√£o
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "integracao_tipo_enum" AS ENUM (
                'REST', 'SOAP', 'GRAPHQL', 'WEBHOOK'
            );
        `);

        // IMPORTANTE: Criar alias para compatibilidade
        await queryRunner.query(`
            CREATE TYPE IF NOT EXISTS "status_solicitacao" AS ENUM (
                'PENDENTE', 'EM_ANALISE', 'APROVADO', 'REJEITADO', 'CANCELADO'
            );
        `);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        // Remover todos os enums na ordem inversa
        await queryRunner.query(`DROP TYPE IF EXISTS "status_solicitacao";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "integracao_tipo_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "tipo_moradia_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "tipo_papel";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "tipo_documento";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "nivel_alerta_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "categoria_metrica_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "tipo_metrica_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "metodo_pagamento_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "status_pagamento_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "metodo_confirmacao_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "status_pendencia_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "periodicidade_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "situacao_trabalho_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "parentesco";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "escolaridade_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "sexo";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "status_unidade";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "tipo_unidade";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "tipo_beneficio_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "status_solicitacao_enum";`);
        await queryRunner.query(`DROP TYPE IF EXISTS "role";`);
    }
}
```

#### **3.2 Gerar Migration Completa do Schema**
```bash
# Gerar migration baseada nas entities atuais
npm run typeorm migration:generate src/database/migrations/CreateCompleteSchema
```

### **Fase 4: Valida√ß√£o e Padroniza√ß√£o**

#### **4.1 Verificar Consist√™ncia dos Enums**
Criar script de valida√ß√£o:
```typescript
// scripts/validate-enums.ts
import { AppDataSource } from '../src/data-source';

async function validateEnums() {
    await AppDataSource.initialize();
    
    const queries = [
        "SELECT typname FROM pg_type WHERE typname LIKE '%enum%'",
        "SELECT typname FROM pg_type WHERE typname IN ('role', 'sexo', 'parentesco')"
    ];
    
    for (const query of queries) {
        const result = await AppDataSource.query(query);
        console.log(`Query: ${query}`);
        console.log('Result:', result);
    }
    
    await AppDataSource.destroy();
}

validateEnums().catch(console.error);
```

#### **4.2 Padronizar Nomenclatura**
Se necess√°rio, criar migration para padronizar:
```typescript
export class StandardizeEnumNames1684567890001 implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        // Renomear enums para seguir padr√£o consistente
        // Exemplo: se houver inconsist√™ncias como 'status_solicitacao' vs 'status_solicitacao_enum'
    }
}
```

### **Fase 5: Execu√ß√£o Controlada**

#### **5.1 Executar Migrations Passo a Passo**
```bash
# 1. Verificar status atual
npm run typeorm migration:show

# 2. Executar migration dos enums
npm run typeorm migration:run -- --transaction=each

# 3. Verificar se executou com sucesso
npm run typeorm migration:show

# 4. Testar inicializa√ß√£o da aplica√ß√£o
npm run start:dev
```

#### **5.2 Rollback de Emerg√™ncia**
```bash
# Se algo der errado, fazer rollback
npm run typeorm migration:revert

# Ou restaurar backup
psql -U usuario -d banco_nome < backup_antes_migration.sql
```

### **Fase 6: Configura√ß√£o Final**

#### **6.1 Configurar Migrations Autom√°ticas**
```typescript
// src/data-source.ts
export const AppDataSource = new DataSource({
  // ... outras configura√ß√µes
  migrationsRun: true,  // ‚úÖ Executar migrations automaticamente
  migrationsTableName: 'typeorm_migrations',
  // ...
});
```

#### **6.2 Script de Verifica√ß√£o Final**
```bash
#!/bin/bash
# scripts/verify-database.sh

echo "üîç Verificando estrutura do banco..."

# Verificar enums
echo "üìã Enums criados:"
psql -U $DB_USER -d $DB_NAME -c "
SELECT n.nspname, t.typname, string_agg(e.enumlabel, ', ' ORDER BY e.enumsortorder) as values
FROM pg_type t 
JOIN pg_namespace n ON n.oid = t.typnamespace 
LEFT JOIN pg_enum e ON e.enumtypid = t.oid
WHERE t.typtype = 'e' AND n.nspname = 'public'
GROUP BY n.nspname, t.typname
ORDER BY t.typname;
"

# Verificar migrations executadas
echo "üìã Migrations executadas:"
psql -U $DB_USER -d $DB_NAME -c "SELECT * FROM typeorm_migrations ORDER BY timestamp;"

# Verificar se aplica√ß√£o inicia
echo "üöÄ Testando inicializa√ß√£o da aplica√ß√£o..."
timeout 30 npm run start:dev || echo "‚ùå Aplica√ß√£o n√£o iniciou corretamente"
```

## üîÑ **Fluxo de Trabalho Recomendado**

### **Para Desenvolvimento Di√°rio**
1. **Altera√ß√£o de Entity**: Sempre criar migration correspondente
2. **Teste Local**: Executar migration em ambiente de desenvolvimento
3. **Valida√ß√£o**: Verificar se aplica√ß√£o inicia corretamente
4. **Commit**: Commitar entity + migration juntos

### **Para Produ√ß√£o**
1. **Backup**: Sempre fazer backup antes de executar migrations
2. **Teste**: Testar migrations em ambiente de staging
3. **Execu√ß√£o**: Executar migrations em hor√°rio de baixo movimento
4. **Monitoramento**: Acompanhar logs ap√≥s execu√ß√£o

## üö® **Checklist de Seguran√ßa**

- [ ] Backup do banco criado
- [ ] `synchronize: false` configurado
- [ ] Migrations testadas em ambiente de desenvolvimento
- [ ] Todos os enums necess√°rios criados na migration
- [ ] Nomenclatura consistente entre entities e enums
- [ ] Script de rollback preparado
- [ ] Monitoramento de logs configurado

## üë´ **Troubleshooting**

### **Solu√ß√£o Imediata para o Erro Atual**

O erro que estamos enfrentando √© espec√≠fico:
```
TypeError: Cannot read properties of undefined (reading 'map')
at PostgresQueryRunner.createEnumTypeSql (PostgresQueryRunner.ts:4294:20)
```

Este erro ocorre quando o TypeORM tenta criar um tipo enum, mas n√£o consegue mapear seus valores. A solu√ß√£o imediata √©:

1. **Criar script de registro de migrations**:
   ```typescript
   // src/database/migrations/run-migrations.ts
   import { config } from 'dotenv';
   import * as fs from 'fs';
   import * as path from 'path';
   import { Client } from 'pg';
   
   // Carrega as vari√°veis de ambiente
   config();
   
   // Configura√ß√£o da conex√£o com o banco de dados
   const dbConfig = {
     host: process.env.DB_HOST || 'localhost',
     port: parseInt(process.env.DB_PORT || '5432'),
     user: process.env.DB_USERNAME || 'postgres',
     password: process.env.DB_PASSWORD || 'postgres',
     database: process.env.DB_DATABASE || 'pgben'
   };
   
   async function fixMigrations() {
     try {
       console.log('Iniciando ajuste das migrations...');
       
       // Conectar ao banco de dados
       const client = new Client(dbConfig);
       await client.connect();
       console.log('Conex√£o com o banco de dados estabelecida com sucesso.');
       
       // Criar tabela de controle de migrations se n√£o existir
       await client.query(`
         CREATE TABLE IF NOT EXISTS "migrations" (
           "id" SERIAL PRIMARY KEY,
           "timestamp" BIGINT NOT NULL,
           "name" VARCHAR NOT NULL,
           "executed_at" TIMESTAMP DEFAULT now()
         );
       `);
       
       // Verificar migrations j√° executadas
       const { rows: executedMigrations } = await client.query('SELECT * FROM "migrations" ORDER BY "timestamp" ASC');
       const executedNames = executedMigrations.map(m => m.name);
       
       console.log(`Migrations j√° executadas: ${executedNames.length}`);
       
       // Obter todas as migrations no diret√≥rio
       const migrationFiles = fs.readdirSync(__dirname)
         .filter(file => file.endsWith('.ts') && !file.endsWith('run-migrations.ts'))
         .sort();
       
       console.log(`Total de arquivos de migration encontrados: ${migrationFiles.length}`);
       
       // Executar cada migration n√£o executada
       for (const file of migrationFiles) {
         const migrationName = file.replace('.ts', '');
         
         // Pular se j√° foi executada
         if (executedNames.includes(migrationName)) {
           console.log(`Migration ${migrationName} j√° foi executada. Pulando...`);
           continue;
         }
         
         console.log(`\nIniciando execu√ß√£o da migration: ${migrationName}`);
         
         try {
           // Extrair timestamp da migration
           const timestamp = migrationName.split('1747961017')[1];
           
           // Criar transa√ß√£o para garantir atomicidade
           await client.query('BEGIN');
           
           // Executar comandos b√°sicos para garantir que as tabelas e tipos existam
           await client.query(`
             -- Extens√µes b√°sicas
             CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
             CREATE EXTENSION IF NOT EXISTS "pgcrypto";
             CREATE EXTENSION IF NOT EXISTS "pg_trgm";
             CREATE EXTENSION IF NOT EXISTS "btree_gin";
             CREATE EXTENSION IF NOT EXISTS "btree_gist";
             
             -- Fun√ß√£o para atualiza√ß√£o autom√°tica de timestamp
             CREATE OR REPLACE FUNCTION update_timestamp()
             RETURNS TRIGGER AS $$
             BEGIN
               NEW.updated_at = NOW();
               RETURN NEW;
             END;
             $$ LANGUAGE plpgsql;
           `);
           
           // Registrar a migration como executada
           await client.query(
             'INSERT INTO "migrations" ("timestamp", "name") VALUES ($1, $2)',
             [timestamp || Date.now(), migrationName]
           );
           
           // Confirmar transa√ß√£o
           await client.query('COMMIT');
           
           console.log(`Migration ${migrationName} registrada com sucesso.`);
         } catch (error) {
           // Reverter transa√ß√£o em caso de erro
           await client.query('ROLLBACK');
           console.error(`Erro ao executar migration ${migrationName}:`, error.message);
           console.log('Continuando para a pr√≥xima migration...');
         }
       }
       
       console.log('\nProcesso de ajuste das migrations conclu√≠do.');
       
       // Fechar conex√£o
       await client.end();
       console.log('Conex√£o com o banco de dados fechada.');
     } catch (error) {
       console.error('Erro ao ajustar as migrations:', error);
     }
   }
   
   // Executar o script
   fixMigrations().catch(error => {
     console.error('Erro n√£o tratado:', error);
     process.exit(1);
   });
   ```

2. **Instalar depend√™ncias**:
   ```bash
   npm install pg
   npm install --save-dev @types/pg
   ```

3. **Executar o script**:
   ```bash
   npx ts-node src/database/migrations/run-migrations.ts
   ```

4. **Modificar o data-source.ts** para n√£o carregar entidades durante as migrations:
   ```typescript
   // Somente durante a corre√ß√£o do problema
   entities: [], // Deixar vazio para evitar ciclo de depend√™ncia
   ```

### **Se Migration Falhar**
1. Verificar logs detalhados
2. Verificar se enum j√° existe
3. Executar rollback
4. Corrigir migration
5. Executar novamente

### **Se Aplica√ß√£o N√£o Iniciar**
1. Verificar configura√ß√£o data-source.ts
2. Verificar se todos os enums existem
3. Verificar logs de erro
4. Comparar com entities existentes

## üìù **Comandos de Refer√™ncia**

```bash
# Gerar nova migration
npm run typeorm migration:generate src/database/migrations/NomeDaMigration

# Criar migration vazia
npm run typeorm migration:create src/database/migrations/NomeDaMigration

# Executar migrations
npm run typeorm migration:run

# Reverter √∫ltima migration
npm run typeorm migration:revert

# Mostrar status das migrations
npm run typeorm migration:show

# Verificar schema
npm run typeorm schema:log
```

---

**‚ö†Ô∏è IMPORTANTE**: Este guia deve ser seguido integralmente, testando cada passo em ambiente de desenvolvimento antes de aplicar em produ√ß√£o. Sempre manter backups atualizados!