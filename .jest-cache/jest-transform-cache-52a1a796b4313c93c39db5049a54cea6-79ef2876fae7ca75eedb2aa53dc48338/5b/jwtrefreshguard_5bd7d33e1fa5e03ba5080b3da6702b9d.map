{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\auth\\guards\\jwt-refresh.guard.ts","mappings":";;;;;;;;;AAAA,2CAKwB;AAGxB;;;;;GAKG;AAEI,IAAM,eAAe,GAArB,MAAM,eAAe;IAC1B;;OAEG;IACH,KAAK,CAAC,WAAW,CAAC,OAAyB;QACzC,IAAI,CAAC;YACH,2CAA2C;YAC3C,MAAM,OAAO,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC,UAAU,EAAE,CAAC;YACpD,MAAM,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC;YAEjD,IAAI,CAAC,UAAU,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE,CAAC;gBACrD,MAAM,IAAI,8BAAqB,CAAC,oCAAoC,CAAC,CAAC;YACxE,CAAC;YAED,kBAAkB;YAClB,MAAM,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YAEvC,IAAI,CAAC,KAAK,EAAE,CAAC;gBACX,MAAM,IAAI,8BAAqB,CAAC,+BAA+B,CAAC,CAAC;YACnE,CAAC;YAED,+DAA+D;YAC/D,mDAAmD;YACnD,kFAAkF;YAClF,uDAAuD;YAEvD,wEAAwE;YACxE,0EAA0E;YAE1E,OAAO,IAAI,CAAC;QACd,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,KAAK,YAAY,8BAAqB,EAAE,CAAC;gBAC3C,MAAM,KAAK,CAAC;YACd,CAAC;YAED,MAAM,IAAI,8BAAqB,CAC7B,+CAA+C,CAChD,CAAC;QACJ,CAAC;IACH,CAAC;CACF,CAAA;AAxCY,0CAAe;0BAAf,eAAe;IAD3B,IAAA,mBAAU,GAAE;GACA,eAAe,CAwC3B","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\auth\\guards\\jwt-refresh.guard.ts"],"sourcesContent":["import {\n  CanActivate,\n  ExecutionContext,\n  Injectable,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { STRATEGY_JWT_REFRESH } from '../constants/strategy.constant';\n\n/**\n * Guard para autenticação JWT com token de atualização\n *\n * Implementação simplificada que evita problemas de incompatibilidade de tipos\n * entre diferentes versões das bibliotecas.\n */\n@Injectable()\nexport class JwtRefreshGuard implements CanActivate {\n  /**\n   * Verifica se o usuário pode acessar o endpoint\n   */\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    try {\n      // Obter o token do cabeçalho da requisição\n      const request = context.switchToHttp().getRequest();\n      const authHeader = request.headers.authorization;\n\n      if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        throw new UnauthorizedException('Token de atualização não fornecido');\n      }\n\n      // Extrair o token\n      const token = authHeader.split(' ')[1];\n\n      if (!token) {\n        throw new UnauthorizedException('Token de atualização inválido');\n      }\n\n      // A validação real do token será feita pelo JwtRefreshStrategy\n      // Aqui apenas verificamos se o token foi fornecido\n      // O NestJS irá automaticamente usar a estratégia configurada para validar o token\n      // e injetar o usuário no request se o token for válido\n\n      // Após a validação do token, o usuário deve estar disponível no request\n      // Esta verificação será feita em um interceptor ou no próprio controlador\n\n      return true;\n    } catch (error) {\n      if (error instanceof UnauthorizedException) {\n        throw error;\n      }\n\n      throw new UnauthorizedException(\n        'Falha na autenticação do token de atualização',\n      );\n    }\n  }\n}\n"],"version":3}