d20e403fc68420a0d76990c203a92cc7
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var AuthorizationService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthorizationService = void 0;
const common_1 = require("@nestjs/common");
const permission_service_1 = require("./permission.service");
const cache_manager_1 = require("@nestjs/cache-manager");
const cache_manager_2 = require("cache-manager");
const common_2 = require("@nestjs/common");
const user_permission_entity_1 = require("../../entities/user-permission.entity");
/**
 * Serviço de autorização centralizado
 *
 * Este serviço é responsável por verificações combinadas de role e permissão,
 * bem como verificações baseadas em dados.
 */
let AuthorizationService = AuthorizationService_1 = class AuthorizationService {
    permissionService;
    cacheManager;
    logger = new common_1.Logger(AuthorizationService_1.name);
    constructor(permissionService, cacheManager) {
        this.permissionService = permissionService;
        this.cacheManager = cacheManager;
    }
    /**
     * Verifica se um usuário está autorizado a realizar uma ação
     *
     * @param options Opções de autorização
     * @returns true se o usuário está autorizado, false caso contrário
     */
    async isAuthorized(options) {
        const { userId, roles, permissionName, scopeType = user_permission_entity_1.ScopeType.GLOBAL, scopeId, operator = 'AND', dataCheck, data, } = options;
        // Verificar cache
        const cacheKey = this.generateCacheKey(options);
        const cachedResult = await this.cacheManager.get(cacheKey);
        if (cachedResult !== undefined && cachedResult !== null) {
            return cachedResult;
        }
        // Verificar roles se especificado
        let hasRole = true;
        if (roles && roles.length > 0) {
            hasRole = await this.hasRole(userId, roles);
        }
        // Verificar permissão se especificada
        let hasPermission = true;
        if (permissionName) {
            hasPermission = await this.permissionService.hasPermission({
                userId,
                permissionName,
                scopeType,
                scopeId,
            });
        }
        // Verificar dados se especificado
        let dataCheckResult = true;
        if (dataCheck && data) {
            const checkResult = await Promise.resolve(dataCheck(data));
            // Garantir que o resultado seja sempre um booleano
            dataCheckResult = checkResult === true;
        }
        // Combinar resultados com o operador especificado
        let result;
        if (operator === 'AND') {
            result = hasRole && hasPermission && dataCheckResult;
        }
        else {
            result = hasRole || hasPermission;
            // Verificação de dados sempre é AND, mesmo com operador OR
            result = result && dataCheckResult;
        }
        // Armazenar em cache (TTL de 5 minutos)
        await this.cacheManager.set(cacheKey, result, 300);
        return result;
    }
    /**
     * Verifica se um usuário possui uma das roles especificadas
     *
     * @param userId ID do usuário
     * @param roles Lista de roles
     * @returns true se o usuário possui uma das roles, false caso contrário
     */
    async hasRole(userId, roles) {
        // Implementação básica - na prática, seria necessário consultar o banco de dados
        // para verificar as roles do usuário
        // Aqui, estamos assumindo que as roles do usuário estão disponíveis no token JWT
        // e foram extraídas pelo guard JwtAuthGuard
        // Na implementação real, você consultaria o banco de dados para obter as roles do usuário
        // Exemplo:
        // const userRoles = await this.userRepository.findRolesByUserId(userId);
        // return roles.some(role => userRoles.includes(role));
        // Implementação temporária
        return true;
    }
    /**
     * Gera uma chave de cache para uma verificação de autorização
     *
     * @param options Opções de autorização
     * @returns Chave de cache
     */
    generateCacheKey(options) {
        const { userId, roles, permissionName, scopeType, scopeId, operator } = options;
        return `auth:${userId}:${roles?.join(',')}:${permissionName}:${scopeType}:${scopeId || 'null'}:${operator}`;
    }
    /**
     * Limpa o cache de autorização de um usuário
     *
     * @param userId ID do usuário
     */
    async clearAuthorizationCache(userId) {
        // Implementação básica: na prática, seria necessário um mecanismo mais eficiente
        // para limpar apenas as chaves relacionadas ao usuário
        await this.cacheManager.del(`auth:${userId}:*`);
    }
};
exports.AuthorizationService = AuthorizationService;
exports.AuthorizationService = AuthorizationService = AuthorizationService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(1, (0, common_2.Inject)(cache_manager_1.CACHE_MANAGER)),
    __metadata("design:paramtypes", [typeof (_a = typeof permission_service_1.PermissionService !== "undefined" && permission_service_1.PermissionService) === "function" ? _a : Object, typeof (_b = typeof cache_manager_2.Cache !== "undefined" && cache_manager_2.Cache) === "function" ? _b : Object])
], AuthorizationService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXGF1dGhcXHNlcnZpY2VzXFxhdXRob3JpemF0aW9uLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBb0Q7QUFDcEQsNkRBRzhCO0FBQzlCLHlEQUFzRDtBQUN0RCxpREFBc0M7QUFDdEMsMkNBQXdDO0FBQ3hDLGtGQUE4RTtBQStDOUU7Ozs7O0dBS0c7QUFFSSxJQUFNLG9CQUFvQiw0QkFBMUIsTUFBTSxvQkFBb0I7SUFJWjtJQUN1QjtJQUp6QixNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsc0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFaEUsWUFDbUIsaUJBQW9DLEVBQ2IsWUFBbUI7UUFEMUMsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUNiLGlCQUFZLEdBQVosWUFBWSxDQUFPO0lBQzFELENBQUM7SUFFSjs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxZQUFZLENBQUMsT0FBNkI7UUFDOUMsTUFBTSxFQUNKLE1BQU0sRUFDTixLQUFLLEVBQ0wsY0FBYyxFQUNkLFNBQVMsR0FBRyxrQ0FBUyxDQUFDLE1BQU0sRUFDNUIsT0FBTyxFQUNQLFFBQVEsR0FBRyxLQUFLLEVBQ2hCLFNBQVMsRUFDVCxJQUFJLEdBQ0wsR0FBRyxPQUFPLENBQUM7UUFFWixrQkFBa0I7UUFDbEIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2hELE1BQU0sWUFBWSxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQVUsUUFBUSxDQUFDLENBQUM7UUFFcEUsSUFBSSxZQUFZLEtBQUssU0FBUyxJQUFJLFlBQVksS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUN4RCxPQUFPLFlBQVksQ0FBQztRQUN0QixDQUFDO1FBRUQsa0NBQWtDO1FBQ2xDLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQztRQUNuQixJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQzlCLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzlDLENBQUM7UUFFRCxzQ0FBc0M7UUFDdEMsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDO1FBQ3pCLElBQUksY0FBYyxFQUFFLENBQUM7WUFDbkIsYUFBYSxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQztnQkFDekQsTUFBTTtnQkFDTixjQUFjO2dCQUNkLFNBQVM7Z0JBQ1QsT0FBTzthQUNSLENBQUMsQ0FBQztRQUNMLENBQUM7UUFFRCxrQ0FBa0M7UUFDbEMsSUFBSSxlQUFlLEdBQUcsSUFBSSxDQUFDO1FBQzNCLElBQUksU0FBUyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ3RCLE1BQU0sV0FBVyxHQUFHLE1BQU0sT0FBTyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUMzRCxtREFBbUQ7WUFDbkQsZUFBZSxHQUFHLFdBQVcsS0FBSyxJQUFJLENBQUM7UUFDekMsQ0FBQztRQUVELGtEQUFrRDtRQUNsRCxJQUFJLE1BQWUsQ0FBQztRQUVwQixJQUFJLFFBQVEsS0FBSyxLQUFLLEVBQUUsQ0FBQztZQUN2QixNQUFNLEdBQUcsT0FBTyxJQUFJLGFBQWEsSUFBSSxlQUFlLENBQUM7UUFDdkQsQ0FBQzthQUFNLENBQUM7WUFDTixNQUFNLEdBQUcsT0FBTyxJQUFJLGFBQWEsQ0FBQztZQUVsQywyREFBMkQ7WUFDM0QsTUFBTSxHQUFHLE1BQU0sSUFBSSxlQUFlLENBQUM7UUFDckMsQ0FBQztRQUVELHdDQUF3QztRQUN4QyxNQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFbkQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBYyxFQUFFLEtBQWU7UUFDbkQsaUZBQWlGO1FBQ2pGLHFDQUFxQztRQUVyQyxpRkFBaUY7UUFDakYsNENBQTRDO1FBRTVDLDBGQUEwRjtRQUUxRixXQUFXO1FBQ1gseUVBQXlFO1FBQ3pFLHVEQUF1RDtRQUV2RCwyQkFBMkI7UUFDM0IsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxnQkFBZ0IsQ0FBQyxPQUE2QjtRQUNwRCxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsR0FDbkUsT0FBTyxDQUFDO1FBRVYsT0FBTyxRQUFRLE1BQU0sSUFBSSxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLGNBQWMsSUFBSSxTQUFTLElBQUksT0FBTyxJQUFJLE1BQU0sSUFBSSxRQUFRLEVBQUUsQ0FBQztJQUM5RyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxNQUFjO1FBQzFDLGlGQUFpRjtRQUNqRix1REFBdUQ7UUFDdkQsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxRQUFRLE1BQU0sSUFBSSxDQUFDLENBQUM7SUFDbEQsQ0FBQztDQUNGLENBQUE7QUE1SFksb0RBQW9COytCQUFwQixvQkFBb0I7SUFEaEMsSUFBQSxtQkFBVSxHQUFFO0lBTVIsV0FBQSxJQUFBLGVBQU0sRUFBQyw2QkFBYSxDQUFDLENBQUE7eURBRGMsc0NBQWlCLG9CQUFqQixzQ0FBaUIsb0RBQ0MscUJBQUssb0JBQUwscUJBQUs7R0FMbEQsb0JBQW9CLENBNEhoQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcYXV0aFxcc2VydmljZXNcXGF1dGhvcml6YXRpb24uc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBMb2dnZXIgfSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQge1xuICBQZXJtaXNzaW9uU2VydmljZSxcbiAgUGVybWlzc2lvbkNoZWNrT3B0aW9ucyxcbn0gZnJvbSAnLi9wZXJtaXNzaW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ0FDSEVfTUFOQUdFUiB9IGZyb20gJ0BuZXN0anMvY2FjaGUtbWFuYWdlcic7XG5pbXBvcnQgeyBDYWNoZSB9IGZyb20gJ2NhY2hlLW1hbmFnZXInO1xuaW1wb3J0IHsgSW5qZWN0IH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xuaW1wb3J0IHsgU2NvcGVUeXBlLCBUaXBvRXNjb3BvIH0gZnJvbSAnLi4vLi4vZW50aXRpZXMvdXNlci1wZXJtaXNzaW9uLmVudGl0eSc7XG5cbi8qKlxuICogSW50ZXJmYWNlIHBhcmEgdmVyaWZpY2HDp8OjbyBkZSBhdXRvcml6YcOnw6NvXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aG9yaXphdGlvbk9wdGlvbnMge1xuICAvKipcbiAgICogSUQgZG8gdXN1w6FyaW8gcGFyYSB2ZXJpZmljYcOnw6NvIGRlIGF1dG9yaXphw6fDo29cbiAgICovXG4gIHVzZXJJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSb2xlcyBuZWNlc3PDoXJpYXMgKG9wY2lvbmFsKVxuICAgKi9cbiAgcm9sZXM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogTm9tZSBkYSBwZXJtaXNzw6NvIG5vIGZvcm1hdG8gYG1vZHVsby5yZWN1cnNvLm9wZXJhY2FvYCAob3BjaW9uYWwpXG4gICAqL1xuICBwZXJtaXNzaW9uTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGlwbyBkZSBlc2NvcG8gKG9wY2lvbmFsLCBwYWRyw6NvIMOpIEdMT0JBTClcbiAgICovXG4gIHNjb3BlVHlwZT86IFRpcG9Fc2NvcG87XG5cbiAgLyoqXG4gICAqIElEIGRvIGVzY29wbyAob3BjaW9uYWwsIG5lY2Vzc8OhcmlvIGFwZW5hcyBwYXJhIHNjb3BlVHlwZSBVTklUKVxuICAgKi9cbiAgc2NvcGVJZD86IHN0cmluZztcblxuICAvKipcbiAgICogT3BlcmFkb3IgbMOzZ2ljbyBwYXJhIGNvbWJpbmFyIHJvbGVzIGUgcGVybWlzc8O1ZXMgKHBhZHLDo28gw6kgJ0FORCcpXG4gICAqL1xuICBvcGVyYXRvcj86ICdBTkQnIHwgJ09SJztcblxuICAvKipcbiAgICogRnVuw6fDo28gZGUgdmVyaWZpY2HDp8OjbyBiYXNlYWRhIGVtIGRhZG9zIChvcGNpb25hbClcbiAgICovXG4gIGRhdGFDaGVjaz86IChkYXRhOiBhbnkpID0+IGJvb2xlYW4gfCBQcm9taXNlPGJvb2xlYW4+O1xuXG4gIC8qKlxuICAgKiBEYWRvcyBwYXJhIHZlcmlmaWNhw6fDo28gYmFzZWFkYSBlbSBkYWRvcyAob3BjaW9uYWwpXG4gICAqL1xuICBkYXRhPzogYW55O1xufVxuXG4vKipcbiAqIFNlcnZpw6dvIGRlIGF1dG9yaXphw6fDo28gY2VudHJhbGl6YWRvXG4gKlxuICogRXN0ZSBzZXJ2acOnbyDDqSByZXNwb25zw6F2ZWwgcG9yIHZlcmlmaWNhw6fDtWVzIGNvbWJpbmFkYXMgZGUgcm9sZSBlIHBlcm1pc3PDo28sXG4gKiBiZW0gY29tbyB2ZXJpZmljYcOnw7VlcyBiYXNlYWRhcyBlbSBkYWRvcy5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEF1dGhvcml6YXRpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXIgPSBuZXcgTG9nZ2VyKEF1dGhvcml6YXRpb25TZXJ2aWNlLm5hbWUpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGVybWlzc2lvblNlcnZpY2U6IFBlcm1pc3Npb25TZXJ2aWNlLFxuICAgIEBJbmplY3QoQ0FDSEVfTUFOQUdFUikgcHJpdmF0ZSByZWFkb25seSBjYWNoZU1hbmFnZXI6IENhY2hlLFxuICApIHt9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIHVtIHVzdcOhcmlvIGVzdMOhIGF1dG9yaXphZG8gYSByZWFsaXphciB1bWEgYcOnw6NvXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIE9ww6fDtWVzIGRlIGF1dG9yaXphw6fDo29cbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIHVzdcOhcmlvIGVzdMOhIGF1dG9yaXphZG8sIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgYXN5bmMgaXNBdXRob3JpemVkKG9wdGlvbnM6IEF1dGhvcml6YXRpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3Qge1xuICAgICAgdXNlcklkLFxuICAgICAgcm9sZXMsXG4gICAgICBwZXJtaXNzaW9uTmFtZSxcbiAgICAgIHNjb3BlVHlwZSA9IFNjb3BlVHlwZS5HTE9CQUwsXG4gICAgICBzY29wZUlkLFxuICAgICAgb3BlcmF0b3IgPSAnQU5EJyxcbiAgICAgIGRhdGFDaGVjayxcbiAgICAgIGRhdGEsXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICAvLyBWZXJpZmljYXIgY2FjaGVcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2VuZXJhdGVDYWNoZUtleShvcHRpb25zKTtcbiAgICBjb25zdCBjYWNoZWRSZXN1bHQgPSBhd2FpdCB0aGlzLmNhY2hlTWFuYWdlci5nZXQ8Ym9vbGVhbj4oY2FjaGVLZXkpO1xuXG4gICAgaWYgKGNhY2hlZFJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGNhY2hlZFJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBWZXJpZmljYXIgcm9sZXMgc2UgZXNwZWNpZmljYWRvXG4gICAgbGV0IGhhc1JvbGUgPSB0cnVlO1xuICAgIGlmIChyb2xlcyAmJiByb2xlcy5sZW5ndGggPiAwKSB7XG4gICAgICBoYXNSb2xlID0gYXdhaXQgdGhpcy5oYXNSb2xlKHVzZXJJZCwgcm9sZXMpO1xuICAgIH1cblxuICAgIC8vIFZlcmlmaWNhciBwZXJtaXNzw6NvIHNlIGVzcGVjaWZpY2FkYVxuICAgIGxldCBoYXNQZXJtaXNzaW9uID0gdHJ1ZTtcbiAgICBpZiAocGVybWlzc2lvbk5hbWUpIHtcbiAgICAgIGhhc1Blcm1pc3Npb24gPSBhd2FpdCB0aGlzLnBlcm1pc3Npb25TZXJ2aWNlLmhhc1Blcm1pc3Npb24oe1xuICAgICAgICB1c2VySWQsXG4gICAgICAgIHBlcm1pc3Npb25OYW1lLFxuICAgICAgICBzY29wZVR5cGUsXG4gICAgICAgIHNjb3BlSWQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZmljYXIgZGFkb3Mgc2UgZXNwZWNpZmljYWRvXG4gICAgbGV0IGRhdGFDaGVja1Jlc3VsdCA9IHRydWU7XG4gICAgaWYgKGRhdGFDaGVjayAmJiBkYXRhKSB7XG4gICAgICBjb25zdCBjaGVja1Jlc3VsdCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShkYXRhQ2hlY2soZGF0YSkpO1xuICAgICAgLy8gR2FyYW50aXIgcXVlIG8gcmVzdWx0YWRvIHNlamEgc2VtcHJlIHVtIGJvb2xlYW5vXG4gICAgICBkYXRhQ2hlY2tSZXN1bHQgPSBjaGVja1Jlc3VsdCA9PT0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDb21iaW5hciByZXN1bHRhZG9zIGNvbSBvIG9wZXJhZG9yIGVzcGVjaWZpY2Fkb1xuICAgIGxldCByZXN1bHQ6IGJvb2xlYW47XG5cbiAgICBpZiAob3BlcmF0b3IgPT09ICdBTkQnKSB7XG4gICAgICByZXN1bHQgPSBoYXNSb2xlICYmIGhhc1Blcm1pc3Npb24gJiYgZGF0YUNoZWNrUmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBoYXNSb2xlIHx8IGhhc1Blcm1pc3Npb247XG5cbiAgICAgIC8vIFZlcmlmaWNhw6fDo28gZGUgZGFkb3Mgc2VtcHJlIMOpIEFORCwgbWVzbW8gY29tIG9wZXJhZG9yIE9SXG4gICAgICByZXN1bHQgPSByZXN1bHQgJiYgZGF0YUNoZWNrUmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEFybWF6ZW5hciBlbSBjYWNoZSAoVFRMIGRlIDUgbWludXRvcylcbiAgICBhd2FpdCB0aGlzLmNhY2hlTWFuYWdlci5zZXQoY2FjaGVLZXksIHJlc3VsdCwgMzAwKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgdW0gdXN1w6FyaW8gcG9zc3VpIHVtYSBkYXMgcm9sZXMgZXNwZWNpZmljYWRhc1xuICAgKlxuICAgKiBAcGFyYW0gdXNlcklkIElEIGRvIHVzdcOhcmlvXG4gICAqIEBwYXJhbSByb2xlcyBMaXN0YSBkZSByb2xlc1xuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gdXN1w6FyaW8gcG9zc3VpIHVtYSBkYXMgcm9sZXMsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBoYXNSb2xlKHVzZXJJZDogc3RyaW5nLCByb2xlczogc3RyaW5nW10pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAvLyBJbXBsZW1lbnRhw6fDo28gYsOhc2ljYSAtIG5hIHByw6F0aWNhLCBzZXJpYSBuZWNlc3PDoXJpbyBjb25zdWx0YXIgbyBiYW5jbyBkZSBkYWRvc1xuICAgIC8vIHBhcmEgdmVyaWZpY2FyIGFzIHJvbGVzIGRvIHVzdcOhcmlvXG5cbiAgICAvLyBBcXVpLCBlc3RhbW9zIGFzc3VtaW5kbyBxdWUgYXMgcm9sZXMgZG8gdXN1w6FyaW8gZXN0w6NvIGRpc3BvbsOtdmVpcyBubyB0b2tlbiBKV1RcbiAgICAvLyBlIGZvcmFtIGV4dHJhw61kYXMgcGVsbyBndWFyZCBKd3RBdXRoR3VhcmRcblxuICAgIC8vIE5hIGltcGxlbWVudGHDp8OjbyByZWFsLCB2b2PDqiBjb25zdWx0YXJpYSBvIGJhbmNvIGRlIGRhZG9zIHBhcmEgb2J0ZXIgYXMgcm9sZXMgZG8gdXN1w6FyaW9cblxuICAgIC8vIEV4ZW1wbG86XG4gICAgLy8gY29uc3QgdXNlclJvbGVzID0gYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS5maW5kUm9sZXNCeVVzZXJJZCh1c2VySWQpO1xuICAgIC8vIHJldHVybiByb2xlcy5zb21lKHJvbGUgPT4gdXNlclJvbGVzLmluY2x1ZGVzKHJvbGUpKTtcblxuICAgIC8vIEltcGxlbWVudGHDp8OjbyB0ZW1wb3LDoXJpYVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlcmEgdW1hIGNoYXZlIGRlIGNhY2hlIHBhcmEgdW1hIHZlcmlmaWNhw6fDo28gZGUgYXV0b3JpemHDp8Ojb1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcMOnw7VlcyBkZSBhdXRvcml6YcOnw6NvXG4gICAqIEByZXR1cm5zIENoYXZlIGRlIGNhY2hlXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlQ2FjaGVLZXkob3B0aW9uczogQXV0aG9yaXphdGlvbk9wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IHsgdXNlcklkLCByb2xlcywgcGVybWlzc2lvbk5hbWUsIHNjb3BlVHlwZSwgc2NvcGVJZCwgb3BlcmF0b3IgfSA9XG4gICAgICBvcHRpb25zO1xuXG4gICAgcmV0dXJuIGBhdXRoOiR7dXNlcklkfToke3JvbGVzPy5qb2luKCcsJyl9OiR7cGVybWlzc2lvbk5hbWV9OiR7c2NvcGVUeXBlfToke3Njb3BlSWQgfHwgJ251bGwnfToke29wZXJhdG9yfWA7XG4gIH1cblxuICAvKipcbiAgICogTGltcGEgbyBjYWNoZSBkZSBhdXRvcml6YcOnw6NvIGRlIHVtIHVzdcOhcmlvXG4gICAqXG4gICAqIEBwYXJhbSB1c2VySWQgSUQgZG8gdXN1w6FyaW9cbiAgICovXG4gIGFzeW5jIGNsZWFyQXV0aG9yaXphdGlvbkNhY2hlKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gSW1wbGVtZW50YcOnw6NvIGLDoXNpY2E6IG5hIHByw6F0aWNhLCBzZXJpYSBuZWNlc3PDoXJpbyB1bSBtZWNhbmlzbW8gbWFpcyBlZmljaWVudGVcbiAgICAvLyBwYXJhIGxpbXBhciBhcGVuYXMgYXMgY2hhdmVzIHJlbGFjaW9uYWRhcyBhbyB1c3XDoXJpb1xuICAgIGF3YWl0IHRoaXMuY2FjaGVNYW5hZ2VyLmRlbChgYXV0aDoke3VzZXJJZH06KmApO1xuICB9XG59XG4iXSwidmVyc2lvbiI6M30=