ba2c57e9e28be1e403740fba5a0c9ba9
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CacheService_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheService = void 0;
const common_1 = require("@nestjs/common");
const bull_1 = require("@nestjs/bull");
const bull_2 = require("bull");
const config_1 = require("@nestjs/config");
const cache_metrics_provider_1 = require("./cache-metrics.provider");
// Estados do Circuit Breaker
var CircuitState;
(function (CircuitState) {
    CircuitState[CircuitState["CLOSED"] = 0] = "CLOSED";
    CircuitState[CircuitState["OPEN"] = 1] = "OPEN";
    CircuitState[CircuitState["HALF_OPEN"] = 2] = "HALF_OPEN"; // Tentando recuperar
})(CircuitState || (CircuitState = {}));
/**
 * Serviço de cache
 *
 * Implementa um sistema de cache utilizando o Redis através do Bull
 * para melhorar a performance de operações frequentes
 */
let CacheService = CacheService_1 = class CacheService {
    cacheQueue;
    metricsProvider;
    configService;
    logger = new common_1.Logger(CacheService_1.name);
    defaultTTL = 3600; // 1 hora em segundos
    // Circuit Breaker configurações
    circuitState = CircuitState.CLOSED;
    failureCount = 0;
    failureThreshold = 3; // Reduzido para 3 falhas para abrir o circuito mais rapidamente
    resetTimeout = 10000; // 10 segundos para tentar recuperar (reduzido para resposta mais rápida)
    lastFailureTime = 0;
    inMemoryCache = new Map();
    localCacheTTL;
    constructor(cacheQueue, metricsProvider, configService) {
        this.cacheQueue = cacheQueue;
        this.metricsProvider = metricsProvider;
        this.configService = configService;
        // Verificar se o Redis está desabilitado via configuração
        const disableRedis = this.configService.get('DISABLE_REDIS') === 'true';
        // Carregar configurações do circuit breaker
        this.failureThreshold = this.configService.get('CACHE_CIRCUIT_BREAKER_THRESHOLD', 3);
        this.resetTimeout = this.configService.get('CACHE_CIRCUIT_BREAKER_RESET', 10000);
        this.localCacheTTL = this.configService.get('CACHE_LOCAL_TTL', 600);
        if (disableRedis) {
            this.logger.warn('Redis está desabilitado. Usando apenas cache local.');
            this.circuitState = CircuitState.OPEN; // Forçar uso do cache local
        }
        // Verificar conexão com Redis na inicialização
        this.checkRedisConnection();
    }
    /**
     * Verifica a conexão com o Redis na inicialização
     * @private
     */
    async checkRedisConnection() {
        try {
            // Definir um timeout para evitar bloqueio
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Timeout ao verificar conexão com Redis')), 2000);
            });
            const pingPromise = this.cacheQueue.client.ping();
            await Promise.race([pingPromise, timeoutPromise]);
            this.logger.log('Conexão com Redis estabelecida com sucesso');
        }
        catch (error) {
            this.logger.error(`Erro ao conectar com Redis: ${error.message}. Usando cache local.`, error.stack);
            // Abrir o circuit breaker para usar cache local
            this.circuitState = CircuitState.OPEN;
        }
    }
    /**
     * Verifica o estado do circuit breaker e atualiza conforme necessário
     * @private
     */
    checkCircuitState() {
        const now = Date.now();
        // Se estiver aberto, verificar se já passou o tempo para tentar recuperar
        if (this.circuitState === CircuitState.OPEN) {
            if (now - this.lastFailureTime > this.resetTimeout) {
                this.logger.log('Circuit Breaker mudando para estado HALF_OPEN, tentando recuperar');
                this.circuitState = CircuitState.HALF_OPEN;
                // Resetar contador de falhas ao tentar recuperar
                this.failureCount = 0;
                // Registrar métrica de recuperação
                this.metricsProvider.registerCacheRecoveryAttempt();
            }
        }
    }
    /**
     * Registra uma falha no circuit breaker
     * @private
     */
    registerFailure() {
        this.failureCount++;
        this.lastFailureTime = Date.now();
        // Registrar métrica de falha
        this.metricsProvider.registerCacheFailure();
        if (this.failureCount >= this.failureThreshold && this.circuitState === CircuitState.CLOSED) {
            this.logger.warn(`Circuit Breaker mudando para estado OPEN após ${this.failureCount} falhas`);
            this.circuitState = CircuitState.OPEN;
            // Limpar fila de cache quando o circuito abrir para evitar acumular operações pendentes
            this.clearCacheQueue().catch(err => {
                this.logger.error(`Erro ao limpar fila de cache: ${err.message}`, err.stack);
            });
        }
    }
    /**
     * Limpa a fila de cache para evitar acumular operações pendentes
     * @private
     */
    async clearCacheQueue() {
        try {
            // Definir um timeout para evitar bloqueio
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Timeout ao limpar fila de cache')), 1000);
            });
            const cleanPromise = Promise.all([
                this.cacheQueue.clean(0, 'delayed'),
                this.cacheQueue.clean(0, 'wait')
            ]);
            await Promise.race([cleanPromise, timeoutPromise]);
            this.logger.log('Fila de cache limpa com sucesso');
        }
        catch (error) {
            this.logger.error(`Erro ao limpar fila de cache: ${error.message}`, error.stack);
            // Forçar o fechamento do circuito em caso de erro ao limpar a fila
            // Isso é importante para evitar que o sistema continue tentando usar o Redis
            this.circuitState = CircuitState.OPEN;
        }
    }
    /**
     * Registra um sucesso no circuit breaker
     * @private
     */
    registerSuccess() {
        if (this.circuitState === CircuitState.HALF_OPEN) {
            this.logger.log('Circuit Breaker recuperado, voltando para estado CLOSED');
            this.circuitState = CircuitState.CLOSED;
            this.failureCount = 0;
        }
        else if (this.circuitState === CircuitState.CLOSED) {
            // Resetar contador de falhas gradualmente em caso de sucesso
            this.failureCount = Math.max(0, this.failureCount - 1);
        }
    }
    /**
     * Salva um valor no cache local em memória
     * @private
     */
    setLocalCache(key, value, ttl = this.localCacheTTL) {
        const expiry = Date.now() + (ttl * 1000);
        this.inMemoryCache.set(key, { value, expiry });
    }
    /**
     * Obtém um valor do cache local em memória
     * @private
     */
    getLocalCache(key) {
        const cached = this.inMemoryCache.get(key);
        if (!cached) {
            return null;
        }
        if (Date.now() > cached.expiry) {
            this.inMemoryCache.delete(key);
            return null;
        }
        return cached.value;
    }
    async get(key) {
        // Primeiro verificar cache local (mais rápido e sem dependência do Redis)
        const localValue = this.getLocalCache(key);
        if (localValue !== null) {
            this.metricsProvider.registerCacheHit();
            return localValue;
        }
        // Verificar o estado do circuit breaker
        this.checkCircuitState();
        // Se o circuit breaker estiver aberto, não tentar Redis e retornar null
        if (this.circuitState === CircuitState.OPEN) {
            this.logger.debug(`Circuit breaker aberto, não tentando Redis para chave: ${key}`);
            this.metricsProvider.registerCacheMiss();
            return null;
        }
        try {
            const job = await this.cacheQueue.getJob(key);
            if (!job) {
                // Cache miss
                this.metricsProvider.registerCacheMiss();
                this.registerSuccess(); // Operação concluída com sucesso (mesmo que seja um miss)
                return null;
            }
            const jobData = await job.data;
            // Verificar se o job expirou
            if (job.finishedOn && Date.now() > job.finishedOn) {
                await job.remove();
                this.metricsProvider.registerCacheMiss();
                this.registerSuccess(); // Operação concluída com sucesso
                return null;
            }
            // Cache hit - armazenar também no cache local
            const value = jobData.value;
            this.setLocalCache(key, value);
            this.metricsProvider.registerCacheHit();
            this.registerSuccess(); // Operação concluída com sucesso
            return value;
        }
        catch (error) {
            this.logger.error(`Erro ao obter valor do cache: ${error.message}`, error.stack);
            this.registerFailure(); // Registrar falha para o circuit breaker
            this.metricsProvider.registerCacheMiss();
            // Se for um erro de timeout, tentar obter o valor do cache local novamente
            // Isso pode acontecer se o valor for adicionado ao cache local por outra thread
            if (error.message && error.message.includes('Timeout')) {
                const retryLocalValue = this.getLocalCache(key);
                if (retryLocalValue !== null) {
                    this.logger.debug(`Valor encontrado no cache local após timeout: ${key}`);
                    return retryLocalValue;
                }
            }
            return null;
        }
    }
    /**
     * Armazena um valor no cache
     * @param key Chave para armazenar o valor
     * @param value Valor a ser armazenado
     * @param ttl Tempo de vida em segundos (padrão: 1 hora)
     */
    async set(key, value, ttl = this.defaultTTL) {
        // Armazenar no cache local primeiro (mais rápido e sem dependência do Redis)
        this.setLocalCache(key, value, ttl);
        // Verificar o estado do circuit breaker
        this.checkCircuitState();
        // Se o circuit breaker estiver aberto, não tentar Redis
        if (this.circuitState === CircuitState.OPEN) {
            this.logger.debug(`Circuit breaker aberto, não tentando Redis para chave: ${key}`);
            return;
        }
        try {
            // Timeout para evitar bloqueio da thread principal
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Timeout ao armazenar no cache')), 500);
            });
            const cachePromise = (async () => {
                // Remover job existente com a mesma chave
                const existingJob = await this.cacheQueue.getJob(key);
                if (existingJob) {
                    await existingJob.remove();
                }
                // Criar novo job com os dados
                await this.cacheQueue.add({ value }, {
                    jobId: key,
                    removeOnComplete: ttl,
                    removeOnFail: true,
                });
            })();
            // Usar race para evitar bloqueio por tempo indefinido
            await Promise.race([cachePromise, timeoutPromise]);
            // Registrar operação de set no cache
            this.metricsProvider.registerCacheSet();
            this.registerSuccess(); // Operação concluída com sucesso
        }
        catch (error) {
            this.logger.error(`Erro ao armazenar valor no cache: ${error.message}`, error.stack);
            this.registerFailure(); // Registrar falha para o circuit breaker
        }
    }
    /**
     * Remove um valor do cache
     * @param key Chave do valor a ser removido
     */
    async del(key) {
        // Remover do cache local
        this.inMemoryCache.delete(key);
        // Verificar o estado do circuit breaker
        this.checkCircuitState();
        // Se o circuit breaker estiver aberto, não tentar Redis
        if (this.circuitState === CircuitState.OPEN) {
            return;
        }
        try {
            // Timeout para evitar bloqueio da thread principal
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Timeout ao remover do cache')), 500);
            });
            const cachePromise = (async () => {
                const job = await this.cacheQueue.getJob(key);
                if (job) {
                    await job.remove();
                }
            })();
            // Usar race para evitar bloqueio por tempo indefinido
            await Promise.race([cachePromise, timeoutPromise]);
            // Registrar operação de delete no cache
            this.metricsProvider.registerCacheDelete();
            this.registerSuccess(); // Operação concluída com sucesso
        }
        catch (error) {
            this.logger.error(`Erro ao remover valor do cache: ${error.message}`, error.stack);
            this.registerFailure(); // Registrar falha para o circuit breaker
        }
    }
    /**
     * Verifica se uma chave existe no cache
     * @param key Chave a ser verificada
     * @returns true se a chave existir, false caso contrário
     */
    async has(key) {
        // Verificar primeiro no cache local
        if (this.getLocalCache(key) !== null) {
            return true;
        }
        // Verificar o estado do circuit breaker
        this.checkCircuitState();
        // Se o circuit breaker estiver aberto, retornar apenas resultado do cache local
        if (this.circuitState === CircuitState.OPEN) {
            return false;
        }
        try {
            const job = await this.cacheQueue.getJob(key);
            const exists = !!job;
            this.registerSuccess(); // Operação concluída com sucesso
            return exists;
        }
        catch (error) {
            this.logger.error(`Erro ao verificar existência no cache: ${error.message}`, error.stack);
            this.registerFailure(); // Registrar falha para o circuit breaker
            return false;
        }
    }
    /**
     * Limpa todo o cache
     */
    async clear() {
        // Limpar cache local
        this.inMemoryCache.clear();
        // Verificar o estado do circuit breaker
        this.checkCircuitState();
        // Se o circuit breaker estiver aberto, não tentar Redis
        if (this.circuitState === CircuitState.OPEN) {
            return;
        }
        try {
            // Timeout para evitar bloqueio da thread principal
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Timeout ao limpar cache')), 1000);
            });
            const cachePromise = this.cacheQueue.empty();
            // Usar race para evitar bloqueio por tempo indefinido
            await Promise.race([cachePromise, timeoutPromise]);
            // Registrar operação de clear no cache
            this.metricsProvider.registerCacheClear();
            this.registerSuccess(); // Operação concluída com sucesso
        }
        catch (error) {
            this.logger.error(`Erro ao limpar cache: ${error.message}`, error.stack);
            this.registerFailure(); // Registrar falha para o circuit breaker
        }
    }
    /**
     * Obtém o estado atual do circuit breaker
     * @returns Estado atual do circuit breaker
     */
    getCircuitState() {
        switch (this.circuitState) {
            case CircuitState.CLOSED:
                return 'CLOSED';
            case CircuitState.OPEN:
                return 'OPEN';
            case CircuitState.HALF_OPEN:
                return 'HALF_OPEN';
            default:
                return 'UNKNOWN';
        }
    }
    /**
     * Força o fechamento do circuit breaker, útil para recuperação manual
     */
    forceCloseCircuit() {
        this.circuitState = CircuitState.CLOSED;
        this.failureCount = 0;
        this.logger.log('Circuit Breaker forçado para estado CLOSED manualmente');
    }
    /**
     * Obtém estatísticas do circuit breaker
     * @returns Estatísticas do circuit breaker
     */
    getCircuitStats() {
        return {
            state: this.getCircuitState(),
            failureCount: this.failureCount,
            lastFailureTime: this.lastFailureTime,
            localCacheSize: this.inMemoryCache.size,
            thresholdConfig: {
                failureThreshold: this.failureThreshold,
                resetTimeoutMs: this.resetTimeout,
            }
        };
    }
};
exports.CacheService = CacheService;
exports.CacheService = CacheService = CacheService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, bull_1.InjectQueue)('cache')),
    __metadata("design:paramtypes", [typeof (_a = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _a : Object, typeof (_b = typeof cache_metrics_provider_1.CacheMetricsProvider !== "undefined" && cache_metrics_provider_1.CacheMetricsProvider) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object])
], CacheService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXHNoYXJlZFxcY2FjaGVcXGNhY2hlLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBb0Q7QUFDcEQsdUNBQTJDO0FBQzNDLCtCQUE2QjtBQUM3QiwyQ0FBK0M7QUFDL0MscUVBQWdFO0FBRWhFLDZCQUE2QjtBQUM3QixJQUFLLFlBSUo7QUFKRCxXQUFLLFlBQVk7SUFDZixtREFBTSxDQUFBO0lBQ04sK0NBQUksQ0FBQTtJQUNKLHlEQUFTLENBQUEsQ0FBQyxxQkFBcUI7QUFDakMsQ0FBQyxFQUpJLFlBQVksS0FBWixZQUFZLFFBSWhCO0FBRUQ7Ozs7O0dBS0c7QUFFSSxJQUFNLFlBQVksb0JBQWxCLE1BQU0sWUFBWTtJQWNrQjtJQUN0QjtJQUNBO0lBZkYsTUFBTSxHQUFHLElBQUksZUFBTSxDQUFDLGNBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2QyxVQUFVLEdBQUcsSUFBSSxDQUFDLENBQUMscUJBQXFCO0lBRXpELGdDQUFnQztJQUN4QixZQUFZLEdBQWlCLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDakQsWUFBWSxHQUFXLENBQUMsQ0FBQztJQUNoQixnQkFBZ0IsR0FBVyxDQUFDLENBQUMsQ0FBQyxnRUFBZ0U7SUFDOUYsWUFBWSxHQUFXLEtBQUssQ0FBQyxDQUFDLHlFQUF5RTtJQUNoSCxlQUFlLEdBQVcsQ0FBQyxDQUFDO0lBQzVCLGFBQWEsR0FBZ0QsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUM5RCxhQUFhLENBQVM7SUFFdkMsWUFDeUMsVUFBaUIsRUFDdkMsZUFBcUMsRUFDckMsYUFBNEI7UUFGTixlQUFVLEdBQVYsVUFBVSxDQUFPO1FBQ3ZDLG9CQUFlLEdBQWYsZUFBZSxDQUFzQjtRQUNyQyxrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQUU3QywwREFBMEQ7UUFDMUQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLEtBQUssTUFBTSxDQUFDO1FBRXhFLDRDQUE0QztRQUM1QyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQVMsaUNBQWlDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDN0YsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBUyw2QkFBNkIsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN6RixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFTLGlCQUFpQixFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRTVFLElBQUksWUFBWSxFQUFFLENBQUM7WUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMscURBQXFELENBQUMsQ0FBQztZQUN4RSxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyw0QkFBNEI7UUFDckUsQ0FBQztRQUVELCtDQUErQztRQUMvQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssS0FBSyxDQUFDLG9CQUFvQjtRQUNoQyxJQUFJLENBQUM7WUFDSCwwQ0FBMEM7WUFDMUMsTUFBTSxjQUFjLEdBQUcsSUFBSSxPQUFPLENBQU8sQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUU7Z0JBQ3JELFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3RGLENBQUMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7WUFFbEQsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsV0FBVyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsNENBQTRDLENBQUMsQ0FBQztRQUNoRSxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLCtCQUErQixLQUFLLENBQUMsT0FBTyx1QkFBdUIsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDcEcsZ0RBQWdEO1lBQ2hELElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQztRQUN4QyxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGlCQUFpQjtRQUN2QixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFdkIsMEVBQTBFO1FBQzFFLElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDNUMsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7Z0JBQ25ELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLG1FQUFtRSxDQUFDLENBQUM7Z0JBQ3JGLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDLFNBQVMsQ0FBQztnQkFDM0MsaURBQWlEO2dCQUNqRCxJQUFJLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQztnQkFFdEIsbUNBQW1DO2dCQUNuQyxJQUFJLENBQUMsZUFBZSxDQUFDLDRCQUE0QixFQUFFLENBQUM7WUFDdEQsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssZUFBZTtRQUNyQixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDcEIsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFbEMsNkJBQTZCO1FBQzdCLElBQUksQ0FBQyxlQUFlLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztRQUU1QyxJQUFJLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLGdCQUFnQixJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQzVGLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGlEQUFpRCxJQUFJLENBQUMsWUFBWSxTQUFTLENBQUMsQ0FBQztZQUM5RixJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUM7WUFFdEMsd0ZBQXdGO1lBQ3hGLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ2pDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGlDQUFpQyxHQUFHLENBQUMsT0FBTyxFQUFFLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQy9FLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSyxLQUFLLENBQUMsZUFBZTtRQUMzQixJQUFJLENBQUM7WUFDSCwwQ0FBMEM7WUFDMUMsTUFBTSxjQUFjLEdBQUcsSUFBSSxPQUFPLENBQU8sQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUU7Z0JBQ3JELFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQy9FLENBQUMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQztnQkFDL0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQztnQkFDbkMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQzthQUNqQyxDQUFDLENBQUM7WUFFSCxNQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUFZLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO1FBQ3JELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsaUNBQWlDLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDakYsbUVBQW1FO1lBQ25FLDZFQUE2RTtZQUM3RSxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUM7UUFDeEMsQ0FBQztJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSyxlQUFlO1FBQ3JCLElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDakQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMseURBQXlELENBQUMsQ0FBQztZQUMzRSxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUM7WUFDeEMsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7UUFDeEIsQ0FBQzthQUFNLElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDckQsNkRBQTZEO1lBQzdELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBQztRQUN6RCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGFBQWEsQ0FBSSxHQUFXLEVBQUUsS0FBUSxFQUFFLE1BQWMsSUFBSSxDQUFDLGFBQWE7UUFDOUUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7O09BR0c7SUFDSyxhQUFhLENBQUksR0FBVztRQUNsQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMzQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFBQSxPQUFPLElBQUksQ0FBQztRQUFBLENBQUM7UUFFM0IsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQy9CLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQy9CLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELE9BQU8sTUFBTSxDQUFDLEtBQVUsQ0FBQztJQUMzQixDQUFDO0lBRUQsS0FBSyxDQUFDLEdBQUcsQ0FBSSxHQUFXO1FBQ3RCLDBFQUEwRTtRQUMxRSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQzlDLElBQUksVUFBVSxLQUFLLElBQUksRUFBRSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxlQUFlLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUN4QyxPQUFPLFVBQVUsQ0FBQztRQUNwQixDQUFDO1FBRUQsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBRXpCLHdFQUF3RTtRQUN4RSxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQzVDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLDBEQUEwRCxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQ25GLElBQUksQ0FBQyxlQUFlLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUN6QyxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRCxJQUFJLENBQUM7WUFDSCxNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRTlDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDVCxhQUFhO2dCQUNiLElBQUksQ0FBQyxlQUFlLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztnQkFDekMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsMERBQTBEO2dCQUNsRixPQUFPLElBQUksQ0FBQztZQUNkLENBQUM7WUFFRCxNQUFNLE9BQU8sR0FBRyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUM7WUFFL0IsNkJBQTZCO1lBQzdCLElBQUksR0FBRyxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNsRCxNQUFNLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDbkIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO2dCQUN6QyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQyxpQ0FBaUM7Z0JBQ3pELE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQztZQUVELDhDQUE4QztZQUM5QyxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBVSxDQUFDO1lBQ2pDLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQy9CLElBQUksQ0FBQyxlQUFlLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUN4QyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQyxpQ0FBaUM7WUFDekQsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUNmLGlDQUFpQyxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQ2hELEtBQUssQ0FBQyxLQUFLLENBQ1osQ0FBQztZQUNGLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLHlDQUF5QztZQUNqRSxJQUFJLENBQUMsZUFBZSxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFFekMsMkVBQTJFO1lBQzNFLGdGQUFnRjtZQUNoRixJQUFJLEtBQUssQ0FBQyxPQUFPLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztnQkFDdkQsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBSSxHQUFHLENBQUMsQ0FBQztnQkFDbkQsSUFBSSxlQUFlLEtBQUssSUFBSSxFQUFFLENBQUM7b0JBQzdCLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGlEQUFpRCxHQUFHLEVBQUUsQ0FBQyxDQUFDO29CQUMxRSxPQUFPLGVBQWUsQ0FBQztnQkFDekIsQ0FBQztZQUNILENBQUM7WUFFRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsR0FBRyxDQUNQLEdBQVcsRUFDWCxLQUFRLEVBQ1IsTUFBYyxJQUFJLENBQUMsVUFBVTtRQUU3Qiw2RUFBNkU7UUFDN0UsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRXBDLHdDQUF3QztRQUN4QyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUV6Qix3REFBd0Q7UUFDeEQsSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUM1QyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQywwREFBMEQsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUNuRixPQUFPO1FBQ1QsQ0FBQztRQUVELElBQUksQ0FBQztZQUNILG1EQUFtRDtZQUNuRCxNQUFNLGNBQWMsR0FBRyxJQUFJLE9BQU8sQ0FBTyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRTtnQkFDckQsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDNUUsQ0FBQyxDQUFDLENBQUM7WUFFSCxNQUFNLFlBQVksR0FBRyxDQUFDLEtBQUssSUFBSSxFQUFFO2dCQUMvQiwwQ0FBMEM7Z0JBQzFDLE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3RELElBQUksV0FBVyxFQUFFLENBQUM7b0JBQ2hCLE1BQU0sV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUM3QixDQUFDO2dCQUVELDhCQUE4QjtnQkFDOUIsTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FDdkIsRUFBRSxLQUFLLEVBQUUsRUFDVDtvQkFDRSxLQUFLLEVBQUUsR0FBRztvQkFDVixnQkFBZ0IsRUFBRSxHQUFHO29CQUNyQixZQUFZLEVBQUUsSUFBSTtpQkFDbkIsQ0FDRixDQUFDO1lBQ0osQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUVMLHNEQUFzRDtZQUN0RCxNQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUFZLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztZQUVuRCxxQ0FBcUM7WUFDckMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ3hDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLGlDQUFpQztRQUMzRCxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUNmLHFDQUFxQyxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQ3BELEtBQUssQ0FBQyxLQUFLLENBQ1osQ0FBQztZQUNGLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLHlDQUF5QztRQUNuRSxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBVztRQUNuQix5QkFBeUI7UUFDekIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFL0Isd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBRXpCLHdEQUF3RDtRQUN4RCxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQzVDLE9BQU87UUFDVCxDQUFDO1FBRUQsSUFBSSxDQUFDO1lBQ0gsbURBQW1EO1lBQ25ELE1BQU0sY0FBYyxHQUFHLElBQUksT0FBTyxDQUFPLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFO2dCQUNyRCxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUMxRSxDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sWUFBWSxHQUFHLENBQUMsS0FBSyxJQUFJLEVBQUU7Z0JBQy9CLE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQzlDLElBQUksR0FBRyxFQUFFLENBQUM7b0JBQ1IsTUFBTSxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3JCLENBQUM7WUFDSCxDQUFDLENBQUMsRUFBRSxDQUFDO1lBRUwsc0RBQXNEO1lBQ3RELE1BQU0sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLFlBQVksRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBRW5ELHdDQUF3QztZQUN4QyxJQUFJLENBQUMsZUFBZSxDQUFDLG1CQUFtQixFQUFFLENBQUM7WUFDM0MsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsaUNBQWlDO1FBQzNELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQ2YsbUNBQW1DLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFDbEQsS0FBSyxDQUFDLEtBQUssQ0FDWixDQUFDO1lBQ0YsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMseUNBQXlDO1FBQ25FLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBVztRQUNuQixvQ0FBb0M7UUFDcEMsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDO1lBQ3JDLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELHdDQUF3QztRQUN4QyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUV6QixnRkFBZ0Y7UUFDaEYsSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUM1QyxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCxJQUFJLENBQUM7WUFDSCxNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzlDLE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFDckIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsaUNBQWlDO1lBQ3pELE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQ2YsMENBQTBDLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFDekQsS0FBSyxDQUFDLEtBQUssQ0FDWixDQUFDO1lBQ0YsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMseUNBQXlDO1lBQ2pFLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxLQUFLO1FBQ1QscUJBQXFCO1FBQ3JCLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFM0Isd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBRXpCLHdEQUF3RDtRQUN4RCxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQzVDLE9BQU87UUFDVCxDQUFDO1FBRUQsSUFBSSxDQUFDO1lBQ0gsbURBQW1EO1lBQ25ELE1BQU0sY0FBYyxHQUFHLElBQUksT0FBTyxDQUFPLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFO2dCQUNyRCxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUN2RSxDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7WUFFN0Msc0RBQXNEO1lBQ3RELE1BQU0sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLFlBQVksRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBRW5ELHVDQUF1QztZQUN2QyxJQUFJLENBQUMsZUFBZSxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDMUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsaUNBQWlDO1FBQzNELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMseUJBQXlCLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDekUsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMseUNBQXlDO1FBQ25FLENBQUM7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsZUFBZTtRQUNiLFFBQVEsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQzFCLEtBQUssWUFBWSxDQUFDLE1BQU07Z0JBQ3RCLE9BQU8sUUFBUSxDQUFDO1lBQ2xCLEtBQUssWUFBWSxDQUFDLElBQUk7Z0JBQ3BCLE9BQU8sTUFBTSxDQUFDO1lBQ2hCLEtBQUssWUFBWSxDQUFDLFNBQVM7Z0JBQ3pCLE9BQU8sV0FBVyxDQUFDO1lBQ3JCO2dCQUNFLE9BQU8sU0FBUyxDQUFDO1FBQ3JCLENBQUM7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxpQkFBaUI7UUFDZixJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUM7UUFDeEMsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsd0RBQXdELENBQUMsQ0FBQztJQUM1RSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsZUFBZTtRQUNiLE9BQU87WUFDTCxLQUFLLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUM3QixZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7WUFDL0IsZUFBZSxFQUFFLElBQUksQ0FBQyxlQUFlO1lBQ3JDLGNBQWMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUk7WUFDdkMsZUFBZSxFQUFFO2dCQUNmLGdCQUFnQixFQUFFLElBQUksQ0FBQyxnQkFBZ0I7Z0JBQ3ZDLGNBQWMsRUFBRSxJQUFJLENBQUMsWUFBWTthQUNsQztTQUNGLENBQUM7SUFDSixDQUFDO0NBQ0YsQ0FBQTtBQWpjWSxvQ0FBWTt1QkFBWixZQUFZO0lBRHhCLElBQUEsbUJBQVUsR0FBRTtJQWVSLFdBQUEsSUFBQSxrQkFBVyxFQUFDLE9BQU8sQ0FBQyxDQUFBO3lEQUE4QixZQUFLLG9CQUFMLFlBQUssb0RBQ3RCLDZDQUFvQixvQkFBcEIsNkNBQW9CLG9EQUN0QixzQkFBYSxvQkFBYixzQkFBYTtHQWhCcEMsWUFBWSxDQWljeEIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXHNoYXJlZFxcY2FjaGVcXGNhY2hlLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTG9nZ2VyIH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xuaW1wb3J0IHsgSW5qZWN0UXVldWUgfSBmcm9tICdAbmVzdGpzL2J1bGwnO1xuaW1wb3J0IHsgUXVldWUgfSBmcm9tICdidWxsJztcbmltcG9ydCB7IENvbmZpZ1NlcnZpY2UgfSBmcm9tICdAbmVzdGpzL2NvbmZpZyc7XG5pbXBvcnQgeyBDYWNoZU1ldHJpY3NQcm92aWRlciB9IGZyb20gJy4vY2FjaGUtbWV0cmljcy5wcm92aWRlcic7XG5cbi8vIEVzdGFkb3MgZG8gQ2lyY3VpdCBCcmVha2VyXG5lbnVtIENpcmN1aXRTdGF0ZSB7XG4gIENMT1NFRCwgLy8gRnVuY2lvbmFtZW50byBub3JtYWxcbiAgT1BFTiwgICAvLyBFbSBmYWxoYSwgbsOjbyB0ZW50YSBvcGVyYcOnw7Vlc1xuICBIQUxGX09QRU4gLy8gVGVudGFuZG8gcmVjdXBlcmFyXG59XG5cbi8qKlxuICogU2VydmnDp28gZGUgY2FjaGVcbiAqXG4gKiBJbXBsZW1lbnRhIHVtIHNpc3RlbWEgZGUgY2FjaGUgdXRpbGl6YW5kbyBvIFJlZGlzIGF0cmF2w6lzIGRvIEJ1bGxcbiAqIHBhcmEgbWVsaG9yYXIgYSBwZXJmb3JtYW5jZSBkZSBvcGVyYcOnw7VlcyBmcmVxdWVudGVzXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDYWNoZVNlcnZpY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlciA9IG5ldyBMb2dnZXIoQ2FjaGVTZXJ2aWNlLm5hbWUpO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRUVEwgPSAzNjAwOyAvLyAxIGhvcmEgZW0gc2VndW5kb3NcbiAgXG4gIC8vIENpcmN1aXQgQnJlYWtlciBjb25maWd1cmHDp8O1ZXNcbiAgcHJpdmF0ZSBjaXJjdWl0U3RhdGU6IENpcmN1aXRTdGF0ZSA9IENpcmN1aXRTdGF0ZS5DTE9TRUQ7XG4gIHByaXZhdGUgZmFpbHVyZUNvdW50OiBudW1iZXIgPSAwO1xuICBwcml2YXRlIHJlYWRvbmx5IGZhaWx1cmVUaHJlc2hvbGQ6IG51bWJlciA9IDM7IC8vIFJlZHV6aWRvIHBhcmEgMyBmYWxoYXMgcGFyYSBhYnJpciBvIGNpcmN1aXRvIG1haXMgcmFwaWRhbWVudGVcbiAgcHJpdmF0ZSByZWFkb25seSByZXNldFRpbWVvdXQ6IG51bWJlciA9IDEwMDAwOyAvLyAxMCBzZWd1bmRvcyBwYXJhIHRlbnRhciByZWN1cGVyYXIgKHJlZHV6aWRvIHBhcmEgcmVzcG9zdGEgbWFpcyByw6FwaWRhKVxuICBwcml2YXRlIGxhc3RGYWlsdXJlVGltZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBpbk1lbW9yeUNhY2hlOiBNYXA8c3RyaW5nLCB7IHZhbHVlOiBhbnk7IGV4cGlyeTogbnVtYmVyIH0+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlYWRvbmx5IGxvY2FsQ2FjaGVUVEw6IG51bWJlcjtcbiAgXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3RRdWV1ZSgnY2FjaGUnKSBwcml2YXRlIHJlYWRvbmx5IGNhY2hlUXVldWU6IFF1ZXVlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWV0cmljc1Byb3ZpZGVyOiBDYWNoZU1ldHJpY3NQcm92aWRlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZ1NlcnZpY2U6IENvbmZpZ1NlcnZpY2UsXG4gICkge1xuICAgIC8vIFZlcmlmaWNhciBzZSBvIFJlZGlzIGVzdMOhIGRlc2FiaWxpdGFkbyB2aWEgY29uZmlndXJhw6fDo29cbiAgICBjb25zdCBkaXNhYmxlUmVkaXMgPSB0aGlzLmNvbmZpZ1NlcnZpY2UuZ2V0KCdESVNBQkxFX1JFRElTJykgPT09ICd0cnVlJztcbiAgICBcbiAgICAvLyBDYXJyZWdhciBjb25maWd1cmHDp8O1ZXMgZG8gY2lyY3VpdCBicmVha2VyXG4gICAgdGhpcy5mYWlsdXJlVGhyZXNob2xkID0gdGhpcy5jb25maWdTZXJ2aWNlLmdldDxudW1iZXI+KCdDQUNIRV9DSVJDVUlUX0JSRUFLRVJfVEhSRVNIT0xEJywgMyk7XG4gICAgdGhpcy5yZXNldFRpbWVvdXQgPSB0aGlzLmNvbmZpZ1NlcnZpY2UuZ2V0PG51bWJlcj4oJ0NBQ0hFX0NJUkNVSVRfQlJFQUtFUl9SRVNFVCcsIDEwMDAwKTtcbiAgICB0aGlzLmxvY2FsQ2FjaGVUVEwgPSB0aGlzLmNvbmZpZ1NlcnZpY2UuZ2V0PG51bWJlcj4oJ0NBQ0hFX0xPQ0FMX1RUTCcsIDYwMCk7XG4gICAgXG4gICAgaWYgKGRpc2FibGVSZWRpcykge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignUmVkaXMgZXN0w6EgZGVzYWJpbGl0YWRvLiBVc2FuZG8gYXBlbmFzIGNhY2hlIGxvY2FsLicpO1xuICAgICAgdGhpcy5jaXJjdWl0U3RhdGUgPSBDaXJjdWl0U3RhdGUuT1BFTjsgLy8gRm9yw6dhciB1c28gZG8gY2FjaGUgbG9jYWxcbiAgICB9XG4gICAgXG4gICAgLy8gVmVyaWZpY2FyIGNvbmV4w6NvIGNvbSBSZWRpcyBuYSBpbmljaWFsaXphw6fDo29cbiAgICB0aGlzLmNoZWNrUmVkaXNDb25uZWN0aW9uKCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBWZXJpZmljYSBhIGNvbmV4w6NvIGNvbSBvIFJlZGlzIG5hIGluaWNpYWxpemHDp8Ojb1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjaGVja1JlZGlzQ29ubmVjdGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRGVmaW5pciB1bSB0aW1lb3V0IHBhcmEgZXZpdGFyIGJsb3F1ZWlvXG4gICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChfLCByZWplY3QpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0IGFvIHZlcmlmaWNhciBjb25leMOjbyBjb20gUmVkaXMnKSksIDIwMDApO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHBpbmdQcm9taXNlID0gdGhpcy5jYWNoZVF1ZXVlLmNsaWVudC5waW5nKCk7XG4gICAgICBcbiAgICAgIGF3YWl0IFByb21pc2UucmFjZShbcGluZ1Byb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ0NvbmV4w6NvIGNvbSBSZWRpcyBlc3RhYmVsZWNpZGEgY29tIHN1Y2Vzc28nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gY29uZWN0YXIgY29tIFJlZGlzOiAke2Vycm9yLm1lc3NhZ2V9LiBVc2FuZG8gY2FjaGUgbG9jYWwuYCwgZXJyb3Iuc3RhY2spO1xuICAgICAgLy8gQWJyaXIgbyBjaXJjdWl0IGJyZWFrZXIgcGFyYSB1c2FyIGNhY2hlIGxvY2FsXG4gICAgICB0aGlzLmNpcmN1aXRTdGF0ZSA9IENpcmN1aXRTdGF0ZS5PUEVOO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFZlcmlmaWNhIG8gZXN0YWRvIGRvIGNpcmN1aXQgYnJlYWtlciBlIGF0dWFsaXphIGNvbmZvcm1lIG5lY2Vzc8OhcmlvXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNoZWNrQ2lyY3VpdFN0YXRlKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gU2UgZXN0aXZlciBhYmVydG8sIHZlcmlmaWNhciBzZSBqw6EgcGFzc291IG8gdGVtcG8gcGFyYSB0ZW50YXIgcmVjdXBlcmFyXG4gICAgaWYgKHRoaXMuY2lyY3VpdFN0YXRlID09PSBDaXJjdWl0U3RhdGUuT1BFTikge1xuICAgICAgaWYgKG5vdyAtIHRoaXMubGFzdEZhaWx1cmVUaW1lID4gdGhpcy5yZXNldFRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdDaXJjdWl0IEJyZWFrZXIgbXVkYW5kbyBwYXJhIGVzdGFkbyBIQUxGX09QRU4sIHRlbnRhbmRvIHJlY3VwZXJhcicpO1xuICAgICAgICB0aGlzLmNpcmN1aXRTdGF0ZSA9IENpcmN1aXRTdGF0ZS5IQUxGX09QRU47XG4gICAgICAgIC8vIFJlc2V0YXIgY29udGFkb3IgZGUgZmFsaGFzIGFvIHRlbnRhciByZWN1cGVyYXJcbiAgICAgICAgdGhpcy5mYWlsdXJlQ291bnQgPSAwO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVnaXN0cmFyIG3DqXRyaWNhIGRlIHJlY3VwZXJhw6fDo29cbiAgICAgICAgdGhpcy5tZXRyaWNzUHJvdmlkZXIucmVnaXN0ZXJDYWNoZVJlY292ZXJ5QXR0ZW1wdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlZ2lzdHJhIHVtYSBmYWxoYSBubyBjaXJjdWl0IGJyZWFrZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmVnaXN0ZXJGYWlsdXJlKCk6IHZvaWQge1xuICAgIHRoaXMuZmFpbHVyZUNvdW50Kys7XG4gICAgdGhpcy5sYXN0RmFpbHVyZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICBcbiAgICAvLyBSZWdpc3RyYXIgbcOpdHJpY2EgZGUgZmFsaGFcbiAgICB0aGlzLm1ldHJpY3NQcm92aWRlci5yZWdpc3RlckNhY2hlRmFpbHVyZSgpO1xuICAgIFxuICAgIGlmICh0aGlzLmZhaWx1cmVDb3VudCA+PSB0aGlzLmZhaWx1cmVUaHJlc2hvbGQgJiYgdGhpcy5jaXJjdWl0U3RhdGUgPT09IENpcmN1aXRTdGF0ZS5DTE9TRUQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oYENpcmN1aXQgQnJlYWtlciBtdWRhbmRvIHBhcmEgZXN0YWRvIE9QRU4gYXDDs3MgJHt0aGlzLmZhaWx1cmVDb3VudH0gZmFsaGFzYCk7XG4gICAgICB0aGlzLmNpcmN1aXRTdGF0ZSA9IENpcmN1aXRTdGF0ZS5PUEVOO1xuICAgICAgXG4gICAgICAvLyBMaW1wYXIgZmlsYSBkZSBjYWNoZSBxdWFuZG8gbyBjaXJjdWl0byBhYnJpciBwYXJhIGV2aXRhciBhY3VtdWxhciBvcGVyYcOnw7VlcyBwZW5kZW50ZXNcbiAgICAgIHRoaXMuY2xlYXJDYWNoZVF1ZXVlKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gbGltcGFyIGZpbGEgZGUgY2FjaGU6ICR7ZXJyLm1lc3NhZ2V9YCwgZXJyLnN0YWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIExpbXBhIGEgZmlsYSBkZSBjYWNoZSBwYXJhIGV2aXRhciBhY3VtdWxhciBvcGVyYcOnw7VlcyBwZW5kZW50ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY2xlYXJDYWNoZVF1ZXVlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBEZWZpbmlyIHVtIHRpbWVvdXQgcGFyYSBldml0YXIgYmxvcXVlaW9cbiAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQgYW8gbGltcGFyIGZpbGEgZGUgY2FjaGUnKSksIDEwMDApO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGNsZWFuUHJvbWlzZSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5jYWNoZVF1ZXVlLmNsZWFuKDAsICdkZWxheWVkJyksXG4gICAgICAgIHRoaXMuY2FjaGVRdWV1ZS5jbGVhbigwLCAnd2FpdCcpXG4gICAgICBdKTtcbiAgICAgIFxuICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtjbGVhblByb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ0ZpbGEgZGUgY2FjaGUgbGltcGEgY29tIHN1Y2Vzc28nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gbGltcGFyIGZpbGEgZGUgY2FjaGU6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvci5zdGFjayk7XG4gICAgICAvLyBGb3LDp2FyIG8gZmVjaGFtZW50byBkbyBjaXJjdWl0byBlbSBjYXNvIGRlIGVycm8gYW8gbGltcGFyIGEgZmlsYVxuICAgICAgLy8gSXNzbyDDqSBpbXBvcnRhbnRlIHBhcmEgZXZpdGFyIHF1ZSBvIHNpc3RlbWEgY29udGludWUgdGVudGFuZG8gdXNhciBvIFJlZGlzXG4gICAgICB0aGlzLmNpcmN1aXRTdGF0ZSA9IENpcmN1aXRTdGF0ZS5PUEVOO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlZ2lzdHJhIHVtIHN1Y2Vzc28gbm8gY2lyY3VpdCBicmVha2VyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHJlZ2lzdGVyU3VjY2VzcygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jaXJjdWl0U3RhdGUgPT09IENpcmN1aXRTdGF0ZS5IQUxGX09QRU4pIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnQ2lyY3VpdCBCcmVha2VyIHJlY3VwZXJhZG8sIHZvbHRhbmRvIHBhcmEgZXN0YWRvIENMT1NFRCcpO1xuICAgICAgdGhpcy5jaXJjdWl0U3RhdGUgPSBDaXJjdWl0U3RhdGUuQ0xPU0VEO1xuICAgICAgdGhpcy5mYWlsdXJlQ291bnQgPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jaXJjdWl0U3RhdGUgPT09IENpcmN1aXRTdGF0ZS5DTE9TRUQpIHtcbiAgICAgIC8vIFJlc2V0YXIgY29udGFkb3IgZGUgZmFsaGFzIGdyYWR1YWxtZW50ZSBlbSBjYXNvIGRlIHN1Y2Vzc29cbiAgICAgIHRoaXMuZmFpbHVyZUNvdW50ID0gTWF0aC5tYXgoMCwgdGhpcy5mYWlsdXJlQ291bnQgLSAxKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTYWx2YSB1bSB2YWxvciBubyBjYWNoZSBsb2NhbCBlbSBtZW3Ds3JpYVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXRMb2NhbENhY2hlPFQ+KGtleTogc3RyaW5nLCB2YWx1ZTogVCwgdHRsOiBudW1iZXIgPSB0aGlzLmxvY2FsQ2FjaGVUVEwpOiB2b2lkIHtcbiAgICBjb25zdCBleHBpcnkgPSBEYXRlLm5vdygpICsgKHR0bCAqIDEwMDApO1xuICAgIHRoaXMuaW5NZW1vcnlDYWNoZS5zZXQoa2V5LCB7IHZhbHVlLCBleHBpcnkgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBPYnTDqW0gdW0gdmFsb3IgZG8gY2FjaGUgbG9jYWwgZW0gbWVtw7NyaWFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgZ2V0TG9jYWxDYWNoZTxUPihrZXk6IHN0cmluZyk6IFQgfCBudWxsIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmluTWVtb3J5Q2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKCFjYWNoZWQpIHtyZXR1cm4gbnVsbDt9XG4gICAgXG4gICAgaWYgKERhdGUubm93KCkgPiBjYWNoZWQuZXhwaXJ5KSB7XG4gICAgICB0aGlzLmluTWVtb3J5Q2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNhY2hlZC52YWx1ZSBhcyBUO1xuICB9XG4gIFxuICBhc3luYyBnZXQ8VD4oa2V5OiBzdHJpbmcpOiBQcm9taXNlPFQgfCBudWxsPiB7XG4gICAgLy8gUHJpbWVpcm8gdmVyaWZpY2FyIGNhY2hlIGxvY2FsIChtYWlzIHLDoXBpZG8gZSBzZW0gZGVwZW5kw6puY2lhIGRvIFJlZGlzKVxuICAgIGNvbnN0IGxvY2FsVmFsdWUgPSB0aGlzLmdldExvY2FsQ2FjaGU8VD4oa2V5KTtcbiAgICBpZiAobG9jYWxWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5tZXRyaWNzUHJvdmlkZXIucmVnaXN0ZXJDYWNoZUhpdCgpO1xuICAgICAgcmV0dXJuIGxvY2FsVmFsdWU7XG4gICAgfVxuICAgIFxuICAgIC8vIFZlcmlmaWNhciBvIGVzdGFkbyBkbyBjaXJjdWl0IGJyZWFrZXJcbiAgICB0aGlzLmNoZWNrQ2lyY3VpdFN0YXRlKCk7XG4gICAgXG4gICAgLy8gU2UgbyBjaXJjdWl0IGJyZWFrZXIgZXN0aXZlciBhYmVydG8sIG7Do28gdGVudGFyIFJlZGlzIGUgcmV0b3JuYXIgbnVsbFxuICAgIGlmICh0aGlzLmNpcmN1aXRTdGF0ZSA9PT0gQ2lyY3VpdFN0YXRlLk9QRU4pIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBDaXJjdWl0IGJyZWFrZXIgYWJlcnRvLCBuw6NvIHRlbnRhbmRvIFJlZGlzIHBhcmEgY2hhdmU6ICR7a2V5fWApO1xuICAgICAgdGhpcy5tZXRyaWNzUHJvdmlkZXIucmVnaXN0ZXJDYWNoZU1pc3MoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgam9iID0gYXdhaXQgdGhpcy5jYWNoZVF1ZXVlLmdldEpvYihrZXkpO1xuXG4gICAgICBpZiAoIWpvYikge1xuICAgICAgICAvLyBDYWNoZSBtaXNzXG4gICAgICAgIHRoaXMubWV0cmljc1Byb3ZpZGVyLnJlZ2lzdGVyQ2FjaGVNaXNzKCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJTdWNjZXNzKCk7IC8vIE9wZXJhw6fDo28gY29uY2x1w61kYSBjb20gc3VjZXNzbyAobWVzbW8gcXVlIHNlamEgdW0gbWlzcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGpvYkRhdGEgPSBhd2FpdCBqb2IuZGF0YTtcblxuICAgICAgLy8gVmVyaWZpY2FyIHNlIG8gam9iIGV4cGlyb3VcbiAgICAgIGlmIChqb2IuZmluaXNoZWRPbiAmJiBEYXRlLm5vdygpID4gam9iLmZpbmlzaGVkT24pIHtcbiAgICAgICAgYXdhaXQgam9iLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLm1ldHJpY3NQcm92aWRlci5yZWdpc3RlckNhY2hlTWlzcygpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyU3VjY2VzcygpOyAvLyBPcGVyYcOnw6NvIGNvbmNsdcOtZGEgY29tIHN1Y2Vzc29cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIENhY2hlIGhpdCAtIGFybWF6ZW5hciB0YW1iw6ltIG5vIGNhY2hlIGxvY2FsXG4gICAgICBjb25zdCB2YWx1ZSA9IGpvYkRhdGEudmFsdWUgYXMgVDtcbiAgICAgIHRoaXMuc2V0TG9jYWxDYWNoZShrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMubWV0cmljc1Byb3ZpZGVyLnJlZ2lzdGVyQ2FjaGVIaXQoKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJTdWNjZXNzKCk7IC8vIE9wZXJhw6fDo28gY29uY2x1w61kYSBjb20gc3VjZXNzb1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gb2J0ZXIgdmFsb3IgZG8gY2FjaGU6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICBlcnJvci5zdGFjayxcbiAgICAgICk7XG4gICAgICB0aGlzLnJlZ2lzdGVyRmFpbHVyZSgpOyAvLyBSZWdpc3RyYXIgZmFsaGEgcGFyYSBvIGNpcmN1aXQgYnJlYWtlclxuICAgICAgdGhpcy5tZXRyaWNzUHJvdmlkZXIucmVnaXN0ZXJDYWNoZU1pc3MoKTtcbiAgICAgIFxuICAgICAgLy8gU2UgZm9yIHVtIGVycm8gZGUgdGltZW91dCwgdGVudGFyIG9idGVyIG8gdmFsb3IgZG8gY2FjaGUgbG9jYWwgbm92YW1lbnRlXG4gICAgICAvLyBJc3NvIHBvZGUgYWNvbnRlY2VyIHNlIG8gdmFsb3IgZm9yIGFkaWNpb25hZG8gYW8gY2FjaGUgbG9jYWwgcG9yIG91dHJhIHRocmVhZFxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnVGltZW91dCcpKSB7XG4gICAgICAgIGNvbnN0IHJldHJ5TG9jYWxWYWx1ZSA9IHRoaXMuZ2V0TG9jYWxDYWNoZTxUPihrZXkpO1xuICAgICAgICBpZiAocmV0cnlMb2NhbFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFZhbG9yIGVuY29udHJhZG8gbm8gY2FjaGUgbG9jYWwgYXDDs3MgdGltZW91dDogJHtrZXl9YCk7XG4gICAgICAgICAgcmV0dXJuIHJldHJ5TG9jYWxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXJtYXplbmEgdW0gdmFsb3Igbm8gY2FjaGVcbiAgICogQHBhcmFtIGtleSBDaGF2ZSBwYXJhIGFybWF6ZW5hciBvIHZhbG9yXG4gICAqIEBwYXJhbSB2YWx1ZSBWYWxvciBhIHNlciBhcm1hemVuYWRvXG4gICAqIEBwYXJhbSB0dGwgVGVtcG8gZGUgdmlkYSBlbSBzZWd1bmRvcyAocGFkcsOjbzogMSBob3JhKVxuICAgKi9cbiAgYXN5bmMgc2V0PFQ+KFxuICAgIGtleTogc3RyaW5nLFxuICAgIHZhbHVlOiBULFxuICAgIHR0bDogbnVtYmVyID0gdGhpcy5kZWZhdWx0VFRMLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBBcm1hemVuYXIgbm8gY2FjaGUgbG9jYWwgcHJpbWVpcm8gKG1haXMgcsOhcGlkbyBlIHNlbSBkZXBlbmTDqm5jaWEgZG8gUmVkaXMpXG4gICAgdGhpcy5zZXRMb2NhbENhY2hlKGtleSwgdmFsdWUsIHR0bCk7XG4gICAgXG4gICAgLy8gVmVyaWZpY2FyIG8gZXN0YWRvIGRvIGNpcmN1aXQgYnJlYWtlclxuICAgIHRoaXMuY2hlY2tDaXJjdWl0U3RhdGUoKTtcbiAgICBcbiAgICAvLyBTZSBvIGNpcmN1aXQgYnJlYWtlciBlc3RpdmVyIGFiZXJ0bywgbsOjbyB0ZW50YXIgUmVkaXNcbiAgICBpZiAodGhpcy5jaXJjdWl0U3RhdGUgPT09IENpcmN1aXRTdGF0ZS5PUEVOKSB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgQ2lyY3VpdCBicmVha2VyIGFiZXJ0bywgbsOjbyB0ZW50YW5kbyBSZWRpcyBwYXJhIGNoYXZlOiAke2tleX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRpbWVvdXQgcGFyYSBldml0YXIgYmxvcXVlaW8gZGEgdGhyZWFkIHByaW5jaXBhbFxuICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCBhbyBhcm1hemVuYXIgbm8gY2FjaGUnKSksIDUwMCk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgY2FjaGVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gUmVtb3ZlciBqb2IgZXhpc3RlbnRlIGNvbSBhIG1lc21hIGNoYXZlXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSm9iID0gYXdhaXQgdGhpcy5jYWNoZVF1ZXVlLmdldEpvYihrZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdKb2IpIHtcbiAgICAgICAgICBhd2FpdCBleGlzdGluZ0pvYi5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyaWFyIG5vdm8gam9iIGNvbSBvcyBkYWRvc1xuICAgICAgICBhd2FpdCB0aGlzLmNhY2hlUXVldWUuYWRkKFxuICAgICAgICAgIHsgdmFsdWUgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBqb2JJZDoga2V5LFxuICAgICAgICAgICAgcmVtb3ZlT25Db21wbGV0ZTogdHRsLFxuICAgICAgICAgICAgcmVtb3ZlT25GYWlsOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9KSgpO1xuICAgICAgXG4gICAgICAvLyBVc2FyIHJhY2UgcGFyYSBldml0YXIgYmxvcXVlaW8gcG9yIHRlbXBvIGluZGVmaW5pZG9cbiAgICAgIGF3YWl0IFByb21pc2UucmFjZShbY2FjaGVQcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pO1xuICAgICAgXG4gICAgICAvLyBSZWdpc3RyYXIgb3BlcmHDp8OjbyBkZSBzZXQgbm8gY2FjaGVcbiAgICAgIHRoaXMubWV0cmljc1Byb3ZpZGVyLnJlZ2lzdGVyQ2FjaGVTZXQoKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJTdWNjZXNzKCk7IC8vIE9wZXJhw6fDo28gY29uY2x1w61kYSBjb20gc3VjZXNzb1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gYXJtYXplbmFyIHZhbG9yIG5vIGNhY2hlOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhpcy5yZWdpc3RlckZhaWx1cmUoKTsgLy8gUmVnaXN0cmFyIGZhbGhhIHBhcmEgbyBjaXJjdWl0IGJyZWFrZXJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVtIHZhbG9yIGRvIGNhY2hlXG4gICAqIEBwYXJhbSBrZXkgQ2hhdmUgZG8gdmFsb3IgYSBzZXIgcmVtb3ZpZG9cbiAgICovXG4gIGFzeW5jIGRlbChrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFJlbW92ZXIgZG8gY2FjaGUgbG9jYWxcbiAgICB0aGlzLmluTWVtb3J5Q2FjaGUuZGVsZXRlKGtleSk7XG4gICAgXG4gICAgLy8gVmVyaWZpY2FyIG8gZXN0YWRvIGRvIGNpcmN1aXQgYnJlYWtlclxuICAgIHRoaXMuY2hlY2tDaXJjdWl0U3RhdGUoKTtcbiAgICBcbiAgICAvLyBTZSBvIGNpcmN1aXQgYnJlYWtlciBlc3RpdmVyIGFiZXJ0bywgbsOjbyB0ZW50YXIgUmVkaXNcbiAgICBpZiAodGhpcy5jaXJjdWl0U3RhdGUgPT09IENpcmN1aXRTdGF0ZS5PUEVOKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBUaW1lb3V0IHBhcmEgZXZpdGFyIGJsb3F1ZWlvIGRhIHRocmVhZCBwcmluY2lwYWxcbiAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQgYW8gcmVtb3ZlciBkbyBjYWNoZScpKSwgNTAwKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBjYWNoZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBqb2IgPSBhd2FpdCB0aGlzLmNhY2hlUXVldWUuZ2V0Sm9iKGtleSk7XG4gICAgICAgIGlmIChqb2IpIHtcbiAgICAgICAgICBhd2FpdCBqb2IucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgICBcbiAgICAgIC8vIFVzYXIgcmFjZSBwYXJhIGV2aXRhciBibG9xdWVpbyBwb3IgdGVtcG8gaW5kZWZpbmlkb1xuICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtjYWNoZVByb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgICBcbiAgICAgIC8vIFJlZ2lzdHJhciBvcGVyYcOnw6NvIGRlIGRlbGV0ZSBubyBjYWNoZVxuICAgICAgdGhpcy5tZXRyaWNzUHJvdmlkZXIucmVnaXN0ZXJDYWNoZURlbGV0ZSgpO1xuICAgICAgdGhpcy5yZWdpc3RlclN1Y2Nlc3MoKTsgLy8gT3BlcmHDp8OjbyBjb25jbHXDrWRhIGNvbSBzdWNlc3NvXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBgRXJybyBhbyByZW1vdmVyIHZhbG9yIGRvIGNhY2hlOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhpcy5yZWdpc3RlckZhaWx1cmUoKTsgLy8gUmVnaXN0cmFyIGZhbGhhIHBhcmEgbyBjaXJjdWl0IGJyZWFrZXJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgdW1hIGNoYXZlIGV4aXN0ZSBubyBjYWNoZVxuICAgKiBAcGFyYW0ga2V5IENoYXZlIGEgc2VyIHZlcmlmaWNhZGFcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBhIGNoYXZlIGV4aXN0aXIsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgYXN5bmMgaGFzKGtleTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gVmVyaWZpY2FyIHByaW1laXJvIG5vIGNhY2hlIGxvY2FsXG4gICAgaWYgKHRoaXMuZ2V0TG9jYWxDYWNoZShrZXkpICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gVmVyaWZpY2FyIG8gZXN0YWRvIGRvIGNpcmN1aXQgYnJlYWtlclxuICAgIHRoaXMuY2hlY2tDaXJjdWl0U3RhdGUoKTtcbiAgICBcbiAgICAvLyBTZSBvIGNpcmN1aXQgYnJlYWtlciBlc3RpdmVyIGFiZXJ0bywgcmV0b3JuYXIgYXBlbmFzIHJlc3VsdGFkbyBkbyBjYWNoZSBsb2NhbFxuICAgIGlmICh0aGlzLmNpcmN1aXRTdGF0ZSA9PT0gQ2lyY3VpdFN0YXRlLk9QRU4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGpvYiA9IGF3YWl0IHRoaXMuY2FjaGVRdWV1ZS5nZXRKb2Ioa2V5KTtcbiAgICAgIGNvbnN0IGV4aXN0cyA9ICEham9iO1xuICAgICAgdGhpcy5yZWdpc3RlclN1Y2Nlc3MoKTsgLy8gT3BlcmHDp8OjbyBjb25jbHXDrWRhIGNvbSBzdWNlc3NvXG4gICAgICByZXR1cm4gZXhpc3RzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gdmVyaWZpY2FyIGV4aXN0w6puY2lhIG5vIGNhY2hlOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhpcy5yZWdpc3RlckZhaWx1cmUoKTsgLy8gUmVnaXN0cmFyIGZhbGhhIHBhcmEgbyBjaXJjdWl0IGJyZWFrZXJcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGltcGEgdG9kbyBvIGNhY2hlXG4gICAqL1xuICBhc3luYyBjbGVhcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBMaW1wYXIgY2FjaGUgbG9jYWxcbiAgICB0aGlzLmluTWVtb3J5Q2FjaGUuY2xlYXIoKTtcbiAgICBcbiAgICAvLyBWZXJpZmljYXIgbyBlc3RhZG8gZG8gY2lyY3VpdCBicmVha2VyXG4gICAgdGhpcy5jaGVja0NpcmN1aXRTdGF0ZSgpO1xuICAgIFxuICAgIC8vIFNlIG8gY2lyY3VpdCBicmVha2VyIGVzdGl2ZXIgYWJlcnRvLCBuw6NvIHRlbnRhciBSZWRpc1xuICAgIGlmICh0aGlzLmNpcmN1aXRTdGF0ZSA9PT0gQ2lyY3VpdFN0YXRlLk9QRU4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRpbWVvdXQgcGFyYSBldml0YXIgYmxvcXVlaW8gZGEgdGhyZWFkIHByaW5jaXBhbFxuICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCBhbyBsaW1wYXIgY2FjaGUnKSksIDEwMDApO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGNhY2hlUHJvbWlzZSA9IHRoaXMuY2FjaGVRdWV1ZS5lbXB0eSgpO1xuICAgICAgXG4gICAgICAvLyBVc2FyIHJhY2UgcGFyYSBldml0YXIgYmxvcXVlaW8gcG9yIHRlbXBvIGluZGVmaW5pZG9cbiAgICAgIGF3YWl0IFByb21pc2UucmFjZShbY2FjaGVQcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pO1xuICAgICAgXG4gICAgICAvLyBSZWdpc3RyYXIgb3BlcmHDp8OjbyBkZSBjbGVhciBubyBjYWNoZVxuICAgICAgdGhpcy5tZXRyaWNzUHJvdmlkZXIucmVnaXN0ZXJDYWNoZUNsZWFyKCk7XG4gICAgICB0aGlzLnJlZ2lzdGVyU3VjY2VzcygpOyAvLyBPcGVyYcOnw6NvIGNvbmNsdcOtZGEgY29tIHN1Y2Vzc29cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gbGltcGFyIGNhY2hlOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3Iuc3RhY2spO1xuICAgICAgdGhpcy5yZWdpc3RlckZhaWx1cmUoKTsgLy8gUmVnaXN0cmFyIGZhbGhhIHBhcmEgbyBjaXJjdWl0IGJyZWFrZXJcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBPYnTDqW0gbyBlc3RhZG8gYXR1YWwgZG8gY2lyY3VpdCBicmVha2VyXG4gICAqIEByZXR1cm5zIEVzdGFkbyBhdHVhbCBkbyBjaXJjdWl0IGJyZWFrZXJcbiAgICovXG4gIGdldENpcmN1aXRTdGF0ZSgpOiBzdHJpbmcge1xuICAgIHN3aXRjaCAodGhpcy5jaXJjdWl0U3RhdGUpIHtcbiAgICAgIGNhc2UgQ2lyY3VpdFN0YXRlLkNMT1NFRDpcbiAgICAgICAgcmV0dXJuICdDTE9TRUQnO1xuICAgICAgY2FzZSBDaXJjdWl0U3RhdGUuT1BFTjpcbiAgICAgICAgcmV0dXJuICdPUEVOJztcbiAgICAgIGNhc2UgQ2lyY3VpdFN0YXRlLkhBTEZfT1BFTjpcbiAgICAgICAgcmV0dXJuICdIQUxGX09QRU4nO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdVTktOT1dOJztcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBGb3LDp2EgbyBmZWNoYW1lbnRvIGRvIGNpcmN1aXQgYnJlYWtlciwgw7p0aWwgcGFyYSByZWN1cGVyYcOnw6NvIG1hbnVhbFxuICAgKi9cbiAgZm9yY2VDbG9zZUNpcmN1aXQoKTogdm9pZCB7XG4gICAgdGhpcy5jaXJjdWl0U3RhdGUgPSBDaXJjdWl0U3RhdGUuQ0xPU0VEO1xuICAgIHRoaXMuZmFpbHVyZUNvdW50ID0gMDtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ0NpcmN1aXQgQnJlYWtlciBmb3LDp2FkbyBwYXJhIGVzdGFkbyBDTE9TRUQgbWFudWFsbWVudGUnKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIE9idMOpbSBlc3RhdMOtc3RpY2FzIGRvIGNpcmN1aXQgYnJlYWtlclxuICAgKiBAcmV0dXJucyBFc3RhdMOtc3RpY2FzIGRvIGNpcmN1aXQgYnJlYWtlclxuICAgKi9cbiAgZ2V0Q2lyY3VpdFN0YXRzKCk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiB0aGlzLmdldENpcmN1aXRTdGF0ZSgpLFxuICAgICAgZmFpbHVyZUNvdW50OiB0aGlzLmZhaWx1cmVDb3VudCxcbiAgICAgIGxhc3RGYWlsdXJlVGltZTogdGhpcy5sYXN0RmFpbHVyZVRpbWUsXG4gICAgICBsb2NhbENhY2hlU2l6ZTogdGhpcy5pbk1lbW9yeUNhY2hlLnNpemUsXG4gICAgICB0aHJlc2hvbGRDb25maWc6IHtcbiAgICAgICAgZmFpbHVyZVRocmVzaG9sZDogdGhpcy5mYWlsdXJlVGhyZXNob2xkLFxuICAgICAgICByZXNldFRpbWVvdXRNczogdGhpcy5yZXNldFRpbWVvdXQsXG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9