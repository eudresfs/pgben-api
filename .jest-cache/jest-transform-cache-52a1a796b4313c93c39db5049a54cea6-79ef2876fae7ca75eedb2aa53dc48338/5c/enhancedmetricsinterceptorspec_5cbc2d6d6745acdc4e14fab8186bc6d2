647704c6b1a674d017ed11928d5398d1
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const testing_1 = require("@nestjs/testing");
const enhanced_metrics_interceptor_1 = require("../enhanced-metrics.interceptor");
const enhanced_metrics_service_1 = require("../enhanced-metrics.service");
const common_1 = require("@nestjs/common");
const rxjs_1 = require("rxjs");
const core_1 = require("@nestjs/core");
/**
 * Testes unitários para o interceptor de métricas aprimorado
 *
 * Verifica o funcionamento do interceptor que coleta métricas
 * avançadas sobre as requisições HTTP, com foco em segurança e compliance LGPD
 */
describe('EnhancedMetricsInterceptor', () => {
    let interceptor;
    let metricsService;
    let reflector;
    // Mock do serviço de métricas aprimoradas
    const mockMetricsService = {
        incrementHttpRequestsInProgress: jest.fn(),
        decrementHttpRequestsInProgress: jest.fn(),
        recordHttpRequest: jest.fn(),
        recordHttpRequestDuration: jest.fn(),
        recordSecurityEvent: jest.fn(),
        recordLgpdDataAccess: jest.fn(),
        recordAuthorizationFailure: jest.fn(),
    };
    // Mock do reflector
    const mockReflector = {
        get: jest.fn(),
    };
    beforeEach(async () => {
        jest.clearAllMocks();
        // Mock para Date.now() - primeiro retorna 1000, depois 1200
        jest
            .spyOn(Date, 'now')
            .mockImplementationOnce(() => 1000)
            .mockImplementationOnce(() => 1200);
        const module = await testing_1.Test.createTestingModule({
            providers: [
                enhanced_metrics_interceptor_1.EnhancedMetricsInterceptor,
                {
                    provide: enhanced_metrics_service_1.EnhancedMetricsService,
                    useValue: mockMetricsService,
                },
                {
                    provide: core_1.Reflector,
                    useValue: mockReflector,
                },
            ],
        }).compile();
        interceptor = module.get(enhanced_metrics_interceptor_1.EnhancedMetricsInterceptor);
        metricsService = module.get(enhanced_metrics_service_1.EnhancedMetricsService);
        reflector = module.get(core_1.Reflector);
    });
    afterEach(() => {
        jest.restoreAllMocks();
    });
    it('deve ser definido', () => {
        expect(interceptor).toBeDefined();
    });
    describe('intercept', () => {
        it('deve coletar métricas para uma requisição bem-sucedida', (done) => {
            // Mock do contexto de execução
            const mockRequest = {
                method: 'GET',
                originalUrl: '/api/cidadaos',
                route: {
                    path: '/api/cidadaos',
                },
                user: {
                    id: 'user123',
                    roles: ['admin'],
                },
                ip: '192.168.1.1',
                headers: {
                    'user-agent': 'test-agent',
                },
            };
            const mockResponse = {
                statusCode: 200,
                getHeaders: jest.fn().mockReturnValue({}),
            };
            const mockExecutionContext = {
                switchToHttp: jest.fn().mockReturnValue({
                    getRequest: jest.fn().mockReturnValue(mockRequest),
                    getResponse: jest.fn().mockReturnValue(mockResponse),
                }),
                getHandler: jest.fn(),
                getClass: jest.fn(),
            };
            // Mock do handler de chamada
            const mockCallHandler = {
                handle: jest.fn().mockReturnValue((0, rxjs_1.of)({ data: 'test' })),
            };
            // Mock do reflector para retornar metadados de LGPD
            mockReflector.get
                .mockReturnValueOnce(false) // isPublic
                .mockReturnValueOnce(['dados_pessoais']); // lgpdDataTypes
            // Executar o interceptor
            interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe({
                next: (data) => {
                    expect(data).toEqual({ data: 'test' });
                    // Verificar se as métricas foram coletadas corretamente
                    expect(mockMetricsService.incrementHttpRequestsInProgress).toHaveBeenCalledWith('GET', '/api/cidadaos', 'admin');
                    expect(mockMetricsService.decrementHttpRequestsInProgress).toHaveBeenCalledWith('GET', '/api/cidadaos', 'admin');
                    // O método recordHttpRequest não recebe ip e user-agent
                    expect(mockMetricsService.recordHttpRequest).toHaveBeenCalledWith('GET', '/api/cidadaos', 200, 'admin');
                    // Verificar se a duração foi registrada
                    // O método recordHttpRequestDuration não recebe ip e user-agent
                    expect(mockMetricsService.recordHttpRequestDuration).toHaveBeenCalledWith('GET', '/api/cidadaos', 200, 0.2, // 200ms em segundos
                    'admin');
                    // O método recordLgpdDataAccess não é chamado automaticamente no interceptor
                    // A verificação de acesso a dados LGPD deve ser feita manualmente
                    done();
                },
                error: (err) => {
                    done.fail(`Erro inesperado: ${err}`);
                },
            });
        });
        it('deve coletar métricas para uma requisição com erro', (done) => {
            // Mock do contexto de execução
            const mockRequest = {
                method: 'POST',
                originalUrl: '/api/cidadaos',
                route: {
                    path: '/api/cidadaos',
                },
                user: {
                    id: 'user123',
                    roles: ['user'],
                },
                ip: '192.168.1.2',
                headers: {
                    'user-agent': 'test-agent',
                },
            };
            const mockResponse = {
                statusCode: 500,
                getHeaders: jest.fn().mockReturnValue({}),
            };
            const mockExecutionContext = {
                switchToHttp: jest.fn().mockReturnValue({
                    getRequest: jest.fn().mockReturnValue(mockRequest),
                    getResponse: jest.fn().mockReturnValue(mockResponse),
                }),
                getHandler: jest.fn(),
                getClass: jest.fn(),
            };
            // Mock do handler de chamada com erro
            const mockError = new Error('Erro interno do servidor');
            mockError.status = 500;
            const mockCallHandler = {
                handle: jest.fn().mockReturnValue((0, rxjs_1.throwError)(() => mockError)),
            };
            // Mock do reflector - não é usado em caso de erro
            mockReflector.get.mockImplementation((key) => {
                if (key === 'isPublic') {
                    return false;
                }
                return undefined;
            });
            // Executar o interceptor
            interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe({
                next: () => {
                    done.fail('O interceptor deveria ter retornado um erro');
                },
                error: (error) => {
                    expect(error).toBe(mockError);
                    // Verificar se as métricas de erro foram registradas
                    expect(mockMetricsService.recordHttpRequest).toHaveBeenCalledWith('POST', '/api/cidadaos', 500, 'user');
                    // Verificar se a duração foi registrada
                    expect(mockMetricsService.recordHttpRequestDuration).toHaveBeenCalledWith('POST', '/api/cidadaos', 500, expect.any(Number), // Duração em segundos
                    'user');
                    // Verificar se o evento de segurança foi registrado
                    expect(mockMetricsService.recordSecurityEvent).toHaveBeenCalledWith('server_error', 'error', 'api');
                    done();
                },
            });
        });
        it('deve lidar com requisições não autenticadas', (done) => {
            // Mock do contexto de execução sem usuário autenticado
            const mockRequest = {
                method: 'GET',
                url: '/api/public',
                route: {
                    path: '/api/public',
                },
                ip: '192.168.1.3',
                headers: {
                    'user-agent': 'test-agent',
                },
            };
            const mockResponse = {
                statusCode: 200,
                getHeaders: jest.fn().mockReturnValue({}),
            };
            const mockExecutionContext = {
                switchToHttp: jest.fn().mockReturnValue({
                    getRequest: jest.fn().mockReturnValue(mockRequest),
                    getResponse: jest.fn().mockReturnValue(mockResponse),
                }),
                getHandler: jest.fn(),
                getClass: jest.fn(),
            };
            // Mock do handler de chamada
            const mockCallHandler = {
                handle: jest.fn().mockReturnValue((0, rxjs_1.of)({ data: 'public data' })),
            };
            // O interceptor não verifica isPublic, apenas registra métricas
            // A verificação de rotas públicas é feita por outros middlewares/guards
            mockReflector.get.mockImplementation((key) => {
                if (key === 'isPublic') {
                    return true;
                }
                return undefined;
            });
            // Executar o interceptor
            interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe({
                next: (data) => {
                    expect(data).toEqual({ data: 'public data' });
                    // Verificar se as métricas foram coletadas sem informações de usuário
                    expect(mockMetricsService.recordHttpRequest).toHaveBeenCalledWith('GET', '/api/public', 200, 'anonymous');
                    // Verificar se a duração foi registrada
                    expect(mockMetricsService.recordHttpRequestDuration).toHaveBeenCalledWith('GET', '/api/public', 200, expect.any(Number), // Duração em segundos
                    'anonymous');
                    // O interceptor não verifica isPublic, então não podemos garantir que recordLgpdDataAccess não foi chamado
                    // A verificação de rotas públicas é feita por outros middlewares/guards
                    done();
                },
                error: done,
            });
        });
        it('deve lidar com erros de autorização', (done) => {
            // Mock do contexto de execução com usuário não autorizado
            const mockRequest = {
                method: 'GET',
                originalUrl: '/api/admin',
                route: {
                    path: '/api/admin',
                },
                user: {
                    id: 'user123',
                    roles: ['user'],
                },
                ip: '192.168.1.4',
                headers: {
                    'user-agent': 'test-agent',
                },
            };
            const mockResponse = {
                statusCode: 403,
                getHeaders: jest.fn().mockReturnValue({}),
            };
            const mockExecutionContext = {
                switchToHttp: jest.fn().mockReturnValue({
                    getRequest: jest.fn().mockReturnValue(mockRequest),
                    getResponse: jest.fn().mockReturnValue(mockResponse),
                }),
                getHandler: jest.fn(),
                getClass: jest.fn(),
            };
            // Mock do handler de chamada com erro de autorização
            const mockError = new common_1.UnauthorizedException('Acesso não autorizado');
            mockError.status = 403;
            const mockCallHandler = {
                handle: jest.fn().mockReturnValue((0, rxjs_1.throwError)(() => mockError)),
            };
            // Mock do reflector para o teste de autorização
            mockReflector.get.mockImplementation((key) => {
                if (key === 'isPublic') {
                    return false;
                }
                if (key === 'roles') {
                    return ['admin'];
                }
                if (key === 'lgpdDataTypes') {
                    return [];
                }
                return undefined;
            });
            // Executar o interceptor
            interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe({
                next: () => {
                    done.fail('Não deveria chegar aqui');
                },
                error: (error) => {
                    expect(error).toBe(mockError);
                    // Verificar se o evento de segurança foi registrado
                    expect(mockMetricsService.recordSecurityEvent).toHaveBeenCalledWith('authorization_failure', 'warning', 'api');
                    // Verificar se a falha de autorização foi registrada
                    expect(mockMetricsService.recordAuthorizationFailure).toHaveBeenCalledWith('/api/admin', 'unknown', 'user');
                    done();
                },
            });
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXHNoYXJlZFxcbW9uaXRvcmluZ1xcdGVzdHNcXGVuaGFuY2VkLW1ldHJpY3MuaW50ZXJjZXB0b3Iuc3BlYy50cyIsIm1hcHBpbmdzIjoiOztBQUFBLDZDQUFzRDtBQUN0RCxrRkFBNkU7QUFDN0UsMEVBQXFFO0FBQ3JFLDJDQUl3QjtBQUN4QiwrQkFBc0M7QUFFdEMsdUNBQXlDO0FBRXpDOzs7OztHQUtHO0FBQ0gsUUFBUSxDQUFDLDRCQUE0QixFQUFFLEdBQUcsRUFBRTtJQUMxQyxJQUFJLFdBQXVDLENBQUM7SUFDNUMsSUFBSSxjQUFzQyxDQUFDO0lBQzNDLElBQUksU0FBb0IsQ0FBQztJQUV6QiwwQ0FBMEM7SUFDMUMsTUFBTSxrQkFBa0IsR0FBRztRQUN6QiwrQkFBK0IsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQzFDLCtCQUErQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDMUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUM1Qix5QkFBeUIsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ3BDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDOUIsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUMvQiwwQkFBMEIsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0tBQ3RDLENBQUM7SUFFRixvQkFBb0I7SUFDcEIsTUFBTSxhQUFhLEdBQUc7UUFDcEIsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7S0FDZixDQUFDO0lBRUYsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3BCLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUVyQiw0REFBNEQ7UUFDNUQsSUFBSTthQUNELEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDO2FBQ2xCLHNCQUFzQixDQUFDLEdBQUcsRUFBRSxDQUFD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SyxlQUFlLEVBQUUsQ0FBQztvQkFDNUIsT0FBTyxFQUFFLENBQUM7Z0JBQ1osQ0FBQztnQkFDRCxPQUFPLFNBQVMsQ0FBQztZQUNuQixDQUFDLENBQUMsQ0FBQztZQUVILHlCQUF5QjtZQUN6QixXQUFXLENBQUMsU0FBUyxDQUFDLG9CQUFvQixFQUFFLGVBQWUsQ0FBQyxDQUFDLFNBQVMsQ0FBQztnQkFDckUsSUFBSSxFQUFFLEdBQUcsRUFBRTtvQkFDVCxJQUFJLENBQUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLENBQUM7Z0JBQ3ZDLENBQUM7Z0JBQ0QsS0FBSyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7b0JBQ2YsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztvQkFFOUIsb0RBQW9EO29CQUNwRCxNQUFNLENBQUMsa0JBQWtCLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxvQkFBb0IsQ0FDakUsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxLQUFLLENBQ04sQ0FBQztvQkFFRixxREFBcUQ7b0JBQ3JELE1BQU0sQ0FDSixrQkFBa0IsQ0FBQywwQkFBMEIsQ0FDOUMsQ0FBQyxvQkFBb0IsQ0FBQyxZQUFZLEVBQUUsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO29CQUV4RCxJQUFJLEVBQUUsQ0FBQztnQkFDVCxDQUFDO2FBQ0YsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZXVkcmVcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxzaGFyZWRcXG1vbml0b3JpbmdcXHRlc3RzXFxlbmhhbmNlZC1tZXRyaWNzLmludGVyY2VwdG9yLnNwZWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGVzdCwgVGVzdGluZ01vZHVsZSB9IGZyb20gJ0BuZXN0anMvdGVzdGluZyc7XG5pbXBvcnQgeyBFbmhhbmNlZE1ldHJpY3NJbnRlcmNlcHRvciB9IGZyb20gJy4uL2VuaGFuY2VkLW1ldHJpY3MuaW50ZXJjZXB0b3InO1xuaW1wb3J0IHsgRW5oYW5jZWRNZXRyaWNzU2VydmljZSB9IGZyb20gJy4uL2VuaGFuY2VkLW1ldHJpY3Muc2VydmljZSc7XG5pbXBvcnQge1xuICBFeGVjdXRpb25Db250ZXh0LFxuICBDYWxsSGFuZGxlcixcbiAgVW5hdXRob3JpemVkRXhjZXB0aW9uLFxufSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBvZiwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tICdleHByZXNzJztcbmltcG9ydCB7IFJlZmxlY3RvciB9IGZyb20gJ0BuZXN0anMvY29yZSc7XG5cbi8qKlxuICogVGVzdGVzIHVuaXTDoXJpb3MgcGFyYSBvIGludGVyY2VwdG9yIGRlIG3DqXRyaWNhcyBhcHJpbW9yYWRvXG4gKlxuICogVmVyaWZpY2EgbyBmdW5jaW9uYW1lbnRvIGRvIGludGVyY2VwdG9yIHF1ZSBjb2xldGEgbcOpdHJpY2FzXG4gKiBhdmFuw6dhZGFzIHNvYnJlIGFzIHJlcXVpc2nDp8O1ZXMgSFRUUCwgY29tIGZvY28gZW0gc2VndXJhbsOnYSBlIGNvbXBsaWFuY2UgTEdQRFxuICovXG5kZXNjcmliZSgnRW5oYW5jZWRNZXRyaWNzSW50ZXJjZXB0b3InLCAoKSA9PiB7XG4gIGxldCBpbnRlcmNlcHRvcjogRW5oYW5jZWRNZXRyaWNzSW50ZXJjZXB0b3I7XG4gIGxldCBtZXRyaWNzU2VydmljZTogRW5oYW5jZWRNZXRyaWNzU2VydmljZTtcbiAgbGV0IHJlZmxlY3RvcjogUmVmbGVjdG9yO1xuXG4gIC8vIE1vY2sgZG8gc2VydmnDp28gZGUgbcOpdHJpY2FzIGFwcmltb3JhZGFzXG4gIGNvbnN0IG1vY2tNZXRyaWNzU2VydmljZSA9IHtcbiAgICBpbmNyZW1lbnRIdHRwUmVxdWVzdHNJblByb2dyZXNzOiBqZXN0LmZuKCksXG4gICAgZGVjcmVtZW50SHR0cFJlcXVlc3RzSW5Qcm9ncmVzczogamVzdC5mbigpLFxuICAgIHJlY29yZEh0dHBSZXF1ZXN0OiBqZXN0LmZuKCksXG4gICAgcmVjb3JkSHR0cFJlcXVlc3REdXJhdGlvbjogamVzdC5mbigpLFxuICAgIHJlY29yZFNlY3VyaXR5RXZlbnQ6IGplc3QuZm4oKSxcbiAgICByZWNvcmRMZ3BkRGF0YUFjY2VzczogamVzdC5mbigpLFxuICAgIHJlY29yZEF1dGhvcml6YXRpb25GYWlsdXJlOiBqZXN0LmZuKCksXG4gIH07XG5cbiAgLy8gTW9jayBkbyByZWZsZWN0b3JcbiAgY29uc3QgbW9ja1JlZmxlY3RvciA9IHtcbiAgICBnZXQ6IGplc3QuZm4oKSxcbiAgfTtcblxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcblxuICAgIC8vIE1vY2sgcGFyYSBEYXRlLm5vdygpIC0gcHJpbWVpcm8gcmV0b3JuYSAxMDAwLCBkZXBvaXMgMTIwMFxuICAgIGplc3RcbiAgICAgIC5zcHlPbihEYXRlLCAnbm93JylcbiAgICAgIC5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IDEwMDApXG4gICAgICAubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiAxMjAwKTtcblxuICAgIGNvbnN0IG1vZHVsZTogVGVzdGluZ01vZHVsZSA9IGF3YWl0IFRlc3QuY3JlYXRlVGVzdGluZ01vZHVsZSh7XG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgRW5oYW5jZWRNZXRyaWNzSW50ZXJjZXB0b3IsXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBFbmhhbmNlZE1ldHJpY3NTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiBtb2NrTWV0cmljc1NlcnZpY2UsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBSZWZsZWN0b3IsXG4gICAgICAgICAgdXNlVmFsdWU6IG1vY2tSZWZsZWN0b3IsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pLmNvbXBpbGUoKTtcblxuICAgIGludGVyY2VwdG9yID0gbW9kdWxlLmdldDxFbmhhbmNlZE1ldHJpY3NJbnRlcmNlcHRvcj4oXG4gICAgICBFbmhhbmNlZE1ldHJpY3NJbnRlcmNlcHRvcixcbiAgICApO1xuICAgIG1ldHJpY3NTZXJ2aWNlID0gbW9kdWxlLmdldDxFbmhhbmNlZE1ldHJpY3NTZXJ2aWNlPihFbmhhbmNlZE1ldHJpY3NTZXJ2aWNlKTtcbiAgICByZWZsZWN0b3IgPSBtb2R1bGUuZ2V0PFJlZmxlY3Rvcj4oUmVmbGVjdG9yKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LnJlc3RvcmVBbGxNb2NrcygpO1xuICB9KTtcblxuICBpdCgnZGV2ZSBzZXIgZGVmaW5pZG8nLCAoKSA9PiB7XG4gICAgZXhwZWN0KGludGVyY2VwdG9yKS50b0JlRGVmaW5lZCgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnaW50ZXJjZXB0JywgKCkgPT4ge1xuICAgIGl0KCdkZXZlIGNvbGV0YXIgbcOpdHJpY2FzIHBhcmEgdW1hIHJlcXVpc2nDp8OjbyBiZW0tc3VjZWRpZGEnLCAoZG9uZSkgPT4ge1xuICAgICAgLy8gTW9jayBkbyBjb250ZXh0byBkZSBleGVjdcOnw6NvXG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgb3JpZ2luYWxVcmw6ICcvYXBpL2NpZGFkYW9zJyxcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBwYXRoOiAnL2FwaS9jaWRhZGFvcycsXG4gICAgICAgIH0sXG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBpZDogJ3VzZXIxMjMnLFxuICAgICAgICAgIHJvbGVzOiBbJ2FkbWluJ10sXG4gICAgICAgIH0sXG4gICAgICAgIGlwOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ3VzZXItYWdlbnQnOiAndGVzdC1hZ2VudCcsXG4gICAgICAgIH0sXG4gICAgICB9IGFzIHVua25vd24gYXMgUmVxdWVzdDtcblxuICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGdldEhlYWRlcnM6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe30pLFxuICAgICAgfSBhcyB1bmtub3duIGFzIFJlc3BvbnNlO1xuXG4gICAgICBjb25zdCBtb2NrRXhlY3V0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgc3dpdGNoVG9IdHRwOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBnZXRSZXF1ZXN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tSZXF1ZXN0KSxcbiAgICAgICAgICBnZXRSZXNwb25zZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShtb2NrUmVzcG9uc2UpLFxuICAgICAgICB9KSxcbiAgICAgICAgZ2V0SGFuZGxlcjogamVzdC5mbigpLFxuICAgICAgICBnZXRDbGFzczogamVzdC5mbigpLFxuICAgICAgfSBhcyB1bmtub3duIGFzIEV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICAgIC8vIE1vY2sgZG8gaGFuZGxlciBkZSBjaGFtYWRhXG4gICAgICBjb25zdCBtb2NrQ2FsbEhhbmRsZXIgPSB7XG4gICAgICAgIGhhbmRsZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShvZih7IGRhdGE6ICd0ZXN0JyB9KSksXG4gICAgICB9IGFzIHVua25vd24gYXMgQ2FsbEhhbmRsZXI7XG5cbiAgICAgIC8vIE1vY2sgZG8gcmVmbGVjdG9yIHBhcmEgcmV0b3JuYXIgbWV0YWRhZG9zIGRlIExHUERcbiAgICAgIG1vY2tSZWZsZWN0b3IuZ2V0XG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKGZhbHNlKSAvLyBpc1B1YmxpY1xuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZShbJ2RhZG9zX3Blc3NvYWlzJ10pOyAvLyBsZ3BkRGF0YVR5cGVzXG5cbiAgICAgIC8vIEV4ZWN1dGFyIG8gaW50ZXJjZXB0b3JcbiAgICAgIGludGVyY2VwdG9yLmludGVyY2VwdChtb2NrRXhlY3V0aW9uQ29udGV4dCwgbW9ja0NhbGxIYW5kbGVyKS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoZGF0YSkgPT4ge1xuICAgICAgICAgIGV4cGVjdChkYXRhKS50b0VxdWFsKHsgZGF0YTogJ3Rlc3QnIH0pO1xuXG4gICAgICAgICAgLy8gVmVyaWZpY2FyIHNlIGFzIG3DqXRyaWNhcyBmb3JhbSBjb2xldGFkYXMgY29ycmV0YW1lbnRlXG4gICAgICAgICAgZXhwZWN0KFxuICAgICAgICAgICAgbW9ja01ldHJpY3NTZXJ2aWNlLmluY3JlbWVudEh0dHBSZXF1ZXN0c0luUHJvZ3Jlc3MsXG4gICAgICAgICAgKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnR0VUJywgJy9hcGkvY2lkYWRhb3MnLCAnYWRtaW4nKTtcblxuICAgICAgICAgIGV4cGVjdChcbiAgICAgICAgICAgIG1vY2tNZXRyaWNzU2VydmljZS5kZWNyZW1lbnRIdHRwUmVxdWVzdHNJblByb2dyZXNzLFxuICAgICAgICAgICkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0dFVCcsICcvYXBpL2NpZGFkYW9zJywgJ2FkbWluJyk7XG5cbiAgICAgICAgICAvLyBPIG3DqXRvZG8gcmVjb3JkSHR0cFJlcXVlc3QgbsOjbyByZWNlYmUgaXAgZSB1c2VyLWFnZW50XG4gICAgICAgICAgZXhwZWN0KG1vY2tNZXRyaWNzU2VydmljZS5yZWNvcmRIdHRwUmVxdWVzdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAnR0VUJyxcbiAgICAgICAgICAgICcvYXBpL2NpZGFkYW9zJyxcbiAgICAgICAgICAgIDIwMCxcbiAgICAgICAgICAgICdhZG1pbicsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFZlcmlmaWNhciBzZSBhIGR1cmHDp8OjbyBmb2kgcmVnaXN0cmFkYVxuICAgICAgICAgIC8vIE8gbcOpdG9kbyByZWNvcmRIdHRwUmVxdWVzdER1cmF0aW9uIG7Do28gcmVjZWJlIGlwIGUgdXNlci1hZ2VudFxuICAgICAgICAgIGV4cGVjdChcbiAgICAgICAgICAgIG1vY2tNZXRyaWNzU2VydmljZS5yZWNvcmRIdHRwUmVxdWVzdER1cmF0aW9uLFxuICAgICAgICAgICkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAnR0VUJyxcbiAgICAgICAgICAgICcvYXBpL2NpZGFkYW9zJyxcbiAgICAgICAgICAgIDIwMCxcbiAgICAgICAgICAgIDAuMiwgLy8gMjAwbXMgZW0gc2VndW5kb3NcbiAgICAgICAgICAgICdhZG1pbicsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIE8gbcOpdG9kbyByZWNvcmRMZ3BkRGF0YUFjY2VzcyBuw6NvIMOpIGNoYW1hZG8gYXV0b21hdGljYW1lbnRlIG5vIGludGVyY2VwdG9yXG4gICAgICAgICAgLy8gQSB2ZXJpZmljYcOnw6NvIGRlIGFjZXNzbyBhIGRhZG9zIExHUEQgZGV2ZSBzZXIgZmVpdGEgbWFudWFsbWVudGVcblxuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IChlcnIpID0+IHtcbiAgICAgICAgICBkb25lLmZhaWwoYEVycm8gaW5lc3BlcmFkbzogJHtlcnJ9YCk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdkZXZlIGNvbGV0YXIgbcOpdHJpY2FzIHBhcmEgdW1hIHJlcXVpc2nDp8OjbyBjb20gZXJybycsIChkb25lKSA9PiB7XG4gICAgICAvLyBNb2NrIGRvIGNvbnRleHRvIGRlIGV4ZWN1w6fDo29cbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgb3JpZ2luYWxVcmw6ICcvYXBpL2NpZGFkYW9zJyxcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBwYXRoOiAnL2FwaS9jaWRhZGFvcycsXG4gICAgICAgIH0sXG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBpZDogJ3VzZXIxMjMnLFxuICAgICAgICAgIHJvbGVzOiBbJ3VzZXInXSxcbiAgICAgICAgfSxcbiAgICAgICAgaXA6ICcxOTIuMTY4LjEuMicsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAndXNlci1hZ2VudCc6ICd0ZXN0LWFnZW50JyxcbiAgICAgICAgfSxcbiAgICAgIH0gYXMgdW5rbm93biBhcyBSZXF1ZXN0O1xuXG4gICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICAgICAgZ2V0SGVhZGVyczogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7fSksXG4gICAgICB9IGFzIHVua25vd24gYXMgUmVzcG9uc2U7XG5cbiAgICAgIGNvbnN0IG1vY2tFeGVjdXRpb25Db250ZXh0ID0ge1xuICAgICAgICBzd2l0Y2hUb0h0dHA6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGdldFJlcXVlc3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobW9ja1JlcXVlc3QpLFxuICAgICAgICAgIGdldFJlc3BvbnNlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tSZXNwb25zZSksXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRIYW5kbGVyOiBqZXN0LmZuKCksXG4gICAgICAgIGdldENsYXNzOiBqZXN0LmZuKCksXG4gICAgICB9IGFzIHVua25vd24gYXMgRXhlY3V0aW9uQ29udGV4dDtcblxuICAgICAgLy8gTW9jayBkbyBoYW5kbGVyIGRlIGNoYW1hZGEgY29tIGVycm9cbiAgICAgIGNvbnN0IG1vY2tFcnJvciA9IG5ldyBFcnJvcignRXJybyBpbnRlcm5vIGRvIHNlcnZpZG9yJyk7XG4gICAgICAobW9ja0Vycm9yIGFzIGFueSkuc3RhdHVzID0gNTAwO1xuXG4gICAgICBjb25zdCBtb2NrQ2FsbEhhbmRsZXIgPSB7XG4gICAgICAgIGhhbmRsZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh0aHJvd0Vycm9yKCgpID0+IG1vY2tFcnJvcikpLFxuICAgICAgfSBhcyB1bmtub3duIGFzIENhbGxIYW5kbGVyO1xuXG4gICAgICAvLyBNb2NrIGRvIHJlZmxlY3RvciAtIG7Do28gw6kgdXNhZG8gZW0gY2FzbyBkZSBlcnJvXG4gICAgICBtb2NrUmVmbGVjdG9yLmdldC5tb2NrSW1wbGVtZW50YXRpb24oKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChrZXkgPT09ICdpc1B1YmxpYycpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRhciBvIGludGVyY2VwdG9yXG4gICAgICBpbnRlcmNlcHRvci5pbnRlcmNlcHQobW9ja0V4ZWN1dGlvbkNvbnRleHQsIG1vY2tDYWxsSGFuZGxlcikuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGRvbmUuZmFpbCgnTyBpbnRlcmNlcHRvciBkZXZlcmlhIHRlciByZXRvcm5hZG8gdW0gZXJybycpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGVycm9yKS50b0JlKG1vY2tFcnJvcik7XG5cbiAgICAgICAgICAvLyBWZXJpZmljYXIgc2UgYXMgbcOpdHJpY2FzIGRlIGVycm8gZm9yYW0gcmVnaXN0cmFkYXNcbiAgICAgICAgICBleHBlY3QobW9ja01ldHJpY3NTZXJ2aWNlLnJlY29yZEh0dHBSZXF1ZXN0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICdQT1NUJyxcbiAgICAgICAgICAgICcvYXBpL2NpZGFkYW9zJyxcbiAgICAgICAgICAgIDUwMCxcbiAgICAgICAgICAgICd1c2VyJyxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gVmVyaWZpY2FyIHNlIGEgZHVyYcOnw6NvIGZvaSByZWdpc3RyYWRhXG4gICAgICAgICAgZXhwZWN0KFxuICAgICAgICAgICAgbW9ja01ldHJpY3NTZXJ2aWNlLnJlY29yZEh0dHBSZXF1ZXN0RHVyYXRpb24sXG4gICAgICAgICAgKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICdQT1NUJyxcbiAgICAgICAgICAgICcvYXBpL2NpZGFkYW9zJyxcbiAgICAgICAgICAgIDUwMCxcbiAgICAgICAgICAgIGV4cGVjdC5hbnkoTnVtYmVyKSwgLy8gRHVyYcOnw6NvIGVtIHNlZ3VuZG9zXG4gICAgICAgICAgICAndXNlcicsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFZlcmlmaWNhciBzZSBvIGV2ZW50byBkZSBzZWd1cmFuw6dhIGZvaSByZWdpc3RyYWRvXG4gICAgICAgICAgZXhwZWN0KG1vY2tNZXRyaWNzU2VydmljZS5yZWNvcmRTZWN1cml0eUV2ZW50KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICdzZXJ2ZXJfZXJyb3InLFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICdhcGknLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdkZXZlIGxpZGFyIGNvbSByZXF1aXNpw6fDtWVzIG7Do28gYXV0ZW50aWNhZGFzJywgKGRvbmUpID0+IHtcbiAgICAgIC8vIE1vY2sgZG8gY29udGV4dG8gZGUgZXhlY3XDp8OjbyBzZW0gdXN1w6FyaW8gYXV0ZW50aWNhZG9cbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICB1cmw6ICcvYXBpL3B1YmxpYycsXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgcGF0aDogJy9hcGkvcHVibGljJyxcbiAgICAgICAgfSxcbiAgICAgICAgaXA6ICcxOTIuMTY4LjEuMycsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAndXNlci1hZ2VudCc6ICd0ZXN0LWFnZW50JyxcbiAgICAgICAgfSxcbiAgICAgIH0gYXMgdW5rbm93biBhcyBSZXF1ZXN0O1xuXG4gICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgZ2V0SGVhZGVyczogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7fSksXG4gICAgICB9IGFzIHVua25vd24gYXMgUmVzcG9uc2U7XG5cbiAgICAgIGNvbnN0IG1vY2tFeGVjdXRpb25Db250ZXh0ID0ge1xuICAgICAgICBzd2l0Y2hUb0h0dHA6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGdldFJlcXVlc3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobW9ja1JlcXVlc3QpLFxuICAgICAgICAgIGdldFJlc3BvbnNlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tSZXNwb25zZSksXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRIYW5kbGVyOiBqZXN0LmZuKCksXG4gICAgICAgIGdldENsYXNzOiBqZXN0LmZuKCksXG4gICAgICB9IGFzIHVua25vd24gYXMgRXhlY3V0aW9uQ29udGV4dDtcblxuICAgICAgLy8gTW9jayBkbyBoYW5kbGVyIGRlIGNoYW1hZGFcbiAgICAgIGNvbnN0IG1vY2tDYWxsSGFuZGxlciA9IHtcbiAgICAgICAgaGFuZGxlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG9mKHsgZGF0YTogJ3B1YmxpYyBkYXRhJyB9KSksXG4gICAgICB9IGFzIHVua25vd24gYXMgQ2FsbEhhbmRsZXI7XG5cbiAgICAgIC8vIE8gaW50ZXJjZXB0b3IgbsOjbyB2ZXJpZmljYSBpc1B1YmxpYywgYXBlbmFzIHJlZ2lzdHJhIG3DqXRyaWNhc1xuICAgICAgLy8gQSB2ZXJpZmljYcOnw6NvIGRlIHJvdGFzIHDDumJsaWNhcyDDqSBmZWl0YSBwb3Igb3V0cm9zIG1pZGRsZXdhcmVzL2d1YXJkc1xuICAgICAgbW9ja1JlZmxlY3Rvci5nZXQubW9ja0ltcGxlbWVudGF0aW9uKChrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoa2V5ID09PSAnaXNQdWJsaWMnKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRhciBvIGludGVyY2VwdG9yXG4gICAgICBpbnRlcmNlcHRvci5pbnRlcmNlcHQobW9ja0V4ZWN1dGlvbkNvbnRleHQsIG1vY2tDYWxsSGFuZGxlcikuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKGRhdGEpID0+IHtcbiAgICAgICAgICBleHBlY3QoZGF0YSkudG9FcXVhbCh7IGRhdGE6ICdwdWJsaWMgZGF0YScgfSk7XG5cbiAgICAgICAgICAvLyBWZXJpZmljYXIgc2UgYXMgbcOpdHJpY2FzIGZvcmFtIGNvbGV0YWRhcyBzZW0gaW5mb3JtYcOnw7VlcyBkZSB1c3XDoXJpb1xuICAgICAgICAgIGV4cGVjdChtb2NrTWV0cmljc1NlcnZpY2UucmVjb3JkSHR0cFJlcXVlc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgJ0dFVCcsXG4gICAgICAgICAgICAnL2FwaS9wdWJsaWMnLFxuICAgICAgICAgICAgMjAwLFxuICAgICAgICAgICAgJ2Fub255bW91cycsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFZlcmlmaWNhciBzZSBhIGR1cmHDp8OjbyBmb2kgcmVnaXN0cmFkYVxuICAgICAgICAgIGV4cGVjdChcbiAgICAgICAgICAgIG1vY2tNZXRyaWNzU2VydmljZS5yZWNvcmRIdHRwUmVxdWVzdER1cmF0aW9uLFxuICAgICAgICAgICkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAnR0VUJyxcbiAgICAgICAgICAgICcvYXBpL3B1YmxpYycsXG4gICAgICAgICAgICAyMDAsXG4gICAgICAgICAgICBleHBlY3QuYW55KE51bWJlciksIC8vIER1cmHDp8OjbyBlbSBzZWd1bmRvc1xuICAgICAgICAgICAgJ2Fub255bW91cycsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIE8gaW50ZXJjZXB0b3IgbsOjbyB2ZXJpZmljYSBpc1B1YmxpYywgZW50w6NvIG7Do28gcG9kZW1vcyBnYXJhbnRpciBxdWUgcmVjb3JkTGdwZERhdGFBY2Nlc3MgbsOjbyBmb2kgY2hhbWFkb1xuICAgICAgICAgIC8vIEEgdmVyaWZpY2HDp8OjbyBkZSByb3RhcyBww7pibGljYXMgw6kgZmVpdGEgcG9yIG91dHJvcyBtaWRkbGV3YXJlcy9ndWFyZHNcblxuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGRvbmUsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdkZXZlIGxpZGFyIGNvbSBlcnJvcyBkZSBhdXRvcml6YcOnw6NvJywgKGRvbmUpID0+IHtcbiAgICAgIC8vIE1vY2sgZG8gY29udGV4dG8gZGUgZXhlY3XDp8OjbyBjb20gdXN1w6FyaW8gbsOjbyBhdXRvcml6YWRvXG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgb3JpZ2luYWxVcmw6ICcvYXBpL2FkbWluJyxcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBwYXRoOiAnL2FwaS9hZG1pbicsXG4gICAgICAgIH0sXG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBpZDogJ3VzZXIxMjMnLFxuICAgICAgICAgIHJvbGVzOiBbJ3VzZXInXSxcbiAgICAgICAgfSxcbiAgICAgICAgaXA6ICcxOTIuMTY4LjEuNCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAndXNlci1hZ2VudCc6ICd0ZXN0LWFnZW50JyxcbiAgICAgICAgfSxcbiAgICAgIH0gYXMgdW5rbm93biBhcyBSZXF1ZXN0O1xuXG4gICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgIHN0YXR1c0NvZGU6IDQwMyxcbiAgICAgICAgZ2V0SGVhZGVyczogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7fSksXG4gICAgICB9IGFzIHVua25vd24gYXMgUmVzcG9uc2U7XG5cbiAgICAgIGNvbnN0IG1vY2tFeGVjdXRpb25Db250ZXh0ID0ge1xuICAgICAgICBzd2l0Y2hUb0h0dHA6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGdldFJlcXVlc3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobW9ja1JlcXVlc3QpLFxuICAgICAgICAgIGdldFJlc3BvbnNlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tSZXNwb25zZSksXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRIYW5kbGVyOiBqZXN0LmZuKCksXG4gICAgICAgIGdldENsYXNzOiBqZXN0LmZuKCksXG4gICAgICB9IGFzIHVua25vd24gYXMgRXhlY3V0aW9uQ29udGV4dDtcblxuICAgICAgLy8gTW9jayBkbyBoYW5kbGVyIGRlIGNoYW1hZGEgY29tIGVycm8gZGUgYXV0b3JpemHDp8Ojb1xuICAgICAgY29uc3QgbW9ja0Vycm9yID0gbmV3IFVuYXV0aG9yaXplZEV4Y2VwdGlvbignQWNlc3NvIG7Do28gYXV0b3JpemFkbycpO1xuICAgICAgKG1vY2tFcnJvciBhcyBhbnkpLnN0YXR1cyA9IDQwMztcblxuICAgICAgY29uc3QgbW9ja0NhbGxIYW5kbGVyID0ge1xuICAgICAgICBoYW5kbGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUodGhyb3dFcnJvcigoKSA9PiBtb2NrRXJyb3IpKSxcbiAgICAgIH0gYXMgdW5rbm93biBhcyBDYWxsSGFuZGxlcjtcblxuICAgICAgLy8gTW9jayBkbyByZWZsZWN0b3IgcGFyYSBvIHRlc3RlIGRlIGF1dG9yaXphw6fDo29cbiAgICAgIG1vY2tSZWZsZWN0b3IuZ2V0Lm1vY2tJbXBsZW1lbnRhdGlvbigoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2lzUHVibGljJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSAncm9sZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIFsnYWRtaW4nXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSAnbGdwZERhdGFUeXBlcycpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRhciBvIGludGVyY2VwdG9yXG4gICAgICBpbnRlcmNlcHRvci5pbnRlcmNlcHQobW9ja0V4ZWN1dGlvbkNvbnRleHQsIG1vY2tDYWxsSGFuZGxlcikuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGRvbmUuZmFpbCgnTsOjbyBkZXZlcmlhIGNoZWdhciBhcXVpJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICBleHBlY3QoZXJyb3IpLnRvQmUobW9ja0Vycm9yKTtcblxuICAgICAgICAgIC8vIFZlcmlmaWNhciBzZSBvIGV2ZW50byBkZSBzZWd1cmFuw6dhIGZvaSByZWdpc3RyYWRvXG4gICAgICAgICAgZXhwZWN0KG1vY2tNZXRyaWNzU2VydmljZS5yZWNvcmRTZWN1cml0eUV2ZW50KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICdhdXRob3JpemF0aW9uX2ZhaWx1cmUnLFxuICAgICAgICAgICAgJ3dhcm5pbmcnLFxuICAgICAgICAgICAgJ2FwaScsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFZlcmlmaWNhciBzZSBhIGZhbGhhIGRlIGF1dG9yaXphw6fDo28gZm9pIHJlZ2lzdHJhZGFcbiAgICAgICAgICBleHBlY3QoXG4gICAgICAgICAgICBtb2NrTWV0cmljc1NlcnZpY2UucmVjb3JkQXV0aG9yaXphdGlvbkZhaWx1cmUsXG4gICAgICAgICAgKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9hZG1pbicsICd1bmtub3duJywgJ3VzZXInKTtcblxuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9