{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\beneficio\\services\\campo-dinamico.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\beneficio\\services\\campo-dinamico.service.ts"],"sourcesContent":["import {\n  Injectable,\n  NotFoundException,\n  ConflictException,\n  BadRequestException,\n} from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { CampoDinamicoBeneficio } from '../../../entities/campo-dinamico-beneficio.entity';\nimport { TipoBeneficio } from '../../../entities/tipo-beneficio.entity';\nimport { CreateCampoDinamicoDto } from '../dto/create-campo-dinamico.dto';\nimport { TipoBeneficioSchema } from '../../../entities/tipo-beneficio-schema.entity';\nimport { Status } from '@/enums';\n\n/**\n * Serviço de Campos Dinâmicos\n *\n * Responsável pela lógica de negócio relacionada aos campos dinâmicos\n * de benefícios, incluindo criação, atualização e versionamento de schema.\n */\n@Injectable()\nexport class CampoDinamicoService {\n  constructor(\n    @InjectRepository(CampoDinamicoBeneficio)\n    private campoDinamicoRepository: Repository<CampoDinamicoBeneficio>,\n\n    @InjectRepository(TipoBeneficio)\n    private tipoBeneficioRepository: Repository<TipoBeneficio>,\n\n    @InjectRepository(TipoBeneficioSchema)\n    private tipoBeneficioSchemaRepository: Repository<TipoBeneficioSchema>,\n  ) {}\n\n  /**\n   * Lista todos os campos dinâmicos de um tipo de benefício\n   *\n   * @param tipoBeneficioId ID do tipo de benefício\n   * @returns Lista de campos dinâmicos\n   */\n  async findByTipoBeneficio(tipoBeneficioId: string) {\n    // Verificar se o tipo de benefício existe\n    const tipoBeneficio = await this.tipoBeneficioRepository.findOne({\n      where: { id: tipoBeneficioId },\n    });\n\n    if (!tipoBeneficio) {\n      throw new NotFoundException(\n        `Tipo de benefício com ID ${tipoBeneficioId} não encontrado`,\n      );\n    }\n\n    // Buscar campos dinâmicos\n    return this.campoDinamicoRepository.find({\n      where: { tipo_beneficio_id: tipoBeneficioId },\n      order: { ordem: 'ASC' },\n    });\n  }\n\n  /**\n   * Cria um novo campo dinâmico para um tipo de benefício\n   *\n   * @param tipoBeneficioId ID do tipo de benefício\n   * @param createCampoDinamicoDto Dados do campo dinâmico\n   * @returns Campo dinâmico criado\n   */\n  async create(\n    tipoBeneficioId: string,\n    createCampoDinamicoDto: CreateCampoDinamicoDto,\n  ) {\n    // Verificar se o tipo de benefício existe\n    const tipoBeneficio = await this.tipoBeneficioRepository.findOne({\n      where: { id: tipoBeneficioId },\n    });\n\n    if (!tipoBeneficio) {\n      throw new NotFoundException(\n        `Tipo de benefício com ID ${tipoBeneficioId} não encontrado`,\n      );\n    }\n\n    // Verificar se já existe um campo com o mesmo nome para este tipo de benefício\n    const campoExistente = await this.campoDinamicoRepository.findOne({\n      where: {\n        tipo_beneficio_id: tipoBeneficioId,\n        nome: createCampoDinamicoDto.nome,\n      },\n    });\n\n    if (campoExistente) {\n      throw new ConflictException(\n        `Já existe um campo com o nome '${createCampoDinamicoDto.nome}' para este tipo de benefício`,\n      );\n    }\n\n    // Adaptar os tipos para garantir compatibilidade\n    const { validacoes, ...restoCampos } = createCampoDinamicoDto;\n\n    // Criar o objeto de campo dinâmico com os tipos corretos\n    // Para resolver o erro de TypeScript, precisamos garantir que o tipo do campo validacoes\n    // seja compatível com a definição da entidade\n    const campoDinamico = this.campoDinamicoRepository.create({\n      ...restoCampos,\n      tipo_beneficio_id: tipoBeneficioId,\n      validacoes: validacoes\n        ? {\n            min:\n              typeof validacoes.min === 'string'\n                ? parseFloat(validacoes.min)\n                : validacoes.min,\n            max:\n              typeof validacoes.max === 'string'\n                ? parseFloat(validacoes.max)\n                : validacoes.max,\n            minLength: validacoes.minLength,\n            maxLength: validacoes.maxLength,\n            pattern: validacoes.pattern,\n            enum: validacoes.enum,\n            format: validacoes.format,\n          }\n        : undefined,\n    });\n\n    const campoCriado = await this.campoDinamicoRepository.save(campoDinamico);\n\n    // Atualizar versionamento do schema\n    await this.criarNovaVersaoSchema(tipoBeneficioId);\n\n    return campoCriado;\n  }\n\n  /**\n   * Atualiza um campo dinâmico existente\n   *\n   * @param id ID do campo dinâmico\n   * @param updateCampoDinamicoDto Dados atualizados do campo dinâmico\n   * @returns Campo dinâmico atualizado\n   */\n  async update(\n    id: string,\n    updateCampoDinamicoDto: Partial<CreateCampoDinamicoDto>,\n  ) {\n    // Verificar se o campo dinâmico existe\n    const campoDinamico = await this.campoDinamicoRepository.findOne({\n      where: { id },\n      relations: ['tipo_beneficio'],\n    });\n\n    if (!campoDinamico) {\n      throw new NotFoundException(`Campo dinâmico com ID ${id} não encontrado`);\n    }\n\n    // Se estiver alterando o nome, verificar se já existe outro com o mesmo nome\n    if (\n      updateCampoDinamicoDto.nome &&\n      updateCampoDinamicoDto.nome !== campoDinamico.nome\n    ) {\n      const campoExistente = await this.campoDinamicoRepository.findOne({\n        where: {\n          tipo_beneficio_id: campoDinamico.tipo_beneficio_id,\n          nome: updateCampoDinamicoDto.nome,\n        },\n      });\n\n      if (campoExistente) {\n        throw new ConflictException(\n          `Já existe um campo com o nome '${updateCampoDinamicoDto.nome}' para este tipo de benefício`,\n        );\n      }\n    }\n\n    // Atualizar campo dinâmico\n    Object.assign(campoDinamico, updateCampoDinamicoDto);\n    const campoAtualizado =\n      await this.campoDinamicoRepository.save(campoDinamico);\n\n    // Atualizar versionamento do schema\n    await this.criarNovaVersaoSchema(campoDinamico.tipo_beneficio_id);\n\n    return campoAtualizado;\n  }\n\n  /**\n   * Remove um campo dinâmico (soft delete)\n   *\n   * @param id ID do campo dinâmico\n   * @returns Resultado da operação\n   */\n  async remove(id: string) {\n    // Verificar se o campo dinâmico existe\n    const campoDinamico = await this.campoDinamicoRepository.findOne({\n      where: { id },\n    });\n\n    if (!campoDinamico) {\n      throw new NotFoundException(`Campo dinâmico com ID ${id} não encontrado`);\n    }\n\n    // Remover campo dinâmico (soft delete)\n    const tipoBeneficioId = campoDinamico.tipo_beneficio_id;\n    await this.campoDinamicoRepository.softRemove(campoDinamico);\n\n    // Atualizar versionamento do schema\n    await this.criarNovaVersaoSchema(tipoBeneficioId);\n\n    return { message: 'Campo dinâmico removido com sucesso' };\n  }\n\n  /**\n   * Cria uma nova versão do schema para um tipo de benefício\n   *\n   * @param tipoBeneficioId ID do tipo de benefício\n   * @returns Nova versão do schema\n   */\n  private async criarNovaVersaoSchema(tipoBeneficioId: string) {\n    // Buscar campos dinâmicos ativos\n    const campos = await this.campoDinamicoRepository.find({\n      where: { tipo_beneficio_id: tipoBeneficioId, ativo: true },\n      order: { ordem: 'ASC' },\n    });\n\n    // Buscar última versão do schema\n    const ultimaVersao = await this.tipoBeneficioSchemaRepository.findOne({\n      where: { tipo_beneficio_id: tipoBeneficioId },\n      order: { versao: 'DESC' },\n    });\n\n    const novaVersao = ultimaVersao ? ultimaVersao.versao + 1 : 1;\n\n    // Construir estrutura de campos\n    const camposEstrutura = campos.map((campo) => {\n      // Mapear TipoDado para os tipos aceitos por CampoEstrutura\n      let tipoMapeado:\n        | 'string'\n        | 'number'\n        | 'boolean'\n        | 'date'\n        | 'enum'\n        | 'array';\n      switch (campo.tipo) {\n        case 'string':\n          tipoMapeado = 'string';\n          break;\n        case 'number':\n          tipoMapeado = 'number';\n          break;\n        case 'boolean':\n          tipoMapeado = 'boolean';\n          break;\n        case 'date':\n          tipoMapeado = 'date';\n          break;\n        case 'array':\n          tipoMapeado = 'array';\n          break;\n        case 'object':\n        default:\n          tipoMapeado = 'string'; // Fallback para string\n          break;\n      }\n\n      return {\n        nome: campo.nome,\n        tipo: tipoMapeado,\n        obrigatorio: campo.obrigatorio,\n        label: campo.label,\n        descricao: campo.descricao,\n        validacoes: campo.validacoes,\n      };\n    });\n\n    // Desativar versões anteriores\n    if (ultimaVersao) {\n      await this.tipoBeneficioSchemaRepository.update(\n        { tipo_beneficio_id: tipoBeneficioId },\n        { status: Status.ATIVO },\n      );\n    }\n\n    // Criar nova versão\n    const novaVersaoSchema = this.tipoBeneficioSchemaRepository.create({\n      tipo_beneficio_id: tipoBeneficioId,\n      entidade_dados: 'DadosDinamicos',\n      schema_estrutura: {\n        campos: camposEstrutura,\n        metadados: {\n          versao: `${novaVersao}.0.0`,\n          descricao: `Versão ${novaVersao} - Atualização automática`,\n          categoria: 'beneficio_eventual',\n          tags: ['dinamico'],\n        },\n      },\n      versao: `${novaVersao}.0.0`,\n      status: Status.ATIVO,\n    });\n\n    return this.tipoBeneficioSchemaRepository.save(novaVersaoSchema);\n  }\n\n  /**\n   * Cria um novo schema baseado nos campos dinâmicos ativos\n   *\n   * @param tipoBeneficioId ID do tipo de benefício\n   * @returns Novo schema\n   */\n  private async criarNovoSchema(tipoBeneficioId: string) {\n    // Buscar campos dinâmicos ativos\n    const campos = await this.campoDinamicoRepository.find({\n      where: { tipo_beneficio_id: tipoBeneficioId, ativo: true },\n      order: { ordem: 'ASC' },\n    });\n\n    // Buscar schema existente\n    const schemaExistente = await this.tipoBeneficioSchemaRepository.findOne({\n      where: { tipo_beneficio_id: tipoBeneficioId },\n    });\n\n    // Desativar schema anterior se existir\n    if (schemaExistente) {\n      await this.tipoBeneficioSchemaRepository.update(\n        { tipo_beneficio_id: tipoBeneficioId },\n        { status: Status.ATIVO },\n      );\n    }\n\n    // Construir estrutura de campos\n    const camposEstrutura = campos.map((campo) => {\n      // Mapear TipoDado para os tipos aceitos por CampoEstrutura\n      let tipoMapeado:\n        | 'string'\n        | 'number'\n        | 'boolean'\n        | 'date'\n        | 'enum'\n        | 'array';\n      switch (campo.tipo) {\n        case 'string':\n          tipoMapeado = 'string';\n          break;\n        case 'number':\n          tipoMapeado = 'number';\n          break;\n        case 'boolean':\n          tipoMapeado = 'boolean';\n          break;\n        case 'date':\n          tipoMapeado = 'date';\n          break;\n        case 'array':\n          tipoMapeado = 'array';\n          break;\n        case 'object':\n        default:\n          tipoMapeado = 'string'; // Fallback para string\n          break;\n      }\n\n      return {\n        nome: campo.nome,\n        tipo: tipoMapeado,\n        obrigatorio: campo.obrigatorio,\n        label: campo.label,\n        descricao: campo.descricao,\n        validacoes: campo.validacoes,\n      };\n    });\n\n    // Criar novo schema\n    const novoSchema = this.tipoBeneficioSchemaRepository.create({\n      tipo_beneficio_id: tipoBeneficioId,\n      entidade_dados: 'DadosDinamicos',\n      schema_estrutura: {\n        campos: camposEstrutura,\n        metadados: {\n          versao: '1.0.0',\n          descricao:\n            'Schema gerado automaticamente a partir de campos dinâmicos',\n          categoria: 'beneficio_eventual',\n          tags: ['dinamico'],\n        },\n      },\n      versao: '1.0.0',\n      status: Status.ATIVO,\n    });\n\n    return this.tipoBeneficioSchemaRepository.save(novoSchema);\n  }\n\n  /**\n   * Obtém o schema ativo de um tipo de benefício\n   *\n   * @param tipoBeneficioId ID do tipo de benefício\n   * @returns Schema ativo\n   */\n  async getSchemaAtivo(tipoBeneficioId: string) {\n    // Verificar se o tipo de benefício existe\n    const tipoBeneficio = await this.tipoBeneficioRepository.findOne({\n      where: { id: tipoBeneficioId },\n    });\n\n    if (!tipoBeneficio) {\n      throw new NotFoundException(\n        `Tipo de benefício com ID ${tipoBeneficioId} não encontrado`,\n      );\n    }\n\n    // Buscar schema ativo\n    const schemaAtivo = await this.tipoBeneficioSchemaRepository.findOne({\n      where: { tipo_beneficio_id: tipoBeneficioId, status: Status.ATIVO },\n    });\n\n    if (!schemaAtivo) {\n      // Se não houver schema ativo, criar um\n      return this.criarNovoSchema(tipoBeneficioId);\n    }\n\n    return schemaAtivo;\n  }\n\n  /**\n   * Obtém o histórico de versões do schema de um tipo de benefício\n   *\n   * @param tipoBeneficioId ID do tipo de benefício\n   * @returns Lista de versões do schema\n   */\n  async getHistoricoVersoes(tipoBeneficioId: string) {\n    // Verificar se o tipo de benefício existe\n    const tipoBeneficio = await this.tipoBeneficioRepository.findOne({\n      where: { id: tipoBeneficioId },\n    });\n\n    if (!tipoBeneficio) {\n      throw new NotFoundException(\n        `Tipo de benefício com ID ${tipoBeneficioId} não encontrado`,\n      );\n    }\n\n    // Buscar versões do schema\n    return this.tipoBeneficioSchemaRepository.find({\n      where: { tipo_beneficio_id: tipoBeneficioId },\n      order: { versao: 'DESC' },\n    });\n  }\n}\n"],"version":3}