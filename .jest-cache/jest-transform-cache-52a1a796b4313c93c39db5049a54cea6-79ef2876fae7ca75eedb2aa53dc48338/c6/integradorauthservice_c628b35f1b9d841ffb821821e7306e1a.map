{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\integrador\\services\\integrador-auth.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\integrador\\services\\integrador-auth.service.ts"],"sourcesContent":["import { Injectable, UnauthorizedException, Logger } from '@nestjs/common';\nimport { Request } from 'express';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { IntegradorTokenService } from './integrador-token.service';\nimport { TokenRevogado } from '../../../entities/token-revogado.entity';\n\n/**\n * Serviço responsável pela autenticação e autorização de integradores.\n * Valida tokens, verifica permissões e registra acessos.\n */\n@Injectable()\nexport class IntegradorAuthService {\n  private readonly logger = new Logger(IntegradorAuthService.name);\n\n  constructor(\n    private readonly tokenService: IntegradorTokenService,\n    @InjectRepository(TokenRevogado)\n    private tokenRevogadoRepository: Repository<TokenRevogado>,\n  ) {}\n\n  /**\n   * Extrai o token de autorização do cabeçalho da requisição.\n   * @param request Objeto de requisição HTTP\n   * @returns Token extraído ou null se não encontrado\n   */\n  extractTokenFromHeader(request: Request): string | null {\n    const authHeader = request.headers.authorization;\n    if (!authHeader) {\n      return null;\n    }\n\n    const parts = authHeader.split(' ');\n    if (parts.length !== 2 || parts[0] !== 'Bearer') {\n      return null;\n    }\n\n    return parts[1];\n  }\n\n  /**\n   * Obtém o endereço IP real da requisição.\n   * @param request Objeto de requisição HTTP\n   * @returns Endereço IP\n   */\n  getIpFromRequest(request: Request): string {\n    // Considera cabeçalhos como X-Forwarded-For para ambientes com proxy\n    const xForwardedFor = request.headers['x-forwarded-for'] as string;\n    if (xForwardedFor) {\n      const ips = xForwardedFor.split(',');\n      return ips[0].trim();\n    }\n    \n    return request.ip || request.socket.remoteAddress || '0.0.0.0';\n  }\n\n  /**\n   * Valida a autenticação de uma requisição.\n   * @param request Objeto de requisição HTTP\n   * @returns Payload do token validado\n   * @throws UnauthorizedException se a autenticação falhar\n   */\n  async validateRequest(request: Request): Promise<any> {\n    const token = this.extractTokenFromHeader(request);\n    if (!token) {\n      throw new UnauthorizedException('Token de autorização não fornecido');\n    }\n\n    try {\n      // Validar o token e obter o payload\n      const payload = await this.tokenService.validateToken(token);\n      \n      // Verificar restrições de IP\n      const ipAddress = this.getIpFromRequest(request);\n      if (!this.tokenService.isIpAllowed(payload.integrador, ipAddress)) {\n        this.logger.warn(\n          `Tentativa de acesso de IP não autorizado: ${ipAddress} para integrador ${payload.integrador.id}`\n        );\n        throw new UnauthorizedException(`Acesso não permitido do IP ${ipAddress}`);\n      }\n\n      // Adicionar informações à requisição para uso posterior\n      request['integrador'] = payload.integrador;\n      request['integradorTokenPayload'] = payload;\n\n      return payload;\n    } catch (error) {\n      // Registrar tentativa de acesso inválida\n      this.logger.warn(`Falha na autenticação de integrador: ${error.message}`);\n      \n      // Propaga a exceção original\n      throw error;\n    }\n  }\n\n  /**\n   * Verifica se a requisição tem as permissões necessárias.\n   * @param request Objeto de requisição HTTP\n   * @param requiredScopes Escopos necessários para a operação\n   * @returns true se autorizado, false caso contrário\n   */\n  checkPermissions(request: Request, requiredScopes: string[]): boolean {\n    const payload = request['integradorTokenPayload'];\n    if (!payload) {\n      return false;\n    }\n\n    return this.tokenService.hasRequiredScopes(payload, requiredScopes);\n  }\n\n  /**\n   * Registra uma tentativa de acesso (sucesso ou falha).\n   * Este método pode ser expandido para incluir mais informações de auditoria.\n   * @param tokenId ID do token (se identificado)\n   * @param integradorId ID do integrador (se identificado)\n   * @param success Indica se o acesso foi bem-sucedido\n   * @param ipAddress Endereço IP da requisição\n   * @param resource Recurso que estava sendo acessado\n   * @param message Mensagem adicional\n   */\n  async registrarTentativaAcesso(\n    tokenId: string | null, \n    integradorId: string | null,\n    success: boolean,\n    ipAddress: string,\n    resource: string,\n    message: string\n  ): Promise<void> {\n    // Aqui poderia ser implementada a lógica para registrar em um banco ou \n    // sistema de monitoramento. Por ora, apenas logamos.\n    if (success) {\n      this.logger.log(\n        `Acesso autorizado: integrador=${integradorId}, token=${tokenId}, ip=${ipAddress}, recurso=${resource}`\n      );\n    } else {\n      this.logger.warn(\n        `Acesso negado: integrador=${integradorId}, ip=${ipAddress}, recurso=${resource}, motivo=${message}`\n      );\n    }\n  }\n\n  /**\n   * Busca na cache local se um token está revogado.\n   * Este método pode ser otimizado com Redis ou outro mecanismo de cache.\n   * @param tokenHash Hash do token a ser verificado\n   * @returns true se o token estiver revogado, false caso contrário\n   */\n  async isTokenRevogado(tokenHash: string): Promise<boolean> {\n    const revogado = await this.tokenRevogadoRepository.findOne({\n      where: { tokenHash }\n    });\n    \n    return !!revogado;\n  }\n}\n"],"version":3}