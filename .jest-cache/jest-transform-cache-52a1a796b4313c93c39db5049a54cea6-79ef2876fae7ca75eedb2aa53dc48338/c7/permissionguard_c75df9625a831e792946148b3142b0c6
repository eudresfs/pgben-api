19340a305ad9fcc8884b647ba5618f0a
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var PermissionGuard_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionGuard = void 0;
const common_1 = require("@nestjs/common");
const core_1 = require("@nestjs/core");
const requires_permission_decorator_1 = require("../decorators/requires-permission.decorator");
const permission_service_1 = require("../services/permission.service");
const user_permission_entity_1 = require("../../entities/user-permission.entity");
const permission_denied_exception_1 = require("../exceptions/permission-denied.exception");
/**
 * Guard para verificar permissões granulares.
 *
 * Este guard verifica se o usuário tem as permissões necessárias para acessar
 * um endpoint, considerando os requisitos de permissão definidos pelo decorador
 * RequiresPermission.
 */
let PermissionGuard = PermissionGuard_1 = class PermissionGuard {
    reflector;
    permissionService;
    logger = new common_1.Logger(PermissionGuard_1.name);
    constructor(reflector, permissionService) {
        this.reflector = reflector;
        this.permissionService = permissionService;
    }
    /**
     * Verifica se o usuário tem as permissões necessárias para acessar o endpoint.
     *
     * @param context Contexto de execução
     * @returns true se o usuário tem as permissões necessárias, false caso contrário
     */
    async canActivate(context) {
        // Obtém os requisitos de permissão do método e da classe
        const methodRequirements = this.reflector.get(requires_permission_decorator_1.PERMISSION_REQUIREMENTS_KEY, context.getHandler()) || [];
        const classRequirements = this.reflector.get(requires_permission_decorator_1.PERMISSION_REQUIREMENTS_KEY, context.getClass()) || [];
        // Combina os requisitos de permissão
        const requirements = [...methodRequirements, ...classRequirements];
        // Se não houver requisitos de permissão, permite o acesso
        if (requirements.length === 0) {
            return true;
        }
        // Obtém a requisição
        const request = context.switchToHttp().getRequest();
        // Verifica se o usuário está autenticado
        if (!request.user || !request.user.id) {
            throw new common_1.UnauthorizedException('Usuário não autenticado');
        }
        const userId = request.user.id;
        // BYPASS PARA SUPER ADMIN: Verifica se o usuário possui permissão de super admin (*.*)
        // Se sim, permite acesso a qualquer endpoint sem verificar outras permissões
        const hasSuperAdminPermission = await this.permissionService.hasPermission({
            userId,
            permissionName: '*.*',
            scopeType: user_permission_entity_1.TipoEscopo.GLOBAL,
        });
        if (hasSuperAdminPermission) {
            this.logger.debug(`Acesso concedido via super admin: usuário ${userId} possui permissão '*.*'`);
            return true;
        }
        // Verifica se o usuário tem pelo menos uma das permissões requeridas (OR lógico)
        const permissionChecks = [];
        const requirementDetails = [];
        // Prepara todas as verificações de permissão
        for (const requirement of requirements) {
            const { permissionName, scopeType = user_permission_entity_1.TipoEscopo.GLOBAL, scopeIdExpression } = requirement;
            // Obtém o ID do escopo a partir da expressão
            let scopeId;
            if (scopeType === user_permission_entity_1.TipoEscopo.UNIDADE && scopeIdExpression) {
                scopeId = this.evaluateScopeIdExpression(scopeIdExpression, request);
            }
            // Adiciona a verificação de permissão à lista
            const permissionCheck = this.permissionService.hasPermission({
                userId,
                permissionName,
                scopeType,
                scopeId,
            });
            permissionChecks.push(permissionCheck);
            requirementDetails.push({ requirement, scopeId });
        }
        // Executa todas as verificações em paralelo
        const results = await Promise.all(permissionChecks);
        // Verifica se pelo menos uma permissão foi concedida
        const hasAnyPermission = results.some(result => result === true);
        if (!hasAnyPermission) {
            // Log detalhado de todas as permissões que falharam
            const failedPermissions = requirementDetails
                .filter((_, index) => !results[index])
                .map(({ requirement, scopeId }) => {
                const { permissionName, scopeType = user_permission_entity_1.TipoEscopo.GLOBAL } = requirement;
                return `${permissionName} (escopo: ${scopeType}${scopeId ? `, ID: ${scopeId}` : ''})`;
            });
            this.logger.warn(`Acesso negado: usuário ${userId} não possui nenhuma das permissões requeridas: ${failedPermissions.join(', ')}`);
            // Lança exceção com a primeira permissão que falhou (para compatibilidade)
            const firstFailedRequirement = requirementDetails.find((_, index) => !results[index]);
            if (firstFailedRequirement) {
                const { permissionName, scopeType = user_permission_entity_1.TipoEscopo.GLOBAL } = firstFailedRequirement.requirement;
                throw new permission_denied_exception_1.PermissionDeniedException(permissionName, scopeType, firstFailedRequirement.scopeId);
            }
        }
        return true;
    }
    /**
     * Avalia a expressão para obter o ID do escopo a partir dos parâmetros da requisição.
     *
     * @param expression Expressão para obter o ID do escopo
     * @param request Requisição
     * @returns ID do escopo ou undefined se não for possível obter
     */
    evaluateScopeIdExpression(expression, request) {
        try {
            // Divide a expressão em partes (ex: 'params.unidadeId' -> ['params', 'unidadeId'])
            const parts = expression.split('.');
            // Avalia a expressão
            let value = request;
            for (const part of parts) {
                if (value && typeof value === 'object' && part in value) {
                    value = value[part];
                }
                else {
                    return undefined;
                }
            }
            return value?.toString();
        }
        catch (error) {
            this.logger.error(`Erro ao avaliar expressão de escopo: ${error.message}`, error.stack);
            return undefined;
        }
    }
};
exports.PermissionGuard = PermissionGuard;
exports.PermissionGuard = PermissionGuard = PermissionGuard_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof core_1.Reflector !== "undefined" && core_1.Reflector) === "function" ? _a : Object, typeof (_b = typeof permission_service_1.PermissionService !== "undefined" && permission_service_1.PermissionService) === "function" ? _b : Object])
], PermissionGuard);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXGF1dGhcXGd1YXJkc1xccGVybWlzc2lvbi5ndWFyZC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUEwRztBQUMxRyx1Q0FBeUM7QUFDekMsK0ZBQWlIO0FBQ2pILHVFQUFtRTtBQUNuRSxrRkFBbUU7QUFDbkUsMkZBQXNGO0FBRXRGOzs7Ozs7R0FNRztBQUVJLElBQU0sZUFBZSx1QkFBckIsTUFBTSxlQUFlO0lBSWhCO0lBQ0E7SUFKTyxNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsaUJBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUUzRCxZQUNVLFNBQW9CLEVBQ3BCLGlCQUFvQztRQURwQyxjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQ3BCLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7SUFDM0MsQ0FBQztJQUVKOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUF5QjtRQUN6Qyx5REFBeUQ7UUFDekQsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FDM0MsMkRBQTJCLEVBQzNCLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FDckIsSUFBSSxFQUFFLENBQUM7UUFFUixNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUMxQywyREFBMkIsRUFDM0IsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUNuQixJQUFJLEVBQUUsQ0FBQztRQUVSLHFDQUFxQztRQUNyQyxNQUFNLFlBQVksR0FBRyxDQUFDLEdBQUcsa0JBQWtCLEVBQUUsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDO1FBRW5FLDBEQUEwRDtRQUMxRCxJQUFJLFlBQVksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDOUIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQscUJBQXFCO1FBQ3JCLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUVwRCx5Q0FBeUM7UUFDekMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ3RDLE1BQU0sSUFBSSw4QkFBcUIsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1FBQzdELENBQUM7UUFFRCxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUUvQix1RkFBdUY7UUFDdkYsNkVBQTZFO1FBQzdFLE1BQU0sdUJBQXVCLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDO1lBQ3pFLE1BQU07WUFDTixjQUFjLEVBQUUsS0FBSztZQUNyQixTQUFTLEVBQUUsbUNBQVUsQ0FBQyxNQUFNO1NBQzdCLENBQUMsQ0FBQztRQUVILElBQUksdUJBQXVCLEVBQUUsQ0FBQztZQUM1QixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyw2Q0FBNkMsTUFBTSx5QkFBeUIsQ0FBQyxDQUFDO1lBQ2hHLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELGlGQUFpRjtRQUNqRixNQUFNLGdCQUFnQixHQUF1QixFQUFFLENBQUM7UUFDaEQsTUFBTSxrQkFBa0IsR0FBb0UsRUFBRSxDQUFDO1FBRS9GLDZDQUE2QztRQUM3QyxLQUFLLE1BQU0sV0FBVyxJQUFJLFlBQVksRUFBRSxDQUFDO1lBQ3ZDLE1BQU0sRUFBRSxjQUFjLEVBQUUsU0FBUyxHQUFHLG1DQUFVLENBQUMsTUFBTSxFQUFFLGlCQUFpQixFQUFFLEdBQUcsV0FBVyxDQUFDO1lBRXpGLDZDQUE2QztZQUM3QyxJQUFJLE9BQTJCLENBQUM7WUFDaEMsSUFBSSxTQUFTLEtBQUssbUNBQVUsQ0FBQyxPQUFPLElBQUksaUJBQWlCLEVBQUUsQ0FBQztnQkFDMUQsT0FBTyxHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxpQkFBaUIsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUN2RSxDQUFDO1lBRUQsOENBQThDO1lBQzlDLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUM7Z0JBQzNELE1BQU07Z0JBQ04sY0FBYztnQkFDZCxTQUFTO2dCQUNULE9BQU87YUFDUixDQUFDLENBQUM7WUFFSCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDdkMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDcEQsQ0FBQztRQUVELDRDQUE0QztRQUM1QyxNQUFNLE9BQU8sR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUVwRCxxREFBcUQ7UUFDckQsTUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxDQUFDO1FBRWpFLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ3RCLG9EQUFvRDtZQUNwRCxNQUFNLGlCQUFpQixHQUFHLGtCQUFrQjtpQkFDekMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ3JDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUU7Z0JBQ2hDLE1BQU0sRUFBRSxjQUFjLEVBQUUsU0FBUyxHQUFHLG1DQUFVLENBQUMsTUFBTSxFQUFFLEdBQUcsV0FBVyxDQUFDO2dCQUN0RSxPQUFPLEdBQUcsY0FBYyxhQUFhLFNBQVMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLFNBQVMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO1lBQ3hGLENBQUMsQ0FBQyxDQUFDO1lBRUwsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQ2QsMEJBQTBCLE1BQU0sa0RBQWtELGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUNqSCxDQUFDO1lBRUYsMkVBQTJFO1lBQzNFLE1BQU0sc0JBQXNCLEdBQUcsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUN0RixJQUFJLHNCQUFzQixFQUFFLENBQUM7Z0JBQzNCLE1BQU0sRUFBRSxjQUFjLEVBQUUsU0FBUyxHQUFHLG1DQUFVLENBQUMsTUFBTSxFQUFFLEdBQUcsc0JBQXNCLENBQUMsV0FBVyxDQUFDO2dCQUM3RixNQUFNLElBQUksdURBQXlCLENBQUMsY0FBYyxFQUFFLFNBQVMsRUFBRSxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNqRyxDQUFDO1FBQ0gsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLHlCQUF5QixDQUFDLFVBQWtCLEVBQUUsT0FBWTtRQUNoRSxJQUFJLENBQUM7WUFDSCxtRkFBbUY7WUFDbkYsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUVwQyxxQkFBcUI7WUFDckIsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDO1lBQ3BCLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFLENBQUM7Z0JBQ3pCLElBQUksS0FBSyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxJQUFJLElBQUksS0FBSyxFQUFFLENBQUM7b0JBQ3hELEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3RCLENBQUM7cUJBQU0sQ0FBQztvQkFDTixPQUFPLFNBQVMsQ0FBQztnQkFDbkIsQ0FBQztZQUNILENBQUM7WUFFRCxPQUFPLEtBQUssRUFBRSxRQUFRLEVBQUUsQ0FBQztRQUMzQixDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3hGLE9BQU8sU0FBUyxDQUFDO1FBQ25CLENBQUM7SUFDSCxDQUFDO0NBQ0YsQ0FBQTtBQTdJWSwwQ0FBZTswQkFBZixlQUFlO0lBRDNCLElBQUEsbUJBQVUsR0FBRTt5REFLVSxnQkFBUyxvQkFBVCxnQkFBUyxvREFDRCxzQ0FBaUIsb0JBQWpCLHNDQUFpQjtHQUxuQyxlQUFlLENBNkkzQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcYXV0aFxcZ3VhcmRzXFxwZXJtaXNzaW9uLmd1YXJkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIENhbkFjdGl2YXRlLCBFeGVjdXRpb25Db250ZXh0LCBMb2dnZXIsIFVuYXV0aG9yaXplZEV4Y2VwdGlvbiB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IFJlZmxlY3RvciB9IGZyb20gJ0BuZXN0anMvY29yZSc7XG5pbXBvcnQgeyBQRVJNSVNTSU9OX1JFUVVJUkVNRU5UU19LRVksIFBlcm1pc3Npb25SZXF1aXJlbWVudCB9IGZyb20gJy4uL2RlY29yYXRvcnMvcmVxdWlyZXMtcGVybWlzc2lvbi5kZWNvcmF0b3InO1xuaW1wb3J0IHsgUGVybWlzc2lvblNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wZXJtaXNzaW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgVGlwb0VzY29wbyB9IGZyb20gJy4uLy4uL2VudGl0aWVzL3VzZXItcGVybWlzc2lvbi5lbnRpdHknO1xuaW1wb3J0IHsgUGVybWlzc2lvbkRlbmllZEV4Y2VwdGlvbiB9IGZyb20gJy4uL2V4Y2VwdGlvbnMvcGVybWlzc2lvbi1kZW5pZWQuZXhjZXB0aW9uJztcblxuLyoqXG4gKiBHdWFyZCBwYXJhIHZlcmlmaWNhciBwZXJtaXNzw7VlcyBncmFudWxhcmVzLlxuICogXG4gKiBFc3RlIGd1YXJkIHZlcmlmaWNhIHNlIG8gdXN1w6FyaW8gdGVtIGFzIHBlcm1pc3PDtWVzIG5lY2Vzc8OhcmlhcyBwYXJhIGFjZXNzYXJcbiAqIHVtIGVuZHBvaW50LCBjb25zaWRlcmFuZG8gb3MgcmVxdWlzaXRvcyBkZSBwZXJtaXNzw6NvIGRlZmluaWRvcyBwZWxvIGRlY29yYWRvclxuICogUmVxdWlyZXNQZXJtaXNzaW9uLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkd1YXJkIGltcGxlbWVudHMgQ2FuQWN0aXZhdGUge1xuICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlciA9IG5ldyBMb2dnZXIoUGVybWlzc2lvbkd1YXJkLm5hbWUpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVmbGVjdG9yOiBSZWZsZWN0b3IsXG4gICAgcHJpdmF0ZSBwZXJtaXNzaW9uU2VydmljZTogUGVybWlzc2lvblNlcnZpY2UsXG4gICkge31cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgbyB1c3XDoXJpbyB0ZW0gYXMgcGVybWlzc8O1ZXMgbmVjZXNzw6FyaWFzIHBhcmEgYWNlc3NhciBvIGVuZHBvaW50LlxuICAgKiBcbiAgICogQHBhcmFtIGNvbnRleHQgQ29udGV4dG8gZGUgZXhlY3XDp8Ojb1xuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gdXN1w6FyaW8gdGVtIGFzIHBlcm1pc3PDtWVzIG5lY2Vzc8OhcmlhcywgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBhc3luYyBjYW5BY3RpdmF0ZShjb250ZXh0OiBFeGVjdXRpb25Db250ZXh0KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gT2J0w6ltIG9zIHJlcXVpc2l0b3MgZGUgcGVybWlzc8OjbyBkbyBtw6l0b2RvIGUgZGEgY2xhc3NlXG4gICAgY29uc3QgbWV0aG9kUmVxdWlyZW1lbnRzID0gdGhpcy5yZWZsZWN0b3IuZ2V0PFBlcm1pc3Npb25SZXF1aXJlbWVudFtdPihcbiAgICAgIFBFUk1JU1NJT05fUkVRVUlSRU1FTlRTX0tFWSxcbiAgICAgIGNvbnRleHQuZ2V0SGFuZGxlcigpLFxuICAgICkgfHwgW107XG5cbiAgICBjb25zdCBjbGFzc1JlcXVpcmVtZW50cyA9IHRoaXMucmVmbGVjdG9yLmdldDxQZXJtaXNzaW9uUmVxdWlyZW1lbnRbXT4oXG4gICAgICBQRVJNSVNTSU9OX1JFUVVJUkVNRU5UU19LRVksXG4gICAgICBjb250ZXh0LmdldENsYXNzKCksXG4gICAgKSB8fCBbXTtcblxuICAgIC8vIENvbWJpbmEgb3MgcmVxdWlzaXRvcyBkZSBwZXJtaXNzw6NvXG4gICAgY29uc3QgcmVxdWlyZW1lbnRzID0gWy4uLm1ldGhvZFJlcXVpcmVtZW50cywgLi4uY2xhc3NSZXF1aXJlbWVudHNdO1xuXG4gICAgLy8gU2UgbsOjbyBob3V2ZXIgcmVxdWlzaXRvcyBkZSBwZXJtaXNzw6NvLCBwZXJtaXRlIG8gYWNlc3NvXG4gICAgaWYgKHJlcXVpcmVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE9idMOpbSBhIHJlcXVpc2nDp8Ojb1xuICAgIGNvbnN0IHJlcXVlc3QgPSBjb250ZXh0LnN3aXRjaFRvSHR0cCgpLmdldFJlcXVlc3QoKTtcbiAgICBcbiAgICAvLyBWZXJpZmljYSBzZSBvIHVzdcOhcmlvIGVzdMOhIGF1dGVudGljYWRvXG4gICAgaWYgKCFyZXF1ZXN0LnVzZXIgfHwgIXJlcXVlc3QudXNlci5pZCkge1xuICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEV4Y2VwdGlvbignVXN1w6FyaW8gbsOjbyBhdXRlbnRpY2FkbycpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJJZCA9IHJlcXVlc3QudXNlci5pZDtcblxuICAgIC8vIEJZUEFTUyBQQVJBIFNVUEVSIEFETUlOOiBWZXJpZmljYSBzZSBvIHVzdcOhcmlvIHBvc3N1aSBwZXJtaXNzw6NvIGRlIHN1cGVyIGFkbWluICgqLiopXG4gICAgLy8gU2Ugc2ltLCBwZXJtaXRlIGFjZXNzbyBhIHF1YWxxdWVyIGVuZHBvaW50IHNlbSB2ZXJpZmljYXIgb3V0cmFzIHBlcm1pc3PDtWVzXG4gICAgY29uc3QgaGFzU3VwZXJBZG1pblBlcm1pc3Npb24gPSBhd2FpdCB0aGlzLnBlcm1pc3Npb25TZXJ2aWNlLmhhc1Blcm1pc3Npb24oe1xuICAgICAgdXNlcklkLFxuICAgICAgcGVybWlzc2lvbk5hbWU6ICcqLionLFxuICAgICAgc2NvcGVUeXBlOiBUaXBvRXNjb3BvLkdMT0JBTCxcbiAgICB9KTtcblxuICAgIGlmIChoYXNTdXBlckFkbWluUGVybWlzc2lvbikge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEFjZXNzbyBjb25jZWRpZG8gdmlhIHN1cGVyIGFkbWluOiB1c3XDoXJpbyAke3VzZXJJZH0gcG9zc3VpIHBlcm1pc3PDo28gJyouKidgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFZlcmlmaWNhIHNlIG8gdXN1w6FyaW8gdGVtIHBlbG8gbWVub3MgdW1hIGRhcyBwZXJtaXNzw7VlcyByZXF1ZXJpZGFzIChPUiBsw7NnaWNvKVxuICAgIGNvbnN0IHBlcm1pc3Npb25DaGVja3M6IFByb21pc2U8Ym9vbGVhbj5bXSA9IFtdO1xuICAgIGNvbnN0IHJlcXVpcmVtZW50RGV0YWlsczogQXJyYXk8eyByZXF1aXJlbWVudDogUGVybWlzc2lvblJlcXVpcmVtZW50OyBzY29wZUlkPzogc3RyaW5nIH0+ID0gW107XG5cbiAgICAvLyBQcmVwYXJhIHRvZGFzIGFzIHZlcmlmaWNhw6fDtWVzIGRlIHBlcm1pc3PDo29cbiAgICBmb3IgKGNvbnN0IHJlcXVpcmVtZW50IG9mIHJlcXVpcmVtZW50cykge1xuICAgICAgY29uc3QgeyBwZXJtaXNzaW9uTmFtZSwgc2NvcGVUeXBlID0gVGlwb0VzY29wby5HTE9CQUwsIHNjb3BlSWRFeHByZXNzaW9uIH0gPSByZXF1aXJlbWVudDtcblxuICAgICAgLy8gT2J0w6ltIG8gSUQgZG8gZXNjb3BvIGEgcGFydGlyIGRhIGV4cHJlc3PDo29cbiAgICAgIGxldCBzY29wZUlkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICBpZiAoc2NvcGVUeXBlID09PSBUaXBvRXNjb3BvLlVOSURBREUgJiYgc2NvcGVJZEV4cHJlc3Npb24pIHtcbiAgICAgICAgc2NvcGVJZCA9IHRoaXMuZXZhbHVhdGVTY29wZUlkRXhwcmVzc2lvbihzY29wZUlkRXhwcmVzc2lvbiwgcmVxdWVzdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkaWNpb25hIGEgdmVyaWZpY2HDp8OjbyBkZSBwZXJtaXNzw6NvIMOgIGxpc3RhXG4gICAgICBjb25zdCBwZXJtaXNzaW9uQ2hlY2sgPSB0aGlzLnBlcm1pc3Npb25TZXJ2aWNlLmhhc1Blcm1pc3Npb24oe1xuICAgICAgICB1c2VySWQsXG4gICAgICAgIHBlcm1pc3Npb25OYW1lLFxuICAgICAgICBzY29wZVR5cGUsXG4gICAgICAgIHNjb3BlSWQsXG4gICAgICB9KTtcblxuICAgICAgcGVybWlzc2lvbkNoZWNrcy5wdXNoKHBlcm1pc3Npb25DaGVjayk7XG4gICAgICByZXF1aXJlbWVudERldGFpbHMucHVzaCh7IHJlcXVpcmVtZW50LCBzY29wZUlkIH0pO1xuICAgIH1cblxuICAgIC8vIEV4ZWN1dGEgdG9kYXMgYXMgdmVyaWZpY2HDp8O1ZXMgZW0gcGFyYWxlbG9cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocGVybWlzc2lvbkNoZWNrcyk7XG5cbiAgICAvLyBWZXJpZmljYSBzZSBwZWxvIG1lbm9zIHVtYSBwZXJtaXNzw6NvIGZvaSBjb25jZWRpZGFcbiAgICBjb25zdCBoYXNBbnlQZXJtaXNzaW9uID0gcmVzdWx0cy5zb21lKHJlc3VsdCA9PiByZXN1bHQgPT09IHRydWUpO1xuXG4gICAgaWYgKCFoYXNBbnlQZXJtaXNzaW9uKSB7XG4gICAgICAvLyBMb2cgZGV0YWxoYWRvIGRlIHRvZGFzIGFzIHBlcm1pc3PDtWVzIHF1ZSBmYWxoYXJhbVxuICAgICAgY29uc3QgZmFpbGVkUGVybWlzc2lvbnMgPSByZXF1aXJlbWVudERldGFpbHNcbiAgICAgICAgLmZpbHRlcigoXywgaW5kZXgpID0+ICFyZXN1bHRzW2luZGV4XSlcbiAgICAgICAgLm1hcCgoeyByZXF1aXJlbWVudCwgc2NvcGVJZCB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwZXJtaXNzaW9uTmFtZSwgc2NvcGVUeXBlID0gVGlwb0VzY29wby5HTE9CQUwgfSA9IHJlcXVpcmVtZW50O1xuICAgICAgICAgIHJldHVybiBgJHtwZXJtaXNzaW9uTmFtZX0gKGVzY29wbzogJHtzY29wZVR5cGV9JHtzY29wZUlkID8gYCwgSUQ6ICR7c2NvcGVJZH1gIDogJyd9KWA7XG4gICAgICAgIH0pO1xuXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICBgQWNlc3NvIG5lZ2FkbzogdXN1w6FyaW8gJHt1c2VySWR9IG7Do28gcG9zc3VpIG5lbmh1bWEgZGFzIHBlcm1pc3PDtWVzIHJlcXVlcmlkYXM6ICR7ZmFpbGVkUGVybWlzc2lvbnMuam9pbignLCAnKX1gLFxuICAgICAgKTtcblxuICAgICAgLy8gTGFuw6dhIGV4Y2XDp8OjbyBjb20gYSBwcmltZWlyYSBwZXJtaXNzw6NvIHF1ZSBmYWxob3UgKHBhcmEgY29tcGF0aWJpbGlkYWRlKVxuICAgICAgY29uc3QgZmlyc3RGYWlsZWRSZXF1aXJlbWVudCA9IHJlcXVpcmVtZW50RGV0YWlscy5maW5kKChfLCBpbmRleCkgPT4gIXJlc3VsdHNbaW5kZXhdKTtcbiAgICAgIGlmIChmaXJzdEZhaWxlZFJlcXVpcmVtZW50KSB7XG4gICAgICAgIGNvbnN0IHsgcGVybWlzc2lvbk5hbWUsIHNjb3BlVHlwZSA9IFRpcG9Fc2NvcG8uR0xPQkFMIH0gPSBmaXJzdEZhaWxlZFJlcXVpcmVtZW50LnJlcXVpcmVtZW50O1xuICAgICAgICB0aHJvdyBuZXcgUGVybWlzc2lvbkRlbmllZEV4Y2VwdGlvbihwZXJtaXNzaW9uTmFtZSwgc2NvcGVUeXBlLCBmaXJzdEZhaWxlZFJlcXVpcmVtZW50LnNjb3BlSWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEF2YWxpYSBhIGV4cHJlc3PDo28gcGFyYSBvYnRlciBvIElEIGRvIGVzY29wbyBhIHBhcnRpciBkb3MgcGFyw6JtZXRyb3MgZGEgcmVxdWlzacOnw6NvLlxuICAgKiBcbiAgICogQHBhcmFtIGV4cHJlc3Npb24gRXhwcmVzc8OjbyBwYXJhIG9idGVyIG8gSUQgZG8gZXNjb3BvXG4gICAqIEBwYXJhbSByZXF1ZXN0IFJlcXVpc2nDp8Ojb1xuICAgKiBAcmV0dXJucyBJRCBkbyBlc2NvcG8gb3UgdW5kZWZpbmVkIHNlIG7Do28gZm9yIHBvc3PDrXZlbCBvYnRlclxuICAgKi9cbiAgcHJpdmF0ZSBldmFsdWF0ZVNjb3BlSWRFeHByZXNzaW9uKGV4cHJlc3Npb246IHN0cmluZywgcmVxdWVzdDogYW55KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICB0cnkge1xuICAgICAgLy8gRGl2aWRlIGEgZXhwcmVzc8OjbyBlbSBwYXJ0ZXMgKGV4OiAncGFyYW1zLnVuaWRhZGVJZCcgLT4gWydwYXJhbXMnLCAndW5pZGFkZUlkJ10pXG4gICAgICBjb25zdCBwYXJ0cyA9IGV4cHJlc3Npb24uc3BsaXQoJy4nKTtcbiAgICAgIFxuICAgICAgLy8gQXZhbGlhIGEgZXhwcmVzc8Ojb1xuICAgICAgbGV0IHZhbHVlID0gcmVxdWVzdDtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBwYXJ0IGluIHZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXJ0XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB2YWx1ZT8udG9TdHJpbmcoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gYXZhbGlhciBleHByZXNzw6NvIGRlIGVzY29wbzogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yLnN0YWNrKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG4iXSwidmVyc2lvbiI6M30=