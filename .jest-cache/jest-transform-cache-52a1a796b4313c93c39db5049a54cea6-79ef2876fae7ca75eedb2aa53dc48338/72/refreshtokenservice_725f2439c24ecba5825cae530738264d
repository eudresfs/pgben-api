d63169bedd40d8517fc05e4c6ce942ea
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RefreshTokenService = void 0;
/* eslint-disable prettier/prettier */
// src/auth/services/refresh-token.service.ts
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const refresh_token_entity_1 = require("../../entities/refresh-token.entity");
let RefreshTokenService = class RefreshTokenService {
    refreshTokenRepository;
    constructor(refreshTokenRepository) {
        this.refreshTokenRepository = refreshTokenRepository;
    }
    /**
     * Cria um novo token de refresh para o usuário
     * @param user Usuário para quem o token será criado
     * @param ttl Tempo de vida do token em segundos
     * @returns O token de refresh criado
     */
    async createToken(user, ttl) {
        const expiresAt = new Date();
        expiresAt.setTime(expiresAt.getTime() + ttl * 1000);
        const refreshToken = this.refreshTokenRepository.create({
            usuario: user,
            usuario_id: user.id,
            token: this.generateToken(),
            expires_at: expiresAt,
        });
        return this.refreshTokenRepository.save(refreshToken);
    }
    /**
     * Encontra um token pelo seu valor
     * @param token Valor do token a ser encontrado
     * @returns O token encontrado ou null
     */
    async findToken(token) {
        return this.refreshTokenRepository.findOne({
            where: { token },
            relations: ['usuario'],
        });
    }
    /**
     * Busca todos os tokens ativos de um usuário
     * @param usuarioId ID do usuário
     * @returns Lista de tokens ativos
     */
    async findActiveTokensByUserId(usuarioId) {
        return this.refreshTokenRepository.find({
            where: {
                usuario_id: usuarioId,
                revoked: false,
                expires_at: (0, typeorm_2.MoreThan)(new Date()), // Apenas tokens não expirados
            },
        });
    }
    /**
     * Revoga um token específico
     * @param token Valor do token a ser revogado
     * @param ipAddress Endereço IP que solicitou a revogação
     * @param replacedByToken Token que substituiu este (opcional)
     */
    async revokeToken(token, ipAddress, replacedByToken) {
        await this.refreshTokenRepository.update({ token }, {
            revoked: true,
            revoked_at: new Date(),
            revokedByIp: ipAddress,
            replacedByToken: replacedByToken,
        });
    }
    /**
     * Revoga todos os tokens descendentes deste token
     * @param refreshToken Token pai
     * @param ipAddress Endereço IP que solicitou a revogação
     */
    async revokeDescendantTokens(refreshToken, ipAddress) {
        // Se houver um token que substituiu este token, revogue-o também
        if (refreshToken.replacedByToken) {
            const childToken = await this.refreshTokenRepository.findOne({
                where: { token: refreshToken.replacedByToken },
            });
            if (childToken && !childToken.revoked) {
                await this.revokeToken(childToken.token, ipAddress);
                // Recursivamente revogar descendentes
                await this.revokeDescendantTokens(childToken, ipAddress);
            }
        }
    }
    /**
     * Revoga todos os tokens ativos de um usuário
     * @param usuarioId ID do usuário
     * @param ipAddress Endereço IP que solicitou a revogação
     * @returns Número de tokens revogados
     */
    async revokeAllUserTokens(usuarioId, ipAddress) {
        const tokens = await this.findActiveTokensByUserId(usuarioId);
        for (const token of tokens) {
            await this.revokeToken(token.token, ipAddress);
        }
        return tokens.length;
    }
    /**
     * Gera um valor de token aleatório e seguro
     * @returns String hexadecimal aleatória
     */
    generateToken() {
        return require('crypto').randomBytes(40).toString('hex');
    }
};
exports.RefreshTokenService = RefreshTokenService;
exports.RefreshTokenService = RefreshTokenService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(refresh_token_entity_1.RefreshToken)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], RefreshTokenService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXGF1dGhcXHNlcnZpY2VzXFxyZWZyZXNoLXRva2VuLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHNDQUFzQztBQUN0Qyw2Q0FBNkM7QUFDN0MsMkNBQTRDO0FBQzVDLDZDQUFtRDtBQUNuRCxxQ0FBK0M7QUFDL0MsOEVBQW1FO0FBSTVELElBQU0sbUJBQW1CLEdBQXpCLE1BQU0sbUJBQW1CO0lBR3BCO0lBRlYsWUFFVSxzQkFBZ0Q7UUFBaEQsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUEwQjtJQUN2RCxDQUFDO0lBRUo7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsV0FBVyxDQUFDLElBQWEsRUFBRSxHQUFXO1FBQzFDLE1BQU0sU0FBUyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7UUFDN0IsU0FBUyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDO1FBRXBELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLENBQUM7WUFDdEQsT0FBTyxFQUFFLElBQUk7WUFDYixVQUFVLEVBQUUsSUFBSSxDQUFDLEVBQUU7WUFDbkIsS0FBSyxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDM0IsVUFBVSxFQUFFLFNBQVM7U0FDdEIsQ0FBQyxDQUFDO1FBRUgsT0FBTyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFhO1FBQzNCLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLE9BQU8sQ0FBQztZQUN6QyxLQUFLLEVBQUUsRUFBRSxLQUFLLEVBQUU7WUFDaEIsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDO1NBQ3ZCLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLHdCQUF3QixDQUFDLFNBQWlCO1FBQzlDLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQztZQUN0QyxLQUFLLEVBQUU7Z0JBQ0wsVUFBVSxFQUFFLFNBQVM7Z0JBQ3JCLE9BQU8sRUFBRSxLQUFLO2dCQUNkLFVBQVUsRUFBRSxJQUFBLGtCQUFRLEVBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxFQUFFLDhCQUE4QjthQUNqRTtTQUNGLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQ2YsS0FBYSxFQUNiLFNBQWlCLEVBQ2pCLGVBQXdCO1FBRXhCLE1BQU0sSUFBSSxDQUFDLHNCQUFzQixDQUFDLE1BQU0sQ0FDdEMsRUFBRSxLQUFLLEVBQUUsRUFDVDtZQUNFLE9BQU8sRUFBRSxJQUFJO1lBQ2IsVUFBVSxFQUFFLElBQUksSUFBSSxFQUFFO1lBQ3RCLFdBQVcsRUFBRSxTQUFTO1lBQ3RCLGVBQWUsRUFBRSxlQUFlO1NBQ2pDLENBQ0YsQ0FBQztJQUNKLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLHNCQUFzQixDQUMxQixZQUEwQixFQUMxQixTQUFpQjtRQUVqQixpRUFBaUU7UUFDakUsSUFBSSxZQUFZLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDakMsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDO2dCQUMzRCxLQUFLLEVBQUUsRUFBRSxLQUFLLEVBQUUsWUFBWSxDQUFDLGVBQWUsRUFBRTthQUMvQyxDQUFDLENBQUM7WUFFSCxJQUFJLFVBQVUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDdEMsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBRXBELHNDQUFzQztnQkFDdEMsTUFBTSxJQUFJLENBQUMsc0JBQXNCLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQzNELENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLG1CQUFtQixDQUN2QixTQUFpQixFQUNqQixTQUFpQjtRQUVqQixNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUU5RCxLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFBRSxDQUFDO1lBQzNCLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ2pELENBQUM7UUFFRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGFBQWE7UUFDbkIsT0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzRCxDQUFDO0NBQ0YsQ0FBQTtBQTdIWSxrREFBbUI7OEJBQW5CLG1CQUFtQjtJQUQvQixJQUFBLG1CQUFVLEdBQUU7SUFHUixXQUFBLElBQUEsMEJBQWdCLEVBQUMsbUNBQVksQ0FBQyxDQUFBO3lEQUNDLG9CQUFVLG9CQUFWLG9CQUFVO0dBSGpDLG1CQUFtQixDQTZIL0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXGF1dGhcXHNlcnZpY2VzXFxyZWZyZXNoLXRva2VuLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIgKi9cbi8vIHNyYy9hdXRoL3NlcnZpY2VzL3JlZnJlc2gtdG9rZW4uc2VydmljZS50c1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IEluamVjdFJlcG9zaXRvcnkgfSBmcm9tICdAbmVzdGpzL3R5cGVvcm0nO1xuaW1wb3J0IHsgUmVwb3NpdG9yeSwgTW9yZVRoYW4gfSBmcm9tICd0eXBlb3JtJztcbmltcG9ydCB7IFJlZnJlc2hUb2tlbiB9IGZyb20gJy4uLy4uL2VudGl0aWVzL3JlZnJlc2gtdG9rZW4uZW50aXR5JztcbmltcG9ydCB7IFVzdWFyaW8gfSBmcm9tICcuLi8uLi9lbnRpdGllcy91c3VhcmlvLmVudGl0eSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSZWZyZXNoVG9rZW5TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdFJlcG9zaXRvcnkoUmVmcmVzaFRva2VuKVxuICAgIHByaXZhdGUgcmVmcmVzaFRva2VuUmVwb3NpdG9yeTogUmVwb3NpdG9yeTxSZWZyZXNoVG9rZW4+LFxuICApIHt9XG5cbiAgLyoqXG4gICAqIENyaWEgdW0gbm92byB0b2tlbiBkZSByZWZyZXNoIHBhcmEgbyB1c3XDoXJpb1xuICAgKiBAcGFyYW0gdXNlciBVc3XDoXJpbyBwYXJhIHF1ZW0gbyB0b2tlbiBzZXLDoSBjcmlhZG9cbiAgICogQHBhcmFtIHR0bCBUZW1wbyBkZSB2aWRhIGRvIHRva2VuIGVtIHNlZ3VuZG9zXG4gICAqIEByZXR1cm5zIE8gdG9rZW4gZGUgcmVmcmVzaCBjcmlhZG9cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRva2VuKHVzZXI6IFVzdWFyaW8sIHR0bDogbnVtYmVyKTogUHJvbWlzZTxSZWZyZXNoVG9rZW4+IHtcbiAgICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZSgpO1xuICAgIGV4cGlyZXNBdC5zZXRUaW1lKGV4cGlyZXNBdC5nZXRUaW1lKCkgKyB0dGwgKiAxMDAwKTtcblxuICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IHRoaXMucmVmcmVzaFRva2VuUmVwb3NpdG9yeS5jcmVhdGUoe1xuICAgICAgdXN1YXJpbzogdXNlcixcbiAgICAgIHVzdWFyaW9faWQ6IHVzZXIuaWQsXG4gICAgICB0b2tlbjogdGhpcy5nZW5lcmF0ZVRva2VuKCksXG4gICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5yZWZyZXNoVG9rZW5SZXBvc2l0b3J5LnNhdmUocmVmcmVzaFRva2VuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvbnRyYSB1bSB0b2tlbiBwZWxvIHNldSB2YWxvclxuICAgKiBAcGFyYW0gdG9rZW4gVmFsb3IgZG8gdG9rZW4gYSBzZXIgZW5jb250cmFkb1xuICAgKiBAcmV0dXJucyBPIHRva2VuIGVuY29udHJhZG8gb3UgbnVsbFxuICAgKi9cbiAgYXN5bmMgZmluZFRva2VuKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPFJlZnJlc2hUb2tlbiB8IG51bGw+IHtcbiAgICByZXR1cm4gdGhpcy5yZWZyZXNoVG9rZW5SZXBvc2l0b3J5LmZpbmRPbmUoe1xuICAgICAgd2hlcmU6IHsgdG9rZW4gfSxcbiAgICAgIHJlbGF0aW9uczogWyd1c3VhcmlvJ10sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQnVzY2EgdG9kb3Mgb3MgdG9rZW5zIGF0aXZvcyBkZSB1bSB1c3XDoXJpb1xuICAgKiBAcGFyYW0gdXN1YXJpb0lkIElEIGRvIHVzdcOhcmlvXG4gICAqIEByZXR1cm5zIExpc3RhIGRlIHRva2VucyBhdGl2b3NcbiAgICovXG4gIGFzeW5jIGZpbmRBY3RpdmVUb2tlbnNCeVVzZXJJZCh1c3VhcmlvSWQ6IHN0cmluZyk6IFByb21pc2U8UmVmcmVzaFRva2VuW10+IHtcbiAgICByZXR1cm4gdGhpcy5yZWZyZXNoVG9rZW5SZXBvc2l0b3J5LmZpbmQoe1xuICAgICAgd2hlcmU6IHtcbiAgICAgICAgdXN1YXJpb19pZDogdXN1YXJpb0lkLFxuICAgICAgICByZXZva2VkOiBmYWxzZSxcbiAgICAgICAgZXhwaXJlc19hdDogTW9yZVRoYW4obmV3IERhdGUoKSksIC8vIEFwZW5hcyB0b2tlbnMgbsOjbyBleHBpcmFkb3NcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV2b2dhIHVtIHRva2VuIGVzcGVjw61maWNvXG4gICAqIEBwYXJhbSB0b2tlbiBWYWxvciBkbyB0b2tlbiBhIHNlciByZXZvZ2Fkb1xuICAgKiBAcGFyYW0gaXBBZGRyZXNzIEVuZGVyZcOnbyBJUCBxdWUgc29saWNpdG91IGEgcmV2b2dhw6fDo29cbiAgICogQHBhcmFtIHJlcGxhY2VkQnlUb2tlbiBUb2tlbiBxdWUgc3Vic3RpdHVpdSBlc3RlIChvcGNpb25hbClcbiAgICovXG4gIGFzeW5jIHJldm9rZVRva2VuKFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgaXBBZGRyZXNzOiBzdHJpbmcsXG4gICAgcmVwbGFjZWRCeVRva2VuPzogc3RyaW5nLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlblJlcG9zaXRvcnkudXBkYXRlKFxuICAgICAgeyB0b2tlbiB9LFxuICAgICAge1xuICAgICAgICByZXZva2VkOiB0cnVlLFxuICAgICAgICByZXZva2VkX2F0OiBuZXcgRGF0ZSgpLFxuICAgICAgICByZXZva2VkQnlJcDogaXBBZGRyZXNzLFxuICAgICAgICByZXBsYWNlZEJ5VG9rZW46IHJlcGxhY2VkQnlUb2tlbixcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXZvZ2EgdG9kb3Mgb3MgdG9rZW5zIGRlc2NlbmRlbnRlcyBkZXN0ZSB0b2tlblxuICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIFRva2VuIHBhaVxuICAgKiBAcGFyYW0gaXBBZGRyZXNzIEVuZGVyZcOnbyBJUCBxdWUgc29saWNpdG91IGEgcmV2b2dhw6fDo29cbiAgICovXG4gIGFzeW5jIHJldm9rZURlc2NlbmRhbnRUb2tlbnMoXG4gICAgcmVmcmVzaFRva2VuOiBSZWZyZXNoVG9rZW4sXG4gICAgaXBBZGRyZXNzOiBzdHJpbmcsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFNlIGhvdXZlciB1bSB0b2tlbiBxdWUgc3Vic3RpdHVpdSBlc3RlIHRva2VuLCByZXZvZ3VlLW8gdGFtYsOpbVxuICAgIGlmIChyZWZyZXNoVG9rZW4ucmVwbGFjZWRCeVRva2VuKSB7XG4gICAgICBjb25zdCBjaGlsZFRva2VuID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW5SZXBvc2l0b3J5LmZpbmRPbmUoe1xuICAgICAgICB3aGVyZTogeyB0b2tlbjogcmVmcmVzaFRva2VuLnJlcGxhY2VkQnlUb2tlbiB9LFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjaGlsZFRva2VuICYmICFjaGlsZFRva2VuLnJldm9rZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXZva2VUb2tlbihjaGlsZFRva2VuLnRva2VuLCBpcEFkZHJlc3MpO1xuXG4gICAgICAgIC8vIFJlY3Vyc2l2YW1lbnRlIHJldm9nYXIgZGVzY2VuZGVudGVzXG4gICAgICAgIGF3YWl0IHRoaXMucmV2b2tlRGVzY2VuZGFudFRva2VucyhjaGlsZFRva2VuLCBpcEFkZHJlc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXZvZ2EgdG9kb3Mgb3MgdG9rZW5zIGF0aXZvcyBkZSB1bSB1c3XDoXJpb1xuICAgKiBAcGFyYW0gdXN1YXJpb0lkIElEIGRvIHVzdcOhcmlvXG4gICAqIEBwYXJhbSBpcEFkZHJlc3MgRW5kZXJlw6dvIElQIHF1ZSBzb2xpY2l0b3UgYSByZXZvZ2HDp8Ojb1xuICAgKiBAcmV0dXJucyBOw7ptZXJvIGRlIHRva2VucyByZXZvZ2Fkb3NcbiAgICovXG4gIGFzeW5jIHJldm9rZUFsbFVzZXJUb2tlbnMoXG4gICAgdXN1YXJpb0lkOiBzdHJpbmcsXG4gICAgaXBBZGRyZXNzOiBzdHJpbmcsXG4gICk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgdG9rZW5zID0gYXdhaXQgdGhpcy5maW5kQWN0aXZlVG9rZW5zQnlVc2VySWQodXN1YXJpb0lkKTtcblxuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICBhd2FpdCB0aGlzLnJldm9rZVRva2VuKHRva2VuLnRva2VuLCBpcEFkZHJlc3MpO1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlcmEgdW0gdmFsb3IgZGUgdG9rZW4gYWxlYXTDs3JpbyBlIHNlZ3Vyb1xuICAgKiBAcmV0dXJucyBTdHJpbmcgaGV4YWRlY2ltYWwgYWxlYXTDs3JpYVxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVRva2VuKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzKDQwKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==