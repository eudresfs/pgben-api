45204a3c499f5a056ec95eec90f1d24e
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntegracaoDocumentoService = void 0;
const common_1 = require("@nestjs/common");
const path = __importStar(require("path"));
const crypto = __importStar(require("crypto"));
/**
 * Serviço de integração com o módulo de Documento
 *
 * Implementa a comunicação entre o módulo de Pagamento e o módulo de Documento,
 * permitindo o armazenamento e recuperação de comprovantes de pagamento.
 *
 * @author Equipe PGBen
 */
let IntegracaoDocumentoService = class IntegracaoDocumentoService {
    // Em uma implementação real, este serviço injetaria o DocumentoService do módulo de documento
    // constructor(private readonly documentoService: DocumentoService) {}
    /**
     * Armazena um comprovante de pagamento
     *
     * @param buffer Buffer com o conteúdo do arquivo
     * @param nomeArquivo Nome original do arquivo
     * @param mimeType Tipo MIME do arquivo
     * @param pagamentoId ID do pagamento relacionado
     * @param tipoDocumento Tipo do documento (comprovante, recibo, etc.)
     * @param usuarioId ID do usuário que está realizando o upload
     * @returns Informações do documento armazenado
     */
    async armazenarComprovante(buffer, nomeArquivo, mimeType, pagamentoId, tipoDocumento, usuarioId) {
        // Validar o arquivo
        this.validarArquivo(buffer, mimeType);
        // Gerar um nome único para o arquivo
        const nomeUnico = this.gerarNomeUnicoArquivo(nomeArquivo, pagamentoId);
        // Calcular hash do arquivo para verificação de integridade
        const hash = crypto.createHash('sha256').update(buffer).digest('hex');
        // Em uma implementação real, chamaria o serviço de documento
        // const resultado = await this.documentoService.armazenarDocumento({
        //   conteudo: buffer,
        //   nomeArquivo: nomeUnico,
        //   mimeType,
        //   categoria: 'COMPROVANTE_PAGAMENTO',
        //   entidadeId: pagamentoId,
        //   tipoEntidade: 'PAGAMENTO',
        //   metadados: {
        //     tipoDocumento,
        //     hash,
        //     uploadedPor: usuarioId
        //   }
        // });
        // Implementação de mock para desenvolvimento
        console.log(`[INTEGRAÇÃO] Armazenando comprovante para o pagamento ${pagamentoId}`);
        // Simular caminho de armazenamento
        const caminhoArquivo = `pagamentos/${pagamentoId}/comprovantes/${nomeUnico}`;
        return {
            id: crypto.randomUUID(),
            caminhoArquivo,
            tamanho: buffer.length,
            hash,
        };
    }
    /**
     * Recupera o conteúdo de um comprovante de pagamento
     *
     * @param caminhoArquivo Caminho do arquivo no sistema de armazenamento
     * @param usuarioId ID do usuário que está solicitando o arquivo
     * @returns Buffer com o conteúdo do arquivo e metadados
     */
    async recuperarComprovante(caminhoArquivo, usuarioId) {
        // Em uma implementação real, chamaria o serviço de documento
        // const documento = await this.documentoService.recuperarDocumento(caminhoArquivo, usuarioId);
        // Registrar acesso ao documento
        // await this.documentoService.registrarAcesso({
        //   caminhoArquivo,
        //   usuarioId,
        //   tipoAcesso: 'DOWNLOAD',
        //   timestamp: new Date()
        // });
        // return {
        //   buffer: documento.conteudo,
        //   nomeArquivo: documento.nomeOriginal,
        //   mimeType: documento.mimeType,
        //   tamanho: documento.tamanho
        // };
        // Implementação de mock para desenvolvimento
        console.log(`[INTEGRAÇÃO] Recuperando comprovante: ${caminhoArquivo}`);
        // Extrair nome do arquivo do caminho
        const nomeArquivo = path.basename(caminhoArquivo);
        // Criar um buffer vazio para simulação
        const buffer = Buffer.from('Conteúdo simulado do arquivo de comprovante');
        // Determinar o MIME type baseado na extensão
        const extensao = path.extname(nomeArquivo).toLowerCase();
        let mimeType = 'application/octet-stream';
        if (extensao === '.pdf') {
            mimeType = 'application/pdf';
        }
        else if (extensao === '.jpg' || extensao === '.jpeg') {
            mimeType = 'image/jpeg';
        }
        else if (extensao === '.png') {
            mimeType = 'image/png';
        }
        return {
            buffer,
            nomeArquivo,
            mimeType,
            tamanho: buffer.length,
        };
    }
    /**
     * Remove um comprovante de pagamento
     *
     * @param caminhoArquivo Caminho do arquivo no sistema de armazenamento
     * @param usuarioId ID do usuário que está solicitando a remoção
     * @returns true se removido com sucesso
     */
    async removerComprovante(caminhoArquivo, usuarioId) {
        // Em uma implementação real, chamaria o serviço de documento
        // await this.documentoService.removerDocumento(caminhoArquivo, usuarioId);
        // Registrar remoção do documento
        // await this.documentoService.registrarOperacao({
        //   caminhoArquivo,
        //   usuarioId,
        //   tipoOperacao: 'REMOCAO',
        //   timestamp: new Date()
        // });
        // return true;
        // Implementação de mock para desenvolvimento
        console.log(`[INTEGRAÇÃO] Removendo comprovante: ${caminhoArquivo}`);
        return true;
    }
    /**
     * Valida um arquivo antes do armazenamento
     *
     * @param buffer Conteúdo do arquivo
     * @param mimeType Tipo MIME declarado
     * @throws BadRequestException se o arquivo for inválido
     */
    validarArquivo(buffer, mimeType) {
        // Verificar tamanho máximo (5MB)
        const tamanhoMaximo = 5 * 1024 * 1024;
        if (buffer.length > tamanhoMaximo) {
            throw new common_1.BadRequestException(`Tamanho do arquivo excede o limite máximo de ${tamanhoMaximo / (1024 * 1024)}MB`);
        }
        // Verificar tipos MIME permitidos
        const tiposPermitidos = [
            'application/pdf',
            'image/jpeg',
            'image/jpg',
            'image/png',
        ];
        if (!tiposPermitidos.includes(mimeType)) {
            throw new common_1.BadRequestException(`Tipo de arquivo não permitido. Tipos permitidos: ${tiposPermitidos.join(', ')}`);
        }
        // Verificação básica de assinatura de arquivo (magic bytes)
        // Esta é uma verificação simplificada, em produção seria mais robusta
        if (mimeType === 'application/pdf' && buffer.length >= 4) {
            const signature = buffer.slice(0, 4).toString('hex');
            if (signature !== '25504446') {
                // %PDF em hex
                throw new common_1.BadRequestException('Arquivo PDF inválido');
            }
        }
        if (mimeType === 'image/jpeg' && buffer.length >= 3) {
            const signature = buffer.slice(0, 3).toString('hex');
            if (signature !== 'ffd8ff') {
                // JPEG SOI marker
                throw new common_1.BadRequestException('Arquivo JPEG inválido');
            }
        }
        if (mimeType === 'image/png' && buffer.length >= 8) {
            const signature = buffer.slice(0, 8).toString('hex');
            if (signature !== '89504e470d0a1a0a') {
                // PNG signature
                throw new common_1.BadRequestException('Arquivo PNG inválido');
            }
        }
    }
    /**
     * Gera um nome único para o arquivo
     *
     * @param nomeOriginal Nome original do arquivo
     * @param pagamentoId ID do pagamento relacionado
     * @returns Nome único para armazenamento
     */
    gerarNomeUnicoArquivo(nomeOriginal, pagamentoId) {
        const timestamp = Date.now();
        const randomString = crypto.randomBytes(8).toString('hex');
        const extensao = path.extname(nomeOriginal);
        return `${timestamp}-${randomString}${extensao}`;
    }
    /**
     * Verifica se um arquivo existe no sistema de armazenamento
     *
     * @param caminhoArquivo Caminho do arquivo
     * @returns true se o arquivo existir
     */
    async verificarArquivoExiste(caminhoArquivo) {
        // Em uma implementação real, chamaria o serviço de documento
        // return this.documentoService.verificarExistencia(caminhoArquivo);
        // Implementação de mock para desenvolvimento
        console.log(`[INTEGRAÇÃO] Verificando existência do arquivo: ${caminhoArquivo}`);
        // Simular que o arquivo existe
        return true;
    }
};
exports.IntegracaoDocumentoService = IntegracaoDocumentoService;
exports.IntegracaoDocumentoService = IntegracaoDocumentoService = __decorate([
    (0, common_1.Injectable)()
], IntegracaoDocumentoService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXHBhZ2FtZW50b1xcc2VydmljZXNcXGludGVncmFjYW8tZG9jdW1lbnRvLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQWlFO0FBQ2pFLDJDQUE2QjtBQUM3QiwrQ0FBaUM7QUFFakM7Ozs7Ozs7R0FPRztBQUVJLElBQU0sMEJBQTBCLEdBQWhDLE1BQU0sMEJBQTBCO0lBQ3JDLDhGQUE4RjtJQUM5RixzRUFBc0U7SUFFdEU7Ozs7Ozs7Ozs7T0FVRztJQUNILEtBQUssQ0FBQyxvQkFBb0IsQ0FDeEIsTUFBYyxFQUNkLFdBQW1CLEVBQ25CLFFBQWdCLEVBQ2hCLFdBQW1CLEVBQ25CLGFBQXFCLEVBQ3JCLFNBQWlCO1FBT2pCLG9CQUFvQjtRQUNwQixJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUV0QyxxQ0FBcUM7UUFDckMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUV2RSwyREFBMkQ7UUFDM0QsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXRFLDZEQUE2RDtRQUM3RCxxRUFBcUU7UUFDckUsc0JBQXNCO1FBQ3RCLDRCQUE0QjtRQUM1QixjQUFjO1FBQ2Qsd0NBQXdDO1FBQ3hDLDZCQUE2QjtRQUM3QiwrQkFBK0I7UUFDL0IsaUJBQWlCO1FBQ2pCLHFCQUFxQjtRQUNyQixZQUFZO1FBQ1osNkJBQTZCO1FBQzdCLE1BQU07UUFDTixNQUFNO1FBRU4sNkNBQTZDO1FBQzdDLE9BQU8sQ0FBQyxHQUFHLENBQ1Qs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QUN4RCxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSyxxQkFBcUIsQ0FDM0IsWUFBb0IsRUFDcEIsV0FBbUI7UUFFbkIsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzdCLE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFNUMsT0FBTyxHQUFHLFNBQVMsSUFBSSxZQUFZLEdBQUcsUUFBUSxFQUFFLENBQUM7SUFDbkQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLHNCQUFzQixDQUFDLGNBQXNCO1FBQ2pELDZEQUE2RDtRQUM3RCxvRUFBb0U7UUFFcEUsNkNBQTZDO1FBQzdDLE9BQU8sQ0FBQyxHQUFHLENBQ1QsbURBQW1ELGNBQWMsRUFBRSxDQUNwRSxDQUFDO1FBRUYsK0JBQStCO1FBQy9CLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztDQUNGLENBQUE7QUE5UFksZ0VBQTBCO3FDQUExQiwwQkFBMEI7SUFEdEMsSUFBQSxtQkFBVSxHQUFFO0dBQ0EsMEJBQTBCLENBOFB0QyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcbW9kdWxlc1xccGFnYW1lbnRvXFxzZXJ2aWNlc1xcaW50ZWdyYWNhby1kb2N1bWVudG8uc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBCYWRSZXF1ZXN0RXhjZXB0aW9uIH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG4vKipcbiAqIFNlcnZpw6dvIGRlIGludGVncmHDp8OjbyBjb20gbyBtw7NkdWxvIGRlIERvY3VtZW50b1xuICpcbiAqIEltcGxlbWVudGEgYSBjb211bmljYcOnw6NvIGVudHJlIG8gbcOzZHVsbyBkZSBQYWdhbWVudG8gZSBvIG3Ds2R1bG8gZGUgRG9jdW1lbnRvLFxuICogcGVybWl0aW5kbyBvIGFybWF6ZW5hbWVudG8gZSByZWN1cGVyYcOnw6NvIGRlIGNvbXByb3ZhbnRlcyBkZSBwYWdhbWVudG8uXG4gKlxuICogQGF1dGhvciBFcXVpcGUgUEdCZW5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEludGVncmFjYW9Eb2N1bWVudG9TZXJ2aWNlIHtcbiAgLy8gRW0gdW1hIGltcGxlbWVudGHDp8OjbyByZWFsLCBlc3RlIHNlcnZpw6dvIGluamV0YXJpYSBvIERvY3VtZW50b1NlcnZpY2UgZG8gbcOzZHVsbyBkZSBkb2N1bWVudG9cbiAgLy8gY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBkb2N1bWVudG9TZXJ2aWNlOiBEb2N1bWVudG9TZXJ2aWNlKSB7fVxuXG4gIC8qKlxuICAgKiBBcm1hemVuYSB1bSBjb21wcm92YW50ZSBkZSBwYWdhbWVudG9cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciBCdWZmZXIgY29tIG8gY29udGXDumRvIGRvIGFycXVpdm9cbiAgICogQHBhcmFtIG5vbWVBcnF1aXZvIE5vbWUgb3JpZ2luYWwgZG8gYXJxdWl2b1xuICAgKiBAcGFyYW0gbWltZVR5cGUgVGlwbyBNSU1FIGRvIGFycXVpdm9cbiAgICogQHBhcmFtIHBhZ2FtZW50b0lkIElEIGRvIHBhZ2FtZW50byByZWxhY2lvbmFkb1xuICAgKiBAcGFyYW0gdGlwb0RvY3VtZW50byBUaXBvIGRvIGRvY3VtZW50byAoY29tcHJvdmFudGUsIHJlY2libywgZXRjLilcbiAgICogQHBhcmFtIHVzdWFyaW9JZCBJRCBkbyB1c3XDoXJpbyBxdWUgZXN0w6EgcmVhbGl6YW5kbyBvIHVwbG9hZFxuICAgKiBAcmV0dXJucyBJbmZvcm1hw6fDtWVzIGRvIGRvY3VtZW50byBhcm1hemVuYWRvXG4gICAqL1xuICBhc3luYyBhcm1hemVuYXJDb21wcm92YW50ZShcbiAgICBidWZmZXI6IEJ1ZmZlcixcbiAgICBub21lQXJxdWl2bzogc3RyaW5nLFxuICAgIG1pbWVUeXBlOiBzdHJpbmcsXG4gICAgcGFnYW1lbnRvSWQ6IHN0cmluZyxcbiAgICB0aXBvRG9jdW1lbnRvOiBzdHJpbmcsXG4gICAgdXN1YXJpb0lkOiBzdHJpbmcsXG4gICk6IFByb21pc2U8e1xuICAgIGlkOiBzdHJpbmc7XG4gICAgY2FtaW5ob0FycXVpdm86IHN0cmluZztcbiAgICB0YW1hbmhvOiBudW1iZXI7XG4gICAgaGFzaDogc3RyaW5nO1xuICB9PiB7XG4gICAgLy8gVmFsaWRhciBvIGFycXVpdm9cbiAgICB0aGlzLnZhbGlkYXJBcnF1aXZvKGJ1ZmZlciwgbWltZVR5cGUpO1xuXG4gICAgLy8gR2VyYXIgdW0gbm9tZSDDum5pY28gcGFyYSBvIGFycXVpdm9cbiAgICBjb25zdCBub21lVW5pY28gPSB0aGlzLmdlcmFyTm9tZVVuaWNvQXJxdWl2byhub21lQXJxdWl2bywgcGFnYW1lbnRvSWQpO1xuXG4gICAgLy8gQ2FsY3VsYXIgaGFzaCBkbyBhcnF1aXZvIHBhcmEgdmVyaWZpY2HDp8OjbyBkZSBpbnRlZ3JpZGFkZVxuICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGJ1ZmZlcikuZGlnZXN0KCdoZXgnKTtcblxuICAgIC8vIEVtIHVtYSBpbXBsZW1lbnRhw6fDo28gcmVhbCwgY2hhbWFyaWEgbyBzZXJ2acOnbyBkZSBkb2N1bWVudG9cbiAgICAvLyBjb25zdCByZXN1bHRhZG8gPSBhd2FpdCB0aGlzLmRvY3VtZW50b1NlcnZpY2UuYXJtYXplbmFyRG9jdW1lbnRvKHtcbiAgICAvLyAgIGNvbnRldWRvOiBidWZmZXIsXG4gICAgLy8gICBub21lQXJxdWl2bzogbm9tZVVuaWNvLFxuICAgIC8vICAgbWltZVR5cGUsXG4gICAgLy8gICBjYXRlZ29yaWE6ICdDT01QUk9WQU5URV9QQUdBTUVOVE8nLFxuICAgIC8vICAgZW50aWRhZGVJZDogcGFnYW1lbnRvSWQsXG4gICAgLy8gICB0aXBvRW50aWRhZGU6ICdQQUdBTUVOVE8nLFxuICAgIC8vICAgbWV0YWRhZG9zOiB7XG4gICAgLy8gICAgIHRpcG9Eb2N1bWVudG8sXG4gICAgLy8gICAgIGhhc2gsXG4gICAgLy8gICAgIHVwbG9hZGVkUG9yOiB1c3VhcmlvSWRcbiAgICAvLyAgIH1cbiAgICAvLyB9KTtcblxuICAgIC8vIEltcGxlbWVudGHDp8OjbyBkZSBtb2NrIHBhcmEgZGVzZW52b2x2aW1lbnRvXG4gICAgY29uc29sZS5sb2coXG4gICAgICBgW0lOVEVHUkHDh8ODT10gQXJtYXplbmFuZG8gY29tcHJvdmFudGUgcGFyYSBvIHBhZ2FtZW50byAke3BhZ2FtZW50b0lkfWAsXG4gICAgKTtcblxuICAgIC8vIFNpbXVsYXIgY2FtaW5obyBkZSBhcm1hemVuYW1lbnRvXG4gICAgY29uc3QgY2FtaW5ob0FycXVpdm8gPSBgcGFnYW1lbnRvcy8ke3BhZ2FtZW50b0lkfS9jb21wcm92YW50ZXMvJHtub21lVW5pY299YDtcblxuICAgIHJldHVybiB7XG4gICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgIGNhbWluaG9BcnF1aXZvLFxuICAgICAgdGFtYW5obzogYnVmZmVyLmxlbmd0aCxcbiAgICAgIGhhc2gsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cGVyYSBvIGNvbnRlw7pkbyBkZSB1bSBjb21wcm92YW50ZSBkZSBwYWdhbWVudG9cbiAgICpcbiAgICogQHBhcmFtIGNhbWluaG9BcnF1aXZvIENhbWluaG8gZG8gYXJxdWl2byBubyBzaXN0ZW1hIGRlIGFybWF6ZW5hbWVudG9cbiAgICogQHBhcmFtIHVzdWFyaW9JZCBJRCBkbyB1c3XDoXJpbyBxdWUgZXN0w6Egc29saWNpdGFuZG8gbyBhcnF1aXZvXG4gICAqIEByZXR1cm5zIEJ1ZmZlciBjb20gbyBjb250ZcO6ZG8gZG8gYXJxdWl2byBlIG1ldGFkYWRvc1xuICAgKi9cbiAgYXN5bmMgcmVjdXBlcmFyQ29tcHJvdmFudGUoXG4gICAgY2FtaW5ob0FycXVpdm86IHN0cmluZyxcbiAgICB1c3VhcmlvSWQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTx7XG4gICAgYnVmZmVyOiBCdWZmZXI7XG4gICAgbm9tZUFycXVpdm86IHN0cmluZztcbiAgICBtaW1lVHlwZTogc3RyaW5nO1xuICAgIHRhbWFuaG86IG51bWJlcjtcbiAgfT4ge1xuICAgIC8vIEVtIHVtYSBpbXBsZW1lbnRhw6fDo28gcmVhbCwgY2hhbWFyaWEgbyBzZXJ2acOnbyBkZSBkb2N1bWVudG9cbiAgICAvLyBjb25zdCBkb2N1bWVudG8gPSBhd2FpdCB0aGlzLmRvY3VtZW50b1NlcnZpY2UucmVjdXBlcmFyRG9jdW1lbnRvKGNhbWluaG9BcnF1aXZvLCB1c3VhcmlvSWQpO1xuXG4gICAgLy8gUmVnaXN0cmFyIGFjZXNzbyBhbyBkb2N1bWVudG9cbiAgICAvLyBhd2FpdCB0aGlzLmRvY3VtZW50b1NlcnZpY2UucmVnaXN0cmFyQWNlc3NvKHtcbiAgICAvLyAgIGNhbWluaG9BcnF1aXZvLFxuICAgIC8vICAgdXN1YXJpb0lkLFxuICAgIC8vICAgdGlwb0FjZXNzbzogJ0RPV05MT0FEJyxcbiAgICAvLyAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxuICAgIC8vIH0pO1xuXG4gICAgLy8gcmV0dXJuIHtcbiAgICAvLyAgIGJ1ZmZlcjogZG9jdW1lbnRvLmNvbnRldWRvLFxuICAgIC8vICAgbm9tZUFycXVpdm86IGRvY3VtZW50by5ub21lT3JpZ2luYWwsXG4gICAgLy8gICBtaW1lVHlwZTogZG9jdW1lbnRvLm1pbWVUeXBlLFxuICAgIC8vICAgdGFtYW5obzogZG9jdW1lbnRvLnRhbWFuaG9cbiAgICAvLyB9O1xuXG4gICAgLy8gSW1wbGVtZW50YcOnw6NvIGRlIG1vY2sgcGFyYSBkZXNlbnZvbHZpbWVudG9cbiAgICBjb25zb2xlLmxvZyhgW0lOVEVHUkHDh8ODT10gUmVjdXBlcmFuZG8gY29tcHJvdmFudGU6ICR7Y2FtaW5ob0FycXVpdm99YCk7XG5cbiAgICAvLyBFeHRyYWlyIG5vbWUgZG8gYXJxdWl2byBkbyBjYW1pbmhvXG4gICAgY29uc3Qgbm9tZUFycXVpdm8gPSBwYXRoLmJhc2VuYW1lKGNhbWluaG9BcnF1aXZvKTtcblxuICAgIC8vIENyaWFyIHVtIGJ1ZmZlciB2YXppbyBwYXJhIHNpbXVsYcOnw6NvXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oJ0NvbnRlw7pkbyBzaW11bGFkbyBkbyBhcnF1aXZvIGRlIGNvbXByb3ZhbnRlJyk7XG5cbiAgICAvLyBEZXRlcm1pbmFyIG8gTUlNRSB0eXBlIGJhc2VhZG8gbmEgZXh0ZW5zw6NvXG4gICAgY29uc3QgZXh0ZW5zYW8gPSBwYXRoLmV4dG5hbWUobm9tZUFycXVpdm8pLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IG1pbWVUeXBlID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG5cbiAgICBpZiAoZXh0ZW5zYW8gPT09ICcucGRmJykge1xuICAgICAgbWltZVR5cGUgPSAnYXBwbGljYXRpb24vcGRmJztcbiAgICB9IGVsc2UgaWYgKGV4dGVuc2FvID09PSAnLmpwZycgfHwgZXh0ZW5zYW8gPT09ICcuanBlZycpIHtcbiAgICAgIG1pbWVUeXBlID0gJ2ltYWdlL2pwZWcnO1xuICAgIH0gZWxzZSBpZiAoZXh0ZW5zYW8gPT09ICcucG5nJykge1xuICAgICAgbWltZVR5cGUgPSAnaW1hZ2UvcG5nJztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYnVmZmVyLFxuICAgICAgbm9tZUFycXVpdm8sXG4gICAgICBtaW1lVHlwZSxcbiAgICAgIHRhbWFuaG86IGJ1ZmZlci5sZW5ndGgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdW0gY29tcHJvdmFudGUgZGUgcGFnYW1lbnRvXG4gICAqXG4gICAqIEBwYXJhbSBjYW1pbmhvQXJxdWl2byBDYW1pbmhvIGRvIGFycXVpdm8gbm8gc2lzdGVtYSBkZSBhcm1hemVuYW1lbnRvXG4gICAqIEBwYXJhbSB1c3VhcmlvSWQgSUQgZG8gdXN1w6FyaW8gcXVlIGVzdMOhIHNvbGljaXRhbmRvIGEgcmVtb8Onw6NvXG4gICAqIEByZXR1cm5zIHRydWUgc2UgcmVtb3ZpZG8gY29tIHN1Y2Vzc29cbiAgICovXG4gIGFzeW5jIHJlbW92ZXJDb21wcm92YW50ZShcbiAgICBjYW1pbmhvQXJxdWl2bzogc3RyaW5nLFxuICAgIHVzdWFyaW9JZDogc3RyaW5nLFxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAvLyBFbSB1bWEgaW1wbGVtZW50YcOnw6NvIHJlYWwsIGNoYW1hcmlhIG8gc2VydmnDp28gZGUgZG9jdW1lbnRvXG4gICAgLy8gYXdhaXQgdGhpcy5kb2N1bWVudG9TZXJ2aWNlLnJlbW92ZXJEb2N1bWVudG8oY2FtaW5ob0FycXVpdm8sIHVzdWFyaW9JZCk7XG5cbiAgICAvLyBSZWdpc3RyYXIgcmVtb8Onw6NvIGRvIGRvY3VtZW50b1xuICAgIC8vIGF3YWl0IHRoaXMuZG9jdW1lbnRvU2VydmljZS5yZWdpc3RyYXJPcGVyYWNhbyh7XG4gICAgLy8gICBjYW1pbmhvQXJxdWl2byxcbiAgICAvLyAgIHVzdWFyaW9JZCxcbiAgICAvLyAgIHRpcG9PcGVyYWNhbzogJ1JFTU9DQU8nLFxuICAgIC8vICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgLy8gfSk7XG5cbiAgICAvLyByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIEltcGxlbWVudGHDp8OjbyBkZSBtb2NrIHBhcmEgZGVzZW52b2x2aW1lbnRvXG4gICAgY29uc29sZS5sb2coYFtJTlRFR1JBw4fDg09dIFJlbW92ZW5kbyBjb21wcm92YW50ZTogJHtjYW1pbmhvQXJxdWl2b31gKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYSB1bSBhcnF1aXZvIGFudGVzIGRvIGFybWF6ZW5hbWVudG9cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciBDb250ZcO6ZG8gZG8gYXJxdWl2b1xuICAgKiBAcGFyYW0gbWltZVR5cGUgVGlwbyBNSU1FIGRlY2xhcmFkb1xuICAgKiBAdGhyb3dzIEJhZFJlcXVlc3RFeGNlcHRpb24gc2UgbyBhcnF1aXZvIGZvciBpbnbDoWxpZG9cbiAgICovXG4gIHByaXZhdGUgdmFsaWRhckFycXVpdm8oYnVmZmVyOiBCdWZmZXIsIG1pbWVUeXBlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBWZXJpZmljYXIgdGFtYW5obyBtw6F4aW1vICg1TUIpXG4gICAgY29uc3QgdGFtYW5ob01heGltbyA9IDUgKiAxMDI0ICogMTAyNDtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IHRhbWFuaG9NYXhpbW8pIHtcbiAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKFxuICAgICAgICBgVGFtYW5obyBkbyBhcnF1aXZvIGV4Y2VkZSBvIGxpbWl0ZSBtw6F4aW1vIGRlICR7dGFtYW5ob01heGltbyAvICgxMDI0ICogMTAyNCl9TUJgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZmljYXIgdGlwb3MgTUlNRSBwZXJtaXRpZG9zXG4gICAgY29uc3QgdGlwb3NQZXJtaXRpZG9zID0gW1xuICAgICAgJ2FwcGxpY2F0aW9uL3BkZicsXG4gICAgICAnaW1hZ2UvanBlZycsXG4gICAgICAnaW1hZ2UvanBnJyxcbiAgICAgICdpbWFnZS9wbmcnLFxuICAgIF07XG5cbiAgICBpZiAoIXRpcG9zUGVybWl0aWRvcy5pbmNsdWRlcyhtaW1lVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKFxuICAgICAgICBgVGlwbyBkZSBhcnF1aXZvIG7Do28gcGVybWl0aWRvLiBUaXBvcyBwZXJtaXRpZG9zOiAke3RpcG9zUGVybWl0aWRvcy5qb2luKCcsICcpfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFZlcmlmaWNhw6fDo28gYsOhc2ljYSBkZSBhc3NpbmF0dXJhIGRlIGFycXVpdm8gKG1hZ2ljIGJ5dGVzKVxuICAgIC8vIEVzdGEgw6kgdW1hIHZlcmlmaWNhw6fDo28gc2ltcGxpZmljYWRhLCBlbSBwcm9kdcOnw6NvIHNlcmlhIG1haXMgcm9idXN0YVxuICAgIGlmIChtaW1lVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3BkZicgJiYgYnVmZmVyLmxlbmd0aCA+PSA0KSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBidWZmZXIuc2xpY2UoMCwgNCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgaWYgKHNpZ25hdHVyZSAhPT0gJzI1NTA0NDQ2Jykge1xuICAgICAgICAvLyAlUERGIGVtIGhleFxuICAgICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEV4Y2VwdGlvbignQXJxdWl2byBQREYgaW52w6FsaWRvJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pbWVUeXBlID09PSAnaW1hZ2UvanBlZycgJiYgYnVmZmVyLmxlbmd0aCA+PSAzKSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBidWZmZXIuc2xpY2UoMCwgMykudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgaWYgKHNpZ25hdHVyZSAhPT0gJ2ZmZDhmZicpIHtcbiAgICAgICAgLy8gSlBFRyBTT0kgbWFya2VyXG4gICAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKCdBcnF1aXZvIEpQRUcgaW52w6FsaWRvJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pbWVUeXBlID09PSAnaW1hZ2UvcG5nJyAmJiBidWZmZXIubGVuZ3RoID49IDgpIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJ1ZmZlci5zbGljZSgwLCA4KS50b1N0cmluZygnaGV4Jyk7XG4gICAgICBpZiAoc2lnbmF0dXJlICE9PSAnODk1MDRlNDcwZDBhMWEwYScpIHtcbiAgICAgICAgLy8gUE5HIHNpZ25hdHVyZVxuICAgICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEV4Y2VwdGlvbignQXJxdWl2byBQTkcgaW52w6FsaWRvJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlcmEgdW0gbm9tZSDDum5pY28gcGFyYSBvIGFycXVpdm9cbiAgICpcbiAgICogQHBhcmFtIG5vbWVPcmlnaW5hbCBOb21lIG9yaWdpbmFsIGRvIGFycXVpdm9cbiAgICogQHBhcmFtIHBhZ2FtZW50b0lkIElEIGRvIHBhZ2FtZW50byByZWxhY2lvbmFkb1xuICAgKiBAcmV0dXJucyBOb21lIMO6bmljbyBwYXJhIGFybWF6ZW5hbWVudG9cbiAgICovXG4gIHByaXZhdGUgZ2VyYXJOb21lVW5pY29BcnF1aXZvKFxuICAgIG5vbWVPcmlnaW5hbDogc3RyaW5nLFxuICAgIHBhZ2FtZW50b0lkOiBzdHJpbmcsXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCByYW5kb21TdHJpbmcgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoOCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IGV4dGVuc2FvID0gcGF0aC5leHRuYW1lKG5vbWVPcmlnaW5hbCk7XG5cbiAgICByZXR1cm4gYCR7dGltZXN0YW1wfS0ke3JhbmRvbVN0cmluZ30ke2V4dGVuc2FvfWA7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgdW0gYXJxdWl2byBleGlzdGUgbm8gc2lzdGVtYSBkZSBhcm1hemVuYW1lbnRvXG4gICAqXG4gICAqIEBwYXJhbSBjYW1pbmhvQXJxdWl2byBDYW1pbmhvIGRvIGFycXVpdm9cbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIGFycXVpdm8gZXhpc3RpclxuICAgKi9cbiAgYXN5bmMgdmVyaWZpY2FyQXJxdWl2b0V4aXN0ZShjYW1pbmhvQXJxdWl2bzogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gRW0gdW1hIGltcGxlbWVudGHDp8OjbyByZWFsLCBjaGFtYXJpYSBvIHNlcnZpw6dvIGRlIGRvY3VtZW50b1xuICAgIC8vIHJldHVybiB0aGlzLmRvY3VtZW50b1NlcnZpY2UudmVyaWZpY2FyRXhpc3RlbmNpYShjYW1pbmhvQXJxdWl2byk7XG5cbiAgICAvLyBJbXBsZW1lbnRhw6fDo28gZGUgbW9jayBwYXJhIGRlc2Vudm9sdmltZW50b1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYFtJTlRFR1JBw4fDg09dIFZlcmlmaWNhbmRvIGV4aXN0w6puY2lhIGRvIGFycXVpdm86ICR7Y2FtaW5ob0FycXVpdm99YCxcbiAgICApO1xuXG4gICAgLy8gU2ltdWxhciBxdWUgbyBhcnF1aXZvIGV4aXN0ZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iXSwidmVyc2lvbiI6M30=