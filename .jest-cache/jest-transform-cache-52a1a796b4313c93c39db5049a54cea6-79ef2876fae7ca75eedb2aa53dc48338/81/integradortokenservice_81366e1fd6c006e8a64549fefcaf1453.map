{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\integrador\\services\\integrador-token.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\integrador\\services\\integrador-token.service.ts"],"sourcesContent":["import { Injectable, NotFoundException, BadRequestException, UnauthorizedException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { JwtService } from '@nestjs/jwt';\nimport * as crypto from 'crypto';\nimport { IntegradorToken, TokenRevogado } from '../../../entities';\nimport { CreateTokenDto } from '../dto/create-token.dto';\nimport { TokenResponseDto } from '../dto/token-response.dto';\nimport { IntegradorService } from './integrador.service';\n\n/**\n * Serviço responsável pelo gerenciamento de tokens de acesso para integradores.\n * Implementa funcionalidades de geração, validação, revogação e consulta de tokens.\n */\n@Injectable()\nexport class IntegradorTokenService {\n  constructor(\n    @InjectRepository(IntegradorToken)\n    private tokenRepository: Repository<IntegradorToken>,\n    \n    @InjectRepository(TokenRevogado)\n    private tokenRevogadoRepository: Repository<TokenRevogado>,\n    \n    private integradorService: IntegradorService,\n    private jwtService: JwtService,\n  ) {}\n\n  /**\n   * Gera um hash seguro de um token.\n   * @param token Token a ser convertido em hash\n   * @returns Hash do token\n   */\n  private generateTokenHash(token: string): string {\n    return crypto.createHash('sha256').update(token).digest('hex');\n  }\n\n  /**\n   * Cria um novo token para um integrador.\n   * @param integradorId ID do integrador\n   * @param createTokenDto Dados para criação do token\n   * @returns Token gerado e informações associadas\n   */\n  async createToken(\n    integradorId: string, \n    createTokenDto: CreateTokenDto\n  ): Promise<{ token: string; tokenInfo: TokenResponseDto }> {\n    // Verificar se o integrador existe e está ativo\n    const integrador = await this.integradorService.findById(integradorId);\n    \n    if (!integrador.ativo) {\n      throw new BadRequestException('Não é possível criar token para um integrador inativo');\n    }\n\n    // Validar escopos solicitados\n    if (createTokenDto.escopos && createTokenDto.escopos.length > 0) {\n      // Se o integrador tem permissões definidas, verificar se todos os escopos solicitados são permitidos\n      if (integrador.permissoesEscopo && integrador.permissoesEscopo.length > 0) {\n        const escoposNaoPermitidos = createTokenDto.escopos.filter(\n          escopo => !integrador.permissoesEscopo.includes(escopo)\n        );\n        \n        if (escoposNaoPermitidos.length > 0) {\n          throw new BadRequestException(\n            `Escopos não permitidos para este integrador: ${escoposNaoPermitidos.join(', ')}`\n          );\n        }\n      }\n    }\n\n    // Configurar expiração (se aplicável)\n    let dataExpiracao: Date | null = null;\n    let expiresIn: string | undefined = undefined;\n    \n    if (!createTokenDto.semExpiracao && createTokenDto.diasValidade) {\n      dataExpiracao = new Date();\n      dataExpiracao.setDate(dataExpiracao.getDate() + createTokenDto.diasValidade);\n      expiresIn = `${createTokenDto.diasValidade}d`;\n    }\n\n    // Criar payload do JWT\n    const payload = {\n      sub: `integrador:${integradorId}`,\n      name: integrador.nome,\n      type: 'api_token',\n      scopes: createTokenDto.escopos || [],\n    };\n\n    // Gerar o token JWT\n    const tokenOptions: any = {};\n    if (expiresIn) {\n      tokenOptions.expiresIn = expiresIn;\n    }\n    \n    const token = this.jwtService.sign(payload, tokenOptions);\n    const tokenHash = this.generateTokenHash(token);\n\n    // Criar registro do token no banco\n    const tokenEntity = this.tokenRepository.create({\n      integrador: { id: integradorId }, // Usando o relacionamento\n      nome: createTokenDto.nome,\n      descricao: createTokenDto.descricao,\n      tokenHash,\n      escopos: createTokenDto.escopos,\n      dataExpiracao: dataExpiracao || undefined // Garante que seja undefined se for null\n    });\n\n    const savedToken = await this.tokenRepository.save(tokenEntity);\n    \n    return {\n      token, // O token JWT completo - só será exposto uma vez\n      tokenInfo: new TokenResponseDto(savedToken)\n    };\n  }\n\n  /**\n   * Obtém todos os tokens associados a um integrador.\n   * @param integradorId ID do integrador\n   * @returns Lista de tokens\n   */\n  async findAllByIntegrador(integradorId: string): Promise<TokenResponseDto[]> {\n    // Verificar se o integrador existe\n    await this.integradorService.findById(integradorId);\n    \n    const tokens = await this.tokenRepository.find({ \n      where: { integradorId },\n      order: { dataCriacao: 'DESC' }\n    });\n    \n    return tokens.map(token => new TokenResponseDto(token));\n  }\n\n  /**\n   * Obtém informações de um token específico.\n   * @param id ID do token\n   * @returns Informações do token\n   */\n  async findOne(id: string): Promise<TokenResponseDto> {\n    const token = await this.tokenRepository.findOne({ where: { id } });\n    \n    if (!token) {\n      throw new NotFoundException(`Token com ID ${id} não encontrado`);\n    }\n    \n    return new TokenResponseDto(token);\n  }\n\n  /**\n   * Revoga um token.\n   * @param id ID do token\n   * @param motivo Motivo da revogação\n   * @returns Informações do token revogado\n   */\n  async revogarToken(id: string, motivo: string): Promise<TokenResponseDto> {\n    const token = await this.tokenRepository.findOne({ where: { id } });\n    \n    if (!token) {\n      throw new NotFoundException(`Token com ID ${id} não encontrado`);\n    }\n    \n    if (token.revogado) {\n      throw new BadRequestException('Token já está revogado');\n    }\n\n    // Atualizar o registro do token\n    token.revogado = true;\n    token.dataRevogacao = new Date();\n    token.motivoRevogacao = motivo;\n    \n    const updatedToken = await this.tokenRepository.save(token);\n\n    // Adicionar à lista de tokens revogados para validação rápida\n    const tokenRevogado = this.tokenRevogadoRepository.create({\n      tokenHash: token.tokenHash,\n      integradorId: token.integradorId,\n      motivoRevogacao: motivo,\n      dataExpiracao: token.dataExpiracao,\n      // Configura a data para remoção do registro da lista de revogados\n      // (para depois da expiração natural, ou um período padrão se não expirar)\n      dataLimpeza: token.dataExpiracao || new Date(Date.now() + 1000 * 60 * 60 * 24 * 90) // 90 dias se não tiver expiração\n    });\n    \n    await this.tokenRevogadoRepository.save(tokenRevogado);\n    \n    return new TokenResponseDto(updatedToken);\n  }\n\n  /**\n   * Valida um token e retorna suas informações.\n   * @param token Token JWT a ser validado\n   * @returns Payload decodificado se válido\n   * @throws UnauthorizedException se o token for inválido\n   */\n  async validateToken(token: string): Promise<any> {\n    try {\n      // Verificar assinatura do token\n      const payload = this.jwtService.verify(token);\n      \n      // Verificar tipo de token\n      if (payload.type !== 'api_token') {\n        throw new UnauthorizedException('Tipo de token inválido');\n      }\n      \n      // Extrair ID do integrador do subject\n      const subParts = payload.sub.split(':');\n      if (subParts.length !== 2 || subParts[0] !== 'integrador') {\n        throw new UnauthorizedException('Formato de token inválido');\n      }\n      \n      const integradorId = subParts[1];\n      \n      // Verificar se o token foi revogado\n      const tokenHash = this.generateTokenHash(token);\n      const tokenRevogado = await this.tokenRevogadoRepository.findOne({\n        where: { tokenHash }\n      });\n      \n      if (tokenRevogado) {\n        throw new UnauthorizedException('Token revogado');\n      }\n      \n      // Verificar se o integrador existe e está ativo\n      const integrador = await this.integradorService.findById(integradorId);\n      if (!integrador.ativo) {\n        throw new UnauthorizedException('Integrador desativado');\n      }\n      \n      // Registrar o último acesso\n      await this.integradorService.registrarAcesso(integradorId);\n      \n      // Buscar o token no banco para atualizar último uso\n      const tokenInfo = await this.tokenRepository.findOne({\n        where: { tokenHash }\n      });\n      \n      if (tokenInfo) {\n        tokenInfo.ultimoUso = new Date();\n        await this.tokenRepository.save(tokenInfo);\n      }\n      \n      // Adicionar integrador ao payload para uso posterior\n      return {\n        ...payload,\n        integrador\n      };\n    } catch (error) {\n      throw new UnauthorizedException('Token inválido: ' + (error.message || 'erro desconhecido'));\n    }\n  }\n\n  /**\n   * Verifica se um token tem as permissões necessárias.\n   * @param payload Payload do token já validado\n   * @param requiredScopes Escopos requeridos\n   * @returns True se o token tiver todos os escopos necessários\n   */\n  hasRequiredScopes(payload: any, requiredScopes: string[]): boolean {\n    if (!requiredScopes || requiredScopes.length === 0) {\n      return true;\n    }\n    \n    if (!payload.scopes || payload.scopes.length === 0) {\n      return false;\n    }\n    \n    // Verificar se o token possui todos os escopos necessários\n    return requiredScopes.every(requiredScope => \n      payload.scopes.includes(requiredScope)\n    );\n  }\n\n  /**\n   * Verifica se um acesso está permitido por restrição de IP.\n   * @param integrador Objeto do integrador\n   * @param ipAddress Endereço IP de origem da requisição\n   * @returns True se o acesso for permitido\n   */\n  isIpAllowed(integrador: any, ipAddress: string): boolean {\n    // Se não houver restrições de IP, permitir acesso\n    if (!integrador.ipPermitidos || integrador.ipPermitidos.length === 0) {\n      return true;\n    }\n    \n    // Verificar se o IP está na lista de permitidos\n    return integrador.ipPermitidos.includes(ipAddress);\n  }\n\n  /**\n   * Limpa tokens revogados antigos da lista de revogação.\n   * Esta função pode ser executada periodicamente para manter a tabela otimizada.\n   */\n  async limparTokensRevogadosExpirados(): Promise<number> {\n    const result = await this.tokenRevogadoRepository\n      .createQueryBuilder()\n      .delete()\n      .from(TokenRevogado)\n      .where('dataLimpeza < :now', { now: new Date() })\n      .execute();\n      \n    return result.affected || 0;\n  }\n}\n"],"version":3}