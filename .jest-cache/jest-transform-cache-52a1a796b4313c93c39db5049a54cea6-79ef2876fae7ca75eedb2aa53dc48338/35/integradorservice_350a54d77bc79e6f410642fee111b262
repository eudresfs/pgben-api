ed78be67da3bd19b772acbc87081e3c9
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntegradorService = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const integrador_entity_1 = require("../../../entities/integrador.entity");
const integrador_response_dto_1 = require("../dto/integrador-response.dto");
/**
 * Serviço responsável pelo gerenciamento de integradores.
 * Implementa operações CRUD e regras de negócio específicas para integradores.
 */
let IntegradorService = class IntegradorService {
    integradorRepository;
    constructor(integradorRepository) {
        this.integradorRepository = integradorRepository;
    }
    /**
     * Cria um novo integrador na plataforma.
     * @param createIntegradorDto Dados do integrador a ser criado
     * @returns Dados do integrador criado
     */
    async create(createIntegradorDto) {
        // Verifica se já existe um integrador com o mesmo nome
        const existingIntegrador = await this.integradorRepository.findOne({
            where: { nome: createIntegradorDto.nome }
        });
        if (existingIntegrador) {
            throw new common_1.ConflictException(`Já existe um integrador com o nome '${createIntegradorDto.nome}'`);
        }
        const integrador = this.integradorRepository.create(createIntegradorDto);
        const savedIntegrador = await this.integradorRepository.save(integrador);
        return new integrador_response_dto_1.IntegradorResponseDto(savedIntegrador);
    }
    /**
     * Retorna todos os integradores cadastrados.
     * @returns Lista de integradores
     */
    async findAll() {
        const integradores = await this.integradorRepository.find();
        return integradores.map(integrador => new integrador_response_dto_1.IntegradorResponseDto(integrador));
    }
    /**
     * Busca um integrador pelo seu ID.
     * @param id ID do integrador
     * @returns Dados do integrador encontrado
     * @throws NotFoundException se o integrador não for encontrado
     */
    async findById(id) {
        const integrador = await this.integradorRepository.findOne({ where: { id } });
        if (!integrador) {
            throw new common_1.NotFoundException(`Integrador com ID ${id} não encontrado`);
        }
        return integrador;
    }
    /**
     * Obtém um integrador pelo ID e retorna com o formato de resposta padronizado.
     * @param id ID do integrador
     * @returns Dados do integrador no formato de resposta
     */
    async findOne(id) {
        const integrador = await this.findById(id);
        return new integrador_response_dto_1.IntegradorResponseDto(integrador);
    }
    /**
     * Atualiza os dados de um integrador.
     * @param id ID do integrador a ser atualizado
     * @param updateIntegradorDto Dados a serem atualizados
     * @returns Dados do integrador atualizado
     */
    async update(id, updateIntegradorDto) {
        // Verifica se o integrador existe
        const integrador = await this.findById(id);
        // Se o nome estiver sendo alterado, verifica se já existe outro com o mesmo nome
        if (updateIntegradorDto.nome && updateIntegradorDto.nome !== integrador.nome) {
            const existingIntegrador = await this.integradorRepository.findOne({
                where: { nome: updateIntegradorDto.nome }
            });
            if (existingIntegrador) {
                throw new common_1.ConflictException(`Já existe um integrador com o nome '${updateIntegradorDto.nome}'`);
            }
        }
        // Atualiza os dados
        Object.assign(integrador, updateIntegradorDto);
        const updatedIntegrador = await this.integradorRepository.save(integrador);
        return new integrador_response_dto_1.IntegradorResponseDto(updatedIntegrador);
    }
    /**
     * Remove um integrador do sistema.
     * @param id ID do integrador a ser removido
     */
    async remove(id) {
        const integrador = await this.findById(id);
        await this.integradorRepository.remove(integrador);
    }
    /**
     * Ativa ou desativa um integrador.
     * @param id ID do integrador
     * @param ativo Novo status de ativação
     * @returns Dados do integrador atualizado
     */
    async toggleAtivo(id, ativo) {
        const integrador = await this.findById(id);
        integrador.ativo = ativo;
        const updatedIntegrador = await this.integradorRepository.save(integrador);
        return new integrador_response_dto_1.IntegradorResponseDto(updatedIntegrador);
    }
    /**
     * Registra um acesso do integrador à API.
     * @param id ID do integrador
     */
    async registrarAcesso(id) {
        await this.integradorRepository.update({ id }, { ultimoAcesso: new Date() });
    }
};
exports.IntegradorService = IntegradorService;
exports.IntegradorService = IntegradorService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(integrador_entity_1.Integrador)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], IntegradorService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXGludGVncmFkb3JcXHNlcnZpY2VzXFxpbnRlZ3JhZG9yLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUFrRjtBQUNsRiw2Q0FBbUQ7QUFDbkQscUNBQXFDO0FBQ3JDLDJFQUFpRTtBQUdqRSw0RUFBdUU7QUFFdkU7OztHQUdHO0FBRUksSUFBTSxpQkFBaUIsR0FBdkIsTUFBTSxpQkFBaUI7SUFHbEI7SUFGVixZQUVVLG9CQUE0QztRQUE1Qyx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXdCO0lBQ25ELENBQUM7SUFFSjs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLE1BQU0sQ0FBQyxtQkFBd0M7UUFDbkQsdURBQXVEO1FBQ3ZELE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDO1lBQ2pFLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxtQkFBbUIsQ0FBQyxJQUFJLEVBQUU7U0FDMUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxrQkFBa0IsRUFBRSxDQUFDO1lBQ3ZCLE1BQU0sSUFBSSwwQkFBaUIsQ0FBQyx1Q0FBdUMsbUJBQW1CLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztRQUNsRyxDQUFDO1FBRUQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ3pFLE1BQU0sZUFBZSxHQUFHLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUV6RSxPQUFPLElBQUksK0NBQXFCLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxPQUFPO1FBQ1gsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDNUQsT0FBTyxZQUFZLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSwrQ0FBcUIsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBVTtRQUN2QixNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFOUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ2hCLE1BQU0sSUFBSSwwQkFBaUIsQ0FBQyxxQkFBcUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQ3hFLENBQUM7UUFFRCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBVTtRQUN0QixNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDM0MsT0FBTyxJQUFJLCtDQUFxQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBVSxFQUFFLG1CQUF3QztRQUMvRCxrQ0FBa0M7UUFDbEMsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRTNDLGlGQUFpRjtRQUNqRixJQUFJLG1CQUFtQixDQUFDLElBQUksSUFBSSxtQkFBbUIsQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQzdFLE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDO2dCQUNqRSxLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsbUJBQW1CLENBQUMsSUFBSSxFQUFFO2FBQzFDLENBQUMsQ0FBQztZQUVILElBQUksa0JBQWtCLEVBQUUsQ0FBQztnQkFDdkIsTUFBTSxJQUFJLDBCQUFpQixDQUFDLHVDQUF1QyxtQkFBbUIsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1lBQ2xHLENBQUM7UUFDSCxDQUFDO1FBRUQsb0JBQW9CO1FBQ3BCLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLG1CQUFtQixDQUFDLENBQUM7UUFDL0MsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFM0UsT0FBTyxJQUFJLCtDQUFxQixDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBVTtRQUNyQixNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDM0MsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBVSxFQUFFLEtBQWM7UUFDMUMsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzNDLFVBQVUsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ3pCLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTNFLE9BQU8sSUFBSSwrQ0FBcUIsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsZUFBZSxDQUFDLEVBQVU7UUFDOUIsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUNwQyxFQUFFLEVBQUUsRUFBRSxFQUNOLEVBQUUsWUFBWSxFQUFFLElBQUksSUFBSSxFQUFFLEVBQUUsQ0FDN0IsQ0FBQztJQUNKLENBQUM7Q0FDRixDQUFBO0FBM0hZLDhDQUFpQjs0QkFBakIsaUJBQWlCO0lBRDdCLElBQUEsbUJBQVUsR0FBRTtJQUdSLFdBQUEsSUFBQSwwQkFBZ0IsRUFBQyw4QkFBVSxDQUFDLENBQUE7eURBQ0Msb0JBQVUsb0JBQVYsb0JBQVU7R0FIL0IsaUJBQWlCLENBMkg3QiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcbW9kdWxlc1xcaW50ZWdyYWRvclxcc2VydmljZXNcXGludGVncmFkb3Iuc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBOb3RGb3VuZEV4Y2VwdGlvbiwgQ29uZmxpY3RFeGNlcHRpb24gfSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3RSZXBvc2l0b3J5IH0gZnJvbSAnQG5lc3Rqcy90eXBlb3JtJztcbmltcG9ydCB7IFJlcG9zaXRvcnkgfSBmcm9tICd0eXBlb3JtJztcbmltcG9ydCB7IEludGVncmFkb3IgfSBmcm9tICcuLi8uLi8uLi9lbnRpdGllcy9pbnRlZ3JhZG9yLmVudGl0eSc7XG5pbXBvcnQgeyBDcmVhdGVJbnRlZ3JhZG9yRHRvIH0gZnJvbSAnLi4vZHRvL2NyZWF0ZS1pbnRlZ3JhZG9yLmR0byc7XG5pbXBvcnQgeyBVcGRhdGVJbnRlZ3JhZG9yRHRvIH0gZnJvbSAnLi4vZHRvL3VwZGF0ZS1pbnRlZ3JhZG9yLmR0byc7XG5pbXBvcnQgeyBJbnRlZ3JhZG9yUmVzcG9uc2VEdG8gfSBmcm9tICcuLi9kdG8vaW50ZWdyYWRvci1yZXNwb25zZS5kdG8nO1xuXG4vKipcbiAqIFNlcnZpw6dvIHJlc3BvbnPDoXZlbCBwZWxvIGdlcmVuY2lhbWVudG8gZGUgaW50ZWdyYWRvcmVzLlxuICogSW1wbGVtZW50YSBvcGVyYcOnw7VlcyBDUlVEIGUgcmVncmFzIGRlIG5lZ8OzY2lvIGVzcGVjw61maWNhcyBwYXJhIGludGVncmFkb3Jlcy5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEludGVncmFkb3JTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdFJlcG9zaXRvcnkoSW50ZWdyYWRvcilcbiAgICBwcml2YXRlIGludGVncmFkb3JSZXBvc2l0b3J5OiBSZXBvc2l0b3J5PEludGVncmFkb3I+LFxuICApIHt9XG5cbiAgLyoqXG4gICAqIENyaWEgdW0gbm92byBpbnRlZ3JhZG9yIG5hIHBsYXRhZm9ybWEuXG4gICAqIEBwYXJhbSBjcmVhdGVJbnRlZ3JhZG9yRHRvIERhZG9zIGRvIGludGVncmFkb3IgYSBzZXIgY3JpYWRvXG4gICAqIEByZXR1cm5zIERhZG9zIGRvIGludGVncmFkb3IgY3JpYWRvXG4gICAqL1xuICBhc3luYyBjcmVhdGUoY3JlYXRlSW50ZWdyYWRvckR0bzogQ3JlYXRlSW50ZWdyYWRvckR0byk6IFByb21pc2U8SW50ZWdyYWRvclJlc3BvbnNlRHRvPiB7XG4gICAgLy8gVmVyaWZpY2Egc2UgasOhIGV4aXN0ZSB1bSBpbnRlZ3JhZG9yIGNvbSBvIG1lc21vIG5vbWVcbiAgICBjb25zdCBleGlzdGluZ0ludGVncmFkb3IgPSBhd2FpdCB0aGlzLmludGVncmFkb3JSZXBvc2l0b3J5LmZpbmRPbmUoeyBcbiAgICAgIHdoZXJlOiB7IG5vbWU6IGNyZWF0ZUludGVncmFkb3JEdG8ubm9tZSB9IFxuICAgIH0pO1xuICAgIFxuICAgIGlmIChleGlzdGluZ0ludGVncmFkb3IpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdEV4Y2VwdGlvbihgSsOhIGV4aXN0ZSB1bSBpbnRlZ3JhZG9yIGNvbSBvIG5vbWUgJyR7Y3JlYXRlSW50ZWdyYWRvckR0by5ub21lfSdgKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRlZ3JhZG9yID0gdGhpcy5pbnRlZ3JhZG9yUmVwb3NpdG9yeS5jcmVhdGUoY3JlYXRlSW50ZWdyYWRvckR0byk7XG4gICAgY29uc3Qgc2F2ZWRJbnRlZ3JhZG9yID0gYXdhaXQgdGhpcy5pbnRlZ3JhZG9yUmVwb3NpdG9yeS5zYXZlKGludGVncmFkb3IpO1xuICAgIFxuICAgIHJldHVybiBuZXcgSW50ZWdyYWRvclJlc3BvbnNlRHRvKHNhdmVkSW50ZWdyYWRvcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0b3JuYSB0b2RvcyBvcyBpbnRlZ3JhZG9yZXMgY2FkYXN0cmFkb3MuXG4gICAqIEByZXR1cm5zIExpc3RhIGRlIGludGVncmFkb3Jlc1xuICAgKi9cbiAgYXN5bmMgZmluZEFsbCgpOiBQcm9taXNlPEludGVncmFkb3JSZXNwb25zZUR0b1tdPiB7XG4gICAgY29uc3QgaW50ZWdyYWRvcmVzID0gYXdhaXQgdGhpcy5pbnRlZ3JhZG9yUmVwb3NpdG9yeS5maW5kKCk7XG4gICAgcmV0dXJuIGludGVncmFkb3Jlcy5tYXAoaW50ZWdyYWRvciA9PiBuZXcgSW50ZWdyYWRvclJlc3BvbnNlRHRvKGludGVncmFkb3IpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdXNjYSB1bSBpbnRlZ3JhZG9yIHBlbG8gc2V1IElELlxuICAgKiBAcGFyYW0gaWQgSUQgZG8gaW50ZWdyYWRvclxuICAgKiBAcmV0dXJucyBEYWRvcyBkbyBpbnRlZ3JhZG9yIGVuY29udHJhZG9cbiAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBzZSBvIGludGVncmFkb3IgbsOjbyBmb3IgZW5jb250cmFkb1xuICAgKi9cbiAgYXN5bmMgZmluZEJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8SW50ZWdyYWRvcj4ge1xuICAgIGNvbnN0IGludGVncmFkb3IgPSBhd2FpdCB0aGlzLmludGVncmFkb3JSZXBvc2l0b3J5LmZpbmRPbmUoeyB3aGVyZTogeyBpZCB9IH0pO1xuICAgIFxuICAgIGlmICghaW50ZWdyYWRvcikge1xuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKGBJbnRlZ3JhZG9yIGNvbSBJRCAke2lkfSBuw6NvIGVuY29udHJhZG9gKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGludGVncmFkb3I7XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIHVtIGludGVncmFkb3IgcGVsbyBJRCBlIHJldG9ybmEgY29tIG8gZm9ybWF0byBkZSByZXNwb3N0YSBwYWRyb25pemFkby5cbiAgICogQHBhcmFtIGlkIElEIGRvIGludGVncmFkb3JcbiAgICogQHJldHVybnMgRGFkb3MgZG8gaW50ZWdyYWRvciBubyBmb3JtYXRvIGRlIHJlc3Bvc3RhXG4gICAqL1xuICBhc3luYyBmaW5kT25lKGlkOiBzdHJpbmcpOiBQcm9taXNlPEludGVncmFkb3JSZXNwb25zZUR0bz4ge1xuICAgIGNvbnN0IGludGVncmFkb3IgPSBhd2FpdCB0aGlzLmZpbmRCeUlkKGlkKTtcbiAgICByZXR1cm4gbmV3IEludGVncmFkb3JSZXNwb25zZUR0byhpbnRlZ3JhZG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHVhbGl6YSBvcyBkYWRvcyBkZSB1bSBpbnRlZ3JhZG9yLlxuICAgKiBAcGFyYW0gaWQgSUQgZG8gaW50ZWdyYWRvciBhIHNlciBhdHVhbGl6YWRvXG4gICAqIEBwYXJhbSB1cGRhdGVJbnRlZ3JhZG9yRHRvIERhZG9zIGEgc2VyZW0gYXR1YWxpemFkb3NcbiAgICogQHJldHVybnMgRGFkb3MgZG8gaW50ZWdyYWRvciBhdHVhbGl6YWRvXG4gICAqL1xuICBhc3luYyB1cGRhdGUoaWQ6IHN0cmluZywgdXBkYXRlSW50ZWdyYWRvckR0bzogVXBkYXRlSW50ZWdyYWRvckR0byk6IFByb21pc2U8SW50ZWdyYWRvclJlc3BvbnNlRHRvPiB7XG4gICAgLy8gVmVyaWZpY2Egc2UgbyBpbnRlZ3JhZG9yIGV4aXN0ZVxuICAgIGNvbnN0IGludGVncmFkb3IgPSBhd2FpdCB0aGlzLmZpbmRCeUlkKGlkKTtcbiAgICBcbiAgICAvLyBTZSBvIG5vbWUgZXN0aXZlciBzZW5kbyBhbHRlcmFkbywgdmVyaWZpY2Egc2UgasOhIGV4aXN0ZSBvdXRybyBjb20gbyBtZXNtbyBub21lXG4gICAgaWYgKHVwZGF0ZUludGVncmFkb3JEdG8ubm9tZSAmJiB1cGRhdGVJbnRlZ3JhZG9yRHRvLm5vbWUgIT09IGludGVncmFkb3Iubm9tZSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdJbnRlZ3JhZG9yID0gYXdhaXQgdGhpcy5pbnRlZ3JhZG9yUmVwb3NpdG9yeS5maW5kT25lKHsgXG4gICAgICAgIHdoZXJlOiB7IG5vbWU6IHVwZGF0ZUludGVncmFkb3JEdG8ubm9tZSB9IFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChleGlzdGluZ0ludGVncmFkb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbmZsaWN0RXhjZXB0aW9uKGBKw6EgZXhpc3RlIHVtIGludGVncmFkb3IgY29tIG8gbm9tZSAnJHt1cGRhdGVJbnRlZ3JhZG9yRHRvLm5vbWV9J2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBBdHVhbGl6YSBvcyBkYWRvc1xuICAgIE9iamVjdC5hc3NpZ24oaW50ZWdyYWRvciwgdXBkYXRlSW50ZWdyYWRvckR0byk7XG4gICAgY29uc3QgdXBkYXRlZEludGVncmFkb3IgPSBhd2FpdCB0aGlzLmludGVncmFkb3JSZXBvc2l0b3J5LnNhdmUoaW50ZWdyYWRvcik7XG4gICAgXG4gICAgcmV0dXJuIG5ldyBJbnRlZ3JhZG9yUmVzcG9uc2VEdG8odXBkYXRlZEludGVncmFkb3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB1bSBpbnRlZ3JhZG9yIGRvIHNpc3RlbWEuXG4gICAqIEBwYXJhbSBpZCBJRCBkbyBpbnRlZ3JhZG9yIGEgc2VyIHJlbW92aWRvXG4gICAqL1xuICBhc3luYyByZW1vdmUoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGludGVncmFkb3IgPSBhd2FpdCB0aGlzLmZpbmRCeUlkKGlkKTtcbiAgICBhd2FpdCB0aGlzLmludGVncmFkb3JSZXBvc2l0b3J5LnJlbW92ZShpbnRlZ3JhZG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdGl2YSBvdSBkZXNhdGl2YSB1bSBpbnRlZ3JhZG9yLlxuICAgKiBAcGFyYW0gaWQgSUQgZG8gaW50ZWdyYWRvclxuICAgKiBAcGFyYW0gYXRpdm8gTm92byBzdGF0dXMgZGUgYXRpdmHDp8Ojb1xuICAgKiBAcmV0dXJucyBEYWRvcyBkbyBpbnRlZ3JhZG9yIGF0dWFsaXphZG9cbiAgICovXG4gIGFzeW5jIHRvZ2dsZUF0aXZvKGlkOiBzdHJpbmcsIGF0aXZvOiBib29sZWFuKTogUHJvbWlzZTxJbnRlZ3JhZG9yUmVzcG9uc2VEdG8+IHtcbiAgICBjb25zdCBpbnRlZ3JhZG9yID0gYXdhaXQgdGhpcy5maW5kQnlJZChpZCk7XG4gICAgaW50ZWdyYWRvci5hdGl2byA9IGF0aXZvO1xuICAgIGNvbnN0IHVwZGF0ZWRJbnRlZ3JhZG9yID0gYXdhaXQgdGhpcy5pbnRlZ3JhZG9yUmVwb3NpdG9yeS5zYXZlKGludGVncmFkb3IpO1xuICAgIFxuICAgIHJldHVybiBuZXcgSW50ZWdyYWRvclJlc3BvbnNlRHRvKHVwZGF0ZWRJbnRlZ3JhZG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RyYSB1bSBhY2Vzc28gZG8gaW50ZWdyYWRvciDDoCBBUEkuXG4gICAqIEBwYXJhbSBpZCBJRCBkbyBpbnRlZ3JhZG9yXG4gICAqL1xuICBhc3luYyByZWdpc3RyYXJBY2Vzc28oaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaW50ZWdyYWRvclJlcG9zaXRvcnkudXBkYXRlKFxuICAgICAgeyBpZCB9LFxuICAgICAgeyB1bHRpbW9BY2Vzc286IG5ldyBEYXRlKCkgfVxuICAgICk7XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==