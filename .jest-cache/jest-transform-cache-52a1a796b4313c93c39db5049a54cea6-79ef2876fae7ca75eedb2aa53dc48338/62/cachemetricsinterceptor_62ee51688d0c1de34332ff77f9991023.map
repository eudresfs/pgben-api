{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\shared\\monitoring\\cache-metrics.interceptor.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\shared\\monitoring\\cache-metrics.interceptor.ts"],"sourcesContent":["import {\n  Injectable,\n  NestInterceptor,\n  ExecutionContext,\n  CallHandler,\n  Logger,\n} from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nimport { EnhancedMetricsService } from './enhanced-metrics.service';\nimport { ConfigService } from '@nestjs/config';\n\n/**\n * Interceptor para coletar métricas de operações de cache\n *\n * Este interceptor monitora operações de cache e registra métricas\n * como taxa de acertos, tempo de resposta e operações totais.\n */\n@Injectable()\nexport class CacheMetricsInterceptor implements NestInterceptor {\n  private readonly logger = new Logger(CacheMetricsInterceptor.name);\n  private readonly cacheEnabled: boolean;\n  private readonly cacheType: string;\n\n  // Contadores para cálculo de taxa de acertos\n  private cacheHits = 0;\n  private cacheMisses = 0;\n  private lastReportTime = Date.now();\n  private readonly reportInterval = 60000; // 1 minuto\n\n  constructor(\n    private readonly metricsService: EnhancedMetricsService,\n    private readonly configService: ConfigService,\n  ) {\n    // Verificar se o Redis está habilitado\n    this.cacheEnabled = this.configService.get('DISABLE_REDIS') !== 'true';\n    this.cacheType = this.cacheEnabled ? 'redis' : 'memory';\n\n    // Iniciar relatório periódico de taxa de acertos\n    this.scheduleHitRatioReport();\n  }\n\n  /**\n   * Intercepta operações de cache e coleta métricas\n   */\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    // Se o cache estiver desabilitado, apenas continua a execução\n    if (!this.cacheEnabled) {\n      return next.handle();\n    }\n\n    const request = context.switchToHttp().getRequest();\n    const { method, url } = request;\n\n    // Identificar operação de cache com base no método e URL\n    const cacheOperation = this.getCacheOperation(method, url);\n    if (!cacheOperation) {\n      return next.handle();\n    }\n\n    const startTime = process.hrtime();\n\n    return next.handle().pipe(\n      tap({\n        next: (data) => {\n          // Calcular duração da operação\n          const [seconds, nanoseconds] = process.hrtime(startTime);\n          const durationSeconds = seconds + nanoseconds / 1e9;\n\n          // Determinar se foi um hit ou miss no cache\n          const isCacheHit = this.isCacheHit(data, cacheOperation);\n\n          // Registrar operação de cache\n          this.metricsService.recordCacheOperation(\n            cacheOperation,\n            true, // operação bem-sucedida\n            this.cacheType,\n          );\n\n          // Registrar duração da operação\n          this.metricsService.recordCacheOperationDuration(\n            cacheOperation,\n            durationSeconds,\n            this.cacheType,\n          );\n\n          // Atualizar contadores para taxa de acertos\n          if (isCacheHit) {\n            this.cacheHits++;\n          } else {\n            this.cacheMisses++;\n          }\n\n          // Atualizar taxa de acertos periodicamente\n          this.updateHitRatioIfNeeded();\n        },\n        error: (error) => {\n          // Registrar operação de cache com falha\n          this.metricsService.recordCacheOperation(\n            cacheOperation,\n            false, // operação falhou\n            this.cacheType,\n          );\n\n          this.logger.error(\n            `Erro em operação de cache ${cacheOperation}: ${error.message}`,\n          );\n        },\n      }),\n    );\n  }\n\n  /**\n   * Identifica a operação de cache com base no método e URL\n   */\n  private getCacheOperation(method: string, url: string): string | null {\n    // Mapear métodos HTTP para operações de cache\n    if (method === 'GET' && url.includes('/api/')) {\n      return 'get';\n    }\n    if (\n      (method === 'POST' || method === 'PUT' || method === 'DELETE') &&\n      url.includes('/api/')\n    ) {\n      return 'invalidate';\n    }\n    return null;\n  }\n\n  /**\n   * Determina se uma operação resultou em um hit no cache\n   */\n  private isCacheHit(data: any, operation: string): boolean {\n    // Lógica para determinar se foi um hit no cache\n    // Esta é uma implementação simplificada e pode precisar ser ajustada\n    // com base na estrutura de resposta real da aplicação\n    if (operation === 'get') {\n      // Verificar se os dados têm uma propriedade que indica origem do cache\n      // ou usar heurística baseada no tempo de resposta\n      return data && data._fromCache === true;\n    }\n    return false;\n  }\n\n  /**\n   * Atualiza a taxa de acertos se o intervalo de relatório foi atingido\n   */\n  private updateHitRatioIfNeeded(): void {\n    const now = Date.now();\n    if (now - this.lastReportTime >= this.reportInterval) {\n      this.updateHitRatio();\n      this.lastReportTime = now;\n    }\n  }\n\n  /**\n   * Calcula e atualiza a taxa de acertos do cache\n   */\n  private updateHitRatio(): void {\n    const total = this.cacheHits + this.cacheMisses;\n    if (total > 0) {\n      const ratio = this.cacheHits / total;\n      this.metricsService.updateCacheHitRatio(ratio, this.cacheType);\n\n      // Resetar contadores após o relatório\n      this.cacheHits = 0;\n      this.cacheMisses = 0;\n\n      this.logger.debug(\n        `Taxa de acertos do cache (${this.cacheType}): ${(ratio * 100).toFixed(2)}%`,\n      );\n    }\n  }\n\n  /**\n   * Agenda relatórios periódicos de taxa de acertos\n   */\n  private scheduleHitRatioReport(): void {\n    setInterval(() => {\n      this.updateHitRatio();\n    }, this.reportInterval);\n  }\n}\n"],"version":3}