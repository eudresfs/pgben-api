09a94c9f4e5cda45f2a649dfca17becd
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var CsvStrategy_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CsvStrategy = void 0;
const common_1 = require("@nestjs/common");
const csv_writer_1 = require("csv-writer");
const fs = __importStar(require("fs"));
const temp_files_service_1 = require("../services/temp-files.service");
/**
 * Estratégia de geração de relatórios em formato CSV
 *
 * Implementa a geração de relatórios em formato CSV usando csv-writer
 */
let CsvStrategy = CsvStrategy_1 = class CsvStrategy {
    tempFilesService;
    logger = new common_1.Logger(CsvStrategy_1.name);
    constructor(tempFilesService) {
        this.tempFilesService = tempFilesService;
    }
    /**
     * Gera um relatório em formato CSV
     * @param tipo Tipo de relatório
     * @param dados Dados do relatório
     * @param opcoes Opções de configuração
     * @returns Buffer contendo o CSV gerado
     */
    async gerar(tipo, dados, opcoes) {
        this.logger.log(`Gerando relatório CSV do tipo: ${tipo}`);
        // Criar arquivo temporário
        const tempFilePath = this.tempFilesService.getTempFilePath('relatorio-csv', 'csv');
        try {
            // Adicionar conteúdo específico conforme o tipo de relatório
            switch (tipo) {
                case 'beneficios-concedidos':
                    return await this.gerarBeneficiosConcedidos(tempFilePath, dados, opcoes);
                case 'solicitacoes-por-status':
                    return await this.gerarSolicitacoesPorStatus(tempFilePath, dados, opcoes);
                case 'atendimentos-por-unidade':
                    return await this.gerarAtendimentosPorUnidade(tempFilePath, dados, opcoes);
                default:
                    throw new Error(`Tipo de relatório não implementado: ${tipo}`);
            }
        }
        catch (error) {
            this.logger.error(`Erro ao gerar relatório CSV: ${error.message}`);
            // Tentar limpar arquivo temporário em caso de erro
            try {
                if (fs.existsSync(tempFilePath)) {
                    fs.unlinkSync(tempFilePath);
                }
            }
            catch (cleanupError) {
                this.logger.warn(`Erro ao limpar arquivo temporário: ${cleanupError.message}`);
            }
            throw error;
        }
    }
    /**
     * Retorna o tipo MIME para arquivos CSV
     */
    getMimeType() {
        return 'text/csv';
    }
    /**
     * Retorna a extensão para arquivos CSV
     */
    getExtensao() {
        return 'csv';
    }
    /**
     * Gera conteúdo para relatório de benefícios concedidos
     * @param tempFilePath Caminho do arquivo temporário
     * @param dados Dados para o relatório
     * @param opcoes Opções de configuração
     * @returns Buffer com o conteúdo do arquivo CSV
     */
    async gerarBeneficiosConcedidos(tempFilePath, solicitacoes, opcoes) {
        const csvWriter = (0, csv_writer_1.createObjectCsvWriter)({
            path: tempFilePath,
            header: [
                { id: 'protocolo', title: 'Protocolo' },
                { id: 'beneficiario', title: 'Beneficiário' },
                { id: 'beneficio', title: 'Benefício' },
                { id: 'unidade', title: 'Unidade' },
                { id: 'data_liberacao', title: 'Data Liberação' },
                { id: 'valor', title: 'Valor' },
            ],
        });
        const records = solicitacoes.map((solicitacao) => ({
            protocolo: solicitacao.protocolo || '',
            beneficiario: solicitacao.beneficiario?.nome || 'N/A',
            beneficio: solicitacao.tipo_beneficio?.nome || 'N/A',
            unidade: solicitacao.unidade?.nome || 'N/A',
            data_liberacao: solicitacao.data_liberacao
                ? new Date(solicitacao.data_liberacao).toLocaleDateString('pt-BR')
                : 'N/A',
            valor: solicitacao.tipo_beneficio?.valor || 0,
        }));
        await csvWriter.writeRecords(records);
        return this.tempFilesService.readAndRemove(tempFilePath);
    }
    /**
     * Gera conteúdo para relatório de solicitações por status
     * @param tempFilePath Caminho do arquivo temporário
     * @param dados Dados para o relatório
     * @param opcoes Opções de configuração
     * @returns Buffer com o conteúdo do arquivo CSV
     */
    async gerarSolicitacoesPorStatus(tempFilePath, agrupadas, opcoes) {
        const csvWriter = (0, csv_writer_1.createObjectCsvWriter)({
            path: tempFilePath,
            header: [
                { id: 'status', title: 'Status' },
                { id: 'protocolo', title: 'Protocolo' },
                { id: 'beneficiario', title: 'Beneficiário' },
                { id: 'beneficio', title: 'Benefício' },
                { id: 'unidade', title: 'Unidade' },
                { id: 'data_abertura', title: 'Data de Abertura' },
            ],
        });
        const records = [];
        Object.keys(agrupadas).forEach((status) => {
            agrupadas[status].forEach((solicitacao) => {
                records.push({
                    status,
                    protocolo: solicitacao.protocolo || '',
                    beneficiario: solicitacao.beneficiario?.nome || 'N/A',
                    beneficio: solicitacao.tipo_beneficio?.nome || 'N/A',
                    unidade: solicitacao.unidade?.nome || 'N/A',
                    data_abertura: solicitacao.data_abertura
                        ? new Date(solicitacao.data_abertura).toLocaleDateString('pt-BR')
                        : 'N/A',
                });
            });
        });
        await csvWriter.writeRecords(records);
        return this.tempFilesService.readAndRemove(tempFilePath);
    }
    /**
     * Gera conteúdo para relatório de atendimentos por unidade
     * @param tempFilePath Caminho do arquivo temporário
     * @param dados Dados para o relatório
     * @param opcoes Opções de configuração
     * @returns Buffer com o conteúdo do arquivo CSV
     */
    async gerarAtendimentosPorUnidade(tempFilePath, resultado, opcoes) {
        const csvWriter = (0, csv_writer_1.createObjectCsvWriter)({
            path: tempFilePath,
            header: [
                { id: 'unidade', title: 'Unidade' },
                { id: 'total', title: 'Total de Solicitações' },
                { id: 'liberadas', title: 'Solicitações Liberadas' },
                { id: 'pendentes', title: 'Solicitações Pendentes' },
                { id: 'taxa_aprovacao', title: 'Taxa de Aprovação (%)' },
            ],
        });
        const records = resultado.map((item) => {
            const taxaAprovacao = item.totalSolicitacoes > 0
                ? ((item.solicitacoesLiberadas / item.totalSolicitacoes) *
                    100).toFixed(2)
                : '0.00';
            return {
                unidade: item.unidade.nome || 'N/A',
                total: item.totalSolicitacoes,
                liberadas: item.solicitacoesLiberadas,
                pendentes: item.solicitacoesPendentes,
                taxa_aprovacao: taxaAprovacao,
            };
        });
        await csvWriter.writeRecords(records);
        return this.tempFilesService.readAndRemove(tempFilePath);
    }
};
exports.CsvStrategy = CsvStrategy;
exports.CsvStrategy = CsvStrategy = CsvStrategy_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof temp_files_service_1.TempFilesService !== "undefined" && temp_files_service_1.TempFilesService) === "function" ? _a : Object])
], CsvStrategy);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXHJlbGF0b3Jpb3MtdW5pZmljYWRvXFxzdHJhdGVnaWVzXFxjc3Yuc3RyYXRlZ3kudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBb0Q7QUFFcEQsMkNBQW1EO0FBQ25ELHVDQUF5QjtBQUN6Qix1RUFBa0U7QUFFbEU7Ozs7R0FJRztBQUVJLElBQU0sV0FBVyxtQkFBakIsTUFBTSxXQUFXO0lBR087SUFGWixNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsYUFBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXZELFlBQTZCLGdCQUFrQztRQUFsQyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO0lBQUcsQ0FBQztJQUVuRTs7Ozs7O09BTUc7SUFDSCxLQUFLLENBQUMsS0FBSyxDQUFDLElBQVksRUFBRSxLQUFVLEVBQUUsTUFBVztRQUMvQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxrQ0FBa0MsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUUxRCwyQkFBMkI7UUFDM0IsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FDeEQsZUFBZSxFQUNmLEtBQUssQ0FDTixDQUFDO1FBRUYsSUFBSSxDQUFDO1lBQ0gsNkRBQTZEO1lBQzdELFFBQVEsSUFBSSxFQUFFLENBQUM7Z0JBQ2IsS0FBSyx1QkFBdUI7b0JBQzFCLE9BQU8sTUFBTSxJQUFJLENBQUMseUJBQXlCLENBQ3pDLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxDQUNQLENBQUM7Z0JBQ0osS0FBSyx5QkFBeUI7b0JBQzVCLE9BQU8sTUFBTSxJQUFJLENBQUMsMEJBQTBCLENBQzFDLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxDQUNQLENBQUM7Z0JBQ0osS0FBSywwQkFBMEI7b0JB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QUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLEtBQUs7Z0JBQ25DLEtBQUssRUFBRSxJQUFJLENBQUMsaUJBQWlCO2dCQUM3QixTQUFTLEVBQUUsSUFBSSxDQUFDLHFCQUFxQjtnQkFDckMsU0FBUyxFQUFFLElBQUksQ0FBQyxxQkFBcUI7Z0JBQ3JDLGNBQWMsRUFBRSxhQUFhO2FBQzlCLENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztRQUVILE1BQU0sU0FBUyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN0QyxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDM0QsQ0FBQztDQUNGLENBQUE7QUF0Tlksa0NBQVc7c0JBQVgsV0FBVztJQUR2QixJQUFBLG1CQUFVLEdBQUU7eURBSW9DLHFDQUFnQixvQkFBaEIscUNBQWdCO0dBSHBELFdBQVcsQ0FzTnZCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZXVkcmVcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxtb2R1bGVzXFxyZWxhdG9yaW9zLXVuaWZpY2Fkb1xcc3RyYXRlZ2llc1xcY3N2LnN0cmF0ZWd5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIExvZ2dlciB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IFJlbGF0b3Jpb1N0cmF0ZWd5IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9yZWxhdG9yaW8tc3RyYXRlZ3kuaW50ZXJmYWNlJztcbmltcG9ydCB7IGNyZWF0ZU9iamVjdENzdldyaXRlciB9IGZyb20gJ2Nzdi13cml0ZXInO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgVGVtcEZpbGVzU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3RlbXAtZmlsZXMuc2VydmljZSc7XG5cbi8qKlxuICogRXN0cmF0w6lnaWEgZGUgZ2VyYcOnw6NvIGRlIHJlbGF0w7NyaW9zIGVtIGZvcm1hdG8gQ1NWXG4gKlxuICogSW1wbGVtZW50YSBhIGdlcmHDp8OjbyBkZSByZWxhdMOzcmlvcyBlbSBmb3JtYXRvIENTViB1c2FuZG8gY3N2LXdyaXRlclxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ3N2U3RyYXRlZ3kgaW1wbGVtZW50cyBSZWxhdG9yaW9TdHJhdGVneSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyID0gbmV3IExvZ2dlcihDc3ZTdHJhdGVneS5uYW1lKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHRlbXBGaWxlc1NlcnZpY2U6IFRlbXBGaWxlc1NlcnZpY2UpIHt9XG5cbiAgLyoqXG4gICAqIEdlcmEgdW0gcmVsYXTDs3JpbyBlbSBmb3JtYXRvIENTVlxuICAgKiBAcGFyYW0gdGlwbyBUaXBvIGRlIHJlbGF0w7NyaW9cbiAgICogQHBhcmFtIGRhZG9zIERhZG9zIGRvIHJlbGF0w7NyaW9cbiAgICogQHBhcmFtIG9wY29lcyBPcMOnw7VlcyBkZSBjb25maWd1cmHDp8Ojb1xuICAgKiBAcmV0dXJucyBCdWZmZXIgY29udGVuZG8gbyBDU1YgZ2VyYWRvXG4gICAqL1xuICBhc3luYyBnZXJhcih0aXBvOiBzdHJpbmcsIGRhZG9zOiBhbnksIG9wY29lczogYW55KTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYEdlcmFuZG8gcmVsYXTDs3JpbyBDU1YgZG8gdGlwbzogJHt0aXBvfWApO1xuXG4gICAgLy8gQ3JpYXIgYXJxdWl2byB0ZW1wb3LDoXJpb1xuICAgIGNvbnN0IHRlbXBGaWxlUGF0aCA9IHRoaXMudGVtcEZpbGVzU2VydmljZS5nZXRUZW1wRmlsZVBhdGgoXG4gICAgICAncmVsYXRvcmlvLWNzdicsXG4gICAgICAnY3N2JyxcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEFkaWNpb25hciBjb250ZcO6ZG8gZXNwZWPDrWZpY28gY29uZm9ybWUgbyB0aXBvIGRlIHJlbGF0w7NyaW9cbiAgICAgIHN3aXRjaCAodGlwbykge1xuICAgICAgICBjYXNlICdiZW5lZmljaW9zLWNvbmNlZGlkb3MnOlxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlcmFyQmVuZWZpY2lvc0NvbmNlZGlkb3MoXG4gICAgICAgICAgICB0ZW1wRmlsZVBhdGgsXG4gICAgICAgICAgICBkYWRvcyxcbiAgICAgICAgICAgIG9wY29lcyxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlICdzb2xpY2l0YWNvZXMtcG9yLXN0YXR1cyc6XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VyYXJTb2xpY2l0YWNvZXNQb3JTdGF0dXMoXG4gICAgICAgICAgICB0ZW1wRmlsZVBhdGgsXG4gICAgICAgICAgICBkYWRvcyxcbiAgICAgICAgICAgIG9wY29lcyxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlICdhdGVuZGltZW50b3MtcG9yLXVuaWRhZGUnOlxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlcmFyQXRlbmRpbWVudG9zUG9yVW5pZGFkZShcbiAgICAgICAgICAgIHRlbXBGaWxlUGF0aCxcbiAgICAgICAgICAgIGRhZG9zLFxuICAgICAgICAgICAgb3Bjb2VzLFxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaXBvIGRlIHJlbGF0w7NyaW8gbsOjbyBpbXBsZW1lbnRhZG86ICR7dGlwb31gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gZ2VyYXIgcmVsYXTDs3JpbyBDU1Y6ICR7ZXJyb3IubWVzc2FnZX1gKTtcblxuICAgICAgLy8gVGVudGFyIGxpbXBhciBhcnF1aXZvIHRlbXBvcsOhcmlvIGVtIGNhc28gZGUgZXJyb1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmModGVtcEZpbGVQYXRoKSkge1xuICAgICAgICAgIGZzLnVubGlua1N5bmModGVtcEZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoY2xlYW51cEVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEVycm8gYW8gbGltcGFyIGFycXVpdm8gdGVtcG9yw6FyaW86ICR7Y2xlYW51cEVycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldG9ybmEgbyB0aXBvIE1JTUUgcGFyYSBhcnF1aXZvcyBDU1ZcbiAgICovXG4gIGdldE1pbWVUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICd0ZXh0L2Nzdic7XG4gIH1cblxuICAvKipcbiAgICogUmV0b3JuYSBhIGV4dGVuc8OjbyBwYXJhIGFycXVpdm9zIENTVlxuICAgKi9cbiAgZ2V0RXh0ZW5zYW8oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2Nzdic7XG4gIH1cblxuICAvKipcbiAgICogR2VyYSBjb250ZcO6ZG8gcGFyYSByZWxhdMOzcmlvIGRlIGJlbmVmw61jaW9zIGNvbmNlZGlkb3NcbiAgICogQHBhcmFtIHRlbXBGaWxlUGF0aCBDYW1pbmhvIGRvIGFycXVpdm8gdGVtcG9yw6FyaW9cbiAgICogQHBhcmFtIGRhZG9zIERhZG9zIHBhcmEgbyByZWxhdMOzcmlvXG4gICAqIEBwYXJhbSBvcGNvZXMgT3DDp8O1ZXMgZGUgY29uZmlndXJhw6fDo29cbiAgICogQHJldHVybnMgQnVmZmVyIGNvbSBvIGNvbnRlw7pkbyBkbyBhcnF1aXZvIENTVlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXJhckJlbmVmaWNpb3NDb25jZWRpZG9zKFxuICAgIHRlbXBGaWxlUGF0aDogc3RyaW5nLFxuICAgIHNvbGljaXRhY29lczogYW55W10sXG4gICAgb3Bjb2VzOiBhbnksXG4gICk6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgY29uc3QgY3N2V3JpdGVyID0gY3JlYXRlT2JqZWN0Q3N2V3JpdGVyKHtcbiAgICAgIHBhdGg6IHRlbXBGaWxlUGF0aCxcbiAgICAgIGhlYWRlcjogW1xuICAgICAgICB7IGlkOiAncHJvdG9jb2xvJywgdGl0bGU6ICdQcm90b2NvbG8nIH0sXG4gICAgICAgIHsgaWQ6ICdiZW5lZmljaWFyaW8nLCB0aXRsZTogJ0JlbmVmaWNpw6FyaW8nIH0sXG4gICAgICAgIHsgaWQ6ICdiZW5lZmljaW8nLCB0aXRsZTogJ0JlbmVmw61jaW8nIH0sXG4gICAgICAgIHsgaWQ6ICd1bmlkYWRlJywgdGl0bGU6ICdVbmlkYWRlJyB9LFxuICAgICAgICB7IGlkOiAnZGF0YV9saWJlcmFjYW8nLCB0aXRsZTogJ0RhdGEgTGliZXJhw6fDo28nIH0sXG4gICAgICAgIHsgaWQ6ICd2YWxvcicsIHRpdGxlOiAnVmFsb3InIH0sXG4gICAgICBdLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVjb3JkcyA9IHNvbGljaXRhY29lcy5tYXAoKHNvbGljaXRhY2FvKSA9PiAoe1xuICAgICAgcHJvdG9jb2xvOiBzb2xpY2l0YWNhby5wcm90b2NvbG8gfHwgJycsXG4gICAgICBiZW5lZmljaWFyaW86IHNvbGljaXRhY2FvLmJlbmVmaWNpYXJpbz8ubm9tZSB8fCAnTi9BJyxcbiAgICAgIGJlbmVmaWNpbzogc29saWNpdGFjYW8udGlwb19iZW5lZmljaW8/Lm5vbWUgfHwgJ04vQScsXG4gICAgICB1bmlkYWRlOiBzb2xpY2l0YWNhby51bmlkYWRlPy5ub21lIHx8ICdOL0EnLFxuICAgICAgZGF0YV9saWJlcmFjYW86IHNvbGljaXRhY2FvLmRhdGFfbGliZXJhY2FvXG4gICAgICAgID8gbmV3IERhdGUoc29saWNpdGFjYW8uZGF0YV9saWJlcmFjYW8pLnRvTG9jYWxlRGF0ZVN0cmluZygncHQtQlInKVxuICAgICAgICA6ICdOL0EnLFxuICAgICAgdmFsb3I6IHNvbGljaXRhY2FvLnRpcG9fYmVuZWZpY2lvPy52YWxvciB8fCAwLFxuICAgIH0pKTtcblxuICAgIGF3YWl0IGNzdldyaXRlci53cml0ZVJlY29yZHMocmVjb3Jkcyk7XG4gICAgcmV0dXJuIHRoaXMudGVtcEZpbGVzU2VydmljZS5yZWFkQW5kUmVtb3ZlKHRlbXBGaWxlUGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogR2VyYSBjb250ZcO6ZG8gcGFyYSByZWxhdMOzcmlvIGRlIHNvbGljaXRhw6fDtWVzIHBvciBzdGF0dXNcbiAgICogQHBhcmFtIHRlbXBGaWxlUGF0aCBDYW1pbmhvIGRvIGFycXVpdm8gdGVtcG9yw6FyaW9cbiAgICogQHBhcmFtIGRhZG9zIERhZG9zIHBhcmEgbyByZWxhdMOzcmlvXG4gICAqIEBwYXJhbSBvcGNvZXMgT3DDp8O1ZXMgZGUgY29uZmlndXJhw6fDo29cbiAgICogQHJldHVybnMgQnVmZmVyIGNvbSBvIGNvbnRlw7pkbyBkbyBhcnF1aXZvIENTVlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXJhclNvbGljaXRhY29lc1BvclN0YXR1cyhcbiAgICB0ZW1wRmlsZVBhdGg6IHN0cmluZyxcbiAgICBhZ3J1cGFkYXM6IGFueSxcbiAgICBvcGNvZXM6IGFueSxcbiAgKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICBjb25zdCBjc3ZXcml0ZXIgPSBjcmVhdGVPYmplY3RDc3ZXcml0ZXIoe1xuICAgICAgcGF0aDogdGVtcEZpbGVQYXRoLFxuICAgICAgaGVhZGVyOiBbXG4gICAgICAgIHsgaWQ6ICdzdGF0dXMnLCB0aXRsZTogJ1N0YXR1cycgfSxcbiAgICAgICAgeyBpZDogJ3Byb3RvY29sbycsIHRpdGxlOiAnUHJvdG9jb2xvJyB9LFxuICAgICAgICB7IGlkOiAnYmVuZWZpY2lhcmlvJywgdGl0bGU6ICdCZW5lZmljacOhcmlvJyB9LFxuICAgICAgICB7IGlkOiAnYmVuZWZpY2lvJywgdGl0bGU6ICdCZW5lZsOtY2lvJyB9LFxuICAgICAgICB7IGlkOiAndW5pZGFkZScsIHRpdGxlOiAnVW5pZGFkZScgfSxcbiAgICAgICAgeyBpZDogJ2RhdGFfYWJlcnR1cmEnLCB0aXRsZTogJ0RhdGEgZGUgQWJlcnR1cmEnIH0sXG4gICAgICBdLFxuICAgIH0pO1xuXG4gICAgLy8gRGVmaW5pciBpbnRlcmZhY2UgcGFyYSBvcyByZWdpc3Ryb3MgZG8gQ1NWXG4gICAgaW50ZXJmYWNlIFJlZ2lzdHJvQ1NWIHtcbiAgICAgIHN0YXR1czogc3RyaW5nO1xuICAgICAgcHJvdG9jb2xvOiBzdHJpbmc7XG4gICAgICBiZW5lZmljaWFyaW86IHN0cmluZztcbiAgICAgIGJlbmVmaWNpbzogc3RyaW5nO1xuICAgICAgdW5pZGFkZTogc3RyaW5nO1xuICAgICAgZGF0YV9hYmVydHVyYTogc3RyaW5nO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY29yZHM6IFJlZ2lzdHJvQ1NWW10gPSBbXTtcbiAgICBPYmplY3Qua2V5cyhhZ3J1cGFkYXMpLmZvckVhY2goKHN0YXR1cykgPT4ge1xuICAgICAgYWdydXBhZGFzW3N0YXR1c10uZm9yRWFjaCgoc29saWNpdGFjYW8pID0+IHtcbiAgICAgICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgcHJvdG9jb2xvOiBzb2xpY2l0YWNhby5wcm90b2NvbG8gfHwgJycsXG4gICAgICAgICAgYmVuZWZpY2lhcmlvOiBzb2xpY2l0YWNhby5iZW5lZmljaWFyaW8/Lm5vbWUgfHwgJ04vQScsXG4gICAgICAgICAgYmVuZWZpY2lvOiBzb2xpY2l0YWNhby50aXBvX2JlbmVmaWNpbz8ubm9tZSB8fCAnTi9BJyxcbiAgICAgICAgICB1bmlkYWRlOiBzb2xpY2l0YWNhby51bmlkYWRlPy5ub21lIHx8ICdOL0EnLFxuICAgICAgICAgIGRhdGFfYWJlcnR1cmE6IHNvbGljaXRhY2FvLmRhdGFfYWJlcnR1cmFcbiAgICAgICAgICAgID8gbmV3IERhdGUoc29saWNpdGFjYW8uZGF0YV9hYmVydHVyYSkudG9Mb2NhbGVEYXRlU3RyaW5nKCdwdC1CUicpXG4gICAgICAgICAgICA6ICdOL0EnLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgY3N2V3JpdGVyLndyaXRlUmVjb3JkcyhyZWNvcmRzKTtcbiAgICByZXR1cm4gdGhpcy50ZW1wRmlsZXNTZXJ2aWNlLnJlYWRBbmRSZW1vdmUodGVtcEZpbGVQYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXJhIGNvbnRlw7pkbyBwYXJhIHJlbGF0w7NyaW8gZGUgYXRlbmRpbWVudG9zIHBvciB1bmlkYWRlXG4gICAqIEBwYXJhbSB0ZW1wRmlsZVBhdGggQ2FtaW5obyBkbyBhcnF1aXZvIHRlbXBvcsOhcmlvXG4gICAqIEBwYXJhbSBkYWRvcyBEYWRvcyBwYXJhIG8gcmVsYXTDs3Jpb1xuICAgKiBAcGFyYW0gb3Bjb2VzIE9ww6fDtWVzIGRlIGNvbmZpZ3VyYcOnw6NvXG4gICAqIEByZXR1cm5zIEJ1ZmZlciBjb20gbyBjb250ZcO6ZG8gZG8gYXJxdWl2byBDU1ZcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2VyYXJBdGVuZGltZW50b3NQb3JVbmlkYWRlKFxuICAgIHRlbXBGaWxlUGF0aDogc3RyaW5nLFxuICAgIHJlc3VsdGFkbzogYW55W10sXG4gICAgb3Bjb2VzOiBhbnksXG4gICk6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgY29uc3QgY3N2V3JpdGVyID0gY3JlYXRlT2JqZWN0Q3N2V3JpdGVyKHtcbiAgICAgIHBhdGg6IHRlbXBGaWxlUGF0aCxcbiAgICAgIGhlYWRlcjogW1xuICAgICAgICB7IGlkOiAndW5pZGFkZScsIHRpdGxlOiAnVW5pZGFkZScgfSxcbiAgICAgICAgeyBpZDogJ3RvdGFsJywgdGl0bGU6ICdUb3RhbCBkZSBTb2xpY2l0YcOnw7VlcycgfSxcbiAgICAgICAgeyBpZDogJ2xpYmVyYWRhcycsIHRpdGxlOiAnU29saWNpdGHDp8O1ZXMgTGliZXJhZGFzJyB9LFxuICAgICAgICB7IGlkOiAncGVuZGVudGVzJywgdGl0bGU6ICdTb2xpY2l0YcOnw7VlcyBQZW5kZW50ZXMnIH0sXG4gICAgICAgIHsgaWQ6ICd0YXhhX2Fwcm92YWNhbycsIHRpdGxlOiAnVGF4YSBkZSBBcHJvdmHDp8OjbyAoJSknIH0sXG4gICAgICBdLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVjb3JkcyA9IHJlc3VsdGFkby5tYXAoKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHRheGFBcHJvdmFjYW8gPVxuICAgICAgICBpdGVtLnRvdGFsU29saWNpdGFjb2VzID4gMFxuICAgICAgICAgID8gKFxuICAgICAgICAgICAgICAoaXRlbS5zb2xpY2l0YWNvZXNMaWJlcmFkYXMgLyBpdGVtLnRvdGFsU29saWNpdGFjb2VzKSAqXG4gICAgICAgICAgICAgIDEwMFxuICAgICAgICAgICAgKS50b0ZpeGVkKDIpXG4gICAgICAgICAgOiAnMC4wMCc7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuaWRhZGU6IGl0ZW0udW5pZGFkZS5ub21lIHx8ICdOL0EnLFxuICAgICAgICB0b3RhbDogaXRlbS50b3RhbFNvbGljaXRhY29lcyxcbiAgICAgICAgbGliZXJhZGFzOiBpdGVtLnNvbGljaXRhY29lc0xpYmVyYWRhcyxcbiAgICAgICAgcGVuZGVudGVzOiBpdGVtLnNvbGljaXRhY29lc1BlbmRlbnRlcyxcbiAgICAgICAgdGF4YV9hcHJvdmFjYW86IHRheGFBcHJvdmFjYW8sXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgYXdhaXQgY3N2V3JpdGVyLndyaXRlUmVjb3JkcyhyZWNvcmRzKTtcbiAgICByZXR1cm4gdGhpcy50ZW1wRmlsZXNTZXJ2aWNlLnJlYWRBbmRSZW1vdmUodGVtcEZpbGVQYXRoKTtcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9