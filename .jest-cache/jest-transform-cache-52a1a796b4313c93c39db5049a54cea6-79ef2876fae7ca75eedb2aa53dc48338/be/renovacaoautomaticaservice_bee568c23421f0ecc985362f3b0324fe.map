{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\beneficio\\services\\renovacao-automatica.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\beneficio\\services\\renovacao-automatica.service.ts"],"sourcesContent":["import {\n  Injectable,\n  NotFoundException,\n  ConflictException,\n  BadRequestException,\n  InternalServerErrorException,\n  Logger,\n} from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, DataSource, LessThanOrEqual, IsNull, Not } from 'typeorm';\nimport { ConfiguracaoRenovacao } from '../../../entities/configuracao-renovacao.entity';\nimport {\n  Solicitacao,\n  StatusSolicitacao,\n} from '../../../entities/solicitacao.entity';\nimport { CreateConfiguracaoRenovacaoDto } from '../dto/create-configuracao-renovacao.dto';\nimport { UpdateConfiguracaoRenovacaoDto } from '../dto/update-configuracao-renovacao.dto';\nimport { WorkflowSolicitacaoService } from '../../solicitacao/services/workflow-solicitacao.service';\nimport { Cron, CronExpression } from '@nestjs/schedule';\n\n/**\n * Serviço de Renovação Automática\n *\n * Responsável por gerenciar as configurações de renovação automática de benefícios\n * e o processo de renovação automática mensal.\n */\n@Injectable()\nexport class RenovacaoAutomaticaService {\n  private readonly logger = new Logger(RenovacaoAutomaticaService.name);\n\n  constructor(\n    @InjectRepository(ConfiguracaoRenovacao)\n    private readonly configuracaoRepository: Repository<ConfiguracaoRenovacao>,\n    @InjectRepository(Solicitacao)\n    private readonly solicitacaoRepository: Repository<Solicitacao>,\n    private readonly workflowService: WorkflowSolicitacaoService,\n    private readonly dataSource: DataSource,\n  ) {}\n\n  /**\n   * Cria uma nova configuração de renovação automática\n   * @param createConfiguracaoDto Dados da configuração\n   * @param usuarioId ID do usuário que está criando a configuração\n   * @returns Configuração criada\n   */\n  async create(\n    createConfiguracaoDto: CreateConfiguracaoRenovacaoDto,\n    usuarioId: string,\n  ): Promise<ConfiguracaoRenovacao> {\n    try {\n      // Verificar se já existe configuração para o tipo de benefício\n      const configuracaoExistente = await this.configuracaoRepository.findOne({\n        where: { tipo_beneficio_id: createConfiguracaoDto.tipo_beneficio_id },\n      });\n\n      if (configuracaoExistente) {\n        throw new ConflictException(\n          'Já existe uma configuração de renovação para este tipo de benefício',\n        );\n      }\n\n      // Criar a configuração\n      const novaConfiguracao = this.configuracaoRepository.create({\n        ...createConfiguracaoDto,\n        usuario_id: usuarioId,\n        ativo: true,\n      });\n\n      return await this.configuracaoRepository.save(novaConfiguracao);\n    } catch (error) {\n      if (error instanceof ConflictException) {\n        throw error;\n      }\n\n      this.logger.error(\n        `Erro ao criar configuração de renovação: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Erro ao criar configuração de renovação',\n      );\n    }\n  }\n\n  /**\n   * Busca todas as configurações de renovação\n   * @returns Lista de configurações\n   */\n  async findAll(): Promise<ConfiguracaoRenovacao[]> {\n    try {\n      return this.configuracaoRepository.find({\n        relations: ['tipo_beneficio'],\n        order: { created_at: 'DESC' },\n      });\n    } catch (error) {\n      this.logger.error(\n        `Erro ao buscar configurações de renovação: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Erro ao buscar configurações de renovação',\n      );\n    }\n  }\n\n  /**\n   * Busca uma configuração de renovação pelo ID\n   * @param id ID da configuração\n   * @returns Configuração\n   */\n  async findById(id: string): Promise<ConfiguracaoRenovacao> {\n    try {\n      const configuracao = await this.configuracaoRepository.findOne({\n        where: { id },\n        relations: ['tipo_beneficio'],\n      });\n\n      if (!configuracao) {\n        throw new NotFoundException('Configuração de renovação não encontrada');\n      }\n\n      return configuracao;\n    } catch (error) {\n      if (error instanceof NotFoundException) {\n        throw error;\n      }\n\n      this.logger.error(\n        `Erro ao buscar configuração de renovação: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Erro ao buscar configuração de renovação',\n      );\n    }\n  }\n\n  /**\n   * Busca uma configuração de renovação pelo tipo de benefício\n   * @param tipoBeneficioId ID do tipo de benefício\n   * @returns Configuração\n   */\n  async findByTipoBeneficio(\n    tipoBeneficioId: string,\n  ): Promise<ConfiguracaoRenovacao> {\n    try {\n      const configuracao = await this.configuracaoRepository.findOne({\n        where: { tipo_beneficio_id: tipoBeneficioId },\n        relations: ['tipo_beneficio'],\n      });\n\n      if (!configuracao) {\n        throw new NotFoundException(\n          'Configuração de renovação não encontrada para este tipo de benefício',\n        );\n      }\n\n      return configuracao;\n    } catch (error) {\n      if (error instanceof NotFoundException) {\n        throw error;\n      }\n\n      this.logger.error(\n        `Erro ao buscar configuração de renovação por tipo de benefício: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Erro ao buscar configuração de renovação por tipo de benefício',\n      );\n    }\n  }\n\n  /**\n   * Atualiza uma configuração de renovação\n   * @param id ID da configuração\n   * @param updateConfiguracaoDto Dados para atualização\n   * @returns Configuração atualizada\n   */\n  async update(\n    id: string,\n    updateConfiguracaoDto: UpdateConfiguracaoRenovacaoDto,\n  ): Promise<ConfiguracaoRenovacao> {\n    try {\n      // Verificar se a configuração existe\n      const configuracao = await this.configuracaoRepository.findOne({\n        where: { id },\n      });\n\n      if (!configuracao) {\n        throw new NotFoundException('Configuração de renovação não encontrada');\n      }\n\n      // Atualizar a configuração\n      await this.configuracaoRepository.update(id, updateConfiguracaoDto);\n\n      // Retornar a configuração atualizada\n      return this.findById(id);\n    } catch (error) {\n      if (error instanceof NotFoundException) {\n        throw error;\n      }\n\n      this.logger.error(\n        `Erro ao atualizar configuração de renovação: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Erro ao atualizar configuração de renovação',\n      );\n    }\n  }\n\n  /**\n   * Remove uma configuração de renovação\n   * @param id ID da configuração\n   * @returns void\n   */\n  async remove(id: string): Promise<void> {\n    try {\n      // Verificar se a configuração existe\n      const configuracao = await this.configuracaoRepository.findOne({\n        where: { id },\n      });\n\n      if (!configuracao) {\n        throw new NotFoundException('Configuração de renovação não encontrada');\n      }\n\n      // Remover a configuração\n      await this.configuracaoRepository.remove(configuracao);\n    } catch (error) {\n      if (error instanceof NotFoundException) {\n        throw error;\n      }\n\n      this.logger.error(\n        `Erro ao remover configuração de renovação: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Erro ao remover configuração de renovação',\n      );\n    }\n  }\n\n  /**\n   * Ativa ou desativa uma configuração de renovação\n   * @param id ID da configuração\n   * @param ativo Status de ativação\n   * @returns Configuração atualizada\n   */\n  async toggleAtivo(\n    id: string,\n    ativo: boolean,\n  ): Promise<ConfiguracaoRenovacao> {\n    try {\n      // Verificar se a configuração existe\n      const configuracao = await this.configuracaoRepository.findOne({\n        where: { id },\n      });\n\n      if (!configuracao) {\n        throw new NotFoundException('Configuração de renovação não encontrada');\n      }\n\n      // Atualizar o status de ativação\n      await this.configuracaoRepository.update(id, { ativo });\n\n      // Retornar a configuração atualizada\n      return this.findById(id);\n    } catch (error) {\n      if (error instanceof NotFoundException) {\n        throw error;\n      }\n\n      this.logger.error(\n        `Erro ao atualizar status de ativação: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Erro ao atualizar status de ativação',\n      );\n    }\n  }\n\n  /**\n   * Configura a renovação automática para uma solicitação\n   * @param solicitacaoId ID da solicitação\n   * @param renovacaoAutomatica Flag indicando se a renovação automática está ativada\n   * @param usuarioId ID do usuário que está configurando a renovação\n   * @returns Solicitação atualizada\n   */\n  async configurarRenovacaoSolicitacao(\n    solicitacaoId: string,\n    renovacaoAutomatica: boolean,\n    usuarioId: string,\n  ): Promise<Solicitacao> {\n    try {\n      // Verificar se a solicitação existe\n      const solicitacao = await this.solicitacaoRepository.findOne({\n        where: { id: solicitacaoId },\n      });\n\n      if (!solicitacao) {\n        throw new NotFoundException('Solicitação de benefício não encontrada');\n      }\n\n      // Verificar se a solicitação está em um estado que permite renovação\n      if (solicitacao.status !== StatusSolicitacao.CONCLUIDA) {\n        throw new BadRequestException(\n          'Apenas solicitações concluídas podem ser configuradas para renovação automática',\n        );\n      }\n\n      // Verificar se existe configuração de renovação para o tipo de benefício\n      const configuracao = await this.configuracaoRepository.findOne({\n        where: {\n          tipo_beneficio_id: solicitacao.tipo_beneficio_id,\n          ativo: true,\n        },\n      });\n\n      if (!configuracao) {\n        throw new BadRequestException(\n          'Não existe configuração de renovação ativa para este tipo de benefício',\n        );\n      }\n\n      if (!configuracao.renovacao_automatica) {\n        throw new BadRequestException(\n          'A renovação automática não está habilitada para este tipo de benefício',\n        );\n      }\n\n      // Preparar os dados para atualização\n      const updateData: any = {\n        renovacao_automatica: renovacaoAutomatica,\n      };\n\n      // Adicionar a data da próxima renovação apenas se estiver ativada\n      if (renovacaoAutomatica) {\n        updateData.data_proxima_renovacao = this.calcularDataProximaRenovacao(\n          configuracao.dias_antecedencia_renovacao,\n        );\n      } else {\n        // Usar SQL bruto para definir como NULL\n        await this.dataSource\n          .createQueryBuilder()\n          .update(Solicitacao)\n          .set({ renovacao_automatica: false })\n          .where('id = :id', { id: solicitacaoId })\n          .execute();\n\n        await this.dataSource.query(\n          `UPDATE solicitacao SET data_proxima_renovacao = NULL WHERE id = $1`,\n          [solicitacaoId],\n        );\n\n        // Retornar mais cedo para evitar a segunda atualização\n        const solicitacaoAtualizada = await this.solicitacaoRepository.findOne({\n          where: { id: solicitacaoId },\n        });\n\n        if (!solicitacaoAtualizada) {\n          throw new NotFoundException(\n            `Solicitação com ID ${solicitacaoId} não encontrada após atualização`,\n          );\n        }\n\n        return solicitacaoAtualizada;\n      }\n\n      // Atualizar a solicitação se a renovação estiver ativada\n      await this.solicitacaoRepository.update(solicitacaoId, updateData);\n\n      // Retornar a solicitação atualizada\n      const solicitacaoAtualizada = await this.solicitacaoRepository.findOne({\n        where: { id: solicitacaoId },\n      });\n\n      if (!solicitacaoAtualizada) {\n        throw new NotFoundException(\n          `Solicitação com ID ${solicitacaoId} não encontrada após atualização`,\n        );\n      }\n\n      return solicitacaoAtualizada;\n    } catch (error) {\n      if (\n        error instanceof NotFoundException ||\n        error instanceof BadRequestException\n      ) {\n        throw error;\n      }\n\n      this.logger.error(\n        `Erro ao configurar renovação automática: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Erro ao configurar renovação automática',\n      );\n    }\n  }\n\n  /**\n   * Calcula a data da próxima renovação\n   * @param diasAntecedencia Dias de antecedência para a renovação\n   * @returns Data da próxima renovação\n   */\n  private calcularDataProximaRenovacao(diasAntecedencia: number): Date {\n    const dataAtual = new Date();\n    const dataProximaRenovacao = new Date(dataAtual);\n\n    // Adicionar um mês à data atual\n    dataProximaRenovacao.setMonth(dataProximaRenovacao.getMonth() + 1);\n\n    // Subtrair os dias de antecedência\n    dataProximaRenovacao.setDate(\n      dataProximaRenovacao.getDate() - diasAntecedencia,\n    );\n\n    return dataProximaRenovacao;\n  }\n\n  /**\n   * Processa as renovações automáticas pendentes\n   * Este método é executado automaticamente todos os dias à meia-noite\n   */\n  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)\n  async processarRenovacoesAutomaticas(): Promise<void> {\n    this.logger.log('Iniciando processamento de renovações automáticas');\n\n    const dataAtual = new Date();\n\n    try {\n      // Buscar solicitações com renovação automática ativada e data de renovação menor ou igual à data atual\n      const solicitacoesPendentes = await this.solicitacaoRepository.find({\n        where: {\n          renovacao_automatica: true,\n          data_proxima_renovacao: LessThanOrEqual(dataAtual),\n          status: StatusSolicitacao.CONCLUIDA,\n        },\n        relations: ['tipo_beneficio'],\n      });\n\n      this.logger.log(\n        `Encontradas ${solicitacoesPendentes.length} solicitações pendentes de renovação`,\n      );\n\n      for (const solicitacao of solicitacoesPendentes) {\n        await this.processarRenovacaoSolicitacao(solicitacao);\n      }\n\n      this.logger.log('Processamento de renovações automáticas concluído');\n    } catch (error) {\n      this.logger.error(\n        `Erro ao processar renovações automáticas: ${error.message}`,\n        error.stack,\n      );\n    }\n  }\n\n  /**\n   * Processa a renovação de uma solicitação específica\n   * @param solicitacao Solicitação a ser renovada\n   */\n  private async processarRenovacaoSolicitacao(\n    solicitacao: Solicitacao,\n  ): Promise<void> {\n    const queryRunner = this.dataSource.createQueryRunner();\n    await queryRunner.connect();\n    await queryRunner.startTransaction();\n\n    try {\n      // Buscar configuração de renovação para o tipo de benefício\n      const configuracao = await this.configuracaoRepository.findOne({\n        where: {\n          tipo_beneficio_id: solicitacao.tipo_beneficio_id,\n          ativo: true,\n        },\n      });\n\n      if (!configuracao || !configuracao.renovacao_automatica) {\n        this.logger.warn(\n          `Configuração de renovação não encontrada ou desativada para a solicitação ${solicitacao.id}`,\n        );\n        return;\n      }\n\n      // Verificar se atingiu o número máximo de renovações\n      const numeroMaximoRenovacoes = configuracao.numero_maximo_renovacoes || 0;\n      if (\n        numeroMaximoRenovacoes > 0 &&\n        solicitacao.contador_renovacoes >= numeroMaximoRenovacoes\n      ) {\n        this.logger.warn(\n          `Solicitação ${solicitacao.id} atingiu o número máximo de renovações (${configuracao.numero_maximo_renovacoes})`,\n        );\n\n        // Desativar renovação automática\n        await queryRunner.manager.update(\n          Solicitacao,\n          { id: solicitacao.id },\n          {\n            renovacao_automatica: false,\n            data_proxima_renovacao: undefined,\n          },\n        );\n\n        await queryRunner.commitTransaction();\n        return;\n      }\n\n      // Criar nova solicitação como renovação\n      const novaSolicitacao = this.solicitacaoRepository.create({\n        tipo_beneficio_id: solicitacao.tipo_beneficio_id,\n        dados_dinamicos: solicitacao.dados_dinamicos,\n        observacoes: `Renovação automática da solicitação ${solicitacao.id}`,\n        solicitacao_original_id:\n          solicitacao.solicitacao_original_id || solicitacao.id,\n        contador_renovacoes: solicitacao.contador_renovacoes + 1,\n        renovacao_automatica: true,\n      });\n\n      // Definir o status inicial da nova solicitação\n      if (configuracao.requer_aprovacao_renovacao) {\n        novaSolicitacao.status = StatusSolicitacao.PENDENTE;\n      } else {\n        novaSolicitacao.status = StatusSolicitacao.APROVADA;\n      }\n\n      // Salvar a nova solicitação\n      const novaSolicitacaoSalva =\n        await queryRunner.manager.save(novaSolicitacao);\n\n      // Calcular a data da próxima renovação\n      const dataProximaRenovacao = this.calcularDataProximaRenovacao(\n        configuracao.dias_antecedencia_renovacao,\n      );\n\n      // Atualizar a solicitação original\n      await queryRunner.manager.update(\n        Solicitacao,\n        { id: solicitacao.id },\n        {\n          data_proxima_renovacao: dataProximaRenovacao,\n        },\n      );\n\n      // Se não requer aprovação, avançar automaticamente para LIBERADA\n      if (!configuracao.requer_aprovacao_renovacao) {\n        await this.workflowService.liberarSolicitacao(\n          novaSolicitacaoSalva.id,\n          'sistema', // ID do sistema como usuário\n        );\n      }\n\n      this.logger.log(\n        `Renovação automática processada com sucesso para a solicitação ${solicitacao.id}. Nova solicitação: ${novaSolicitacaoSalva.id}`,\n      );\n\n      await queryRunner.commitTransaction();\n    } catch (error) {\n      await queryRunner.rollbackTransaction();\n      this.logger.error(\n        `Erro ao processar renovação da solicitação ${solicitacao.id}: ${error.message}`,\n        error.stack,\n      );\n    } finally {\n      await queryRunner.release();\n    }\n  }\n\n  /**\n   * Verifica a configuração de renovação automática de uma solicitação\n   * @param solicitacaoId ID da solicitação\n   * @returns Informações sobre a configuração de renovação da solicitação\n   */\n  async verificarRenovacaoSolicitacao(solicitacaoId: string): Promise<{\n    renovacao_automatica: boolean;\n    contador_renovacoes: number;\n    data_proxima_renovacao: Date | null;\n    solicitacao_original_id: string | null;\n    configuracao_tipo_beneficio: boolean;\n    dias_antecedencia: number | null;\n    numero_maximo_renovacoes: number | null;\n    requer_aprovacao: boolean | null;\n  }> {\n    try {\n      // Buscar solicitação\n      const solicitacao = await this.solicitacaoRepository.findOne({\n        where: { id: solicitacaoId },\n        relations: ['tipo_beneficio'],\n      });\n\n      if (!solicitacao) {\n        throw new NotFoundException('Solicitação não encontrada');\n      }\n\n      // Buscar configuração de renovação para o tipo de benefício\n      const configuracao = await this.configuracaoRepository.findOne({\n        where: { tipo_beneficio_id: solicitacao.tipo_beneficio_id },\n      });\n\n      // Preparar resposta\n      return {\n        renovacao_automatica: solicitacao.renovacao_automatica,\n        contador_renovacoes: solicitacao.contador_renovacoes,\n        data_proxima_renovacao: solicitacao.data_proxima_renovacao,\n        solicitacao_original_id: solicitacao.solicitacao_original_id,\n        configuracao_tipo_beneficio: configuracao\n          ? configuracao.renovacao_automatica && configuracao.ativo\n          : false,\n        dias_antecedencia: configuracao\n          ? configuracao.dias_antecedencia_renovacao || null\n          : null,\n        numero_maximo_renovacoes: configuracao\n          ? configuracao.numero_maximo_renovacoes || null\n          : null,\n        requer_aprovacao: configuracao\n          ? configuracao.requer_aprovacao_renovacao\n          : null,\n      };\n    } catch (error) {\n      if (error instanceof NotFoundException) {\n        throw error;\n      }\n\n      this.logger.error(\n        `Erro ao verificar configuração de renovação da solicitação ${solicitacaoId}: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Erro ao verificar configuração de renovação da solicitação',\n      );\n    }\n  }\n\n  /**\n   * Verifica e processa manualmente as renovações pendentes\n   * @param usuarioId ID do usuário que está executando a verificação\n   * @returns Número de solicitações renovadas\n   */\n  async verificarRenovacoesPendentes(usuarioId: string): Promise<number> {\n    this.logger.log(\n      `Verificação manual de renovações pendentes iniciada por ${usuarioId}`,\n    );\n\n    const dataAtual = new Date();\n    let renovacoesProcessadas = 0;\n\n    try {\n      // Buscar solicitações com renovação automática ativada e data de renovação menor ou igual à data atual\n      const solicitacoesPendentes = await this.solicitacaoRepository.find({\n        where: {\n          renovacao_automatica: true,\n          data_proxima_renovacao: LessThanOrEqual(dataAtual),\n          status: StatusSolicitacao.CONCLUIDA,\n        },\n        relations: ['tipo_beneficio'],\n      });\n\n      this.logger.log(\n        `Encontradas ${solicitacoesPendentes.length} solicitações pendentes de renovação`,\n      );\n\n      for (const solicitacao of solicitacoesPendentes) {\n        await this.processarRenovacaoSolicitacao(solicitacao);\n        renovacoesProcessadas++;\n      }\n\n      this.logger.log(\n        `Verificação manual concluída. ${renovacoesProcessadas} renovações processadas.`,\n      );\n      return renovacoesProcessadas;\n    } catch (error) {\n      this.logger.error(\n        `Erro ao verificar renovações pendentes: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Erro ao verificar renovações pendentes',\n      );\n    }\n  }\n}\n"],"version":3}