0b9a53d9932fc1432cdd0d1e334004e7
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const testing_1 = require("@nestjs/testing");
const temp_files_service_1 = require("../services/temp-files.service");
const fs = __importStar(require("fs"));
/**
 * Testes unitários para o serviço de arquivos temporários
 *
 * Este arquivo contém testes que validam a funcionalidade do serviço
 * responsável por gerenciar arquivos temporários durante a geração de relatórios
 */
describe('TempFilesService', () => {
    // Mock para fs
    jest.mock('fs', () => ({
        existsSync: jest.fn(),
        mkdirSync: jest.fn(),
        writeFileSync: jest.fn(),
        unlinkSync: jest.fn(),
        promises: {
            unlink: jest.fn(),
        },
    }));
    let service;
    beforeEach(async () => {
        const module = await testing_1.Test.createTestingModule({
            providers: [temp_files_service_1.TempFilesService],
        }).compile();
        service = module.get(temp_files_service_1.TempFilesService);
        // Reset mocks antes de cada teste
        jest.clearAllMocks();
        fs.existsSync.mockReturnValue(true);
    });
    it('deve ser definido', () => {
        expect(service).toBeDefined();
    });
    describe('getTempFilePath', () => {
        it('deve gerar um caminho de arquivo temporário com prefixo e extensão', () => {
            const filePath = service.getTempFilePath('teste', 'pdf');
            expect(filePath).toMatch(/temp\/relatorios\/teste-[a-zA-Z0-9]+-[a-zA-Z0-9]+\.pdf/);
        });
        it('deve criar o diretório temporário se não existir', () => {
            fs.existsSync.mockReturnValueOnce(false);
            service.getTempFilePath('teste', 'pdf');
            expect(fs.mkdirSync).toHaveBeenCalledWith(expect.stringContaining('temp/relatorios'), { recursive: true });
        });
    });
    describe('cleanupTempFile', () => {
        it('deve excluir um arquivo temporário', async () => {
            const mockPath = 'temp/relatorios/teste-123.pdf';
            await service.cleanupTempFile(mockPath);
            expect(fs.promises.unlink).toHaveBeenCalledWith(mockPath);
        });
        it('deve lidar com erros ao excluir arquivos', async () => {
            const mockPath = 'temp/relatorios/teste-123.pdf';
            const mockError = new Error('Erro ao excluir arquivo');
            fs.promises.unlink.mockRejectedValueOnce(mockError);
            // Não deve lançar erro, apenas logar
            await expect(service.cleanupTempFile(mockPath)).resolves.not.toThrow();
        });
    });
    describe('getTempDir', () => {
        it('deve retornar o diretório temporário padrão', () => {
            expect(service.getTempDir()).toBe('temp/relatorios');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXHJlbGF0b3Jpb3MtdW5pZmljYWRvXFxfX3Rlc3RzX19cXHRlbXAtZmlsZXMuc2VydmljZS5zcGVjLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkNBQXNEO0FBQ3RELHVFQUFrRTtBQUNsRSx1Q0FBeUI7QUFHekI7Ozs7O0dBS0c7QUFDSCxRQUFRLENBQUMsa0JBQWtCLEVBQUUsR0FBRyxFQUFFO0lBR2hDLGVBQWU7SUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ3JCLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ3JCLFNBQVMsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ3BCLGFBQWEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ3hCLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ3JCLFFBQVEsRUFBRTtZQUNSLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1NBQ2xCO0tBQ0YsQ0FBQyxDQUFDLENBQUM7SUFYSixJQUFJLE9BQXlCLENBQUM7SUFhOUIsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3BCLE1BQU0sTUFBTSxHQUFrQixNQUFNLGNBQUksQ0FBQyxtQkFBbUIsQ0FBQztZQUMzRCxTQUFTLEVBQUUsQ0FBQyxxQ0FBZ0IsQ0FBQztTQUM5QixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFYixPQUFPLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBbUIscUNBQWdCLENBQUMsQ0FBQztRQUV6RCxrQ0FBa0M7UUFDbEMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3BCLEVBQUUsQ0FBQyxVQUF3QixDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNyRCxDQUFDLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQyxtQkFBbUIsRUFBRSxHQUFHLEVBQUU7UUFDM0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ2hDLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLGlCQUFpQixFQUFFLEdBQUcsRUFBRTtRQUMvQixFQUFFLENBQUMsb0VBQW9FLEVBQUUsR0FBRyxFQUFFO1lBQzVFLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3pELE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLENBQ3RCLHdEQUF3RCxDQUN6RCxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsa0RBQWtELEVBQUUsR0FBRyxFQUFFO1lBQ3pELEVBQUUsQ0FBQyxVQUF3QixDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDO1lBRXhELE9BQU8sQ0FBQyxlQUFlLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBRXhDLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsb0JBQW9CLENBQ3ZDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxFQUMxQyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FDcEIsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsaUJBQWlCLEVBQUUsR0FBRyxFQUFFO1FBQy9CLEVBQUUsQ0FBQyxvQ0FBb0MsRUFBRSxLQUFLLElBQUksRUFBRTtZQUNsRCxNQUFNLFFBQVEsR0FBRywrQkFBK0IsQ0FBQztZQUVqRCxNQUFNLE9BQU8sQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFeEMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDNUQsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsMENBQTBDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDeEQsTUFBTSxRQUFRLEdBQUcsK0JBQStCLENBQUM7WUFDakQsTUFBTSxTQUFTLEdBQUcsSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztZQUV0RCxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQW9CLENBQUMscUJBQXFCLENBQUMsU0FBUyxDQUFDLENBQUM7WUFFbkUscUNBQXFDO1lBQ3JDLE1BQU0sTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3pFLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRTtRQUMxQixFQUFFLENBQUMsNkNBQTZDLEVBQUUsR0FBRyxFQUFFO1lBQ3JELE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUN2RCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXHJlbGF0b3Jpb3MtdW5pZmljYWRvXFxfX3Rlc3RzX19cXHRlbXAtZmlsZXMuc2VydmljZS5zcGVjLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRlc3QsIFRlc3RpbmdNb2R1bGUgfSBmcm9tICdAbmVzdGpzL3Rlc3RpbmcnO1xuaW1wb3J0IHsgVGVtcEZpbGVzU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3RlbXAtZmlsZXMuc2VydmljZSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG4vKipcbiAqIFRlc3RlcyB1bml0w6FyaW9zIHBhcmEgbyBzZXJ2acOnbyBkZSBhcnF1aXZvcyB0ZW1wb3LDoXJpb3NcbiAqXG4gKiBFc3RlIGFycXVpdm8gY29udMOpbSB0ZXN0ZXMgcXVlIHZhbGlkYW0gYSBmdW5jaW9uYWxpZGFkZSBkbyBzZXJ2acOnb1xuICogcmVzcG9uc8OhdmVsIHBvciBnZXJlbmNpYXIgYXJxdWl2b3MgdGVtcG9yw6FyaW9zIGR1cmFudGUgYSBnZXJhw6fDo28gZGUgcmVsYXTDs3Jpb3NcbiAqL1xuZGVzY3JpYmUoJ1RlbXBGaWxlc1NlcnZpY2UnLCAoKSA9PiB7XG4gIGxldCBzZXJ2aWNlOiBUZW1wRmlsZXNTZXJ2aWNlO1xuXG4gIC8vIE1vY2sgcGFyYSBmc1xuICBqZXN0Lm1vY2soJ2ZzJywgKCkgPT4gKHtcbiAgICBleGlzdHNTeW5jOiBqZXN0LmZuKCksXG4gICAgbWtkaXJTeW5jOiBqZXN0LmZuKCksXG4gICAgd3JpdGVGaWxlU3luYzogamVzdC5mbigpLFxuICAgIHVubGlua1N5bmM6IGplc3QuZm4oKSxcbiAgICBwcm9taXNlczoge1xuICAgICAgdW5saW5rOiBqZXN0LmZuKCksXG4gICAgfSxcbiAgfSkpO1xuXG4gIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vZHVsZTogVGVzdGluZ01vZHVsZSA9IGF3YWl0IFRlc3QuY3JlYXRlVGVzdGluZ01vZHVsZSh7XG4gICAgICBwcm92aWRlcnM6IFtUZW1wRmlsZXNTZXJ2aWNlXSxcbiAgICB9KS5jb21waWxlKCk7XG5cbiAgICBzZXJ2aWNlID0gbW9kdWxlLmdldDxUZW1wRmlsZXNTZXJ2aWNlPihUZW1wRmlsZXNTZXJ2aWNlKTtcblxuICAgIC8vIFJlc2V0IG1vY2tzIGFudGVzIGRlIGNhZGEgdGVzdGVcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAoZnMuZXhpc3RzU3luYyBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgfSk7XG5cbiAgaXQoJ2RldmUgc2VyIGRlZmluaWRvJywgKCkgPT4ge1xuICAgIGV4cGVjdChzZXJ2aWNlKS50b0JlRGVmaW5lZCgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0VGVtcEZpbGVQYXRoJywgKCkgPT4ge1xuICAgIGl0KCdkZXZlIGdlcmFyIHVtIGNhbWluaG8gZGUgYXJxdWl2byB0ZW1wb3LDoXJpbyBjb20gcHJlZml4byBlIGV4dGVuc8OjbycsICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gc2VydmljZS5nZXRUZW1wRmlsZVBhdGgoJ3Rlc3RlJywgJ3BkZicpO1xuICAgICAgZXhwZWN0KGZpbGVQYXRoKS50b01hdGNoKFxuICAgICAgICAvdGVtcFxcL3JlbGF0b3Jpb3NcXC90ZXN0ZS1bYS16QS1aMC05XSstW2EtekEtWjAtOV0rXFwucGRmLyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGV2ZSBjcmlhciBvIGRpcmV0w7NyaW8gdGVtcG9yw6FyaW8gc2UgbsOjbyBleGlzdGlyJywgKCkgPT4ge1xuICAgICAgKGZzLmV4aXN0c1N5bmMgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWVPbmNlKGZhbHNlKTtcblxuICAgICAgc2VydmljZS5nZXRUZW1wRmlsZVBhdGgoJ3Rlc3RlJywgJ3BkZicpO1xuXG4gICAgICBleHBlY3QoZnMubWtkaXJTeW5jKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ3RlbXAvcmVsYXRvcmlvcycpLFxuICAgICAgICB7IHJlY3Vyc2l2ZTogdHJ1ZSB9LFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NsZWFudXBUZW1wRmlsZScsICgpID0+IHtcbiAgICBpdCgnZGV2ZSBleGNsdWlyIHVtIGFycXVpdm8gdGVtcG9yw6FyaW8nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUGF0aCA9ICd0ZW1wL3JlbGF0b3Jpb3MvdGVzdGUtMTIzLnBkZic7XG5cbiAgICAgIGF3YWl0IHNlcnZpY2UuY2xlYW51cFRlbXBGaWxlKG1vY2tQYXRoKTtcblxuICAgICAgZXhwZWN0KGZzLnByb21pc2VzLnVubGluaykudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1BhdGgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RldmUgbGlkYXIgY29tIGVycm9zIGFvIGV4Y2x1aXIgYXJxdWl2b3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUGF0aCA9ICd0ZW1wL3JlbGF0b3Jpb3MvdGVzdGUtMTIzLnBkZic7XG4gICAgICBjb25zdCBtb2NrRXJyb3IgPSBuZXcgRXJyb3IoJ0Vycm8gYW8gZXhjbHVpciBhcnF1aXZvJyk7XG5cbiAgICAgIChmcy5wcm9taXNlcy51bmxpbmsgYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobW9ja0Vycm9yKTtcblxuICAgICAgLy8gTsOjbyBkZXZlIGxhbsOnYXIgZXJybywgYXBlbmFzIGxvZ2FyXG4gICAgICBhd2FpdCBleHBlY3Qoc2VydmljZS5jbGVhbnVwVGVtcEZpbGUobW9ja1BhdGgpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0VGVtcERpcicsICgpID0+IHtcbiAgICBpdCgnZGV2ZSByZXRvcm5hciBvIGRpcmV0w7NyaW8gdGVtcG9yw6FyaW8gcGFkcsOjbycsICgpID0+IHtcbiAgICAgIGV4cGVjdChzZXJ2aWNlLmdldFRlbXBEaXIoKSkudG9CZSgndGVtcC9yZWxhdG9yaW9zJyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=