{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\shared\\services\\hybrid-cache.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\shared\\services\\hybrid-cache.service.ts"],"sourcesContent":["import { Injectable, Logger, OnModuleInit } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Cron } from '@nestjs/schedule';\nimport { HealthCheckService } from './health-check.service';\nimport { CacheService } from '../cache/cache.service';\n\ninterface CacheEntry {\n  value: any;\n  ttl: number;\n  createdAt: number;\n  accessCount: number;\n  lastAccessed: number;\n  priority: 'low' | 'medium' | 'high' | 'critical';\n}\n\ninterface CacheMetrics {\n  l1Hits: number;\n  l1Misses: number;\n  l2Hits: number;\n  l2Misses: number;\n  evictions: number;\n  warmingOperations: number;\n  failovers: number;\n}\n\n/**\n * Serviço de Cache Híbrido Resiliente\n *\n * Implementa um sistema de cache em múltiplas camadas com estratégias de resiliência:\n *\n * L1 Cache (Memória Local):\n * - Cache em memória ultra-rápido\n * - Limitado por tamanho configurável\n * - Algoritmo LRU com prioridades\n * - Sempre disponível\n *\n * L2 Cache (Redis):\n * - Cache distribuído persistente\n * - Compartilhado entre instâncias\n * - Fallback automático para L1 em caso de falha\n * - Circuit breaker integrado\n *\n * Funcionalidades de Resiliência:\n * - Cache warming automático\n * - Prevenção de cache stampede\n * - Métricas detalhadas\n * - Recuperação automática\n */\n@Injectable()\nexport class HybridCacheService implements OnModuleInit {\n  private readonly logger = new Logger(HybridCacheService.name);\n\n  // L1 Cache (Memória Local)\n  private readonly l1Cache = new Map<string, CacheEntry>();\n  private readonly maxL1Size: number;\n  private readonly defaultTtl: number;\n\n  // Configurações\n  private readonly enableL2Cache: boolean;\n  private readonly enableCacheWarming: boolean;\n  private readonly warmingInterval: number;\n\n  // Métricas\n  private metrics: CacheMetrics = {\n    l1Hits: 0,\n    l1Misses: 0,\n    l2Hits: 0,\n    l2Misses: 0,\n    evictions: 0,\n    warmingOperations: 0,\n    failovers: 0,\n  };\n\n  // Cache warming - chaves críticas que devem estar sempre em cache\n  private readonly criticalKeys = new Set<string>();\n  private readonly warmingCallbacks = new Map<string, () => Promise<any>>();\n\n  // Prevenção de cache stampede\n  private readonly pendingOperations = new Map<string, Promise<any>>();\n\n  constructor(\n    private readonly configService: ConfigService,\n    private readonly healthCheckService: HealthCheckService,\n    private readonly cacheService: CacheService,\n  ) {\n    this.maxL1Size = this.configService.get('CACHE_L1_MAX_SIZE', 1000);\n    this.defaultTtl = this.configService.get('CACHE_DEFAULT_TTL', 300000); // 5 minutos\n    this.enableL2Cache =\n      this.configService.get('CACHE_ENABLE_L2', 'true') === 'true';\n    this.enableCacheWarming =\n      this.configService.get('CACHE_ENABLE_WARMING', 'true') === 'true';\n    this.warmingInterval = this.configService.get(\n      'CACHE_WARMING_INTERVAL',\n      60000,\n    ); // 1 minuto\n  }\n\n  async onModuleInit() {\n    this.logger.log('Inicializando Hybrid Cache Service');\n\n    // TEMPORÁRIO: Desabilitando inicialização para evitar travamento\n    this.logger.warn(\n      '⚠️ Inicialização do HybridCacheService desabilitada temporariamente',\n    );\n\n    // TODO: Reabilitar após resolver problemas de conectividade com Redis\n    /*\n    if (this.enableCacheWarming) {\n      this.logger.log('Cache warming habilitado');\n    }\n    \n    // Registrar chaves críticas padrão\n    this.registerCriticalKey('system:config', async () => {\n      // Exemplo: carregar configurações do sistema\n      return { loaded: true, timestamp: Date.now() };\n    });\n    */\n  }\n\n  /**\n   * Obtém valor do cache com estratégia híbrida\n   *\n   * Fluxo:\n   * 1. Verifica L1 Cache (memória local)\n   * 2. Se não encontrar, verifica L2 Cache (Redis)\n   * 3. Se encontrar no L2, promove para L1\n   * 4. Se não encontrar em nenhum, retorna null\n   *\n   * @param key Chave do cache\n   * @returns Valor do cache ou null\n   */\n  async get<T = any>(key: string): Promise<T | null> {\n    const startTime = Date.now();\n\n    try {\n      // L1 Cache (Memória Local)\n      const l1Result = this.getFromL1<T>(key);\n      if (l1Result !== null) {\n        this.metrics.l1Hits++;\n        this.logger.debug(\n          `L1 Cache HIT para '${key}' em ${Date.now() - startTime}ms`,\n        );\n        return l1Result;\n      }\n\n      this.metrics.l1Misses++;\n\n      // L2 Cache (Redis) - apenas se habilitado e disponível\n      if (this.enableL2Cache && (await this.isL2Available())) {\n        const l2Result = await this.getFromL2<T>(key);\n        if (l2Result !== null) {\n          this.metrics.l2Hits++;\n\n          // Promover para L1 Cache\n          this.setToL1(key, l2Result, this.defaultTtl, 'medium');\n\n          this.logger.debug(\n            `L2 Cache HIT para '${key}' em ${Date.now() - startTime}ms`,\n          );\n          return l2Result;\n        }\n\n        this.metrics.l2Misses++;\n      }\n\n      this.logger.debug(\n        `Cache MISS para '${key}' em ${Date.now() - startTime}ms`,\n      );\n      return null;\n    } catch (error) {\n      this.logger.error(`Erro ao obter cache para '${key}': ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Define valor no cache com estratégia híbrida\n   *\n   * @param key Chave do cache\n   * @param value Valor a ser armazenado\n   * @param ttl TTL em milissegundos (opcional)\n   * @param priority Prioridade do cache (opcional)\n   */\n  async set<T = any>(\n    key: string,\n    value: T,\n    ttl: number = this.defaultTtl,\n    priority: 'low' | 'medium' | 'high' | 'critical' = 'medium',\n  ): Promise<void> {\n    try {\n      // Sempre armazenar no L1 Cache\n      this.setToL1(key, value, ttl, priority);\n\n      // Armazenar no L2 Cache se disponível\n      if (this.enableL2Cache && (await this.isL2Available())) {\n        await this.setToL2(key, value, ttl);\n      }\n\n      this.logger.debug(\n        `Cache SET para '${key}' com TTL ${ttl}ms e prioridade ${priority}`,\n      );\n    } catch (error) {\n      this.logger.error(\n        `Erro ao definir cache para '${key}': ${error.message}`,\n      );\n      // Não propagar erro - cache não deve quebrar a aplicação\n    }\n  }\n\n  /**\n   * Remove valor do cache\n   */\n  async del(key: string): Promise<void> {\n    try {\n      // Remover do L1 Cache\n      this.l1Cache.delete(key);\n\n      // Remover do L2 Cache se disponível\n      if (this.enableL2Cache && (await this.isL2Available())) {\n        await this.cacheService.del(key);\n      }\n\n      this.logger.debug(`Cache DEL para '${key}'`);\n    } catch (error) {\n      this.logger.error(\n        `Erro ao remover cache para '${key}': ${error.message}`,\n      );\n    }\n  }\n\n  /**\n   * Verifica se uma chave existe no cache\n   */\n  async has(key: string): Promise<boolean> {\n    try {\n      // Verificar L1 Cache\n      if (this.hasInL1(key)) {\n        return true;\n      }\n\n      // Verificar L2 Cache se disponível\n      if (this.enableL2Cache && (await this.isL2Available())) {\n        return await this.cacheService.has(key);\n      }\n\n      return false;\n    } catch (error) {\n      this.logger.error(\n        `Erro ao verificar cache para '${key}': ${error.message}`,\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Obtém ou define valor no cache com prevenção de cache stampede\n   *\n   * @param key Chave do cache\n   * @param factory Função para gerar o valor se não estiver em cache\n   * @param ttl TTL em milissegundos\n   * @param priority Prioridade do cache\n   */\n  async getOrSet<T = any>(\n    key: string,\n    factory: () => Promise<T>,\n    ttl: number = this.defaultTtl,\n    priority: 'low' | 'medium' | 'high' | 'critical' = 'medium',\n  ): Promise<T> {\n    // Verificar se já existe no cache\n    const cached = await this.get<T>(key);\n    if (cached !== null) {\n      return cached;\n    }\n\n    // Prevenção de cache stampede\n    const pendingKey = `pending:${key}`;\n    if (this.pendingOperations.has(pendingKey)) {\n      this.logger.debug(`Aguardando operação pendente para '${key}'`);\n      return await this.pendingOperations.get(pendingKey);\n    }\n\n    // Criar nova operação\n    const operation = this.executeFactory(key, factory, ttl, priority);\n    this.pendingOperations.set(pendingKey, operation);\n\n    try {\n      const result = await operation;\n      return result;\n    } finally {\n      this.pendingOperations.delete(pendingKey);\n    }\n  }\n\n  /**\n   * Executa factory e armazena resultado no cache\n   */\n  private async executeFactory<T>(\n    key: string,\n    factory: () => Promise<T>,\n    ttl: number,\n    priority: 'low' | 'medium' | 'high' | 'critical',\n  ): Promise<T> {\n    try {\n      const result = await factory();\n      await this.set(key, result, ttl, priority);\n      return result;\n    } catch (error) {\n      this.logger.error(\n        `Erro ao executar factory para '${key}': ${error.message}`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Registra chave crítica para cache warming\n   */\n  registerCriticalKey(key: string, factory: () => Promise<any>): void {\n    this.criticalKeys.add(key);\n    this.warmingCallbacks.set(key, factory);\n    this.logger.debug(`Chave crítica registrada: ${key}`);\n  }\n\n  /**\n   * Remove chave crítica\n   */\n  unregisterCriticalKey(key: string): void {\n    this.criticalKeys.delete(key);\n    this.warmingCallbacks.delete(key);\n    this.logger.debug(`Chave crítica removida: ${key}`);\n  }\n\n  /**\n   * Job de cache warming - executa periodicamente\n   */\n  @Cron('0 * * * * *') // A cada minuto\n  async performCacheWarming(): Promise<void> {\n    if (!this.enableCacheWarming || this.criticalKeys.size === 0) {\n      return;\n    }\n\n    this.logger.debug('Iniciando cache warming');\n\n    let warmedCount = 0;\n\n    for (const key of this.criticalKeys) {\n      try {\n        const factory = this.warmingCallbacks.get(key);\n        if (!factory) {\n          continue;\n        }\n\n        // Verificar se precisa de warming (não existe ou está próximo do vencimento)\n        const needsWarming = await this.needsCacheWarming(key);\n\n        if (needsWarming) {\n          await this.getOrSet(key, factory, this.defaultTtl * 2, 'critical'); // TTL maior para chaves críticas\n          warmedCount++;\n          this.metrics.warmingOperations++;\n        }\n      } catch (error) {\n        this.logger.warn(\n          `Erro no cache warming para '${key}': ${error.message}`,\n        );\n      }\n    }\n\n    if (warmedCount > 0) {\n      this.logger.debug(\n        `Cache warming concluído: ${warmedCount} chaves aquecidas`,\n      );\n    }\n  }\n\n  /**\n   * Verifica se uma chave precisa de cache warming\n   */\n  private async needsCacheWarming(key: string): Promise<boolean> {\n    const entry = this.l1Cache.get(key);\n\n    if (!entry) {\n      return true; // Não existe, precisa de warming\n    }\n\n    const now = Date.now();\n    const timeToExpire = entry.createdAt + entry.ttl - now;\n    const warmingThreshold = entry.ttl * 0.2; // 20% do TTL\n\n    return timeToExpire <= warmingThreshold;\n  }\n\n  /**\n   * Limpa cache expirado - executa periodicamente\n   */\n  @Cron('0 */5 * * * *') // A cada 5 minutos\n  async cleanupExpiredCache(): Promise<void> {\n    const now = Date.now();\n    let cleanedCount = 0;\n\n    for (const [key, entry] of this.l1Cache.entries()) {\n      if (now > entry.createdAt + entry.ttl) {\n        this.l1Cache.delete(key);\n        cleanedCount++;\n      }\n    }\n\n    if (cleanedCount > 0) {\n      this.logger.debug(`Limpeza de cache: ${cleanedCount} entradas removidas`);\n    }\n  }\n\n  // Métodos privados para L1 Cache\n\n  private getFromL1<T>(key: string): T | null {\n    const entry = this.l1Cache.get(key);\n\n    if (!entry) {\n      return null;\n    }\n\n    const now = Date.now();\n\n    // Verificar se expirou\n    if (now > entry.createdAt + entry.ttl) {\n      this.l1Cache.delete(key);\n      return null;\n    }\n\n    // Atualizar estatísticas de acesso\n    entry.accessCount++;\n    entry.lastAccessed = now;\n\n    return entry.value;\n  }\n\n  private setToL1<T>(\n    key: string,\n    value: T,\n    ttl: number,\n    priority: 'low' | 'medium' | 'high' | 'critical',\n  ): void {\n    // Verificar se precisa fazer eviction\n    if (this.l1Cache.size >= this.maxL1Size) {\n      this.evictL1Cache();\n    }\n\n    const now = Date.now();\n\n    this.l1Cache.set(key, {\n      value,\n      ttl,\n      createdAt: now,\n      accessCount: 0,\n      lastAccessed: now,\n      priority,\n    });\n  }\n\n  private hasInL1(key: string): boolean {\n    const entry = this.l1Cache.get(key);\n\n    if (!entry) {\n      return false;\n    }\n\n    const now = Date.now();\n\n    // Verificar se expirou\n    if (now > entry.createdAt + entry.ttl) {\n      this.l1Cache.delete(key);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Algoritmo de eviction LRU com prioridades\n   */\n  private evictL1Cache(): void {\n    const priorityOrder = ['low', 'medium', 'high', 'critical'];\n\n    for (const priority of priorityOrder) {\n      const candidates = Array.from(this.l1Cache.entries())\n        .filter(([_, entry]) => entry.priority === priority)\n        .sort((a, b) => a[1].lastAccessed - b[1].lastAccessed); // LRU\n\n      if (candidates.length > 0) {\n        const [keyToEvict] = candidates[0];\n        this.l1Cache.delete(keyToEvict);\n        this.metrics.evictions++;\n        this.logger.debug(\n          `Cache eviction: removida chave '${keyToEvict}' com prioridade ${priority}`,\n        );\n        return;\n      }\n    }\n  }\n\n  // Métodos privados para L2 Cache\n\n  private async getFromL2<T>(key: string): Promise<T | null> {\n    try {\n      return await this.cacheService.get<T>(key);\n    } catch (error) {\n      this.logger.warn(\n        `Erro ao acessar L2 Cache para '${key}': ${error.message}`,\n      );\n      this.metrics.failovers++;\n      return null;\n    }\n  }\n\n  private async setToL2<T>(key: string, value: T, ttl: number): Promise<void> {\n    try {\n      await this.cacheService.set(key, value, ttl);\n    } catch (error) {\n      this.logger.warn(\n        `Erro ao definir L2 Cache para '${key}': ${error.message}`,\n      );\n      this.metrics.failovers++;\n    }\n  }\n\n  private async isL2Available(): Promise<boolean> {\n    try {\n      return await this.healthCheckService.isRedisAvailable();\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Retorna métricas detalhadas do cache\n   */\n  getMetrics() {\n    const totalL1Operations = this.metrics.l1Hits + this.metrics.l1Misses;\n    const totalL2Operations = this.metrics.l2Hits + this.metrics.l2Misses;\n\n    return {\n      ...this.metrics,\n      l1Size: this.l1Cache.size,\n      l1MaxSize: this.maxL1Size,\n      l1HitRate:\n        totalL1Operations > 0\n          ? (this.metrics.l1Hits / totalL1Operations) * 100\n          : 0,\n      l2HitRate:\n        totalL2Operations > 0\n          ? (this.metrics.l2Hits / totalL2Operations) * 100\n          : 0,\n      overallHitRate:\n        totalL1Operations + totalL2Operations > 0\n          ? ((this.metrics.l1Hits + this.metrics.l2Hits) /\n              (totalL1Operations + totalL2Operations)) *\n            100\n          : 0,\n      criticalKeysCount: this.criticalKeys.size,\n      pendingOperations: this.pendingOperations.size,\n    };\n  }\n\n  /**\n   * Reseta métricas (útil para testes)\n   */\n  resetMetrics(): void {\n    this.metrics = {\n      l1Hits: 0,\n      l1Misses: 0,\n      l2Hits: 0,\n      l2Misses: 0,\n      evictions: 0,\n      warmingOperations: 0,\n      failovers: 0,\n    };\n  }\n\n  /**\n   * Limpa todo o cache (útil para testes)\n   */\n  async clear(): Promise<void> {\n    this.l1Cache.clear();\n\n    if (this.enableL2Cache && (await this.isL2Available())) {\n      try {\n        // Implementar clear no CacheService se necessário\n        this.logger.debug('L2 Cache cleared');\n      } catch (error) {\n        this.logger.warn(`Erro ao limpar L2 Cache: ${error.message}`);\n      }\n    }\n\n    this.logger.debug('Cache híbrido limpo');\n  }\n}\n"],"version":3}