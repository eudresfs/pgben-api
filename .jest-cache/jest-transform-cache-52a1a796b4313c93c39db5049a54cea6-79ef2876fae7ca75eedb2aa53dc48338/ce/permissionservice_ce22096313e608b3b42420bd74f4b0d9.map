{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\auth\\services\\permission.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\auth\\services\\permission.service.ts"],"sourcesContent":["import { Injectable, Logger, Inject } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Permission } from '../../entities/permission.entity';\nimport { PermissionRepository } from '../repositories/permission.repository';\nimport { RolePermissionRepository } from '../repositories/role-permission.repository';\nimport { UserPermissionRepository } from '../repositories/user-permission.repository';\nimport { PermissionScopeRepository } from '../repositories/permission-scope.repository';\nimport { TipoEscopo } from '../../entities/user-permission.entity';\nimport { CACHE_MANAGER } from '@nestjs/cache-manager';\nimport { Cache } from 'cache-manager';\n\n/**\n * Interface para verificação de permissão com escopo.\n */\nexport interface PermissionCheckOptions {\n  /**\n   * ID do usuário para verificação de permissão\n   */\n  userId: string;\n\n  /**\n   * Nome da permissão no formato `modulo.recurso.operacao`\n   */\n  permissionName: string;\n\n  /**\n   * Tipo de escopo (opcional, padrão é GLOBAL)\n   */\n  scopeType?: TipoEscopo;\n\n  /**\n   * ID do escopo (opcional, necessário apenas para scopeType UNIT)\n   */\n  scopeId?: string | null | undefined;\n}\n\n/**\n * Serviço responsável por verificar permissões de usuários.\n *\n * Este serviço implementa a lógica de verificação de permissões granulares,\n * considerando permissões diretas, permissões de role e permissões compostas.\n * Também implementa cache para otimizar o desempenho das verificações.\n */\n@Injectable()\nexport class PermissionService {\n  private readonly logger = new Logger(PermissionService.name);\n  private readonly CACHE_TTL = 300; // 5 minutos em segundos\n\n  constructor(\n    @InjectRepository(PermissionRepository)\n    private permissionRepository: PermissionRepository,\n    @InjectRepository(RolePermissionRepository)\n    private rolePermissionRepository: RolePermissionRepository,\n    @InjectRepository(UserPermissionRepository)\n    private userPermissionRepository: UserPermissionRepository,\n    @InjectRepository(PermissionScopeRepository)\n    private permissionScopeRepository: PermissionScopeRepository,\n    @Inject(CACHE_MANAGER)\n    private cacheManager: Cache,\n  ) {\n    this.logger.log('PermissionService inicializado');\n\n    // Verificar se o cache está funcionando\n    this.cacheManager\n      .set('permission_service_test', 'ok', 10)\n      .then(() => this.logger.log('Cache inicializado com sucesso'))\n      .catch((err) =>\n        this.logger.warn(\n          `Erro ao inicializar cache: ${err.message}. Usando fallback.`,\n        ),\n      );\n  }\n\n  /**\n   * Verifica se um usuário tem uma permissão específica.\n   *\n   * @param options Opções de verificação de permissão\n   * @returns true se o usuário tem a permissão, false caso contrário\n   */\n  async hasPermission(options: PermissionCheckOptions): Promise<boolean> {\n    try {\n      const {\n        userId,\n        permissionName,\n        scopeType = TipoEscopo.GLOBAL,\n        scopeId,\n      } = options;\n\n      // Validação de parâmetros\n      if (!userId || !permissionName) {\n        this.logger.warn(\n          `Tentativa de verificar permissão com parâmetros inválidos: userId=${userId}, permissionName=${permissionName}`,\n        );\n        return false;\n      }\n\n      // Validação de escopo\n      if (scopeType === TipoEscopo.UNIDADE && !scopeId) {\n        this.logger.warn(\n          `Tentativa de verificar permissão com escopo UNIT sem fornecer scopeId: userId=${userId}, permissionName=${permissionName}`,\n        );\n        return false;\n      }\n\n      // Verificar cache\n      const cacheKey = this.generateCacheKey(\n        userId,\n        permissionName,\n        scopeType,\n        scopeId,\n      );\n      let cachedResult;\n\n      try {\n        cachedResult = await this.cacheManager.get<boolean>(cacheKey);\n        if (cachedResult !== undefined && cachedResult !== null) {\n          return cachedResult;\n        }\n      } catch (error) {\n        this.logger.warn(\n          `Erro ao acessar cache: ${error.message}. Usando verificação direta.`,\n        );\n      }\n\n      // Verificar permissões compostas\n      if (permissionName.includes(',')) {\n        const permissions = permissionName.split(',');\n        for (const perm of permissions) {\n          const hasIndividualPermission = await this.hasPermission({\n            userId,\n            permissionName: perm.trim(),\n            scopeType,\n            scopeId,\n          });\n\n          if (hasIndividualPermission) {\n            try {\n              await this.cacheManager.set(cacheKey, true, 300);\n            } catch (error) {\n              this.logger.warn(`Erro ao escrever no cache: ${error.message}`);\n            }\n            return true;\n          }\n        }\n\n        try {\n          await this.cacheManager.set(cacheKey, false, 300);\n        } catch (error) {\n          this.logger.warn(`Erro ao escrever no cache: ${error.message}`);\n        }\n        return false;\n      }\n\n      // Verifica permissões diretas do usuário\n      const hasDirectPermission = await this.checkDirectPermission(\n        userId,\n        permissionName,\n        scopeType,\n        scopeId,\n      );\n      if (hasDirectPermission) {\n        await this.cacheManager.set(cacheKey, true, this.CACHE_TTL);\n        return true;\n      }\n\n      // Verifica permissões da role do usuário\n      const hasRolePermission = await this.checkRolePermission(\n        userId,\n        permissionName,\n      );\n      if (hasRolePermission) {\n        await this.cacheManager.set(cacheKey, true, this.CACHE_TTL);\n        return true;\n      }\n\n      // Verifica permissões compostas (wildcards)\n      const hasCompositePermission = await this.checkCompositePermission(\n        userId,\n        permissionName,\n        scopeType,\n        scopeId,\n      );\n      if (hasCompositePermission) {\n        await this.cacheManager.set(cacheKey, true, this.CACHE_TTL);\n        return true;\n      }\n\n      // Se chegou aqui, o usuário não tem a permissão\n      await this.cacheManager.set(cacheKey, false, this.CACHE_TTL);\n      return false;\n    } catch (error) {\n      this.logger.error(`Erro ao verificar permissão: ${error.message}`, {\n        options, // Usar o objeto options completo em vez das propriedades individuais\n        stack: error.stack,\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Verifica se um usuário tem uma permissão direta.\n   *\n   * @param userId ID do usuário\n   * @param permissionName Nome da permissão\n   * @param scopeType Tipo de escopo\n   * @param scopeId ID do escopo (opcional para escopo GLOBAL)\n   * @returns true se o usuário tem a permissão direta, false caso contrário\n   */\n  private async checkDirectPermission(\n    userId: string,\n    permissionName: string,\n    scopeType: TipoEscopo,\n    scopeId?: string | null | undefined,\n  ): Promise<boolean> {\n    try {\n      // Busca a permissão pelo nome\n      const permission =\n        await this.permissionRepository.findByName(permissionName);\n      if (!permission) {\n        this.logger.warn(`Permissão não encontrada: ${permissionName}`);\n        return false;\n      }\n\n      // Verifica se o usuário tem a permissão direta\n      const userPermission =\n        await this.userPermissionRepository.findByUserAndPermission(\n          userId,\n          permission.id,\n          scopeType,\n          scopeId || undefined,\n        );\n\n      // Se não encontrou a permissão ou ela não está concedida, retorna false\n      if (!userPermission || !userPermission.granted) {\n        return false;\n      }\n\n      // Verifica se a permissão está expirada\n      if (userPermission.validUntil && userPermission.validUntil < new Date()) {\n        this.logger.debug(\n          `Permissão expirada: ${permissionName} para usuário ${userId}`,\n        );\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      this.logger.error(\n        `Erro ao verificar permissão direta: ${error.message}`,\n        {\n          userId,\n          permissionName,\n          scopeType,\n          scopeId,\n          stack: error.stack,\n        },\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Verifica se um usuário tem uma permissão através da sua role.\n   *\n   * @param userId ID do usuário\n   * @param permissionName Nome da permissão\n   * @returns true se o usuário tem a permissão através da sua role, false caso contrário\n   */\n  async checkRolePermission(\n    userId: string,\n    permissionName: string,\n  ): Promise<boolean> {\n    try {\n      // Busca a permissão pelo nome\n      const permission =\n        await this.permissionRepository.findByName(permissionName);\n      if (!permission) {\n        this.logger.warn(`Permissão não encontrada: ${permissionName}`);\n        return false;\n      }\n\n      // Verifica se existe uma role com a permissão usando o método findPermissionsByUserRoles\n      const permissions =\n        await this.rolePermissionRepository.findPermissionsByUserRoles(userId);\n\n      // Verifica se a permissão específica está na lista de permissões da role\n      return permissions.some(\n        (p) => p.id === permission.id || p.name === permissionName,\n      );\n    } catch (error) {\n      this.logger.error(\n        `Erro ao verificar permissão de role: ${error.message}`,\n        {\n          userId,\n          permissionName,\n          stack: error.stack,\n        },\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Verifica se um usuário tem uma permissão composta (com wildcard).\n   *\n   * @param userId ID do usuário\n   * @param permissionName Nome da permissão específica que está sendo verificada\n   * @param scopeType Tipo de escopo\n   * @param scopeId ID do escopo (opcional para escopo GLOBAL)\n   * @returns true se o usuário tem a permissão composta, false caso contrário\n   */\n  async checkCompositePermission(\n    userId: string,\n    permissionName: string,\n    scopeType: TipoEscopo,\n    scopeId?: string | null | undefined,\n  ): Promise<boolean> {\n    try {\n      // Divide o nome da permissão em partes (ex: 'modulo.recurso.operacao')\n      const parts = permissionName.split('.');\n      if (parts.length < 2) {\n        return false; // Formato inválido\n      }\n\n      // Constrói os wildcards possíveis\n      const wildcards: string[] = [];\n\n      // Permissão super admin - verifica primeiro para otimização\n      wildcards.push('*.*');\n\n      // Wildcard para módulo (ex: 'modulo.*')\n      wildcards.push(`${parts[0]}.*`);\n\n      // Wildcard para recurso (ex: 'modulo.recurso.*')\n      if (parts.length >= 2) {\n        wildcards.push(`${parts[0]}.${parts[1]}.*`);\n      }\n\n      // Wildcard para operação (ex: '*.operacao')\n      if (parts.length >= 2) {\n        wildcards.push(`*.${parts[parts.length - 1]}`);\n      }\n\n      // Verifica cada wildcard\n      for (const wildcard of wildcards) {\n        // Verifica permissão direta\n        const hasDirectWildcard = await this.checkDirectPermission(\n          userId,\n          wildcard,\n          scopeType,\n          scopeId,\n        );\n        if (hasDirectWildcard) {\n          this.logger.debug(\n            `Usuário ${userId} tem permissão wildcard direta: ${wildcard}`,\n          );\n          return true;\n        }\n\n        // Verifica permissão de role\n        const hasRoleWildcard = await this.checkRolePermission(\n          userId,\n          wildcard,\n        );\n        if (hasRoleWildcard) {\n          this.logger.debug(\n            `Usuário ${userId} tem permissão wildcard via role: ${wildcard}`,\n          );\n          return true;\n        }\n      }\n\n      return false;\n    } catch (error) {\n      this.logger.error(\n        `Erro ao verificar permissão composta: ${error.message}`,\n        {\n          userId,\n          permissionName,\n          scopeType,\n          scopeId,\n          stack: error.stack,\n        },\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Gera uma chave de cache para uma verificação de permissão.\n   *\n   * @param userId ID do usuário\n   * @param permissionName Nome da permissão\n   * @param scopeType Tipo de escopo\n   * @param scopeId ID do escopo (opcional para escopo GLOBAL)\n   * @returns Chave de cache\n   */\n  generateCacheKey(\n    userId: string,\n    permissionName: string,\n    scopeType: TipoEscopo,\n    scopeId?: string | null | undefined,\n  ): string {\n    return `permission:${userId}:${permissionName}:${scopeType}:${scopeId || 'global'}`;\n  }\n\n  /**\n   * Limpa o cache de permissões de um usuário.\n   *\n   * @param userId ID do usuário\n   */\n  async clearUserPermissionCache(userId: string): Promise<void> {\n    try {\n      // Implementação simplificada para evitar uso de métodos que podem não estar disponíveis\n      // em todas as implementações de cache\n      this.logger.debug(`Limpando cache para o usuário: ${userId}`);\n\n      // Como não temos acesso direto a um método para limpar todo o cache,\n      // vamos usar uma abordagem alternativa que funciona com a maioria das implementações\n      // Definimos uma chave com TTL muito curto para forçar a limpeza do cache\n      await this.cacheManager.set(\n        `user-cache-clear:${userId}:${Date.now()}`,\n        true,\n        1,\n      );\n\n      this.logger.debug(`Cache de permissões limpo para o usuário ${userId}`);\n    } catch (error) {\n      this.logger.error(\n        `Erro ao limpar cache de permissões do usuário: ${error.message}`,\n        {\n          userId,\n          stack: error.stack,\n        },\n      );\n    }\n  }\n\n  /**\n   * Limpa o cache de permissões para uma permissão específica.\n   *\n   * @param permissionName Nome da permissão\n   */\n  async clearPermissionCache(permissionName: string): Promise<void> {\n    try {\n      // Obter todas as chaves de cache relacionadas à permissão\n      // Isso é uma simplificação, pois o cache-manager não suporta busca por padrão\n      // Em uma implementação real, seria necessário usar um adaptador que suporte isso\n\n      // Limpar o cache\n      // Como não podemos buscar chaves, vamos apenas registrar que o cache deveria ser limpo\n      this.logger.log(`Cache da permissão ${permissionName} deveria ser limpo`);\n    } catch (error) {\n      this.logger.error(`Erro ao limpar cache da permissão: ${error.message}`, {\n        permissionName,\n        stack: error.stack,\n      });\n    }\n  }\n\n  /**\n   * Obtém todas as permissões ativas de um usuário.\n   *\n   * @param userId ID do usuário\n   * @param includeInactive Se true, inclui permissões inativas (revogadas ou expiradas)\n   * @returns Lista de permissões do usuário\n   */\n  async getUserPermissions(\n    userId: string,\n    includeInactive: boolean = false,\n  ): Promise<Permission[]> {\n    try {\n      // Busca permissões diretas do usuário\n      const userPermissions =\n        await this.userPermissionRepository.findByUserId(userId);\n\n      // Filtra permissões ativas, se necessário\n      const filteredUserPermissions = includeInactive\n        ? userPermissions\n        : userPermissions.filter(\n            (up) =>\n              up.granted && (!up.validUntil || up.validUntil > new Date()),\n          );\n\n      // Obtém IDs das permissões\n      const permissionIds = filteredUserPermissions.map(\n        (up) => up.permissionId,\n      );\n\n      // Busca permissões de role do usuário\n      const rolePermissions =\n        await this.rolePermissionRepository.findPermissionsByUserRoles(userId);\n\n      // Adiciona IDs de permissões de role\n      rolePermissions.forEach((permission) => {\n        if (!permissionIds.includes(permission.id)) {\n          permissionIds.push(permission.id);\n        }\n      });\n\n      // Busca detalhes das permissões\n      if (permissionIds.length === 0) {\n        return [];\n      }\n\n      return this.permissionRepository.findByIds(permissionIds);\n    } catch (error) {\n      this.logger.error(\n        `Erro ao obter permissões do usuário: ${error.message}`,\n        {\n          userId,\n          includeInactive,\n          stack: error.stack,\n        },\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Obtém todas as permissões disponíveis no sistema.\n   *\n   * @returns Lista de todas as permissões\n   */\n  async getAllPermissions(): Promise<Permission[]> {\n    try {\n      // Busca todas as permissões no banco, usando a query builder para ter mais controle\n      // e evitar problemas com nomes de propriedades\n      const permissions = await this.permissionRepository\n        .createQueryBuilder('permission')\n        .select(['permission.id', 'permission.nome', 'permission.descricao'])\n        .getMany();\n      return permissions;\n    } catch (error) {\n      this.logger.error(\n        `Erro ao buscar todas as permissões: ${error.message}`,\n        {\n          stack: error.stack,\n        },\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Cria uma nova permissão no sistema.\n   *\n   * @param name Nome da permissão (deve seguir o formato modulo.operacao)\n   * @param description Descrição da permissão\n   * @param createdBy ID do usuário que está criando a permissão\n   * @returns A permissão criada ou null se ocorrer um erro\n   */\n  async createPermission(\n    name: string,\n    description: string,\n    createdBy: string,\n  ): Promise<Permission | null> {\n    try {\n      // Validação de parâmetros\n      if (!name || !createdBy) {\n        this.logger.warn(\n          `Tentativa de criar permissão com parâmetros inválidos: name=${name}, createdBy=${createdBy}`,\n        );\n        return null;\n      }\n\n      // Verifica se a permissão já existe\n      const existingPermission =\n        await this.permissionRepository.findByName(name);\n      if (existingPermission) {\n        this.logger.warn(`Tentativa de criar permissão já existente: ${name}`);\n        return existingPermission;\n      }\n\n      // Cria a nova permissão\n      const newPermission = this.permissionRepository.create({\n        nome: name,\n        descricao: description || `Permissão ${name}`,\n      });\n\n      // Salva a permissão no banco de dados\n      const savedPermission =\n        await this.permissionRepository.save(newPermission);\n\n      this.logger.log(`Permissão ${name} criada com sucesso por ${createdBy}`);\n\n      return savedPermission;\n    } catch (error) {\n      this.logger.error(`Erro ao criar permissão: ${error.message}`, {\n        name,\n        description,\n        createdBy,\n        stack: error.stack,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Cria uma permissão se ela não existir.\n   *\n   * @param name Nome da permissão\n   * @param description Descrição da permissão\n   * @param createdBy ID do usuário que está criando a permissão\n   * @returns A permissão criada ou existente, ou null se ocorrer um erro\n   */\n  async createPermissionIfNotExists(\n    name: string,\n    description: string,\n    createdBy: string,\n  ): Promise<Permission | null> {\n    try {\n      // Busca a permissão pelo nome\n      const existingPermission =\n        await this.permissionRepository.findByName(name);\n      if (existingPermission) {\n        return existingPermission;\n      }\n\n      // Se não existir, cria uma nova\n      return this.createPermission(name, description, createdBy);\n    } catch (error) {\n      this.logger.error(\n        `Erro ao criar permissão se não existir: ${error.message}`,\n        {\n          name,\n          description,\n          createdBy,\n          stack: error.stack,\n        },\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Revoga uma permissão de um usuário.\n   *\n   * @param userId ID do usuário\n   * @param permissionName Nome da permissão\n   * @param scopeType Tipo de escopo\n   * @param scopeId ID do escopo (opcional para escopo GLOBAL)\n   * @param createdBy ID do usuário que está revogando a permissão\n   * @returns true se a permissão foi revogada com sucesso, false caso contrário\n   */\n  async revokePermission(\n    userId: string,\n    permissionName: string,\n    scopeType: TipoEscopo,\n    scopeId: string | null | undefined,\n    createdBy: string,\n  ): Promise<boolean> {\n    try {\n      // Validação de parâmetros\n      if (!userId || !permissionName || !createdBy) {\n        this.logger.warn(\n          `Tentativa de revogar permissão com parâmetros inválidos: userId=${userId}, permissionName=${permissionName}, createdBy=${createdBy}`,\n        );\n        return false;\n      }\n\n      // Validação de escopo\n      if (scopeType === TipoEscopo.UNIDADE && !scopeId) {\n        this.logger.warn(\n          `Tentativa de revogar permissão com escopo UNIT sem fornecer scopeId: userId=${userId}, permissionName=${permissionName}`,\n        );\n        return false;\n      }\n\n      // Busca a permissão pelo nome\n      const permission =\n        await this.permissionRepository.findByName(permissionName);\n      if (!permission) {\n        this.logger.warn(\n          `Tentativa de revogar permissão inexistente: permissionName=${permissionName}`,\n        );\n        return false;\n      }\n\n      // Verifica se o usuário tem a permissão\n      const existingPermission =\n        await this.userPermissionRepository.findByUserAndPermission(\n          userId,\n          permission.id,\n          scopeType,\n          scopeId || undefined,\n        );\n\n      if (!existingPermission) {\n        this.logger.warn(\n          `Tentativa de revogar permissão que o usuário não possui: userId=${userId}, permissionName=${permissionName}`,\n        );\n        return false;\n      }\n\n      // Verifica se a permissão já está revogada\n      if (existingPermission && !existingPermission.granted) {\n        this.logger.log(\n          `Permissão já está revogada: userId=${userId}, permissionName=${permissionName}`,\n        );\n        return true; // Considera sucesso, pois o estado final é o desejado\n      }\n\n      // Atualiza a permissão existente para revogada\n      await this.userPermissionRepository.updateUserPermission(\n        existingPermission.id,\n        {\n          granted: false,\n          updatedBy: createdBy,\n        },\n      );\n\n      // Limpa o cache de permissões do usuário\n      await this.clearUserPermissionCache(userId);\n\n      // Limpa o cache da permissão específica\n      await this.clearPermissionCache(permissionName);\n\n      // Registra a operação no log\n      this.logger.log(\n        `Permissão ${permissionName} revogada do usuário ${userId} com escopo ${scopeType} por ${createdBy}`,\n      );\n      return true;\n    } catch (error) {\n      this.logger.error(`Erro ao revogar permissão: ${error.message}`, {\n        userId,\n        permissionName,\n        scopeType,\n        scopeId,\n        createdBy,\n        stack: error.stack,\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Concede uma permissão a um usuário.\n   *\n   * @param userId ID do usuário\n   * @param permissionName Nome da permissão\n   * @param scopeType Tipo de escopo\n   * @param scopeId ID do escopo (opcional para escopo GLOBAL)\n   * @param validUntil Data de validade da permissão (opcional)\n   * @param createdBy ID do usuário que está concedendo a permissão\n   * @returns true se a permissão foi concedida com sucesso, false caso contrário\n   */\n  async grantPermission(\n    userId: string,\n    permissionName: string,\n    scopeType: TipoEscopo,\n    scopeId: string | null | undefined,\n    validUntil: Date | null | undefined,\n    createdBy: string,\n  ): Promise<boolean> {\n    try {\n      // Validação de parâmetros\n      if (!userId || !permissionName || !createdBy) {\n        this.logger.warn(\n          `Tentativa de conceder permissão com parâmetros inválidos: userId=${userId}, permissionName=${permissionName}, createdBy=${createdBy}`,\n        );\n        return false;\n      }\n\n      // Validação de escopo\n      if (scopeType === TipoEscopo.UNIDADE && !scopeId) {\n        this.logger.warn(\n          `Tentativa de conceder permissão com escopo UNIT sem fornecer scopeId: userId=${userId}, permissionName=${permissionName}`,\n        );\n        return false;\n      }\n\n      // Busca a permissão pelo nome\n      const permission =\n        await this.permissionRepository.findByName(permissionName);\n      if (!permission) {\n        this.logger.warn(\n          `Tentativa de conceder permissão inexistente: permissionName=${permissionName}`,\n        );\n        return false;\n      }\n\n      // Verifica se o usuário já tem a permissão\n      const existingPermission =\n        await this.userPermissionRepository.findByUserAndPermission(\n          userId,\n          permission.id,\n          scopeType,\n          scopeId || undefined,\n        );\n\n      // Se já existe e está ativa, apenas atualiza a data de validade se necessário\n      if (existingPermission && existingPermission.granted) {\n        // Verifica se precisa atualizar a data de validade\n        if (\n          validUntil &&\n          (!existingPermission.validUntil ||\n            validUntil > existingPermission.validUntil)\n        ) {\n          await this.userPermissionRepository.updateUserPermission(\n            existingPermission.id,\n            {\n              validUntil,\n              updatedBy: createdBy,\n            },\n          );\n\n          this.logger.log(\n            `Data de validade da permissão ${permissionName} atualizada para o usuário ${userId}`,\n          );\n        } else {\n          this.logger.log(\n            `Usuário ${userId} já possui a permissão ${permissionName}`,\n          );\n        }\n\n        return true;\n      }\n\n      // Se existe mas está revogada, reativa\n      if (existingPermission && !existingPermission.granted) {\n        await this.userPermissionRepository.updateUserPermission(\n          existingPermission.id,\n          {\n            granted: true,\n            validUntil: validUntil || null,\n            updatedBy: createdBy,\n          },\n        );\n\n        this.logger.log(\n          `Permissão ${permissionName} reativada para o usuário ${userId} com escopo ${scopeType} por ${createdBy}`,\n        );\n      } else {\n        // Cria uma nova permissão para o usuário\n        await this.userPermissionRepository.createUserPermission({\n          userId,\n          permissionId: permission.id,\n          scopeType,\n          scopeId: scopeId || undefined,\n          granted: true,\n          validUntil: validUntil || null,\n          createdBy,\n        });\n\n        this.logger.log(\n          `Permissão ${permissionName} concedida ao usuário ${userId} com escopo ${scopeType} por ${createdBy}`,\n        );\n      }\n\n      // Limpa o cache de permissões do usuário\n      await this.clearUserPermissionCache(userId);\n\n      // Limpa o cache da permissão específica\n      await this.clearPermissionCache(permissionName);\n\n      return true;\n    } catch (error) {\n      this.logger.error(`Erro ao conceder permissão: ${error.message}`, {\n        error: error.message,\n        stack: error.stack,\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Obtém as permissões associadas a uma role.\n   *\n   * @param roleId ID da role\n   * @returns Lista de permissões associadas à role\n   */\n  async getPermissionsByRole(roleId: string): Promise<Permission[]> {\n    try {\n      // Busca as permissões associadas à role\n      const rolePermissions =\n        await this.rolePermissionRepository.findByRoleId(roleId);\n\n      if (!rolePermissions || rolePermissions.length === 0) {\n        return [];\n      }\n\n      // Extrai os IDs das permissões\n      const permissionIds = rolePermissions.map((rp) => rp.permissionId);\n\n      // Busca os detalhes das permissões\n      return this.permissionRepository.findByIds(permissionIds);\n    } catch (error) {\n      this.logger.error(`Erro ao obter permissões da role: ${error.message}`, {\n        roleId,\n        stack: error.stack,\n      });\n      return [];\n    }\n  }\n\n  /**\n   * Obtém as permissões de role associadas a um usuário.\n   *\n   * @param userId ID do usuário\n   * @returns Lista de permissões de role do usuário\n   */\n  async getRolePermissionsByUserId(userId: string): Promise<Permission[]> {\n    try {\n      // Busca permissões de role do usuário\n      const permissions =\n        await this.rolePermissionRepository.findPermissionsByUserRoles(userId);\n\n      return permissions || [];\n    } catch (error) {\n      this.logger.error(\n        `Erro ao obter permissões de role do usuário: ${error.message}`,\n        {\n          userId,\n          stack: error.stack,\n        },\n      );\n      return [];\n    }\n  }\n}\n"],"version":3}