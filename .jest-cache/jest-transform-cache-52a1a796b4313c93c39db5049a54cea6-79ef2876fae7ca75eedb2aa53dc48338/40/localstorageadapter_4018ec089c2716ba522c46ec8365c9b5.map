{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\documento\\adapters\\local-storage.adapter.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\documento\\adapters\\local-storage.adapter.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { StorageProvider } from '../interfaces/storage-provider.interface';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\n\n/**\n * Adaptador para armazenamento de documentos no sistema de arquivos local\n *\n * Implementa a interface StorageProvider para integração com o sistema de arquivos\n */\n@Injectable()\nexport class LocalStorageAdapter implements StorageProvider {\n  readonly nome = 'Armazenamento Local';\n  private readonly logger = new Logger(LocalStorageAdapter.name);\n  private readonly baseDir: string;\n\n  constructor(private configService: ConfigService) {\n    this.baseDir = this.configService.get<string>(\n      'UPLOADS_DIR',\n      path.join(process.cwd(), 'uploads'),\n    );\n\n    // Garantir que o diretório base existe\n    if (!fs.existsSync(this.baseDir)) {\n      fs.mkdirSync(this.baseDir, { recursive: true });\n    }\n\n    this.logger.log(\n      `Adaptador de armazenamento local inicializado para diretório: ${this.baseDir}`,\n    );\n  }\n\n  /**\n   * Salva um arquivo no sistema de arquivos local\n   * @param buffer Buffer do arquivo\n   * @param nomeArquivo Nome do arquivo\n   * @param mimetype Tipo MIME do arquivo\n   * @param metadados Metadados opcionais do arquivo\n   * @returns Caminho relativo do arquivo armazenado\n   */\n  async salvarArquivo(\n    buffer: Buffer,\n    nomeArquivo: string,\n    mimetype: string,\n    metadados?: Record<string, any>,\n  ): Promise<string> {\n    try {\n      // Extrair informações dos metadados\n      const solicitacaoId = metadados?.solicitacaoId || 'default';\n      const tipoDocumento = metadados?.tipoDocumento || 'OUTRO';\n\n      // Criar estrutura de diretórios\n      const dirPath = path.join(this.baseDir, solicitacaoId, tipoDocumento);\n      if (!fs.existsSync(dirPath)) {\n        fs.mkdirSync(dirPath, { recursive: true });\n      }\n\n      // Gerar nome de arquivo único\n      const timestamp = Date.now();\n      const randomString = crypto.randomBytes(8).toString('hex');\n      const fileExtension = path.extname(nomeArquivo);\n      const fileName = `${timestamp}-${randomString}${fileExtension}`;\n\n      // Caminho completo do arquivo\n      const filePath = path.join(dirPath, fileName);\n\n      // Salvar arquivo\n      fs.writeFileSync(filePath, buffer);\n\n      // Salvar metadados em arquivo separado\n      if (metadados) {\n        const metadataPath = `${filePath}.metadata.json`;\n        fs.writeFileSync(\n          metadataPath,\n          JSON.stringify(\n            {\n              ...metadados,\n              mimetype,\n              originalName: nomeArquivo,\n              timestamp,\n            },\n            null,\n            2,\n          ),\n        );\n      }\n\n      // Retornar caminho relativo\n      const relativePath = path.join(solicitacaoId, tipoDocumento, fileName);\n      this.logger.debug(`Arquivo salvo com sucesso: ${relativePath}`);\n\n      return relativePath.replace(/\\\\/g, '/'); // Normalizar para formato de caminho com barras\n    } catch (error) {\n      this.logger.error(`Erro ao salvar arquivo: ${error.message}`);\n      throw new Error(`Erro ao salvar arquivo: ${error.message}`);\n    }\n  }\n\n  /**\n   * Obtém um arquivo do sistema de arquivos local\n   * @param caminho Caminho relativo do arquivo\n   * @returns Buffer do arquivo\n   */\n  async obterArquivo(caminho: string): Promise<Buffer> {\n    try {\n      const filePath = path.join(this.baseDir, caminho);\n\n      if (!fs.existsSync(filePath)) {\n        throw new Error(`Arquivo não encontrado: ${caminho}`);\n      }\n\n      const buffer = fs.readFileSync(filePath);\n      this.logger.debug(\n        `Arquivo obtido com sucesso: ${caminho} (${buffer.length} bytes)`,\n      );\n\n      return buffer;\n    } catch (error) {\n      this.logger.error(`Erro ao obter arquivo: ${error.message}`);\n      throw new Error(`Erro ao obter arquivo: ${error.message}`);\n    }\n  }\n\n  /**\n   * Remove um arquivo do sistema de arquivos local\n   * @param caminho Caminho relativo do arquivo\n   */\n  async removerArquivo(caminho: string): Promise<void> {\n    try {\n      const filePath = path.join(this.baseDir, caminho);\n      const metadataPath = `${filePath}.metadata.json`;\n\n      // Remover arquivo principal\n      if (fs.existsSync(filePath)) {\n        fs.unlinkSync(filePath);\n      } else {\n        this.logger.warn(`Arquivo não encontrado para remoção: ${caminho}`);\n      }\n\n      // Remover arquivo de metadados se existir\n      if (fs.existsSync(metadataPath)) {\n        fs.unlinkSync(metadataPath);\n      }\n\n      this.logger.debug(`Arquivo removido com sucesso: ${caminho}`);\n    } catch (error) {\n      this.logger.error(`Erro ao remover arquivo: ${error.message}`);\n      throw new Error(`Erro ao remover arquivo: ${error.message}`);\n    }\n  }\n\n  /**\n   * Faz upload de um arquivo para o sistema de arquivos local\n   * @param buffer Buffer do arquivo\n   * @param key Caminho relativo do arquivo\n   * @param mimetype Tipo MIME do arquivo\n   * @param metadata Metadados opcionais do arquivo\n   * @returns Caminho relativo do arquivo armazenado\n   */\n  async upload(\n    buffer: Buffer,\n    key: string,\n    mimetype: string,\n    metadata?: Record<string, any>,\n  ): Promise<string> {\n    return this.salvarArquivo(buffer, key, mimetype, metadata);\n  }\n\n  /**\n   * Faz download de um arquivo do sistema de arquivos local\n   * @param key Caminho relativo do arquivo\n   * @returns Buffer do arquivo\n   */\n  async download(key: string): Promise<Buffer> {\n    return this.obterArquivo(key);\n  }\n\n  /**\n   * Remove um arquivo do sistema de arquivos local\n   * @param key Caminho relativo do arquivo\n   */\n  async delete(key: string): Promise<void> {\n    return this.removerArquivo(key);\n  }\n\n  /**\n   * Obtém a URL de acesso a um arquivo no sistema de arquivos local\n   * @param key Caminho relativo do arquivo\n   * @param expiresIn Tempo de expiração da URL em segundos (não utilizado para armazenamento local)\n   * @returns Caminho absoluto do arquivo\n   */\n  async getUrl(key: string, expiresIn?: number): Promise<string> {\n    try {\n      const filePath = path.join(this.baseDir, key);\n\n      if (!fs.existsSync(filePath)) {\n        throw new Error(`Arquivo não encontrado: ${key}`);\n      }\n\n      // Para armazenamento local, retornamos o caminho absoluto\n      // Em um ambiente web real, isso poderia ser uma URL para um endpoint que serve o arquivo\n      const baseUrl = this.configService.get<string>(\n        'BASE_URL',\n        'http://localhost:3000',\n      );\n      return `${baseUrl}/documentos/arquivo/${key}`;\n    } catch (error) {\n      this.logger.error(`Erro ao gerar URL: ${error.message}`);\n      throw new Error(`Erro ao gerar URL: ${error.message}`);\n    }\n  }\n\n  /**\n   * Verifica se um arquivo existe no sistema de arquivos local\n   * @param key Caminho relativo do arquivo\n   * @returns true se o arquivo existe, false caso contrário\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      const filePath = path.join(this.baseDir, key);\n      return fs.existsSync(filePath);\n    } catch (error) {\n      this.logger.error(\n        `Erro ao verificar existência do arquivo: ${error.message}`,\n      );\n      throw new Error(\n        `Erro ao verificar existência do arquivo: ${error.message}`,\n      );\n    }\n  }\n\n  /**\n   * Copia um arquivo de um caminho para outro no sistema de arquivos local\n   * @param sourceKey Caminho relativo do arquivo de origem\n   * @param destinationKey Caminho relativo do arquivo de destino\n   * @returns Caminho relativo do arquivo copiado\n   */\n  async copy(sourceKey: string, destinationKey: string): Promise<string> {\n    try {\n      const sourceFilePath = path.join(this.baseDir, sourceKey);\n      const destFilePath = path.join(this.baseDir, destinationKey);\n      const sourceMetadataPath = `${sourceFilePath}.metadata.json`;\n      const destMetadataPath = `${destFilePath}.metadata.json`;\n\n      // Verificar se o arquivo de origem existe\n      if (!fs.existsSync(sourceFilePath)) {\n        throw new Error(`Arquivo de origem não encontrado: ${sourceKey}`);\n      }\n\n      // Criar diretório de destino se não existir\n      const destDir = path.dirname(destFilePath);\n      if (!fs.existsSync(destDir)) {\n        fs.mkdirSync(destDir, { recursive: true });\n      }\n\n      // Copiar arquivo\n      fs.copyFileSync(sourceFilePath, destFilePath);\n\n      // Copiar metadados se existirem\n      if (fs.existsSync(sourceMetadataPath)) {\n        fs.copyFileSync(sourceMetadataPath, destMetadataPath);\n      }\n\n      this.logger.debug(\n        `Arquivo copiado com sucesso de ${sourceKey} para ${destinationKey}`,\n      );\n\n      return destinationKey;\n    } catch (error) {\n      this.logger.error(`Erro ao copiar arquivo: ${error.message}`);\n      throw new Error(`Erro ao copiar arquivo: ${error.message}`);\n    }\n  }\n\n  /**\n   * Lista arquivos com um prefixo específico no sistema de arquivos local\n   * @param prefix Prefixo para filtrar arquivos\n   * @param maxKeys Número máximo de chaves a retornar (padrão: 1000)\n   * @returns Lista de caminhos relativos de arquivos\n   */\n  async list(prefix: string, maxKeys: number = 1000): Promise<string[]> {\n    try {\n      const prefixPath = path.join(this.baseDir, prefix);\n      const prefixDir =\n        fs.existsSync(prefixPath) && fs.statSync(prefixPath).isDirectory()\n          ? prefixPath\n          : path.dirname(prefixPath);\n\n      if (!fs.existsSync(prefixDir)) {\n        return [];\n      }\n\n      // Função recursiva para listar arquivos\n      const listFilesRecursively = (\n        dir: string,\n        basePath: string,\n        results: string[] = [],\n        depth: number = 0,\n      ): string[] => {\n        // Limitar profundidade da recursão\n        if (depth > 10 || results.length >= maxKeys) {\n          return results;\n        }\n\n        const files = fs.readdirSync(dir);\n\n        for (const file of files) {\n          if (results.length >= maxKeys) {\n            break;\n          }\n\n          const filePath = path.join(dir, file);\n          const stat = fs.statSync(filePath);\n\n          if (stat.isDirectory()) {\n            listFilesRecursively(filePath, basePath, results, depth + 1);\n          } else if (!file.endsWith('.metadata.json')) {\n            // Ignorar arquivos de metadados\n            const relativePath = path\n              .relative(this.baseDir, filePath)\n              .replace(/\\\\/g, '/');\n            if (relativePath.startsWith(prefix)) {\n              results.push(relativePath);\n            }\n          }\n        }\n\n        return results;\n      };\n\n      const results = listFilesRecursively(prefixDir, this.baseDir);\n      this.logger.debug(\n        `Encontrados ${results.length} arquivos com prefixo: ${prefix}`,\n      );\n\n      return results.slice(0, maxKeys);\n    } catch (error) {\n      this.logger.error(`Erro ao listar arquivos: ${error.message}`);\n      throw new Error(`Erro ao listar arquivos: ${error.message}`);\n    }\n  }\n}\n"],"version":3}