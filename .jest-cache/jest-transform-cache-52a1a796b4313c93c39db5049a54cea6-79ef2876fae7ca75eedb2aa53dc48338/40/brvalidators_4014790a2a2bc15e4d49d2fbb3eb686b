eff9c761c1f3b883ee8fcfef52d7fc7f
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelefoneValidator = exports.CEPValidator = exports.NISValidator = exports.CPFValidator = void 0;
exports.IsCPF = IsCPF;
exports.IsNIS = IsNIS;
exports.IsCEP = IsCEP;
exports.IsTelefone = IsTelefone;
const class_validator_1 = require("class-validator");
/**
 * Validador de CPF
 *
 * Verifica se o CPF informado é válido, incluindo cálculo dos dígitos verificadores
 */
let CPFValidator = class CPFValidator {
    validate(cpf, args) {
        if (!cpf) {
            return false;
        }
        // Remove caracteres não numéricos
        cpf = cpf.replace(/[^\d]/g, '');
        // Verifica se tem 11 dígitos
        if (cpf.length !== 11) {
            return false;
        }
        // Verifica se todos os dígitos são iguais (CPF inválido, mas passa na verificação de dígitos)
        if (/^(\d)\1{10}$/.test(cpf)) {
            return false;
        }
        // Cálculo do primeiro dígito verificador
        let soma = 0;
        for (let i = 0; i < 9; i++) {
            soma += parseInt(cpf.charAt(i)) * (10 - i);
        }
        let resto = 11 - (soma % 11);
        const dv1 = resto > 9 ? 0 : resto;
        // Cálculo do segundo dígito verificador
        soma = 0;
        for (let i = 0; i < 10; i++) {
            soma += parseInt(cpf.charAt(i)) * (11 - i);
        }
        resto = 11 - (soma % 11);
        const dv2 = resto > 9 ? 0 : resto;
        // Verifica se os dígitos verificadores estão corretos
        return dv1 === parseInt(cpf.charAt(9)) && dv2 === parseInt(cpf.charAt(10));
    }
    defaultMessage(args) {
        return 'CPF inválido';
    }
};
exports.CPFValidator = CPFValidator;
exports.CPFValidator = CPFValidator = __decorate([
    (0, class_validator_1.ValidatorConstraint)({ name: 'cpf', async: false })
], CPFValidator);
/**
 * Validador de NIS (PIS/PASEP/NIT)
 *
 * Verifica se o NIS informado é válido, incluindo cálculo do dígito verificador
 */
let NISValidator = class NISValidator {
    validate(nis, args) {
        if (!nis) {
            return false;
        }
        // Remove caracteres não numéricos
        nis = nis.replace(/[^\d]/g, '');
        // Verifica se tem 11 dígitos
        if (nis.length !== 11) {
            return false;
        }
        // Verifica se todos os dígitos são iguais (NIS inválido, mas passa na verificação de dígitos)
        if (/^(\d)\1{10}$/.test(nis)) {
            return false;
        }
        // Pesos para cálculo do dígito verificador
        const pesos = [3, 2, 9, 8, 7, 6, 5, 4, 3, 2];
        // Cálculo do dígito verificador
        let soma = 0;
        for (let i = 0; i < 10; i++) {
            soma += parseInt(nis.charAt(i)) * pesos[i];
        }
        const resto = soma % 11;
        let dv = 11 - resto;
        if (dv === 10 || dv === 11) {
            dv = 0;
        }
        // Verifica se o dígito verificador está correto
        return dv === parseInt(nis.charAt(10));
    }
    defaultMessage(args) {
        return 'NIS (PIS/PASEP/NIT) inválido';
    }
};
exports.NISValidator = NISValidator;
exports.NISValidator = NISValidator = __decorate([
    (0, class_validator_1.ValidatorConstraint)({ name: 'nis', async: false })
], NISValidator);
/**
 * Validador de CEP
 *
 * Verifica se o CEP está no formato correto (apenas validação de formato)
 */
let CEPValidator = class CEPValidator {
    validate(cep, args) {
        if (!cep) {
            return false;
        }
        // Remove caracteres não numéricos
        cep = cep.replace(/[^\d]/g, '');
        // Verifica se tem 8 dígitos
        return cep.length === 8;
    }
    defaultMessage(args) {
        return 'CEP inválido, deve conter 8 dígitos';
    }
};
exports.CEPValidator = CEPValidator;
exports.CEPValidator = CEPValidator = __decorate([
    (0, class_validator_1.ValidatorConstraint)({ name: 'cep', async: false })
], CEPValidator);
/**
 * Validador de telefone brasileiro
 *
 * Verifica se o telefone está em um formato válido para Brasil
 */
let TelefoneValidator = class TelefoneValidator {
    validate(telefone, args) {
        if (!telefone) {
            return false;
        }
        // Remove caracteres não numéricos
        telefone = telefone.replace(/[^\d]/g, '');
        // Verifica se tem entre 10 e 11 dígitos (com DDD)
        return telefone.length >= 10 && telefone.length <= 11;
    }
    defaultMessage(args) {
        return 'Telefone inválido, deve conter DDD + número (10 ou 11 dígitos no total)';
    }
};
exports.TelefoneValidator = TelefoneValidator;
exports.TelefoneValidator = TelefoneValidator = __decorate([
    (0, class_validator_1.ValidatorConstraint)({ name: 'telefone', async: false })
], TelefoneValidator);
/**
 * Decorator para validação de CPF
 */
function IsCPF(validationOptions) {
    return function (object, propertyName) {
        (0, class_validator_1.registerDecorator)({
            name: 'isCPF',
            target: object.constructor,
            propertyName: propertyName,
            options: validationOptions,
            constraints: [],
            validator: CPFValidator,
        });
    };
}
/**
 * Decorator para validação de NIS
 */
function IsNIS(validationOptions) {
    return function (object, propertyName) {
        (0, class_validator_1.registerDecorator)({
            name: 'isNIS',
            target: object.constructor,
            propertyName: propertyName,
            options: validationOptions,
            constraints: [],
            validator: NISValidator,
        });
    };
}
/**
 * Decorator para validação de CEP
 */
function IsCEP(validationOptions) {
    return function (object, propertyName) {
        (0, class_validator_1.registerDecorator)({
            name: 'isCEP',
            target: object.constructor,
            propertyName: propertyName,
            options: validationOptions,
            constraints: [],
            validator: CEPValidator,
        });
    };
}
/**
 * Decorator para validação de telefone brasileiro
 */
function IsTelefone(validationOptions) {
    return function (object, propertyName) {
        (0, class_validator_1.registerDecorator)({
            name: 'isTelefone',
            target: object.constructor,
            propertyName: propertyName,
            options: validationOptions,
            constraints: [],
            validator: TelefoneValidator,
        });
    };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXHNoYXJlZFxcdmFsaWRhdG9yc1xcYnItdmFsaWRhdG9ycy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUE2SkEsc0JBV0M7QUFLRCxzQkFXQztBQUtELHNCQVdDO0FBS0QsZ0NBV0M7QUF4TkQscURBTXlCO0FBRXpCOzs7O0dBSUc7QUFFSSxJQUFNLFlBQVksR0FBbEIsTUFBTSxZQUFZO0lBQ3ZCLFFBQVEsQ0FBQyxHQUFXLEVBQUUsSUFBeUI7UUFDN0MsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ1QsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBRUQsa0NBQWtDO1FBQ2xDLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVoQyw2QkFBNkI7UUFDN0IsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLEVBQUUsRUFBRSxDQUFDO1lBQ3RCLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUVELDhGQUE4RjtRQUM5RixJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUM3QixPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCx5Q0FBeUM7UUFDekMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ2IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQzNCLElBQUksSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzdDLENBQUM7UUFDRCxJQUFJLEtBQUssR0FBRyxFQUFFLEdBQUcsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDN0IsTUFBTSxHQUFHLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFFbEMsd0NBQXdDO1FBQ3hDLElBQUksR0FBRyxDQUFDLENBQUM7UUFDVCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDNUIsSUFBSSxJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDN0MsQ0FBQztRQUNELEtBQUssR0FBRyxFQUFFLEdBQUcsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDekIsTUFBTSxHQUFHLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFFbEMsc0RBQXNEO1FBQ3RELE9BQU8sR0FBRyxLQUFLLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxLQUFLLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDN0UsQ0FBQztJQUVELGNBQWMsQ0FBQyxJQUF5QjtRQUN0QyxPQUFPLGNBQWMsQ0FBQztJQUN4QixDQUFDO0NBQ0YsQ0FBQTtBQTFDWSxvQ0FBWTt1QkFBWixZQUFZO0lBRHhCLElBQUEscUNBQW1CLEVBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQztHQUN0QyxZQUFZLENBMEN4QjtBQUVEOzs7O0dBSUc7QUFFSSxJQUFNLFlBQVksR0FBbEIsTUFBTSxZQUFZO0lBQ3ZCLFFBQVEsQ0FBQyxHQUFXLEVBQUUsSUFBeUI7UUFDN0MsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ1QsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBRUQsa0NBQWtDO1FBQ2xDLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVoQyw2QkFBNkI7UUFDN0IsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLEVBQUUsRUFBRSxDQUFDO1lBQ3RCLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUVELDhGQUE4RjtRQUM5RixJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUM3QixPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCwyQ0FBMkM7UUFDM0MsTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUU3QyxnQ0FBZ0M7UUFDaEMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ2IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQzVCLElBQUksSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3QyxDQUFDO1FBQ0QsTUFBTSxLQUFLLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUN4QixJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUM7WUFDM0IsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNULENBQUM7UUFFRCxnREFBZ0Q7UUFDaEQsT0FBTyxFQUFFLEtBQUssUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQsY0FBYyxDQUFDLElBQXlCO1FBQ3RDLE9BQU8sOEJBQThCLENBQUM7SUFDeEMsQ0FBQztDQUNGLENBQUE7QUF4Q1ksb0NBQVk7dUJBQVosWUFBWTtJQUR4QixJQUFBLHFDQUFtQixFQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUM7R0FDdEMsWUFBWSxDQXdDeEI7QUFFRDs7OztHQUlHO0FBRUksSUFBTSxZQUFZLEdBQWxCLE1BQU0sWUFBWTtJQUN2QixRQUFRLENBQUMsR0FBVyxFQUFFLElBQXlCO1FBQzdDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNULE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUVELGtDQUFrQztRQUNsQyxHQUFHLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFaEMsNEJBQTRCO1FBQzVCLE9BQU8sR0FBRyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVELGNBQWMsQ0FBQyxJQUF5QjtRQUN0QyxPQUFPLHFDQUFxQyxDQUFDO0lBQy9DLENBQUM7Q0FDRixDQUFBO0FBaEJZLG9DQUFZO3VCQUFaLFlBQVk7SUFEeEIsSUFBQSxxQ0FBbUIsRUFBQyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDO0dBQ3RDLFlBQVksQ0FnQnhCO0FBRUQ7Ozs7R0FJRztBQUVJLElBQU0saUJBQWlCLEdBQXZCLE1BQU0saUJBQWlCO0lBQzVCLFFBQVEsQ0FBQyxRQUFnQixFQUFFLElBQXlCO1FBQ2xELElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNkLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUVELGtDQUFrQztRQUNsQyxRQUFRLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFMUMsa0RBQWtEO1FBQ2xELE9BQU8sUUFBUSxDQUFDLE1BQU0sSUFBSSxFQUFFLElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDeEQsQ0FBQztJQUVELGNBQWMsQ0FBQyxJQUF5QjtRQUN0QyxPQUFPLHlFQUF5RSxDQUFDO0lBQ25GLENBQUM7Q0FDRixDQUFBO0FBaEJZLDhDQUFpQjs0QkFBakIsaUJBQWlCO0lBRDdCLElBQUEscUNBQW1CLEVBQUMsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQztHQUMzQyxpQkFBaUIsQ0FnQjdCO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixLQUFLLENBQUMsaUJBQXFDO0lBQ3pELE9BQU8sVUFBVSxNQUFjLEVBQUUsWUFBb0I7UUFDbkQsSUFBQSxtQ0FBaUIsRUFBQztZQUNoQixJQUFJLEVBQUUsT0FBTztZQUNiLE1BQU0sRUFBRSxNQUFNLENBQUMsV0FBVztZQUMxQixZQUFZLEVBQUUsWUFBWTtZQUMxQixPQUFPLEVBQUUsaUJBQWlCO1lBQzFCLFdBQVcsRUFBRSxFQUFFO1lBQ2YsU0FBUyxFQUFFLFlBQVk7U0FDeEIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsS0FBSyxDQUFDLGlCQUFxQztJQUN6RCxPQUFPLFVBQVUsTUFBYyxFQUFFLFlBQW9CO1FBQ25ELElBQUEsbUNBQWlCLEVBQUM7WUFDaEIsSUFBSSxFQUFFLE9BQU87WUFDYixNQUFNLEVBQUUsTUFBTSxDQUFDLFdBQVc7WUFDMUIsWUFBWSxFQUFFLFlBQVk7WUFDMUIsT0FBTyxFQUFFLGlCQUFpQjtZQUMxQixXQUFXLEVBQUUsRUFBRTtZQUNmLFNBQVMsRUFBRSxZQUFZO1NBQ3hCLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLEtBQUssQ0FBQyxpQkFBcUM7SUFDekQsT0FBTyxVQUFVLE1BQWMsRUFBRSxZQUFvQjtRQUNuRCxJQUFBLG1DQUFpQixFQUFDO1lBQ2hCLElBQUksRUFBRSxPQUFPO1lBQ2IsTUFBTSxFQUFFLE1BQU0sQ0FBQyxXQUFXO1lBQzFCLFlBQVksRUFBRSxZQUFZO1lBQzFCLE9BQU8sRUFBRSxpQkFBaUI7WUFDMUIsV0FBVyxFQUFFLEVBQUU7WUFDZixTQUFTLEVBQUUsWUFBWTtTQUN4QixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixVQUFVLENBQUMsaUJBQXFDO0lBQzlELE9BQU8sVUFBVSxNQUFjLEVBQUUsWUFBb0I7UUFDbkQsSUFBQSxtQ0FBaUIsRUFBQztZQUNoQixJQUFJLEVBQUUsWUFBWTtZQUNsQixNQUFNLEVBQUUsTUFBTSxDQUFDLFdBQVc7WUFDMUIsWUFBWSxFQUFFLFlBQVk7WUFDMUIsT0FBTyxFQUFFLGlCQUFpQjtZQUMxQixXQUFXLEVBQUUsRUFBRTtZQUNmLFNBQVMsRUFBRSxpQkFBaUI7U0FDN0IsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBQ0osQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcc2hhcmVkXFx2YWxpZGF0b3JzXFxici12YWxpZGF0b3JzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFZhbGlkYXRvckNvbnN0cmFpbnQsXG4gIFZhbGlkYXRvckNvbnN0cmFpbnRJbnRlcmZhY2UsXG4gIFZhbGlkYXRpb25Bcmd1bWVudHMsXG4gIFZhbGlkYXRpb25PcHRpb25zLFxuICByZWdpc3RlckRlY29yYXRvcixcbn0gZnJvbSAnY2xhc3MtdmFsaWRhdG9yJztcblxuLyoqXG4gKiBWYWxpZGFkb3IgZGUgQ1BGXG4gKlxuICogVmVyaWZpY2Egc2UgbyBDUEYgaW5mb3JtYWRvIMOpIHbDoWxpZG8sIGluY2x1aW5kbyBjw6FsY3VsbyBkb3MgZMOtZ2l0b3MgdmVyaWZpY2Fkb3Jlc1xuICovXG5AVmFsaWRhdG9yQ29uc3RyYWludCh7IG5hbWU6ICdjcGYnLCBhc3luYzogZmFsc2UgfSlcbmV4cG9ydCBjbGFzcyBDUEZWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3JDb25zdHJhaW50SW50ZXJmYWNlIHtcbiAgdmFsaWRhdGUoY3BmOiBzdHJpbmcsIGFyZ3M6IFZhbGlkYXRpb25Bcmd1bWVudHMpIHtcbiAgICBpZiAoIWNwZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBjYXJhY3RlcmVzIG7Do28gbnVtw6lyaWNvc1xuICAgIGNwZiA9IGNwZi5yZXBsYWNlKC9bXlxcZF0vZywgJycpO1xuXG4gICAgLy8gVmVyaWZpY2Egc2UgdGVtIDExIGTDrWdpdG9zXG4gICAgaWYgKGNwZi5sZW5ndGggIT09IDExKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZpY2Egc2UgdG9kb3Mgb3MgZMOtZ2l0b3Mgc8OjbyBpZ3VhaXMgKENQRiBpbnbDoWxpZG8sIG1hcyBwYXNzYSBuYSB2ZXJpZmljYcOnw6NvIGRlIGTDrWdpdG9zKVxuICAgIGlmICgvXihcXGQpXFwxezEwfSQvLnRlc3QoY3BmKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEPDoWxjdWxvIGRvIHByaW1laXJvIGTDrWdpdG8gdmVyaWZpY2Fkb3JcbiAgICBsZXQgc29tYSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICAgIHNvbWEgKz0gcGFyc2VJbnQoY3BmLmNoYXJBdChpKSkgKiAoMTAgLSBpKTtcbiAgICB9XG4gICAgbGV0IHJlc3RvID0gMTEgLSAoc29tYSAlIDExKTtcbiAgICBjb25zdCBkdjEgPSByZXN0byA+IDkgPyAwIDogcmVzdG87XG5cbiAgICAvLyBDw6FsY3VsbyBkbyBzZWd1bmRvIGTDrWdpdG8gdmVyaWZpY2Fkb3JcbiAgICBzb21hID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgIHNvbWEgKz0gcGFyc2VJbnQoY3BmLmNoYXJBdChpKSkgKiAoMTEgLSBpKTtcbiAgICB9XG4gICAgcmVzdG8gPSAxMSAtIChzb21hICUgMTEpO1xuICAgIGNvbnN0IGR2MiA9IHJlc3RvID4gOSA/IDAgOiByZXN0bztcblxuICAgIC8vIFZlcmlmaWNhIHNlIG9zIGTDrWdpdG9zIHZlcmlmaWNhZG9yZXMgZXN0w6NvIGNvcnJldG9zXG4gICAgcmV0dXJuIGR2MSA9PT0gcGFyc2VJbnQoY3BmLmNoYXJBdCg5KSkgJiYgZHYyID09PSBwYXJzZUludChjcGYuY2hhckF0KDEwKSk7XG4gIH1cblxuICBkZWZhdWx0TWVzc2FnZShhcmdzOiBWYWxpZGF0aW9uQXJndW1lbnRzKSB7XG4gICAgcmV0dXJuICdDUEYgaW52w6FsaWRvJztcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYWRvciBkZSBOSVMgKFBJUy9QQVNFUC9OSVQpXG4gKlxuICogVmVyaWZpY2Egc2UgbyBOSVMgaW5mb3JtYWRvIMOpIHbDoWxpZG8sIGluY2x1aW5kbyBjw6FsY3VsbyBkbyBkw61naXRvIHZlcmlmaWNhZG9yXG4gKi9cbkBWYWxpZGF0b3JDb25zdHJhaW50KHsgbmFtZTogJ25pcycsIGFzeW5jOiBmYWxzZSB9KVxuZXhwb3J0IGNsYXNzIE5JU1ZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvckNvbnN0cmFpbnRJbnRlcmZhY2Uge1xuICB2YWxpZGF0ZShuaXM6IHN0cmluZywgYXJnczogVmFsaWRhdGlvbkFyZ3VtZW50cykge1xuICAgIGlmICghbmlzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGNhcmFjdGVyZXMgbsOjbyBudW3DqXJpY29zXG4gICAgbmlzID0gbmlzLnJlcGxhY2UoL1teXFxkXS9nLCAnJyk7XG5cbiAgICAvLyBWZXJpZmljYSBzZSB0ZW0gMTEgZMOtZ2l0b3NcbiAgICBpZiAobmlzLmxlbmd0aCAhPT0gMTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZmljYSBzZSB0b2RvcyBvcyBkw61naXRvcyBzw6NvIGlndWFpcyAoTklTIGludsOhbGlkbywgbWFzIHBhc3NhIG5hIHZlcmlmaWNhw6fDo28gZGUgZMOtZ2l0b3MpXG4gICAgaWYgKC9eKFxcZClcXDF7MTB9JC8udGVzdChuaXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUGVzb3MgcGFyYSBjw6FsY3VsbyBkbyBkw61naXRvIHZlcmlmaWNhZG9yXG4gICAgY29uc3QgcGVzb3MgPSBbMywgMiwgOSwgOCwgNywgNiwgNSwgNCwgMywgMl07XG5cbiAgICAvLyBDw6FsY3VsbyBkbyBkw61naXRvIHZlcmlmaWNhZG9yXG4gICAgbGV0IHNvbWEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgc29tYSArPSBwYXJzZUludChuaXMuY2hhckF0KGkpKSAqIHBlc29zW2ldO1xuICAgIH1cbiAgICBjb25zdCByZXN0byA9IHNvbWEgJSAxMTtcbiAgICBsZXQgZHYgPSAxMSAtIHJlc3RvO1xuICAgIGlmIChkdiA9PT0gMTAgfHwgZHYgPT09IDExKSB7XG4gICAgICBkdiA9IDA7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZpY2Egc2UgbyBkw61naXRvIHZlcmlmaWNhZG9yIGVzdMOhIGNvcnJldG9cbiAgICByZXR1cm4gZHYgPT09IHBhcnNlSW50KG5pcy5jaGFyQXQoMTApKTtcbiAgfVxuXG4gIGRlZmF1bHRNZXNzYWdlKGFyZ3M6IFZhbGlkYXRpb25Bcmd1bWVudHMpIHtcbiAgICByZXR1cm4gJ05JUyAoUElTL1BBU0VQL05JVCkgaW52w6FsaWRvJztcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYWRvciBkZSBDRVBcbiAqXG4gKiBWZXJpZmljYSBzZSBvIENFUCBlc3TDoSBubyBmb3JtYXRvIGNvcnJldG8gKGFwZW5hcyB2YWxpZGHDp8OjbyBkZSBmb3JtYXRvKVxuICovXG5AVmFsaWRhdG9yQ29uc3RyYWludCh7IG5hbWU6ICdjZXAnLCBhc3luYzogZmFsc2UgfSlcbmV4cG9ydCBjbGFzcyBDRVBWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3JDb25zdHJhaW50SW50ZXJmYWNlIHtcbiAgdmFsaWRhdGUoY2VwOiBzdHJpbmcsIGFyZ3M6IFZhbGlkYXRpb25Bcmd1bWVudHMpIHtcbiAgICBpZiAoIWNlcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBjYXJhY3RlcmVzIG7Do28gbnVtw6lyaWNvc1xuICAgIGNlcCA9IGNlcC5yZXBsYWNlKC9bXlxcZF0vZywgJycpO1xuXG4gICAgLy8gVmVyaWZpY2Egc2UgdGVtIDggZMOtZ2l0b3NcbiAgICByZXR1cm4gY2VwLmxlbmd0aCA9PT0gODtcbiAgfVxuXG4gIGRlZmF1bHRNZXNzYWdlKGFyZ3M6IFZhbGlkYXRpb25Bcmd1bWVudHMpIHtcbiAgICByZXR1cm4gJ0NFUCBpbnbDoWxpZG8sIGRldmUgY29udGVyIDggZMOtZ2l0b3MnO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhZG9yIGRlIHRlbGVmb25lIGJyYXNpbGVpcm9cbiAqXG4gKiBWZXJpZmljYSBzZSBvIHRlbGVmb25lIGVzdMOhIGVtIHVtIGZvcm1hdG8gdsOhbGlkbyBwYXJhIEJyYXNpbFxuICovXG5AVmFsaWRhdG9yQ29uc3RyYWludCh7IG5hbWU6ICd0ZWxlZm9uZScsIGFzeW5jOiBmYWxzZSB9KVxuZXhwb3J0IGNsYXNzIFRlbGVmb25lVmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yQ29uc3RyYWludEludGVyZmFjZSB7XG4gIHZhbGlkYXRlKHRlbGVmb25lOiBzdHJpbmcsIGFyZ3M6IFZhbGlkYXRpb25Bcmd1bWVudHMpIHtcbiAgICBpZiAoIXRlbGVmb25lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGNhcmFjdGVyZXMgbsOjbyBudW3DqXJpY29zXG4gICAgdGVsZWZvbmUgPSB0ZWxlZm9uZS5yZXBsYWNlKC9bXlxcZF0vZywgJycpO1xuXG4gICAgLy8gVmVyaWZpY2Egc2UgdGVtIGVudHJlIDEwIGUgMTEgZMOtZ2l0b3MgKGNvbSBEREQpXG4gICAgcmV0dXJuIHRlbGVmb25lLmxlbmd0aCA+PSAxMCAmJiB0ZWxlZm9uZS5sZW5ndGggPD0gMTE7XG4gIH1cblxuICBkZWZhdWx0TWVzc2FnZShhcmdzOiBWYWxpZGF0aW9uQXJndW1lbnRzKSB7XG4gICAgcmV0dXJuICdUZWxlZm9uZSBpbnbDoWxpZG8sIGRldmUgY29udGVyIERERCArIG7Dum1lcm8gKDEwIG91IDExIGTDrWdpdG9zIG5vIHRvdGFsKSc7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNvcmF0b3IgcGFyYSB2YWxpZGHDp8OjbyBkZSBDUEZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIElzQ1BGKHZhbGlkYXRpb25PcHRpb25zPzogVmFsaWRhdGlvbk9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3Q6IG9iamVjdCwgcHJvcGVydHlOYW1lOiBzdHJpbmcpIHtcbiAgICByZWdpc3RlckRlY29yYXRvcih7XG4gICAgICBuYW1lOiAnaXNDUEYnLFxuICAgICAgdGFyZ2V0OiBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgIG9wdGlvbnM6IHZhbGlkYXRpb25PcHRpb25zLFxuICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgdmFsaWRhdG9yOiBDUEZWYWxpZGF0b3IsXG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIHBhcmEgdmFsaWRhw6fDo28gZGUgTklTXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBJc05JUyh2YWxpZGF0aW9uT3B0aW9ucz86IFZhbGlkYXRpb25PcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqZWN0OiBvYmplY3QsIHByb3BlcnR5TmFtZTogc3RyaW5nKSB7XG4gICAgcmVnaXN0ZXJEZWNvcmF0b3Ioe1xuICAgICAgbmFtZTogJ2lzTklTJyxcbiAgICAgIHRhcmdldDogb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgICBvcHRpb25zOiB2YWxpZGF0aW9uT3B0aW9ucyxcbiAgICAgIGNvbnN0cmFpbnRzOiBbXSxcbiAgICAgIHZhbGlkYXRvcjogTklTVmFsaWRhdG9yLFxuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIERlY29yYXRvciBwYXJhIHZhbGlkYcOnw6NvIGRlIENFUFxuICovXG5leHBvcnQgZnVuY3Rpb24gSXNDRVAodmFsaWRhdGlvbk9wdGlvbnM/OiBWYWxpZGF0aW9uT3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdDogb2JqZWN0LCBwcm9wZXJ0eU5hbWU6IHN0cmluZykge1xuICAgIHJlZ2lzdGVyRGVjb3JhdG9yKHtcbiAgICAgIG5hbWU6ICdpc0NFUCcsXG4gICAgICB0YXJnZXQ6IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxuICAgICAgb3B0aW9uczogdmFsaWRhdGlvbk9wdGlvbnMsXG4gICAgICBjb25zdHJhaW50czogW10sXG4gICAgICB2YWxpZGF0b3I6IENFUFZhbGlkYXRvcixcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvcmF0b3IgcGFyYSB2YWxpZGHDp8OjbyBkZSB0ZWxlZm9uZSBicmFzaWxlaXJvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBJc1RlbGVmb25lKHZhbGlkYXRpb25PcHRpb25zPzogVmFsaWRhdGlvbk9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3Q6IG9iamVjdCwgcHJvcGVydHlOYW1lOiBzdHJpbmcpIHtcbiAgICByZWdpc3RlckRlY29yYXRvcih7XG4gICAgICBuYW1lOiAnaXNUZWxlZm9uZScsXG4gICAgICB0YXJnZXQ6IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxuICAgICAgb3B0aW9uczogdmFsaWRhdGlvbk9wdGlvbnMsXG4gICAgICBjb25zdHJhaW50czogW10sXG4gICAgICB2YWxpZGF0b3I6IFRlbGVmb25lVmFsaWRhdG9yLFxuICAgIH0pO1xuICB9O1xufVxuIl0sInZlcnNpb24iOjN9