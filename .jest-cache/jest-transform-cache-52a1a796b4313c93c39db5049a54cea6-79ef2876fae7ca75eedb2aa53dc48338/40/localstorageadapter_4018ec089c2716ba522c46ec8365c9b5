41753e42a79eba612791e1903dd1763b
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var LocalStorageAdapter_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStorageAdapter = void 0;
const common_1 = require("@nestjs/common");
const config_1 = require("@nestjs/config");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const crypto = __importStar(require("crypto"));
/**
 * Adaptador para armazenamento de documentos no sistema de arquivos local
 *
 * Implementa a interface StorageProvider para integração com o sistema de arquivos
 */
let LocalStorageAdapter = LocalStorageAdapter_1 = class LocalStorageAdapter {
    configService;
    nome = 'Armazenamento Local';
    logger = new common_1.Logger(LocalStorageAdapter_1.name);
    baseDir;
    constructor(configService) {
        this.configService = configService;
        this.baseDir = this.configService.get('UPLOADS_DIR', path.join(process.cwd(), 'uploads'));
        // Garantir que o diretório base existe
        if (!fs.existsSync(this.baseDir)) {
            fs.mkdirSync(this.baseDir, { recursive: true });
        }
        this.logger.log(`Adaptador de armazenamento local inicializado para diretório: ${this.baseDir}`);
    }
    /**
     * Salva um arquivo no sistema de arquivos local
     * @param buffer Buffer do arquivo
     * @param nomeArquivo Nome do arquivo
     * @param mimetype Tipo MIME do arquivo
     * @param metadados Metadados opcionais do arquivo
     * @returns Caminho relativo do arquivo armazenado
     */
    async salvarArquivo(buffer, nomeArquivo, mimetype, metadados) {
        try {
            // Extrair informações dos metadados
            const solicitacaoId = metadados?.solicitacaoId || 'default';
            const tipoDocumento = metadados?.tipoDocumento || 'OUTRO';
            // Criar estrutura de diretórios
            const dirPath = path.join(this.baseDir, solicitacaoId, tipoDocumento);
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath, { recursive: true });
            }
            // Gerar nome de arquivo único
            const timestamp = Date.now();
            const randomString = crypto.randomBytes(8).toString('hex');
            const fileExtension = path.extname(nomeArquivo);
            const fileName = `${timestamp}-${randomString}${fileExtension}`;
            // Caminho completo do arquivo
            const filePath = path.join(dirPath, fileName);
            // Salvar arquivo
            fs.writeFileSync(filePath, buffer);
            // Salvar metadados em arquivo separado
            if (metadados) {
                const metadataPath = `${filePath}.metadata.json`;
                fs.writeFileSync(metadataPath, JSON.stringify({
                    ...metadados,
                    mimetype,
                    originalName: nomeArquivo,
                    timestamp,
                }, null, 2));
            }
            // Retornar caminho relativo
            const relativePath = path.join(solicitacaoId, tipoDocumento, fileName);
            this.logger.debug(`Arquivo salvo com sucesso: ${relativePath}`);
            return relativePath.replace(/\\/g, '/'); // Normalizar para formato de caminho com barras
        }
        catch (error) {
            this.logger.error(`Erro ao salvar arquivo: ${error.message}`);
            throw new Error(`Erro ao salvar arquivo: ${error.message}`);
        }
    }
    /**
     * Obtém um arquivo do sistema de arquivos local
     * @param caminho Caminho relativo do arquivo
     * @returns Buffer do arquivo
     */
    async obterArquivo(caminho) {
        try {
            const filePath = path.join(this.baseDir, caminho);
            if (!fs.existsSync(filePath)) {
                throw new Error(`Arquivo não encontrado: ${caminho}`);
            }
            const buffer = fs.readFileSync(filePath);
            this.logger.debug(`Arquivo obtido com sucesso: ${caminho} (${buffer.length} bytes)`);
            return buffer;
        }
        catch (error) {
            this.logger.error(`Erro ao obter arquivo: ${error.message}`);
            throw new Error(`Erro ao obter arquivo: ${error.message}`);
        }
    }
    /**
     * Remove um arquivo do sistema de arquivos local
     * @param caminho Caminho relativo do arquivo
     */
    async removerArquivo(caminho) {
        try {
            const filePath = path.join(this.baseDir, caminho);
            const metadataPath = `${filePath}.metadata.json`;
            // Remover arquivo principal
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
            }
            else {
                this.logger.warn(`Arquivo não encontrado para remoção: ${caminho}`);
            }
            // Remover arquivo de metadados se existir
            if (fs.existsSync(metadataPath)) {
                fs.unlinkSync(metadataPath);
            }
            this.logger.debug(`Arquivo removido com sucesso: ${caminho}`);
        }
        catch (error) {
            this.logger.error(`Erro ao remover arquivo: ${error.message}`);
            throw new Error(`Erro ao remover arquivo: ${error.message}`);
        }
    }
    /**
     * Faz upload de um arquivo para o sistema de arquivos local
     * @param buffer Buffer do arquivo
     * @param key Caminho relativo do arquivo
     * @param mimetype Tipo MIME do arquivo
     * @param metadata Metadados opcionais do arquivo
     * @returns Caminho relativo do arquivo armazenado
     */
    async upload(buffer, key, mimetype, metadata) {
        return this.salvarArquivo(buffer, key, mimetype, metadata);
    }
    /**
     * Faz download de um arquivo do sistema de arquivos local
     * @param key Caminho relativo do arquivo
     * @returns Buffer do arquivo
     */
    async download(key) {
        return this.obterArquivo(key);
    }
    /**
     * Remove um arquivo do sistema de arquivos local
     * @param key Caminho relativo do arquivo
     */
    async delete(key) {
        return this.removerArquivo(key);
    }
    /**
     * Obtém a URL de acesso a um arquivo no sistema de arquivos local
     * @param key Caminho relativo do arquivo
     * @param expiresIn Tempo de expiração da URL em segundos (não utilizado para armazenamento local)
     * @returns Caminho absoluto do arquivo
     */
    async getUrl(key, expiresIn) {
        try {
            const filePath = path.join(this.baseDir, key);
            if (!fs.existsSync(filePath)) {
                throw new Error(`Arquivo não encontrado: ${key}`);
            }
            // Para armazenamento local, retornamos o caminho absoluto
            // Em um ambiente web real, isso poderia ser uma URL para um endpoint que serve o arquivo
            const baseUrl = this.configService.get('BASE_URL', 'http://localhost:3000');
            return `${baseUrl}/documentos/arquivo/${key}`;
        }
        catch (error) {
            this.logger.error(`Erro ao gerar URL: ${error.message}`);
            throw new Error(`Erro ao gerar URL: ${error.message}`);
        }
    }
    /**
     * Verifica se um arquivo existe no sistema de arquivos local
     * @param key Caminho relativo do arquivo
     * @returns true se o arquivo existe, false caso contrário
     */
    async exists(key) {
        try {
            const filePath = path.join(this.baseDir, key);
            return fs.existsSync(filePath);
        }
        catch (error) {
            this.logger.error(`Erro ao verificar existência do arquivo: ${error.message}`);
            throw new Error(`Erro ao verificar existência do arquivo: ${error.message}`);
        }
    }
    /**
     * Copia um arquivo de um caminho para outro no sistema de arquivos local
     * @param sourceKey Caminho relativo do arquivo de origem
     * @param destinationKey Caminho relativo do arquivo de destino
     * @returns Caminho relativo do arquivo copiado
     */
    async copy(sourceKey, destinationKey) {
        try {
            const sourceFilePath = path.join(this.baseDir, sourceKey);
            const destFilePath = path.join(this.baseDir, destinationKey);
            const sourceMetadataPath = `${sourceFilePath}.metadata.json`;
            const destMetadataPath = `${destFilePath}.metadata.json`;
            // Verificar se o arquivo de origem existe
            if (!fs.existsSync(sourceFilePath)) {
                throw new Error(`Arquivo de origem não encontrado: ${sourceKey}`);
            }
            // Criar diretório de destino se não existir
            const destDir = path.dirname(destFilePath);
            if (!fs.existsSync(destDir)) {
                fs.mkdirSync(destDir, { recursive: true });
            }
            // Copiar arquivo
            fs.copyFileSync(sourceFilePath, destFilePath);
            // Copiar metadados se existirem
            if (fs.existsSync(sourceMetadataPath)) {
                fs.copyFileSync(sourceMetadataPath, destMetadataPath);
            }
            this.logger.debug(`Arquivo copiado com sucesso de ${sourceKey} para ${destinationKey}`);
            return destinationKey;
        }
        catch (error) {
            this.logger.error(`Erro ao copiar arquivo: ${error.message}`);
            throw new Error(`Erro ao copiar arquivo: ${error.message}`);
        }
    }
    /**
     * Lista arquivos com um prefixo específico no sistema de arquivos local
     * @param prefix Prefixo para filtrar arquivos
     * @param maxKeys Número máximo de chaves a retornar (padrão: 1000)
     * @returns Lista de caminhos relativos de arquivos
     */
    async list(prefix, maxKeys = 1000) {
        try {
            const prefixPath = path.join(this.baseDir, prefix);
            const prefixDir = fs.existsSync(prefixPath) && fs.statSync(prefixPath).isDirectory()
                ? prefixPath
                : path.dirname(prefixPath);
            if (!fs.existsSync(prefixDir)) {
                return [];
            }
            // Função recursiva para listar arquivos
            const listFilesRecursively = (dir, basePath, results = [], depth = 0) => {
                // Limitar profundidade da recursão
                if (depth > 10 || results.length >= maxKeys) {
                    return results;
                }
                const files = fs.readdirSync(dir);
                for (const file of files) {
                    if (results.length >= maxKeys) {
                        break;
                    }
                    const filePath = path.join(dir, file);
                    const stat = fs.statSync(filePath);
                    if (stat.isDirectory()) {
                        listFilesRecursively(filePath, basePath, results, depth + 1);
                    }
                    else if (!file.endsWith('.metadata.json')) {
                        // Ignorar arquivos de metadados
                        const relativePath = path
                            .relative(this.baseDir, filePath)
                            .replace(/\\/g, '/');
                        if (relativePath.startsWith(prefix)) {
                            results.push(relativePath);
                        }
                    }
                }
                return results;
            };
            const results = listFilesRecursively(prefixDir, this.baseDir);
            this.logger.debug(`Encontrados ${results.length} arquivos com prefixo: ${prefix}`);
            return results.slice(0, maxKeys);
        }
        catch (error) {
            this.logger.error(`Erro ao listar arquivos: ${error.message}`);
            throw new Error(`Erro ao listar arquivos: ${error.message}`);
        }
    }
};
exports.LocalStorageAdapter = LocalStorageAdapter;
exports.LocalStorageAdapter = LocalStorageAdapter = LocalStorageAdapter_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], LocalStorageAdapter);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXGRvY3VtZW50b1xcYWRhcHRlcnNcXGxvY2FsLXN0b3JhZ2UuYWRhcHRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUFvRDtBQUNwRCwyQ0FBK0M7QUFFL0MsdUNBQXlCO0FBQ3pCLDJDQUE2QjtBQUM3QiwrQ0FBaUM7QUFFakM7Ozs7R0FJRztBQUVJLElBQU0sbUJBQW1CLDJCQUF6QixNQUFNLG1CQUFtQjtJQUtWO0lBSlgsSUFBSSxHQUFHLHFCQUFxQixDQUFDO0lBQ3JCLE1BQU0sR0FBRyxJQUFJLGVBQU0sQ0FBQyxxQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QyxPQUFPLENBQVM7SUFFakMsWUFBb0IsYUFBNEI7UUFBNUIsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDOUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FDbkMsYUFBYSxFQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUNwQyxDQUFDO1FBRUYsdUNBQXVDO1FBQ3ZDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQ2pDLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ2xELENBQUM7UUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FDYixpRUFBaUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUNoRixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsYUFBYSxDQUNqQixNQUFjLEVBQ2Qs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OltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZXVkcmVcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxtb2R1bGVzXFxkb2N1bWVudG9cXGFkYXB0ZXJzXFxsb2NhbC1zdG9yYWdlLmFkYXB0ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTG9nZ2VyIH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xuaW1wb3J0IHsgQ29uZmlnU2VydmljZSB9IGZyb20gJ0BuZXN0anMvY29uZmlnJztcbmltcG9ydCB7IFN0b3JhZ2VQcm92aWRlciB9IGZyb20gJy4uL2ludGVyZmFjZXMvc3RvcmFnZS1wcm92aWRlci5pbnRlcmZhY2UnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG4vKipcbiAqIEFkYXB0YWRvciBwYXJhIGFybWF6ZW5hbWVudG8gZGUgZG9jdW1lbnRvcyBubyBzaXN0ZW1hIGRlIGFycXVpdm9zIGxvY2FsXG4gKlxuICogSW1wbGVtZW50YSBhIGludGVyZmFjZSBTdG9yYWdlUHJvdmlkZXIgcGFyYSBpbnRlZ3Jhw6fDo28gY29tIG8gc2lzdGVtYSBkZSBhcnF1aXZvc1xuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTG9jYWxTdG9yYWdlQWRhcHRlciBpbXBsZW1lbnRzIFN0b3JhZ2VQcm92aWRlciB7XG4gIHJlYWRvbmx5IG5vbWUgPSAnQXJtYXplbmFtZW50byBMb2NhbCc7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyID0gbmV3IExvZ2dlcihMb2NhbFN0b3JhZ2VBZGFwdGVyLm5hbWUpO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VEaXI6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbmZpZ1NlcnZpY2U6IENvbmZpZ1NlcnZpY2UpIHtcbiAgICB0aGlzLmJhc2VEaXIgPSB0aGlzLmNvbmZpZ1NlcnZpY2UuZ2V0PHN0cmluZz4oXG4gICAgICAnVVBMT0FEU19ESVInLFxuICAgICAgcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICd1cGxvYWRzJyksXG4gICAgKTtcblxuICAgIC8vIEdhcmFudGlyIHF1ZSBvIGRpcmV0w7NyaW8gYmFzZSBleGlzdGVcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmModGhpcy5iYXNlRGlyKSkge1xuICAgICAgZnMubWtkaXJTeW5jKHRoaXMuYmFzZURpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgYEFkYXB0YWRvciBkZSBhcm1hemVuYW1lbnRvIGxvY2FsIGluaWNpYWxpemFkbyBwYXJhIGRpcmV0w7NyaW86ICR7dGhpcy5iYXNlRGlyfWAsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYWx2YSB1bSBhcnF1aXZvIG5vIHNpc3RlbWEgZGUgYXJxdWl2b3MgbG9jYWxcbiAgICogQHBhcmFtIGJ1ZmZlciBCdWZmZXIgZG8gYXJxdWl2b1xuICAgKiBAcGFyYW0gbm9tZUFycXVpdm8gTm9tZSBkbyBhcnF1aXZvXG4gICAqIEBwYXJhbSBtaW1ldHlwZSBUaXBvIE1JTUUgZG8gYXJxdWl2b1xuICAgKiBAcGFyYW0gbWV0YWRhZG9zIE1ldGFkYWRvcyBvcGNpb25haXMgZG8gYXJxdWl2b1xuICAgKiBAcmV0dXJucyBDYW1pbmhvIHJlbGF0aXZvIGRvIGFycXVpdm8gYXJtYXplbmFkb1xuICAgKi9cbiAgYXN5bmMgc2FsdmFyQXJxdWl2byhcbiAgICBidWZmZXI6IEJ1ZmZlcixcbiAgICBub21lQXJxdWl2bzogc3RyaW5nLFxuICAgIG1pbWV0eXBlOiBzdHJpbmcsXG4gICAgbWV0YWRhZG9zPzogUmVjb3JkPHN0cmluZywgYW55PixcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRXh0cmFpciBpbmZvcm1hw6fDtWVzIGRvcyBtZXRhZGFkb3NcbiAgICAgIGNvbnN0IHNvbGljaXRhY2FvSWQgPSBtZXRhZGFkb3M/LnNvbGljaXRhY2FvSWQgfHwgJ2RlZmF1bHQnO1xuICAgICAgY29uc3QgdGlwb0RvY3VtZW50byA9IG1ldGFkYWRvcz8udGlwb0RvY3VtZW50byB8fCAnT1VUUk8nO1xuXG4gICAgICAvLyBDcmlhciBlc3RydXR1cmEgZGUgZGlyZXTDs3Jpb3NcbiAgICAgIGNvbnN0IGRpclBhdGggPSBwYXRoLmpvaW4odGhpcy5iYXNlRGlyLCBzb2xpY2l0YWNhb0lkLCB0aXBvRG9jdW1lbnRvKTtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXJQYXRoKSkge1xuICAgICAgICBmcy5ta2RpclN5bmMoZGlyUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdlcmFyIG5vbWUgZGUgYXJxdWl2byDDum5pY29cbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCByYW5kb21TdHJpbmcgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoOCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IHBhdGguZXh0bmFtZShub21lQXJxdWl2byk7XG4gICAgICBjb25zdCBmaWxlTmFtZSA9IGAke3RpbWVzdGFtcH0tJHtyYW5kb21TdHJpbmd9JHtmaWxlRXh0ZW5zaW9ufWA7XG5cbiAgICAgIC8vIENhbWluaG8gY29tcGxldG8gZG8gYXJxdWl2b1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4oZGlyUGF0aCwgZmlsZU5hbWUpO1xuXG4gICAgICAvLyBTYWx2YXIgYXJxdWl2b1xuICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgYnVmZmVyKTtcblxuICAgICAgLy8gU2FsdmFyIG1ldGFkYWRvcyBlbSBhcnF1aXZvIHNlcGFyYWRvXG4gICAgICBpZiAobWV0YWRhZG9zKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhUGF0aCA9IGAke2ZpbGVQYXRofS5tZXRhZGF0YS5qc29uYDtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhcbiAgICAgICAgICBtZXRhZGF0YVBhdGgsXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLm1ldGFkYWRvcyxcbiAgICAgICAgICAgICAgbWltZXR5cGUsXG4gICAgICAgICAgICAgIG9yaWdpbmFsTmFtZTogbm9tZUFycXVpdm8sXG4gICAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgMixcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXRvcm5hciBjYW1pbmhvIHJlbGF0aXZvXG4gICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLmpvaW4oc29saWNpdGFjYW9JZCwgdGlwb0RvY3VtZW50bywgZmlsZU5hbWUpO1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEFycXVpdm8gc2Fsdm8gY29tIHN1Y2Vzc286ICR7cmVsYXRpdmVQYXRofWApO1xuXG4gICAgICByZXR1cm4gcmVsYXRpdmVQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTsgLy8gTm9ybWFsaXphciBwYXJhIGZvcm1hdG8gZGUgY2FtaW5obyBjb20gYmFycmFzXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIHNhbHZhciBhcnF1aXZvOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm8gYW8gc2FsdmFyIGFycXVpdm86ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIHVtIGFycXVpdm8gZG8gc2lzdGVtYSBkZSBhcnF1aXZvcyBsb2NhbFxuICAgKiBAcGFyYW0gY2FtaW5obyBDYW1pbmhvIHJlbGF0aXZvIGRvIGFycXVpdm9cbiAgICogQHJldHVybnMgQnVmZmVyIGRvIGFycXVpdm9cbiAgICovXG4gIGFzeW5jIG9idGVyQXJxdWl2byhjYW1pbmhvOiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbih0aGlzLmJhc2VEaXIsIGNhbWluaG8pO1xuXG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJxdWl2byBuw6NvIGVuY29udHJhZG86ICR7Y2FtaW5ob31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYnVmZmVyID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoKTtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgQXJxdWl2byBvYnRpZG8gY29tIHN1Y2Vzc286ICR7Y2FtaW5ob30gKCR7YnVmZmVyLmxlbmd0aH0gYnl0ZXMpYCxcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIG9idGVyIGFycXVpdm86ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJybyBhbyBvYnRlciBhcnF1aXZvOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB1bSBhcnF1aXZvIGRvIHNpc3RlbWEgZGUgYXJxdWl2b3MgbG9jYWxcbiAgICogQHBhcmFtIGNhbWluaG8gQ2FtaW5obyByZWxhdGl2byBkbyBhcnF1aXZvXG4gICAqL1xuICBhc3luYyByZW1vdmVyQXJxdWl2byhjYW1pbmhvOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5iYXNlRGlyLCBjYW1pbmhvKTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhUGF0aCA9IGAke2ZpbGVQYXRofS5tZXRhZGF0YS5qc29uYDtcblxuICAgICAgLy8gUmVtb3ZlciBhcnF1aXZvIHByaW5jaXBhbFxuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpKSB7XG4gICAgICAgIGZzLnVubGlua1N5bmMoZmlsZVBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgQXJxdWl2byBuw6NvIGVuY29udHJhZG8gcGFyYSByZW1vw6fDo286ICR7Y2FtaW5ob31gKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlciBhcnF1aXZvIGRlIG1ldGFkYWRvcyBzZSBleGlzdGlyXG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhtZXRhZGF0YVBhdGgpKSB7XG4gICAgICAgIGZzLnVubGlua1N5bmMobWV0YWRhdGFQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEFycXVpdm8gcmVtb3ZpZG8gY29tIHN1Y2Vzc286ICR7Y2FtaW5ob31gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gcmVtb3ZlciBhcnF1aXZvOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm8gYW8gcmVtb3ZlciBhcnF1aXZvOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZheiB1cGxvYWQgZGUgdW0gYXJxdWl2byBwYXJhIG8gc2lzdGVtYSBkZSBhcnF1aXZvcyBsb2NhbFxuICAgKiBAcGFyYW0gYnVmZmVyIEJ1ZmZlciBkbyBhcnF1aXZvXG4gICAqIEBwYXJhbSBrZXkgQ2FtaW5obyByZWxhdGl2byBkbyBhcnF1aXZvXG4gICAqIEBwYXJhbSBtaW1ldHlwZSBUaXBvIE1JTUUgZG8gYXJxdWl2b1xuICAgKiBAcGFyYW0gbWV0YWRhdGEgTWV0YWRhZG9zIG9wY2lvbmFpcyBkbyBhcnF1aXZvXG4gICAqIEByZXR1cm5zIENhbWluaG8gcmVsYXRpdm8gZG8gYXJxdWl2byBhcm1hemVuYWRvXG4gICAqL1xuICBhc3luYyB1cGxvYWQoXG4gICAgYnVmZmVyOiBCdWZmZXIsXG4gICAga2V5OiBzdHJpbmcsXG4gICAgbWltZXR5cGU6IHN0cmluZyxcbiAgICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuc2FsdmFyQXJxdWl2byhidWZmZXIsIGtleSwgbWltZXR5cGUsIG1ldGFkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYXogZG93bmxvYWQgZGUgdW0gYXJxdWl2byBkbyBzaXN0ZW1hIGRlIGFycXVpdm9zIGxvY2FsXG4gICAqIEBwYXJhbSBrZXkgQ2FtaW5obyByZWxhdGl2byBkbyBhcnF1aXZvXG4gICAqIEByZXR1cm5zIEJ1ZmZlciBkbyBhcnF1aXZvXG4gICAqL1xuICBhc3luYyBkb3dubG9hZChrZXk6IHN0cmluZyk6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgcmV0dXJuIHRoaXMub2J0ZXJBcnF1aXZvKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVtIGFycXVpdm8gZG8gc2lzdGVtYSBkZSBhcnF1aXZvcyBsb2NhbFxuICAgKiBAcGFyYW0ga2V5IENhbWluaG8gcmVsYXRpdm8gZG8gYXJxdWl2b1xuICAgKi9cbiAgYXN5bmMgZGVsZXRlKGtleTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlckFycXVpdm8oa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnTDqW0gYSBVUkwgZGUgYWNlc3NvIGEgdW0gYXJxdWl2byBubyBzaXN0ZW1hIGRlIGFycXVpdm9zIGxvY2FsXG4gICAqIEBwYXJhbSBrZXkgQ2FtaW5obyByZWxhdGl2byBkbyBhcnF1aXZvXG4gICAqIEBwYXJhbSBleHBpcmVzSW4gVGVtcG8gZGUgZXhwaXJhw6fDo28gZGEgVVJMIGVtIHNlZ3VuZG9zIChuw6NvIHV0aWxpemFkbyBwYXJhIGFybWF6ZW5hbWVudG8gbG9jYWwpXG4gICAqIEByZXR1cm5zIENhbWluaG8gYWJzb2x1dG8gZG8gYXJxdWl2b1xuICAgKi9cbiAgYXN5bmMgZ2V0VXJsKGtleTogc3RyaW5nLCBleHBpcmVzSW4/OiBudW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbih0aGlzLmJhc2VEaXIsIGtleSk7XG5cbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhmaWxlUGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcnF1aXZvIG7Do28gZW5jb250cmFkbzogJHtrZXl9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhcmEgYXJtYXplbmFtZW50byBsb2NhbCwgcmV0b3JuYW1vcyBvIGNhbWluaG8gYWJzb2x1dG9cbiAgICAgIC8vIEVtIHVtIGFtYmllbnRlIHdlYiByZWFsLCBpc3NvIHBvZGVyaWEgc2VyIHVtYSBVUkwgcGFyYSB1bSBlbmRwb2ludCBxdWUgc2VydmUgbyBhcnF1aXZvXG4gICAgICBjb25zdCBiYXNlVXJsID0gdGhpcy5jb25maWdTZXJ2aWNlLmdldDxzdHJpbmc+KFxuICAgICAgICAnQkFTRV9VUkwnLFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyxcbiAgICAgICk7XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vZG9jdW1lbnRvcy9hcnF1aXZvLyR7a2V5fWA7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIGdlcmFyIFVSTDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvIGFvIGdlcmFyIFVSTDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSB1bSBhcnF1aXZvIGV4aXN0ZSBubyBzaXN0ZW1hIGRlIGFycXVpdm9zIGxvY2FsXG4gICAqIEBwYXJhbSBrZXkgQ2FtaW5obyByZWxhdGl2byBkbyBhcnF1aXZvXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyBhcnF1aXZvIGV4aXN0ZSwgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBhc3luYyBleGlzdHMoa2V5OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5iYXNlRGlyLCBrZXkpO1xuICAgICAgcmV0dXJuIGZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gdmVyaWZpY2FyIGV4aXN0w6puY2lhIGRvIGFycXVpdm86ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEVycm8gYW8gdmVyaWZpY2FyIGV4aXN0w6puY2lhIGRvIGFycXVpdm86ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29waWEgdW0gYXJxdWl2byBkZSB1bSBjYW1pbmhvIHBhcmEgb3V0cm8gbm8gc2lzdGVtYSBkZSBhcnF1aXZvcyBsb2NhbFxuICAgKiBAcGFyYW0gc291cmNlS2V5IENhbWluaG8gcmVsYXRpdm8gZG8gYXJxdWl2byBkZSBvcmlnZW1cbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uS2V5IENhbWluaG8gcmVsYXRpdm8gZG8gYXJxdWl2byBkZSBkZXN0aW5vXG4gICAqIEByZXR1cm5zIENhbWluaG8gcmVsYXRpdm8gZG8gYXJxdWl2byBjb3BpYWRvXG4gICAqL1xuICBhc3luYyBjb3B5KHNvdXJjZUtleTogc3RyaW5nLCBkZXN0aW5hdGlvbktleTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc291cmNlRmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5iYXNlRGlyLCBzb3VyY2VLZXkpO1xuICAgICAgY29uc3QgZGVzdEZpbGVQYXRoID0gcGF0aC5qb2luKHRoaXMuYmFzZURpciwgZGVzdGluYXRpb25LZXkpO1xuICAgICAgY29uc3Qgc291cmNlTWV0YWRhdGFQYXRoID0gYCR7c291cmNlRmlsZVBhdGh9Lm1ldGFkYXRhLmpzb25gO1xuICAgICAgY29uc3QgZGVzdE1ldGFkYXRhUGF0aCA9IGAke2Rlc3RGaWxlUGF0aH0ubWV0YWRhdGEuanNvbmA7XG5cbiAgICAgIC8vIFZlcmlmaWNhciBzZSBvIGFycXVpdm8gZGUgb3JpZ2VtIGV4aXN0ZVxuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHNvdXJjZUZpbGVQYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFycXVpdm8gZGUgb3JpZ2VtIG7Do28gZW5jb250cmFkbzogJHtzb3VyY2VLZXl9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyaWFyIGRpcmV0w7NyaW8gZGUgZGVzdGlubyBzZSBuw6NvIGV4aXN0aXJcbiAgICAgIGNvbnN0IGRlc3REaXIgPSBwYXRoLmRpcm5hbWUoZGVzdEZpbGVQYXRoKTtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhkZXN0RGlyKSkge1xuICAgICAgICBmcy5ta2RpclN5bmMoZGVzdERpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvcGlhciBhcnF1aXZvXG4gICAgICBmcy5jb3B5RmlsZVN5bmMoc291cmNlRmlsZVBhdGgsIGRlc3RGaWxlUGF0aCk7XG5cbiAgICAgIC8vIENvcGlhciBtZXRhZGFkb3Mgc2UgZXhpc3RpcmVtXG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhzb3VyY2VNZXRhZGF0YVBhdGgpKSB7XG4gICAgICAgIGZzLmNvcHlGaWxlU3luYyhzb3VyY2VNZXRhZGF0YVBhdGgsIGRlc3RNZXRhZGF0YVBhdGgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYEFycXVpdm8gY29waWFkbyBjb20gc3VjZXNzbyBkZSAke3NvdXJjZUtleX0gcGFyYSAke2Rlc3RpbmF0aW9uS2V5fWAsXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZGVzdGluYXRpb25LZXk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIGNvcGlhciBhcnF1aXZvOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm8gYW8gY29waWFyIGFycXVpdm86ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlzdGEgYXJxdWl2b3MgY29tIHVtIHByZWZpeG8gZXNwZWPDrWZpY28gbm8gc2lzdGVtYSBkZSBhcnF1aXZvcyBsb2NhbFxuICAgKiBAcGFyYW0gcHJlZml4IFByZWZpeG8gcGFyYSBmaWx0cmFyIGFycXVpdm9zXG4gICAqIEBwYXJhbSBtYXhLZXlzIE7Dum1lcm8gbcOheGltbyBkZSBjaGF2ZXMgYSByZXRvcm5hciAocGFkcsOjbzogMTAwMClcbiAgICogQHJldHVybnMgTGlzdGEgZGUgY2FtaW5ob3MgcmVsYXRpdm9zIGRlIGFycXVpdm9zXG4gICAqL1xuICBhc3luYyBsaXN0KHByZWZpeDogc3RyaW5nLCBtYXhLZXlzOiBudW1iZXIgPSAxMDAwKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcmVmaXhQYXRoID0gcGF0aC5qb2luKHRoaXMuYmFzZURpciwgcHJlZml4KTtcbiAgICAgIGNvbnN0IHByZWZpeERpciA9XG4gICAgICAgIGZzLmV4aXN0c1N5bmMocHJlZml4UGF0aCkgJiYgZnMuc3RhdFN5bmMocHJlZml4UGF0aCkuaXNEaXJlY3RvcnkoKVxuICAgICAgICAgID8gcHJlZml4UGF0aFxuICAgICAgICAgIDogcGF0aC5kaXJuYW1lKHByZWZpeFBhdGgpO1xuXG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocHJlZml4RGlyKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIC8vIEZ1bsOnw6NvIHJlY3Vyc2l2YSBwYXJhIGxpc3RhciBhcnF1aXZvc1xuICAgICAgY29uc3QgbGlzdEZpbGVzUmVjdXJzaXZlbHkgPSAoXG4gICAgICAgIGRpcjogc3RyaW5nLFxuICAgICAgICBiYXNlUGF0aDogc3RyaW5nLFxuICAgICAgICByZXN1bHRzOiBzdHJpbmdbXSA9IFtdLFxuICAgICAgICBkZXB0aDogbnVtYmVyID0gMCxcbiAgICAgICk6IHN0cmluZ1tdID0+IHtcbiAgICAgICAgLy8gTGltaXRhciBwcm9mdW5kaWRhZGUgZGEgcmVjdXJzw6NvXG4gICAgICAgIGlmIChkZXB0aCA+IDEwIHx8IHJlc3VsdHMubGVuZ3RoID49IG1heEtleXMpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVzID0gZnMucmVhZGRpclN5bmMoZGlyKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPj0gbWF4S2V5cykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4oZGlyLCBmaWxlKTtcbiAgICAgICAgICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMoZmlsZVBhdGgpO1xuXG4gICAgICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgbGlzdEZpbGVzUmVjdXJzaXZlbHkoZmlsZVBhdGgsIGJhc2VQYXRoLCByZXN1bHRzLCBkZXB0aCArIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWZpbGUuZW5kc1dpdGgoJy5tZXRhZGF0YS5qc29uJykpIHtcbiAgICAgICAgICAgIC8vIElnbm9yYXIgYXJxdWl2b3MgZGUgbWV0YWRhZG9zXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoXG4gICAgICAgICAgICAgIC5yZWxhdGl2ZSh0aGlzLmJhc2VEaXIsIGZpbGVQYXRoKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gbGlzdEZpbGVzUmVjdXJzaXZlbHkocHJlZml4RGlyLCB0aGlzLmJhc2VEaXIpO1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgIGBFbmNvbnRyYWRvcyAke3Jlc3VsdHMubGVuZ3RofSBhcnF1aXZvcyBjb20gcHJlZml4bzogJHtwcmVmaXh9YCxcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiByZXN1bHRzLnNsaWNlKDAsIG1heEtleXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRXJybyBhbyBsaXN0YXIgYXJxdWl2b3M6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJybyBhbyBsaXN0YXIgYXJxdWl2b3M6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==