7789023ddd375f51c521a67aa0e6d4fd
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var SseGuard_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SseGuard = void 0;
const common_1 = require("@nestjs/common");
const jwt_1 = require("@nestjs/jwt");
/**
 * Guard para autenticação de conexões SSE
 *
 * Valida o token JWT fornecido via query parameter para estabelecer
 * conexões SSE seguras. O token deve ser válido e não expirado.
 */
let SseGuard = SseGuard_1 = class SseGuard {
    jwtService;
    logger = new common_1.Logger(SseGuard_1.name);
    constructor(jwtService) {
        this.jwtService = jwtService;
    }
    /**
     * Valida se a requisição pode prosseguir
     * @param context Contexto de execução da requisição
     * @returns true se autorizado, lança exceção caso contrário
     */
    canActivate(context) {
        const request = context.switchToHttp().getRequest();
        // Tenta obter o token do query parameter ou header Authorization
        const token = this.extractToken(request);
        if (!token) {
            this.logger.warn('Tentativa de conexão SSE sem token de acesso');
            throw new common_1.UnauthorizedException('Token de acesso obrigatório para conexões SSE');
        }
        try {
            // Verifica e decodifica o token JWT
            const payload = this.jwtService.verify(token);
            // Adiciona os dados do usuário à requisição
            request['user'] = {
                id: payload.sub || payload.id,
                email: payload.email,
                roles: payload.roles || [],
                ...payload
            };
            this.logger.debug(`Conexão SSE autorizada para usuário: ${request['user'].id}`);
            return true;
        }
        catch (error) {
            this.logger.warn(`Token SSE inválido: ${error.message}`);
            if (error.name === 'TokenExpiredError') {
                throw new common_1.UnauthorizedException('Token expirado. Faça login novamente.');
            }
            if (error.name === 'JsonWebTokenError') {
                throw new common_1.UnauthorizedException('Token inválido ou malformado.');
            }
            throw new common_1.UnauthorizedException('Falha na autenticação do token.');
        }
    }
    /**
     * Extrai o token JWT da requisição
     * @param request Objeto da requisição HTTP
     * @returns Token JWT ou null se não encontrado
     */
    extractToken(request) {
        // Primeiro tenta obter do query parameter 'token'
        const queryToken = request.query.token;
        if (queryToken) {
            return queryToken;
        }
        // Depois tenta obter do header Authorization
        const authHeader = request.headers.authorization;
        if (authHeader && authHeader.startsWith('Bearer ')) {
            return authHeader.substring(7);
        }
        // Tenta obter de um cookie (se configurado)
        const cookieToken = request.cookies?.['access_token'];
        if (cookieToken) {
            return cookieToken;
        }
        return null;
    }
};
exports.SseGuard = SseGuard;
exports.SseGuard = SseGuard = SseGuard_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof jwt_1.JwtService !== "undefined" && jwt_1.JwtService) === "function" ? _a : Object])
], SseGuard);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXG5vdGlmaWNhY2FvXFxndWFyZHNcXHNzZS5ndWFyZC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUEwRztBQUMxRyxxQ0FBeUM7QUFHekM7Ozs7O0dBS0c7QUFFSSxJQUFNLFFBQVEsZ0JBQWQsTUFBTSxRQUFRO0lBR1U7SUFGWixNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsVUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXBELFlBQTZCLFVBQXNCO1FBQXRCLGVBQVUsR0FBVixVQUFVLENBQVk7SUFBRyxDQUFDO0lBRXZEOzs7O09BSUc7SUFDSCxXQUFXLENBQUMsT0FBeUI7UUFDbkMsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLFlBQVksRUFBRSxDQUFDLFVBQVUsRUFBVyxDQUFDO1FBRTdELGlFQUFpRTtRQUNqRSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXpDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNYLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDhDQUE4QyxDQUFDLENBQUM7WUFDakUsTUFBTSxJQUFJLDhCQUFxQixDQUFDLCtDQUErQyxDQUFDLENBQUM7UUFDbkYsQ0FBQztRQUVELElBQUksQ0FBQztZQUNILG9DQUFvQztZQUNwQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUU5Qyw0Q0FBNEM7WUFDNUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHO2dCQUNoQixFQUFFLEVBQUUsT0FBTyxDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsRUFBRTtnQkFDN0IsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLO2dCQUNwQixLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssSUFBSSxFQUFFO2dCQUMxQixHQUFHLE9BQU87YUFDWCxDQUFDO1lBRUYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsd0NBQXdDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ2hGLE9BQU8sSUFBSSxDQUFDO1FBRWQsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFFekQsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLG1CQUFtQixFQUFFLENBQUM7Z0JBQ3ZDLE1BQU0sSUFBSSw4QkFBcUIsQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO1lBQzNFLENBQUM7WUFFRCxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssbUJBQW1CLEVBQUUsQ0FBQztnQkFDdkMsTUFBTSxJQUFJLDhCQUFxQixDQUFDLCtCQUErQixDQUFDLENBQUM7WUFDbkUsQ0FBQztZQUVELE1BQU0sSUFBSSw4QkFBcUIsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO1FBQ3JFLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLFlBQVksQ0FBQyxPQUFnQjtRQUNuQyxrREFBa0Q7UUFDbEQsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFlLENBQUM7UUFDakQsSUFBSSxVQUFVLEVBQUUsQ0FBQztZQUNmLE9BQU8sVUFBVSxDQUFDO1FBQ3BCLENBQUM7UUFFRCw2Q0FBNkM7UUFDN0MsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7UUFDakQsSUFBSSxVQUFVLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDO1lBQ25ELE9BQU8sVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqQyxDQUFDO1FBRUQsNENBQTRDO1FBQzVDLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUN0RCxJQUFJLFdBQVcsRUFBRSxDQUFDO1lBQ2hCLE9BQU8sV0FBVyxDQUFDO1FBQ3JCLENBQUM7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7Q0FDRixDQUFBO0FBN0VZLDRCQUFRO21CQUFSLFFBQVE7SUFEcEIsSUFBQSxtQkFBVSxHQUFFO3lEQUk4QixnQkFBVSxvQkFBVixnQkFBVTtHQUh4QyxRQUFRLENBNkVwQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcbW9kdWxlc1xcbm90aWZpY2FjYW9cXGd1YXJkc1xcc3NlLmd1YXJkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIENhbkFjdGl2YXRlLCBFeGVjdXRpb25Db250ZXh0LCBVbmF1dGhvcml6ZWRFeGNlcHRpb24sIExvZ2dlciB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IEp3dFNlcnZpY2UgfSBmcm9tICdAbmVzdGpzL2p3dCc7XG5pbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSAnZXhwcmVzcyc7XG5cbi8qKlxuICogR3VhcmQgcGFyYSBhdXRlbnRpY2HDp8OjbyBkZSBjb25leMO1ZXMgU1NFXG4gKiBcbiAqIFZhbGlkYSBvIHRva2VuIEpXVCBmb3JuZWNpZG8gdmlhIHF1ZXJ5IHBhcmFtZXRlciBwYXJhIGVzdGFiZWxlY2VyXG4gKiBjb25leMO1ZXMgU1NFIHNlZ3VyYXMuIE8gdG9rZW4gZGV2ZSBzZXIgdsOhbGlkbyBlIG7Do28gZXhwaXJhZG8uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTc2VHdWFyZCBpbXBsZW1lbnRzIENhbkFjdGl2YXRlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXIgPSBuZXcgTG9nZ2VyKFNzZUd1YXJkLm5hbWUpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgand0U2VydmljZTogSnd0U2VydmljZSkge31cblxuICAvKipcbiAgICogVmFsaWRhIHNlIGEgcmVxdWlzacOnw6NvIHBvZGUgcHJvc3NlZ3VpclxuICAgKiBAcGFyYW0gY29udGV4dCBDb250ZXh0byBkZSBleGVjdcOnw6NvIGRhIHJlcXVpc2nDp8Ojb1xuICAgKiBAcmV0dXJucyB0cnVlIHNlIGF1dG9yaXphZG8sIGxhbsOnYSBleGNlw6fDo28gY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBjYW5BY3RpdmF0ZShjb250ZXh0OiBFeGVjdXRpb25Db250ZXh0KTogYm9vbGVhbiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGNvbnRleHQuc3dpdGNoVG9IdHRwKCkuZ2V0UmVxdWVzdDxSZXF1ZXN0PigpO1xuICAgIFxuICAgIC8vIFRlbnRhIG9idGVyIG8gdG9rZW4gZG8gcXVlcnkgcGFyYW1ldGVyIG91IGhlYWRlciBBdXRob3JpemF0aW9uXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmV4dHJhY3RUb2tlbihyZXF1ZXN0KTtcblxuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1RlbnRhdGl2YSBkZSBjb25leMOjbyBTU0Ugc2VtIHRva2VuIGRlIGFjZXNzbycpO1xuICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEV4Y2VwdGlvbignVG9rZW4gZGUgYWNlc3NvIG9icmlnYXTDs3JpbyBwYXJhIGNvbmV4w7VlcyBTU0UnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gVmVyaWZpY2EgZSBkZWNvZGlmaWNhIG8gdG9rZW4gSldUXG4gICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5qd3RTZXJ2aWNlLnZlcmlmeSh0b2tlbik7XG4gICAgICBcbiAgICAgIC8vIEFkaWNpb25hIG9zIGRhZG9zIGRvIHVzdcOhcmlvIMOgIHJlcXVpc2nDp8Ojb1xuICAgICAgcmVxdWVzdFsndXNlciddID0ge1xuICAgICAgICBpZDogcGF5bG9hZC5zdWIgfHwgcGF5bG9hZC5pZCxcbiAgICAgICAgZW1haWw6IHBheWxvYWQuZW1haWwsXG4gICAgICAgIHJvbGVzOiBwYXlsb2FkLnJvbGVzIHx8IFtdLFxuICAgICAgICAuLi5wYXlsb2FkXG4gICAgICB9O1xuICAgICAgXG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgQ29uZXjDo28gU1NFIGF1dG9yaXphZGEgcGFyYSB1c3XDoXJpbzogJHtyZXF1ZXN0Wyd1c2VyJ10uaWR9YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBUb2tlbiBTU0UgaW52w6FsaWRvOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICBcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnVG9rZW5FeHBpcmVkRXJyb3InKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmF1dGhvcml6ZWRFeGNlcHRpb24oJ1Rva2VuIGV4cGlyYWRvLiBGYcOnYSBsb2dpbiBub3ZhbWVudGUuJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnSnNvbldlYlRva2VuRXJyb3InKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmF1dGhvcml6ZWRFeGNlcHRpb24oJ1Rva2VuIGludsOhbGlkbyBvdSBtYWxmb3JtYWRvLicpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgVW5hdXRob3JpemVkRXhjZXB0aW9uKCdGYWxoYSBuYSBhdXRlbnRpY2HDp8OjbyBkbyB0b2tlbi4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFpIG8gdG9rZW4gSldUIGRhIHJlcXVpc2nDp8Ojb1xuICAgKiBAcGFyYW0gcmVxdWVzdCBPYmpldG8gZGEgcmVxdWlzacOnw6NvIEhUVFBcbiAgICogQHJldHVybnMgVG9rZW4gSldUIG91IG51bGwgc2UgbsOjbyBlbmNvbnRyYWRvXG4gICAqL1xuICBwcml2YXRlIGV4dHJhY3RUb2tlbihyZXF1ZXN0OiBSZXF1ZXN0KTogc3RyaW5nIHwgbnVsbCB7XG4gICAgLy8gUHJpbWVpcm8gdGVudGEgb2J0ZXIgZG8gcXVlcnkgcGFyYW1ldGVyICd0b2tlbidcbiAgICBjb25zdCBxdWVyeVRva2VuID0gcmVxdWVzdC5xdWVyeS50b2tlbiBhcyBzdHJpbmc7XG4gICAgaWYgKHF1ZXJ5VG9rZW4pIHtcbiAgICAgIHJldHVybiBxdWVyeVRva2VuO1xuICAgIH1cblxuICAgIC8vIERlcG9pcyB0ZW50YSBvYnRlciBkbyBoZWFkZXIgQXV0aG9yaXphdGlvblxuICAgIGNvbnN0IGF1dGhIZWFkZXIgPSByZXF1ZXN0LmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICBpZiAoYXV0aEhlYWRlciAmJiBhdXRoSGVhZGVyLnN0YXJ0c1dpdGgoJ0JlYXJlciAnKSkge1xuICAgICAgcmV0dXJuIGF1dGhIZWFkZXIuc3Vic3RyaW5nKDcpO1xuICAgIH1cblxuICAgIC8vIFRlbnRhIG9idGVyIGRlIHVtIGNvb2tpZSAoc2UgY29uZmlndXJhZG8pXG4gICAgY29uc3QgY29va2llVG9rZW4gPSByZXF1ZXN0LmNvb2tpZXM/LlsnYWNjZXNzX3Rva2VuJ107XG4gICAgaWYgKGNvb2tpZVRva2VuKSB7XG4gICAgICByZXR1cm4gY29va2llVG9rZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0iXSwidmVyc2lvbiI6M30=