2cf74e3d8373a1497c061e74a0a6f7fb
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PasswordResetToken = void 0;
const typeorm_1 = require("typeorm");
const class_validator_1 = require("class-validator");
const usuario_entity_1 = require("./usuario.entity");
/**
 * Entidade para Tokens de Recuperação de Senha
 *
 * Armazena tokens temporários para recuperação de senha com:
 * - Associação ao usuário
 * - Token único e seguro
 * - Controle de expiração
 * - Rastreamento de uso
 * - Auditoria de tentativas
 */
let PasswordResetToken = class PasswordResetToken {
    id;
    /**
     * Token único para recuperação de senha
     * Gerado com alta entropia para segurança
     */
    token;
    /**
     * Hash do token para verificação segura
     * Armazenamos o hash para evitar exposição do token original
     */
    token_hash;
    /**
     * Usuário associado ao token
     */
    usuario;
    usuario_id;
    /**
     * Data e hora de expiração do token
     * Padrão: 15 minutos após criação
     */
    expires_at;
    /**
     * Indica se o token já foi utilizado
     * Tokens são de uso único
     */
    is_used;
    /**
     * Data e hora em que o token foi utilizado
     */
    used_at;
    /**
     * IP do cliente que solicitou o token
     * Para auditoria e segurança
     */
    client_ip;
    /**
     * User Agent do cliente que solicitou o token
     * Para auditoria e detecção de anomalias
     */
    user_agent;
    /**
     * Número de tentativas de uso do token
     * Para detectar ataques de força bruta
     */
    attempts;
    /**
     * Data da última tentativa de uso
     */
    last_attempt_at;
    /**
     * Motivo da invalidação (se aplicável)
     * Ex: 'expired', 'used', 'revoked', 'suspicious_activity'
     */
    invalidation_reason;
    /**
     * Metadados adicionais em formato JSON
     * Para informações extras de auditoria
     */
    metadata;
    created_at;
    updated_at;
    /**
     * Verifica se o token está válido
     * @returns true se o token não expirou e não foi usado
     */
    isValid() {
        const now = new Date();
        return !this.is_used && this.expires_at > now;
    }
    /**
     * Verifica se o token expirou
     * @returns true se o token expirou
     */
    isExpired() {
        const now = new Date();
        return this.expires_at <= now;
    }
    /**
     * Marca o token como usado
     * @param reason Motivo da invalidação
     */
    markAsUsed(reason = 'used') {
        this.is_used = true;
        this.used_at = new Date();
        this.invalidation_reason = reason;
    }
    /**
     * Incrementa o contador de tentativas
     */
    incrementAttempts() {
        this.attempts += 1;
        this.last_attempt_at = new Date();
    }
    /**
     * Calcula o tempo restante até a expiração em minutos
     * @returns Minutos restantes ou 0 se expirado
     */
    getMinutesUntilExpiration() {
        const now = new Date();
        if (this.expires_at <= now) {
            return 0;
        }
        return Math.ceil((this.expires_at.getTime() - now.getTime()) / (1000 * 60));
    }
    /**
     * Verifica se o token pertence a um usuário específico
     * @param usuarioId ID do usuário
     * @returns true se pertence ao usuário
     */
    belongsToUser(usuarioId) {
        return this.usuario_id === usuarioId;
    }
    /**
     * Verifica se o token foi criado recentemente (últimas 24 horas)
     * @returns true se foi criado recentemente
     */
    isRecentlyCreated() {
        const now = new Date();
        const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        return this.created_at > oneDayAgo;
    }
    /**
     * Verifica se há muitas tentativas de uso (possível ataque)
     * @param maxAttempts Número máximo de tentativas permitidas
     * @returns true se excedeu o limite
     */
    hasTooManyAttempts(maxAttempts = 5) {
        return this.attempts >= maxAttempts;
    }
    /**
     * Verifica se o token expira em breve (próximos 5 minutos)
     * @param minutes Minutos para considerar como "em breve"
     * @returns true se expira em breve
     */
    expiresWithin(minutes = 5) {
        const now = new Date();
        const futureTime = new Date(now.getTime() + minutes * 60 * 1000);
        return this.expires_at <= futureTime;
    }
    /**
     * Calcula há quantos minutos o token foi criado
     * @returns minutos desde a criação
     */
    getMinutesSinceCreation() {
        const now = new Date();
        const diffMs = now.getTime() - this.created_at.getTime();
        return Math.floor(diffMs / (1000 * 60));
    }
    /**
     * Obtém o status atual do token
     * @returns status do token
     */
    getStatus() {
        if (this.is_used)
            return 'used';
        if (this.isExpired())
            return 'expired';
        if (this.hasTooManyAttempts())
            return 'too_many_attempts';
        return 'valid';
    }
    /**
     * Verifica se tem informações de cliente (IP e User Agent)
     * @returns true se tem informações de cliente
     */
    hasClientInfo() {
        return !!(this.client_ip || this.user_agent);
    }
    /**
     * Adiciona metadados ao token
     * @param key Chave do metadado
     * @param value Valor do metadado
     */
    addMetadata(key, value) {
        if (!this.metadata) {
            this.metadata = {};
        }
        this.metadata[key] = value;
    }
    /**
     * Obtém um metadado específico
     * @param key Chave do metadado
     * @returns Valor do metadado ou undefined
     */
    getMetadata(key) {
        return this.metadata?.[key];
    }
    /**
     * Obtém informações resumidas do token
     * @returns objeto com informações resumidas
     */
    getSummary() {
        return {
            id: this.id,
            usuario_id: this.usuario_id,
            is_used: this.is_used,
            expires_at: this.expires_at,
            created_at: this.created_at,
            attempts: this.attempts,
            status: this.getStatus(),
            minutesUntilExpiration: this.getMinutesUntilExpiration(),
            hasClientInfo: this.hasClientInfo()
        };
    }
    /**
     * Invalida o token com um motivo específico
     * @param reason Motivo da invalidação
     */
    invalidate(reason) {
        this.is_used = true;
        this.used_at = new Date();
        this.invalidation_reason = reason;
    }
    /**
     * Verifica se o token foi invalidado por motivos de segurança
     * @returns true se foi invalidado por segurança
     */
    isSecurityInvalidated() {
        const securityReasons = [
            'suspicious_activity',
            'too_many_attempts',
            'security_breach',
            'admin_revoke'
        ];
        return securityReasons.includes(this.invalidation_reason);
    }
    /**
     * Gera uma chave única para o token
     * @returns chave única
     */
    getUniqueKey() {
        return `password_reset_${this.usuario_id}_${this.id}`;
    }
    /**
     * Verifica se o token está em estado consistente
     * @returns true se está consistente
     */
    isConsistent() {
        return (!!this.id &&
            !!this.token &&
            !!this.token_hash &&
            !!this.usuario_id &&
            !!this.expires_at &&
            !!this.created_at &&
            typeof this.is_used === 'boolean' &&
            typeof this.attempts === 'number');
    }
    /**
     * Remove informações sensíveis para logs
     * @returns objeto sanitizado
     */
    toSafeLog() {
        return {
            id: this.id,
            usuario_id: this.usuario_id,
            token_preview: this.token.substring(0, 8) + '...',
            is_used: this.is_used,
            expires_at: this.expires_at,
            created_at: this.created_at,
            attempts: this.attempts,
            status: this.getStatus(),
            hasClientInfo: this.hasClientInfo()
        };
    }
    /**
     * Formata a data de expiração para exibição
     * @returns data formatada
     */
    getExpiracaoFormatada() {
        return this.expires_at.toLocaleString('pt-BR', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        });
    }
    /**
     * Formata a data de criação para exibição
     * @returns data formatada
     */
    getCriacaoFormatada() {
        return this.created_at.toLocaleString('pt-BR', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        });
    }
    /**
     * Verifica se o token pode ser usado para reset de senha
     * @returns true se pode ser usado
     */
    canBeUsedForReset() {
        return (this.isValid() &&
            !this.hasTooManyAttempts() &&
            !this.isSecurityInvalidated());
    }
};
exports.PasswordResetToken = PasswordResetToken;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)('uuid'),
    __metadata("design:type", String)
], PasswordResetToken.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'varchar',
        length: 255,
        unique: true,
        nullable: false,
        comment: 'Token único para recuperação de senha',
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'Token é obrigatório' }),
    (0, class_validator_1.IsString)({ message: 'Token deve ser uma string' }),
    (0, class_validator_1.Length)(10, 255, { message: 'Token deve ter entre 10 e 255 caracteres' }),
    __metadata("design:type", String)
], PasswordResetToken.prototype, "token", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'varchar',
        length: 255,
        nullable: false,
        comment: 'Hash do token para verificação segura',
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'Hash do token é obrigatório' }),
    (0, class_validator_1.IsString)({ message: 'Hash do token deve ser uma string' }),
    (0, class_validator_1.Length)(32, 255, { message: 'Hash do token deve ter entre 32 e 255 caracteres' }),
    __metadata("design:type", String)
], PasswordResetToken.prototype, "token_hash", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => usuario_entity_1.Usuario, { onDelete: 'CASCADE' }),
    (0, typeorm_1.JoinColumn)({ name: 'usuario_id' }),
    __metadata("design:type", typeof (_a = typeof usuario_entity_1.Usuario !== "undefined" && usuario_entity_1.Usuario) === "function" ? _a : Object)
], PasswordResetToken.prototype, "usuario", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'uuid',
        nullable: false,
        comment: 'ID do usuário associado ao token',
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'ID do usuário é obrigatório' }),
    (0, class_validator_1.IsUUID)('4', { message: 'ID do usuário inválido' }),
    __metadata("design:type", String)
], PasswordResetToken.prototype, "usuario_id", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'timestamp',
        nullable: false,
        comment: 'Data e hora de expiração do token',
    }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], PasswordResetToken.prototype, "expires_at", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'boolean',
        default: false,
        nullable: false,
        comment: 'Indica se o token já foi utilizado',
    }),
    (0, class_validator_1.IsBoolean)({ message: 'Campo is_used deve ser um boolean' }),
    __metadata("design:type", Boolean)
], PasswordResetToken.prototype, "is_used", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'timestamp',
        nullable: true,
        comment: 'Data e hora em que o token foi utilizado',
    }),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], PasswordResetToken.prototype, "used_at", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'varchar',
        length: 45, // IPv6 max length
        nullable: true,
        comment: 'IP do cliente que solicitou o token',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'IP do cliente deve ser uma string' }),
    (0, class_validator_1.Length)(7, 45, { message: 'IP do cliente deve ter entre 7 e 45 caracteres' }),
    __metadata("design:type", String)
], PasswordResetToken.prototype, "client_ip", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'text',
        nullable: true,
        comment: 'User Agent do cliente que solicitou o token',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'User Agent deve ser uma string' }),
    __metadata("design:type", String)
], PasswordResetToken.prototype, "user_agent", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'integer',
        default: 0,
        nullable: false,
        comment: 'Número de tentativas de uso do token',
    }),
    (0, class_validator_1.IsNumber)({}, { message: 'Número de tentativas deve ser um número' }),
    (0, class_validator_1.Min)(0, { message: 'Número de tentativas não pode ser negativo' }),
    (0, class_validator_1.Max)(100, { message: 'Número de tentativas não pode exceder 100' }),
    __metadata("design:type", Number)
], PasswordResetToken.prototype, "attempts", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'timestamp',
        nullable: true,
        comment: 'Data da última tentativa de uso',
    }),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], PasswordResetToken.prototype, "last_attempt_at", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'varchar',
        length: 50,
        nullable: true,
        comment: 'Motivo da invalidação do token',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'Motivo da invalidação deve ser uma string' }),
    (0, class_validator_1.Length)(3, 50, { message: 'Motivo da invalidação deve ter entre 3 e 50 caracteres' }),
    __metadata("design:type", String)
], PasswordResetToken.prototype, "invalidation_reason", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'jsonb',
        nullable: true,
        comment: 'Metadados adicionais para auditoria',
    }),
    __metadata("design:type", typeof (_e = typeof Record !== "undefined" && Record) === "function" ? _e : Object)
], PasswordResetToken.prototype, "metadata", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)({
        type: 'timestamp',
        default: () => 'CURRENT_TIMESTAMP',
        comment: 'Data de criação do registro',
    }),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], PasswordResetToken.prototype, "created_at", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)({
        type: 'timestamp',
        default: () => 'CURRENT_TIMESTAMP',
        onUpdate: 'CURRENT_TIMESTAMP',
        comment: 'Data da última atualização do registro',
    }),
    __metadata("design:type", typeof (_g = typeof Date !== "undefined" && Date) === "function" ? _g : Object)
], PasswordResetToken.prototype, "updated_at", void 0);
exports.PasswordResetToken = PasswordResetToken = __decorate([
    (0, typeorm_1.Entity)('password_reset_tokens'),
    (0, typeorm_1.Index)(['token'], { unique: true }),
    (0, typeorm_1.Index)(['usuario_id', 'is_used']),
    (0, typeorm_1.Index)(['expires_at']),
    (0, typeorm_1.Index)(['used_at'])
], PasswordResetToken);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXGVudGl0aWVzXFxwYXNzd29yZC1yZXNldC10b2tlbi5lbnRpdHkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLHFDQVNpQjtBQUNqQixxREFBa0g7QUFDbEgscURBQTJDO0FBRTNDOzs7Ozs7Ozs7R0FTRztBQU1JLElBQU0sa0JBQWtCLEdBQXhCLE1BQU0sa0JBQWtCO0lBRTdCLEVBQUUsQ0FBUztJQUVYOzs7T0FHRztJQVdILEtBQUssQ0FBUztJQUVkOzs7T0FHRztJQVVILFVBQVUsQ0FBUztJQUVuQjs7T0FFRztJQUdILE9BQU8sQ0FBVTtJQVNqQixVQUFVLENBQVM7SUFFbkI7OztPQUdHO0lBTUgsVUFBVSxDQUFPO0lBRWpCOzs7T0FHRztJQVFILE9BQU8sQ0FBVTtJQUVqQjs7T0FFRztJQU1ILE9BQU8sQ0FBTztJQUVkOzs7T0FHRztJQVVILFNBQVMsQ0FBUztJQUVsQjs7O09BR0c7SUFRSCxVQUFVLENBQVM7SUFFbkI7OztPQUdHO0lBVUgsUUFBUSxDQUFTO0lBRWpCOztPQUVHO0lBTUgsZUFBZSxDQUFPO0lBRXRCOzs7T0FHRztJQVVILG1CQUFtQixDQUFTO0lBRTVCOzs7T0FHRztJQU1ILFFBQVEsQ0FBc0I7SUFPOUIsVUFBVSxDQUFPO0lBUWpCLFVBQVUsQ0FBTztJQUVqQjs7O09BR0c7SUFDSCxPQUFPO1FBQ0wsTUFBTSxHQUFHLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUN2QixPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsVUFBVSxHQUFHLEdBQUcsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsU0FBUztRQUNQLE1BQU0sR0FBRyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7UUFDdkIsT0FBTyxJQUFJLENBQUMsVUFBVSxJQUFJLEdBQUcsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7OztP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VSxJQUFJLG9CQUFKLElBQUk7c0RBQUM7NkJBakxOLGtCQUFrQjtJQUw5QixJQUFBLGdCQUFNLEVBQUMsdUJBQXVCLENBQUM7SUFDL0IsSUFBQSxlQUFLLEVBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUNsQyxJQUFBLGVBQUssRUFBQyxDQUFDLFlBQVksRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNoQyxJQUFBLGVBQUssRUFBQyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3JCLElBQUEsZUFBSyxFQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7R0FDTixrQkFBa0IsQ0E2YzlCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZXVkcmVcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxlbnRpdGllc1xccGFzc3dvcmQtcmVzZXQtdG9rZW4uZW50aXR5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEVudGl0eSxcbiAgUHJpbWFyeUdlbmVyYXRlZENvbHVtbixcbiAgQ29sdW1uLFxuICBNYW55VG9PbmUsXG4gIEpvaW5Db2x1bW4sXG4gIENyZWF0ZURhdGVDb2x1bW4sXG4gIFVwZGF0ZURhdGVDb2x1bW4sXG4gIEluZGV4LFxufSBmcm9tICd0eXBlb3JtJztcbmltcG9ydCB7IElzTm90RW1wdHksIElzVVVJRCwgSXNCb29sZWFuLCBJc09wdGlvbmFsLCBJc1N0cmluZywgSXNOdW1iZXIsIExlbmd0aCwgTWluLCBNYXggfSBmcm9tICdjbGFzcy12YWxpZGF0b3InO1xuaW1wb3J0IHsgVXN1YXJpbyB9IGZyb20gJy4vdXN1YXJpby5lbnRpdHknO1xuXG4vKipcbiAqIEVudGlkYWRlIHBhcmEgVG9rZW5zIGRlIFJlY3VwZXJhw6fDo28gZGUgU2VuaGFcbiAqIFxuICogQXJtYXplbmEgdG9rZW5zIHRlbXBvcsOhcmlvcyBwYXJhIHJlY3VwZXJhw6fDo28gZGUgc2VuaGEgY29tOlxuICogLSBBc3NvY2lhw6fDo28gYW8gdXN1w6FyaW9cbiAqIC0gVG9rZW4gw7puaWNvIGUgc2VndXJvXG4gKiAtIENvbnRyb2xlIGRlIGV4cGlyYcOnw6NvXG4gKiAtIFJhc3RyZWFtZW50byBkZSB1c29cbiAqIC0gQXVkaXRvcmlhIGRlIHRlbnRhdGl2YXNcbiAqL1xuQEVudGl0eSgncGFzc3dvcmRfcmVzZXRfdG9rZW5zJylcbkBJbmRleChbJ3Rva2VuJ10sIHsgdW5pcXVlOiB0cnVlIH0pXG5ASW5kZXgoWyd1c3VhcmlvX2lkJywgJ2lzX3VzZWQnXSlcbkBJbmRleChbJ2V4cGlyZXNfYXQnXSlcbkBJbmRleChbJ3VzZWRfYXQnXSlcbmV4cG9ydCBjbGFzcyBQYXNzd29yZFJlc2V0VG9rZW4ge1xuICBAUHJpbWFyeUdlbmVyYXRlZENvbHVtbigndXVpZCcpXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRva2VuIMO6bmljbyBwYXJhIHJlY3VwZXJhw6fDo28gZGUgc2VuaGFcbiAgICogR2VyYWRvIGNvbSBhbHRhIGVudHJvcGlhIHBhcmEgc2VndXJhbsOnYVxuICAgKi9cbiAgQENvbHVtbih7XG4gICAgdHlwZTogJ3ZhcmNoYXInLFxuICAgIGxlbmd0aDogMjU1LFxuICAgIHVuaXF1ZTogdHJ1ZSxcbiAgICBudWxsYWJsZTogZmFsc2UsXG4gICAgY29tbWVudDogJ1Rva2VuIMO6bmljbyBwYXJhIHJlY3VwZXJhw6fDo28gZGUgc2VuaGEnLFxuICB9KVxuICBASXNOb3RFbXB0eSh7IG1lc3NhZ2U6ICdUb2tlbiDDqSBvYnJpZ2F0w7NyaW8nIH0pXG4gIEBJc1N0cmluZyh7IG1lc3NhZ2U6ICdUb2tlbiBkZXZlIHNlciB1bWEgc3RyaW5nJyB9KVxuICBATGVuZ3RoKDEwLCAyNTUsIHsgbWVzc2FnZTogJ1Rva2VuIGRldmUgdGVyIGVudHJlIDEwIGUgMjU1IGNhcmFjdGVyZXMnIH0pXG4gIHRva2VuOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEhhc2ggZG8gdG9rZW4gcGFyYSB2ZXJpZmljYcOnw6NvIHNlZ3VyYVxuICAgKiBBcm1hemVuYW1vcyBvIGhhc2ggcGFyYSBldml0YXIgZXhwb3Npw6fDo28gZG8gdG9rZW4gb3JpZ2luYWxcbiAgICovXG4gIEBDb2x1bW4oe1xuICAgIHR5cGU6ICd2YXJjaGFyJyxcbiAgICBsZW5ndGg6IDI1NSxcbiAgICBudWxsYWJsZTogZmFsc2UsXG4gICAgY29tbWVudDogJ0hhc2ggZG8gdG9rZW4gcGFyYSB2ZXJpZmljYcOnw6NvIHNlZ3VyYScsXG4gIH0pXG4gIEBJc05vdEVtcHR5KHsgbWVzc2FnZTogJ0hhc2ggZG8gdG9rZW4gw6kgb2JyaWdhdMOzcmlvJyB9KVxuICBASXNTdHJpbmcoeyBtZXNzYWdlOiAnSGFzaCBkbyB0b2tlbiBkZXZlIHNlciB1bWEgc3RyaW5nJyB9KVxuICBATGVuZ3RoKDMyLCAyNTUsIHsgbWVzc2FnZTogJ0hhc2ggZG8gdG9rZW4gZGV2ZSB0ZXIgZW50cmUgMzIgZSAyNTUgY2FyYWN0ZXJlcycgfSlcbiAgdG9rZW5faGFzaDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc3XDoXJpbyBhc3NvY2lhZG8gYW8gdG9rZW5cbiAgICovXG4gIEBNYW55VG9PbmUoKCkgPT4gVXN1YXJpbywgeyBvbkRlbGV0ZTogJ0NBU0NBREUnIH0pXG4gIEBKb2luQ29sdW1uKHsgbmFtZTogJ3VzdWFyaW9faWQnIH0pXG4gIHVzdWFyaW86IFVzdWFyaW87XG5cbiAgQENvbHVtbih7XG4gICAgdHlwZTogJ3V1aWQnLFxuICAgIG51bGxhYmxlOiBmYWxzZSxcbiAgICBjb21tZW50OiAnSUQgZG8gdXN1w6FyaW8gYXNzb2NpYWRvIGFvIHRva2VuJyxcbiAgfSlcbiAgQElzTm90RW1wdHkoeyBtZXNzYWdlOiAnSUQgZG8gdXN1w6FyaW8gw6kgb2JyaWdhdMOzcmlvJyB9KVxuICBASXNVVUlEKCc0JywgeyBtZXNzYWdlOiAnSUQgZG8gdXN1w6FyaW8gaW52w6FsaWRvJyB9KVxuICB1c3VhcmlvX2lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERhdGEgZSBob3JhIGRlIGV4cGlyYcOnw6NvIGRvIHRva2VuXG4gICAqIFBhZHLDo286IDE1IG1pbnV0b3MgYXDDs3MgY3JpYcOnw6NvXG4gICAqL1xuICBAQ29sdW1uKHtcbiAgICB0eXBlOiAndGltZXN0YW1wJyxcbiAgICBudWxsYWJsZTogZmFsc2UsXG4gICAgY29tbWVudDogJ0RhdGEgZSBob3JhIGRlIGV4cGlyYcOnw6NvIGRvIHRva2VuJyxcbiAgfSlcbiAgZXhwaXJlc19hdDogRGF0ZTtcblxuICAvKipcbiAgICogSW5kaWNhIHNlIG8gdG9rZW4gasOhIGZvaSB1dGlsaXphZG9cbiAgICogVG9rZW5zIHPDo28gZGUgdXNvIMO6bmljb1xuICAgKi9cbiAgQENvbHVtbih7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIG51bGxhYmxlOiBmYWxzZSxcbiAgICBjb21tZW50OiAnSW5kaWNhIHNlIG8gdG9rZW4gasOhIGZvaSB1dGlsaXphZG8nLFxuICB9KVxuICBASXNCb29sZWFuKHsgbWVzc2FnZTogJ0NhbXBvIGlzX3VzZWQgZGV2ZSBzZXIgdW0gYm9vbGVhbicgfSlcbiAgaXNfdXNlZDogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGF0YSBlIGhvcmEgZW0gcXVlIG8gdG9rZW4gZm9pIHV0aWxpemFkb1xuICAgKi9cbiAgQENvbHVtbih7XG4gICAgdHlwZTogJ3RpbWVzdGFtcCcsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgY29tbWVudDogJ0RhdGEgZSBob3JhIGVtIHF1ZSBvIHRva2VuIGZvaSB1dGlsaXphZG8nLFxuICB9KVxuICB1c2VkX2F0OiBEYXRlO1xuXG4gIC8qKlxuICAgKiBJUCBkbyBjbGllbnRlIHF1ZSBzb2xpY2l0b3UgbyB0b2tlblxuICAgKiBQYXJhIGF1ZGl0b3JpYSBlIHNlZ3VyYW7Dp2FcbiAgICovXG4gIEBDb2x1bW4oe1xuICAgIHR5cGU6ICd2YXJjaGFyJyxcbiAgICBsZW5ndGg6IDQ1LCAvLyBJUHY2IG1heCBsZW5ndGhcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBjb21tZW50OiAnSVAgZG8gY2xpZW50ZSBxdWUgc29saWNpdG91IG8gdG9rZW4nLFxuICB9KVxuICBASXNPcHRpb25hbCgpXG4gIEBJc1N0cmluZyh7IG1lc3NhZ2U6ICdJUCBkbyBjbGllbnRlIGRldmUgc2VyIHVtYSBzdHJpbmcnIH0pXG4gIEBMZW5ndGgoNywgNDUsIHsgbWVzc2FnZTogJ0lQIGRvIGNsaWVudGUgZGV2ZSB0ZXIgZW50cmUgNyBlIDQ1IGNhcmFjdGVyZXMnIH0pXG4gIGNsaWVudF9pcDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2VyIEFnZW50IGRvIGNsaWVudGUgcXVlIHNvbGljaXRvdSBvIHRva2VuXG4gICAqIFBhcmEgYXVkaXRvcmlhIGUgZGV0ZWPDp8OjbyBkZSBhbm9tYWxpYXNcbiAgICovXG4gIEBDb2x1bW4oe1xuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBjb21tZW50OiAnVXNlciBBZ2VudCBkbyBjbGllbnRlIHF1ZSBzb2xpY2l0b3UgbyB0b2tlbicsXG4gIH0pXG4gIEBJc09wdGlvbmFsKClcbiAgQElzU3RyaW5nKHsgbWVzc2FnZTogJ1VzZXIgQWdlbnQgZGV2ZSBzZXIgdW1hIHN0cmluZycgfSlcbiAgdXNlcl9hZ2VudDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOw7ptZXJvIGRlIHRlbnRhdGl2YXMgZGUgdXNvIGRvIHRva2VuXG4gICAqIFBhcmEgZGV0ZWN0YXIgYXRhcXVlcyBkZSBmb3LDp2EgYnJ1dGFcbiAgICovXG4gIEBDb2x1bW4oe1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiAwLFxuICAgIG51bGxhYmxlOiBmYWxzZSxcbiAgICBjb21tZW50OiAnTsO6bWVybyBkZSB0ZW50YXRpdmFzIGRlIHVzbyBkbyB0b2tlbicsXG4gIH0pXG4gIEBJc051bWJlcih7fSwgeyBtZXNzYWdlOiAnTsO6bWVybyBkZSB0ZW50YXRpdmFzIGRldmUgc2VyIHVtIG7Dum1lcm8nIH0pXG4gIEBNaW4oMCwgeyBtZXNzYWdlOiAnTsO6bWVybyBkZSB0ZW50YXRpdmFzIG7Do28gcG9kZSBzZXIgbmVnYXRpdm8nIH0pXG4gIEBNYXgoMTAwLCB7IG1lc3NhZ2U6ICdOw7ptZXJvIGRlIHRlbnRhdGl2YXMgbsOjbyBwb2RlIGV4Y2VkZXIgMTAwJyB9KVxuICBhdHRlbXB0czogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBEYXRhIGRhIMO6bHRpbWEgdGVudGF0aXZhIGRlIHVzb1xuICAgKi9cbiAgQENvbHVtbih7XG4gICAgdHlwZTogJ3RpbWVzdGFtcCcsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgY29tbWVudDogJ0RhdGEgZGEgw7psdGltYSB0ZW50YXRpdmEgZGUgdXNvJyxcbiAgfSlcbiAgbGFzdF9hdHRlbXB0X2F0OiBEYXRlO1xuXG4gIC8qKlxuICAgKiBNb3Rpdm8gZGEgaW52YWxpZGHDp8OjbyAoc2UgYXBsaWPDoXZlbClcbiAgICogRXg6ICdleHBpcmVkJywgJ3VzZWQnLCAncmV2b2tlZCcsICdzdXNwaWNpb3VzX2FjdGl2aXR5J1xuICAgKi9cbiAgQENvbHVtbih7XG4gICAgdHlwZTogJ3ZhcmNoYXInLFxuICAgIGxlbmd0aDogNTAsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgY29tbWVudDogJ01vdGl2byBkYSBpbnZhbGlkYcOnw6NvIGRvIHRva2VuJyxcbiAgfSlcbiAgQElzT3B0aW9uYWwoKVxuICBASXNTdHJpbmcoeyBtZXNzYWdlOiAnTW90aXZvIGRhIGludmFsaWRhw6fDo28gZGV2ZSBzZXIgdW1hIHN0cmluZycgfSlcbiAgQExlbmd0aCgzLCA1MCwgeyBtZXNzYWdlOiAnTW90aXZvIGRhIGludmFsaWRhw6fDo28gZGV2ZSB0ZXIgZW50cmUgMyBlIDUwIGNhcmFjdGVyZXMnIH0pXG4gIGludmFsaWRhdGlvbl9yZWFzb246IHN0cmluZztcblxuICAvKipcbiAgICogTWV0YWRhZG9zIGFkaWNpb25haXMgZW0gZm9ybWF0byBKU09OXG4gICAqIFBhcmEgaW5mb3JtYcOnw7VlcyBleHRyYXMgZGUgYXVkaXRvcmlhXG4gICAqL1xuICBAQ29sdW1uKHtcbiAgICB0eXBlOiAnanNvbmInLFxuICAgIG51bGxhYmxlOiB0cnVlLFxuICAgIGNvbW1lbnQ6ICdNZXRhZGFkb3MgYWRpY2lvbmFpcyBwYXJhIGF1ZGl0b3JpYScsXG4gIH0pXG4gIG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG4gIEBDcmVhdGVEYXRlQ29sdW1uKHtcbiAgICB0eXBlOiAndGltZXN0YW1wJyxcbiAgICBkZWZhdWx0OiAoKSA9PiAnQ1VSUkVOVF9USU1FU1RBTVAnLFxuICAgIGNvbW1lbnQ6ICdEYXRhIGRlIGNyaWHDp8OjbyBkbyByZWdpc3RybycsXG4gIH0pXG4gIGNyZWF0ZWRfYXQ6IERhdGU7XG5cbiAgQFVwZGF0ZURhdGVDb2x1bW4oe1xuICAgIHR5cGU6ICd0aW1lc3RhbXAnLFxuICAgIGRlZmF1bHQ6ICgpID0+ICdDVVJSRU5UX1RJTUVTVEFNUCcsXG4gICAgb25VcGRhdGU6ICdDVVJSRU5UX1RJTUVTVEFNUCcsXG4gICAgY29tbWVudDogJ0RhdGEgZGEgw7psdGltYSBhdHVhbGl6YcOnw6NvIGRvIHJlZ2lzdHJvJyxcbiAgfSlcbiAgdXBkYXRlZF9hdDogRGF0ZTtcblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgbyB0b2tlbiBlc3TDoSB2w6FsaWRvXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyB0b2tlbiBuw6NvIGV4cGlyb3UgZSBuw6NvIGZvaSB1c2Fkb1xuICAgKi9cbiAgaXNWYWxpZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIHJldHVybiAhdGhpcy5pc191c2VkICYmIHRoaXMuZXhwaXJlc19hdCA+IG5vdztcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBvIHRva2VuIGV4cGlyb3VcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIHRva2VuIGV4cGlyb3VcbiAgICovXG4gIGlzRXhwaXJlZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIHJldHVybiB0aGlzLmV4cGlyZXNfYXQgPD0gbm93O1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmNhIG8gdG9rZW4gY29tbyB1c2Fkb1xuICAgKiBAcGFyYW0gcmVhc29uIE1vdGl2byBkYSBpbnZhbGlkYcOnw6NvXG4gICAqL1xuICBtYXJrQXNVc2VkKHJlYXNvbjogc3RyaW5nID0gJ3VzZWQnKTogdm9pZCB7XG4gICAgdGhpcy5pc191c2VkID0gdHJ1ZTtcbiAgICB0aGlzLnVzZWRfYXQgPSBuZXcgRGF0ZSgpO1xuICAgIHRoaXMuaW52YWxpZGF0aW9uX3JlYXNvbiA9IHJlYXNvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnRhIG8gY29udGFkb3IgZGUgdGVudGF0aXZhc1xuICAgKi9cbiAgaW5jcmVtZW50QXR0ZW1wdHMoKTogdm9pZCB7XG4gICAgdGhpcy5hdHRlbXB0cyArPSAxO1xuICAgIHRoaXMubGFzdF9hdHRlbXB0X2F0ID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhIG8gdGVtcG8gcmVzdGFudGUgYXTDqSBhIGV4cGlyYcOnw6NvIGVtIG1pbnV0b3NcbiAgICogQHJldHVybnMgTWludXRvcyByZXN0YW50ZXMgb3UgMCBzZSBleHBpcmFkb1xuICAgKi9cbiAgZ2V0TWludXRlc1VudGlsRXhwaXJhdGlvbigpOiBudW1iZXIge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgaWYgKHRoaXMuZXhwaXJlc19hdCA8PSBub3cpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5jZWlsKCh0aGlzLmV4cGlyZXNfYXQuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwKSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgbyB0b2tlbiBwZXJ0ZW5jZSBhIHVtIHVzdcOhcmlvIGVzcGVjw61maWNvXG4gICAqIEBwYXJhbSB1c3VhcmlvSWQgSUQgZG8gdXN1w6FyaW9cbiAgICogQHJldHVybnMgdHJ1ZSBzZSBwZXJ0ZW5jZSBhbyB1c3XDoXJpb1xuICAgKi9cbiAgYmVsb25nc1RvVXNlcih1c3VhcmlvSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnVzdWFyaW9faWQgPT09IHVzdWFyaW9JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBvIHRva2VuIGZvaSBjcmlhZG8gcmVjZW50ZW1lbnRlICjDumx0aW1hcyAyNCBob3JhcylcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBmb2kgY3JpYWRvIHJlY2VudGVtZW50ZVxuICAgKi9cbiAgaXNSZWNlbnRseUNyZWF0ZWQoKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBvbmVEYXlBZ28gPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpIC0gMjQgKiA2MCAqIDYwICogMTAwMCk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlZF9hdCA+IG9uZURheUFnbztcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBow6EgbXVpdGFzIHRlbnRhdGl2YXMgZGUgdXNvIChwb3Nzw612ZWwgYXRhcXVlKVxuICAgKiBAcGFyYW0gbWF4QXR0ZW1wdHMgTsO6bWVybyBtw6F4aW1vIGRlIHRlbnRhdGl2YXMgcGVybWl0aWRhc1xuICAgKiBAcmV0dXJucyB0cnVlIHNlIGV4Y2VkZXUgbyBsaW1pdGVcbiAgICovXG4gIGhhc1Rvb01hbnlBdHRlbXB0cyhtYXhBdHRlbXB0czogbnVtYmVyID0gNSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmF0dGVtcHRzID49IG1heEF0dGVtcHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIG8gdG9rZW4gZXhwaXJhIGVtIGJyZXZlIChwcsOzeGltb3MgNSBtaW51dG9zKVxuICAgKiBAcGFyYW0gbWludXRlcyBNaW51dG9zIHBhcmEgY29uc2lkZXJhciBjb21vIFwiZW0gYnJldmVcIlxuICAgKiBAcmV0dXJucyB0cnVlIHNlIGV4cGlyYSBlbSBicmV2ZVxuICAgKi9cbiAgZXhwaXJlc1dpdGhpbihtaW51dGVzOiBudW1iZXIgPSA1KTogYm9vbGVhbiB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBmdXR1cmVUaW1lID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIG1pbnV0ZXMgKiA2MCAqIDEwMDApO1xuICAgIHJldHVybiB0aGlzLmV4cGlyZXNfYXQgPD0gZnV0dXJlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhIGjDoSBxdWFudG9zIG1pbnV0b3MgbyB0b2tlbiBmb2kgY3JpYWRvXG4gICAqIEByZXR1cm5zIG1pbnV0b3MgZGVzZGUgYSBjcmlhw6fDo29cbiAgICovXG4gIGdldE1pbnV0ZXNTaW5jZUNyZWF0aW9uKCk6IG51bWJlciB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBkaWZmTXMgPSBub3cuZ2V0VGltZSgpIC0gdGhpcy5jcmVhdGVkX2F0LmdldFRpbWUoKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkaWZmTXMgLyAoMTAwMCAqIDYwKSk7XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIG8gc3RhdHVzIGF0dWFsIGRvIHRva2VuXG4gICAqIEByZXR1cm5zIHN0YXR1cyBkbyB0b2tlblxuICAgKi9cbiAgZ2V0U3RhdHVzKCk6ICd2YWxpZCcgfCAnZXhwaXJlZCcgfCAndXNlZCcgfCAndG9vX21hbnlfYXR0ZW1wdHMnIHtcbiAgICBpZiAodGhpcy5pc191c2VkKSByZXR1cm4gJ3VzZWQnO1xuICAgIGlmICh0aGlzLmlzRXhwaXJlZCgpKSByZXR1cm4gJ2V4cGlyZWQnO1xuICAgIGlmICh0aGlzLmhhc1Rvb01hbnlBdHRlbXB0cygpKSByZXR1cm4gJ3Rvb19tYW55X2F0dGVtcHRzJztcbiAgICByZXR1cm4gJ3ZhbGlkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSB0ZW0gaW5mb3JtYcOnw7VlcyBkZSBjbGllbnRlIChJUCBlIFVzZXIgQWdlbnQpXG4gICAqIEByZXR1cm5zIHRydWUgc2UgdGVtIGluZm9ybWHDp8O1ZXMgZGUgY2xpZW50ZVxuICAgKi9cbiAgaGFzQ2xpZW50SW5mbygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEodGhpcy5jbGllbnRfaXAgfHwgdGhpcy51c2VyX2FnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGljaW9uYSBtZXRhZGFkb3MgYW8gdG9rZW5cbiAgICogQHBhcmFtIGtleSBDaGF2ZSBkbyBtZXRhZGFkb1xuICAgKiBAcGFyYW0gdmFsdWUgVmFsb3IgZG8gbWV0YWRhZG9cbiAgICovXG4gIGFkZE1ldGFkYXRhKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLm1ldGFkYXRhKSB7XG4gICAgICB0aGlzLm1ldGFkYXRhID0ge307XG4gICAgfVxuICAgIHRoaXMubWV0YWRhdGFba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idMOpbSB1bSBtZXRhZGFkbyBlc3BlY8OtZmljb1xuICAgKiBAcGFyYW0ga2V5IENoYXZlIGRvIG1ldGFkYWRvXG4gICAqIEByZXR1cm5zIFZhbG9yIGRvIG1ldGFkYWRvIG91IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0TWV0YWRhdGEoa2V5OiBzdHJpbmcpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhPy5ba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnTDqW0gaW5mb3JtYcOnw7VlcyByZXN1bWlkYXMgZG8gdG9rZW5cbiAgICogQHJldHVybnMgb2JqZXRvIGNvbSBpbmZvcm1hw6fDtWVzIHJlc3VtaWRhc1xuICAgKi9cbiAgZ2V0U3VtbWFyeSgpOiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB1c3VhcmlvX2lkOiBzdHJpbmc7XG4gICAgaXNfdXNlZDogYm9vbGVhbjtcbiAgICBleHBpcmVzX2F0OiBEYXRlO1xuICAgIGNyZWF0ZWRfYXQ6IERhdGU7XG4gICAgYXR0ZW1wdHM6IG51bWJlcjtcbiAgICBzdGF0dXM6IHN0cmluZztcbiAgICBtaW51dGVzVW50aWxFeHBpcmF0aW9uOiBudW1iZXI7XG4gICAgaGFzQ2xpZW50SW5mbzogYm9vbGVhbjtcbiAgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgdXN1YXJpb19pZDogdGhpcy51c3VhcmlvX2lkLFxuICAgICAgaXNfdXNlZDogdGhpcy5pc191c2VkLFxuICAgICAgZXhwaXJlc19hdDogdGhpcy5leHBpcmVzX2F0LFxuICAgICAgY3JlYXRlZF9hdDogdGhpcy5jcmVhdGVkX2F0LFxuICAgICAgYXR0ZW1wdHM6IHRoaXMuYXR0ZW1wdHMsXG4gICAgICBzdGF0dXM6IHRoaXMuZ2V0U3RhdHVzKCksXG4gICAgICBtaW51dGVzVW50aWxFeHBpcmF0aW9uOiB0aGlzLmdldE1pbnV0ZXNVbnRpbEV4cGlyYXRpb24oKSxcbiAgICAgIGhhc0NsaWVudEluZm86IHRoaXMuaGFzQ2xpZW50SW5mbygpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZhbGlkYSBvIHRva2VuIGNvbSB1bSBtb3Rpdm8gZXNwZWPDrWZpY29cbiAgICogQHBhcmFtIHJlYXNvbiBNb3Rpdm8gZGEgaW52YWxpZGHDp8Ojb1xuICAgKi9cbiAgaW52YWxpZGF0ZShyZWFzb246IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuaXNfdXNlZCA9IHRydWU7XG4gICAgdGhpcy51c2VkX2F0ID0gbmV3IERhdGUoKTtcbiAgICB0aGlzLmludmFsaWRhdGlvbl9yZWFzb24gPSByZWFzb247XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgbyB0b2tlbiBmb2kgaW52YWxpZGFkbyBwb3IgbW90aXZvcyBkZSBzZWd1cmFuw6dhXG4gICAqIEByZXR1cm5zIHRydWUgc2UgZm9pIGludmFsaWRhZG8gcG9yIHNlZ3VyYW7Dp2FcbiAgICovXG4gIGlzU2VjdXJpdHlJbnZhbGlkYXRlZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCBzZWN1cml0eVJlYXNvbnMgPSBbXG4gICAgICAnc3VzcGljaW91c19hY3Rpdml0eScsXG4gICAgICAndG9vX21hbnlfYXR0ZW1wdHMnLFxuICAgICAgJ3NlY3VyaXR5X2JyZWFjaCcsXG4gICAgICAnYWRtaW5fcmV2b2tlJ1xuICAgIF07XG4gICAgXG4gICAgcmV0dXJuIHNlY3VyaXR5UmVhc29ucy5pbmNsdWRlcyh0aGlzLmludmFsaWRhdGlvbl9yZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlcmEgdW1hIGNoYXZlIMO6bmljYSBwYXJhIG8gdG9rZW5cbiAgICogQHJldHVybnMgY2hhdmUgw7puaWNhXG4gICAqL1xuICBnZXRVbmlxdWVLZXkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHBhc3N3b3JkX3Jlc2V0XyR7dGhpcy51c3VhcmlvX2lkfV8ke3RoaXMuaWR9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBvIHRva2VuIGVzdMOhIGVtIGVzdGFkbyBjb25zaXN0ZW50ZVxuICAgKiBAcmV0dXJucyB0cnVlIHNlIGVzdMOhIGNvbnNpc3RlbnRlXG4gICAqL1xuICBpc0NvbnNpc3RlbnQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgICEhdGhpcy5pZCAmJlxuICAgICAgISF0aGlzLnRva2VuICYmXG4gICAgICAhIXRoaXMudG9rZW5faGFzaCAmJlxuICAgICAgISF0aGlzLnVzdWFyaW9faWQgJiZcbiAgICAgICEhdGhpcy5leHBpcmVzX2F0ICYmXG4gICAgICAhIXRoaXMuY3JlYXRlZF9hdCAmJlxuICAgICAgdHlwZW9mIHRoaXMuaXNfdXNlZCA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICB0eXBlb2YgdGhpcy5hdHRlbXB0cyA9PT0gJ251bWJlcidcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBpbmZvcm1hw6fDtWVzIHNlbnPDrXZlaXMgcGFyYSBsb2dzXG4gICAqIEByZXR1cm5zIG9iamV0byBzYW5pdGl6YWRvXG4gICAqL1xuICB0b1NhZmVMb2coKToge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdXN1YXJpb19pZDogc3RyaW5nO1xuICAgIHRva2VuX3ByZXZpZXc6IHN0cmluZztcbiAgICBpc191c2VkOiBib29sZWFuO1xuICAgIGV4cGlyZXNfYXQ6IERhdGU7XG4gICAgY3JlYXRlZF9hdDogRGF0ZTtcbiAgICBhdHRlbXB0czogbnVtYmVyO1xuICAgIHN0YXR1czogc3RyaW5nO1xuICAgIGhhc0NsaWVudEluZm86IGJvb2xlYW47XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHVzdWFyaW9faWQ6IHRoaXMudXN1YXJpb19pZCxcbiAgICAgIHRva2VuX3ByZXZpZXc6IHRoaXMudG9rZW4uc3Vic3RyaW5nKDAsIDgpICsgJy4uLicsXG4gICAgICBpc191c2VkOiB0aGlzLmlzX3VzZWQsXG4gICAgICBleHBpcmVzX2F0OiB0aGlzLmV4cGlyZXNfYXQsXG4gICAgICBjcmVhdGVkX2F0OiB0aGlzLmNyZWF0ZWRfYXQsXG4gICAgICBhdHRlbXB0czogdGhpcy5hdHRlbXB0cyxcbiAgICAgIHN0YXR1czogdGhpcy5nZXRTdGF0dXMoKSxcbiAgICAgIGhhc0NsaWVudEluZm86IHRoaXMuaGFzQ2xpZW50SW5mbygpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXRhIGEgZGF0YSBkZSBleHBpcmHDp8OjbyBwYXJhIGV4aWJpw6fDo29cbiAgICogQHJldHVybnMgZGF0YSBmb3JtYXRhZGFcbiAgICovXG4gIGdldEV4cGlyYWNhb0Zvcm1hdGFkYSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmV4cGlyZXNfYXQudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJywge1xuICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgbW9udGg6ICcyLWRpZ2l0JyxcbiAgICAgIGRheTogJzItZGlnaXQnLFxuICAgICAgaG91cjogJzItZGlnaXQnLFxuICAgICAgbWludXRlOiAnMi1kaWdpdCdcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXRhIGEgZGF0YSBkZSBjcmlhw6fDo28gcGFyYSBleGliacOnw6NvXG4gICAqIEByZXR1cm5zIGRhdGEgZm9ybWF0YWRhXG4gICAqL1xuICBnZXRDcmlhY2FvRm9ybWF0YWRhKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlZF9hdC50b0xvY2FsZVN0cmluZygncHQtQlInLCB7XG4gICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgICBtb250aDogJzItZGlnaXQnLFxuICAgICAgZGF5OiAnMi1kaWdpdCcsXG4gICAgICBob3VyOiAnMi1kaWdpdCcsXG4gICAgICBtaW51dGU6ICcyLWRpZ2l0J1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIG8gdG9rZW4gcG9kZSBzZXIgdXNhZG8gcGFyYSByZXNldCBkZSBzZW5oYVxuICAgKiBAcmV0dXJucyB0cnVlIHNlIHBvZGUgc2VyIHVzYWRvXG4gICAqL1xuICBjYW5CZVVzZWRGb3JSZXNldCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICF0aGlzLmhhc1Rvb01hbnlBdHRlbXB0cygpICYmXG4gICAgICAhdGhpcy5pc1NlY3VyaXR5SW52YWxpZGF0ZWQoKVxuICAgICk7XG4gIH1cbn0iXSwidmVyc2lvbiI6M30=