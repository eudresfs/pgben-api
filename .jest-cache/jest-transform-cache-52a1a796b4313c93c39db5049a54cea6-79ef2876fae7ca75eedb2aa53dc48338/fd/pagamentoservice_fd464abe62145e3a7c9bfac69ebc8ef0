7c3feef44958c18b3dd2c2fdd25b3a6b
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PagamentoService = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const pagamento_entity_1 = require("../../../entities/pagamento.entity");
const status_pagamento_enum_1 = require("../../../enums/status-pagamento.enum");
const status_transition_validator_1 = require("../validators/status-transition-validator");
const enum_normalizer_util_1 = require("../../../shared/utils/enum-normalizer.util");
/**
 * Serviço para gerenciamento de operações relacionadas a pagamentos
 *
 * Implementa a lógica de negócio para criação, consulta, atualização
 * e gerenciamento de ciclo de vida dos pagamentos no sistema.
 *
 * @author Equipe PGBen
 */
let PagamentoService = class PagamentoService {
    pagamentoRepository;
    statusValidator;
    constructor(pagamentoRepository, statusValidator) {
        this.pagamentoRepository = pagamentoRepository;
        this.statusValidator = statusValidator;
    }
    /**
     * Cria um novo registro de pagamento para uma solicitação aprovada
     *
     * @param solicitacaoId ID da solicitação aprovada
     * @param createDto Dados para criação do pagamento
     * @param usuarioId ID do usuário que está realizando a operação
     * @returns Pagamento criado
     */
    async createPagamento(solicitacaoId, createDto, usuarioId) {
        // Validar se a solicitação existe e está aprovada
        // const solicitacao = await this.solicitacaoService.findOne(solicitacaoId);
        // if (!solicitacao) {
        //   throw new NotFoundException('Solicitação não encontrada');
        // }
        // if (solicitacao.status !== 'aprovada') {
        //   throw new ConflictException('Somente solicitações aprovadas podem ter pagamentos liberados');
        // }
        // Validar método de pagamento e informações bancárias
        if (createDto.metodoPagamento !== 'presencial' && !createDto.infoBancariaId) {
            throw new common_1.ConflictException('Informações bancárias são obrigatórias para pagamentos não presenciais');
        }
        // Validar limites de valor
        // await this.validarLimitesPagamento(solicitacao.tipoBeneficioId, createDto.valor);
        // Normalizar campos de enum antes de criar a entidade
        const dadosNormalizados = (0, enum_normalizer_util_1.normalizeEnumFields)({
            solicitacaoId,
            infoBancariaId: createDto.infoBancariaId,
            valor: createDto.valor,
            dataLiberacao: createDto.dataLiberacao,
            status: status_pagamento_enum_1.StatusPagamentoEnum.LIBERADO, // Status inicial ao criar o pagamento
            metodoPagamento: createDto.metodoPagamento,
            liberadoPor: usuarioId,
            observacoes: createDto.observacoes
        });
        // Criar nova entidade de pagamento
        const pagamento = this.pagamentoRepository.create(dadosNormalizados);
        // Salvar o pagamento
        const result = await this.pagamentoRepository.save(pagamento);
        // Atualizar status da solicitação
        // await this.solicitacaoService.atualizarStatusParaPagamentoPendente(solicitacaoId);
        // Registrar operação no log de auditoria
        // await this.auditoriaService.registrarOperacao({
        //   tipoOperacao: 'CRIACAO_PAGAMENTO',
        //   usuarioId,
        //   entidadeId: result.id,
        //   tipoEntidade: 'PAGAMENTO',
        //   dadosAnteriores: null,
        //   dadosNovos: result
        // });
        return result;
    }
    /**
     * Atualiza o status de um pagamento existente
     *
     * @param id ID do pagamento
     * @param novoStatus Novo status do pagamento
     * @param usuarioId ID do usuário que está realizando a operação
     * @returns Pagamento atualizado
     */
    async atualizarStatus(id, novoStatus, usuarioId) {
        // Buscar o pagamento pelo ID
        const pagamento = await this.findOne(id);
        if (!pagamento) {
            throw new common_1.NotFoundException('Pagamento não encontrado');
        }
        // Validar a transição de status
        const transitionResult = this.statusValidator.canTransition(pagamento.status, novoStatus);
        if (!transitionResult.allowed) {
            throw new common_1.ConflictException(`Transição de status não permitida: ${transitionResult.reason}`);
        }
        // Salvar dados anteriores para auditoria
        const dadosAnteriores = { ...pagamento };
        // Normalizar o novo status antes de atualizar
        const statusNormalizado = (0, enum_normalizer_util_1.normalizeEnumFields)({ status: novoStatus }).status;
        // Atualizar o status
        pagamento.status = statusNormalizado;
        // Salvar a atualização
        const result = await this.pagamentoRepository.save(pagamento);
        // Atualizar status da solicitação, se necessário
        // if (novoStatus === StatusPagamentoEnum.CONFIRMADO) {
        //   await this.solicitacaoService.atualizarStatusParaConcluido(pagamento.solicitacaoId);
        // } else if (novoStatus === StatusPagamentoEnum.CANCELADO) {
        //   await this.solicitacaoService.atualizarStatusParaAprovado(pagamento.solicitacaoId);
        // }
        // Registrar operação no log de auditoria
        // await this.auditoriaService.registrarOperacao({
        //   tipoOperacao: 'ATUALIZACAO_STATUS_PAGAMENTO',
        //   usuarioId,
        //   entidadeId: id,
        //   tipoEntidade: 'PAGAMENTO',
        //   dadosAnteriores,
        //   dadosNovos: result
        // });
        return result;
    }
    /**
     * Cancela um pagamento existente
     *
     * @param id ID do pagamento a ser cancelado
     * @param usuarioId ID do usuário que está realizando a operação
     * @param motivoCancelamento Motivo do cancelamento
     * @returns Pagamento cancelado
     */
    async cancelarPagamento(id, usuarioId, motivoCancelamento) {
        // Buscar o pagamento pelo ID
        const pagamento = await this.findOne(id);
        if (!pagamento) {
            throw new common_1.NotFoundException('Pagamento não encontrado');
        }
        // Verificar se o pagamento pode ser cancelado
        if (!this.statusValidator.canBeCanceled(pagamento.status)) {
            throw new common_1.ConflictException('Este pagamento não pode ser cancelado devido ao seu status atual');
        }
        // Salvar dados anteriores para auditoria
        const dadosAnteriores = { ...pagamento };
        // Atualizar o status e registrar motivo do cancelamento
        pagamento.status = status_pagamento_enum_1.StatusPagamentoEnum.CANCELADO;
        pagamento.observacoes = pagamento.observacoes
            ? `${pagamento.observacoes}\nMotivo do cancelamento: ${motivoCancelamento}`
            : `Motivo do cancelamento: ${motivoCancelamento}`;
        // Salvar a atualização
        const result = await this.pagamentoRepository.save(pagamento);
        // Atualizar status da solicitação
        // await this.solicitacaoService.atualizarStatusParaAprovado(pagamento.solicitacaoId);
        // Registrar operação no log de auditoria
        // await this.auditoriaService.registrarOperacao({
        //   tipoOperacao: 'CANCELAMENTO_PAGAMENTO',
        //   usuarioId,
        //   entidadeId: id,
        //   tipoEntidade: 'PAGAMENTO',
        //   dadosAnteriores,
        //   dadosNovos: result,
        //   observacoes: motivoCancelamento
        // });
        return result;
    }
    /**
     * Busca um pagamento pelo ID
     *
     * @param id ID do pagamento
     * @returns Pagamento encontrado ou null
     */
    async findOne(id) {
        return this.pagamentoRepository.findOneBy({ id });
    }
    /**
     * Busca um pagamento pelo ID com todos os relacionamentos
     *
     * @param id ID do pagamento
     * @returns Pagamento encontrado com relacionamentos ou null
     */
    async findOneWithRelations(id) {
        return this.pagamentoRepository.findOne({
            where: { id },
            relations: ['comprovantes', 'confirmacoes'],
        });
    }
    /**
     * Lista pagamentos com filtros e paginação
     *
     * @param options Opções de filtro
     * @returns Lista de pagamentos com meta-informações de paginação
     */
    async findAll(options) {
        const { status, unidadeId, dataInicio, dataFim, metodoPagamento, page = 1, limit = 10 } = options;
        // Construir a query base
        const queryBuilder = this.pagamentoRepository.createQueryBuilder('pagamento');
        // Adicionar condições
        if (status) {
            queryBuilder.andWhere('pagamento.status = :status', { status });
        }
        if (metodoPagamento) {
            queryBuilder.andWhere('pagamento.metodo_pagamento = :metodoPagamento', { metodoPagamento });
        }
        if (dataInicio) {
            queryBuilder.andWhere('pagamento.data_liberacao >= :dataInicio', { dataInicio });
        }
        if (dataFim) {
            queryBuilder.andWhere('pagamento.data_liberacao <= :dataFim', { dataFim });
        }
        // Filtro por unidade (requer join com solicitação)
        if (unidadeId) {
            queryBuilder
                .innerJoin('solicitacao', 's', 'pagamento.solicitacao_id = s.id')
                .andWhere('s.unidade_id = :unidadeId', { unidadeId });
        }
        // Adicionar paginação
        queryBuilder
            .skip((page - 1) * limit)
            .take(limit);
        // Ordenar por data de liberação (mais recentes primeiro)
        queryBuilder.orderBy('pagamento.data_liberacao', 'DESC');
        // Executar a query
        const [items, total] = await queryBuilder.getManyAndCount();
        return {
            items,
            total,
            page,
            limit
        };
    }
    /**
     * Lista pagamentos pendentes (liberados mas não confirmados)
     *
     * @param options Opções de filtro
     * @returns Lista de pagamentos pendentes
     */
    async findPendentes(options) {
        const { unidadeId, tipoBeneficioId, page = 1, limit = 10 } = options;
        // Construir a query base
        const queryBuilder = this.pagamentoRepository.createQueryBuilder('pagamento');
        // Filtrar apenas pagamentos liberados
        queryBuilder.where('pagamento.status = :status', { status: status_pagamento_enum_1.StatusPagamentoEnum.LIBERADO });
        // Filtros adicionais que requerem joins
        if (unidadeId || tipoBeneficioId) {
            queryBuilder.innerJoin('solicitacao', 's', 'pagamento.solicitacao_id = s.id');
            if (unidadeId) {
                queryBuilder.andWhere('s.unidade_id = :unidadeId', { unidadeId });
            }
            if (tipoBeneficioId) {
                queryBuilder.andWhere('s.tipo_beneficio_id = :tipoBeneficioId', { tipoBeneficioId });
            }
        }
        // Adicionar paginação
        queryBuilder
            .skip((page - 1) * limit)
            .take(limit);
        // Ordenar por data de liberação (mais antigos primeiro)
        queryBuilder.orderBy('pagamento.data_liberacao', 'ASC');
        // Executar a query
        const [items, total] = await queryBuilder.getManyAndCount();
        return {
            items,
            total,
            page,
            limit
        };
    }
    /**
     * Valida se o valor está dentro dos limites permitidos para o tipo de benefício
     *
     * @param tipoBeneficioId ID do tipo de benefício
     * @param valor Valor a ser validado
     * @throws ConflictException se o valor exceder os limites permitidos
     */
    async validarLimitesPagamento(tipoBeneficioId, valor) {
        // Esta é uma implementação de placeholder
        // Será integrada com o ConfiguracaoModule ou TipoBeneficioService
        // const tipoBeneficio = await this.tipoBeneficioService.findOne(tipoBeneficioId);
        // if (!tipoBeneficio) {
        //   throw new NotFoundException('Tipo de benefício não encontrado');
        // }
        // if (valor > tipoBeneficio.valorMaximo) {
        //   throw new ConflictException(
        //     `O valor excede o limite máximo permitido (${tipoBeneficio.valorMaximo}) para este tipo de benefício`
        //   );
        // }
        // if (valor < tipoBeneficio.valorMinimo) {
        //   throw new ConflictException(
        //     `O valor está abaixo do limite mínimo permitido (${tipoBeneficio.valorMinimo}) para este tipo de benefício`
        //   );
        // }
    }
};
exports.PagamentoService = PagamentoService;
exports.PagamentoService = PagamentoService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(pagamento_entity_1.Pagamento)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof status_transition_validator_1.StatusTransitionValidator !== "undefined" && status_transition_validator_1.StatusTransitionValidator) === "function" ? _b : Object])
], PagamentoService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXHBhZ2FtZW50b1xcc2VydmljZXNcXHBhZ2FtZW50by5zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBa0Y7QUFDbEYsNkNBQW1EO0FBQ25ELHFDQUFxQztBQUNyQyx5RUFBK0Q7QUFDL0QsZ0ZBQTJFO0FBRTNFLDJGQUFzRjtBQUN0RixxRkFBaUY7QUFFakY7Ozs7Ozs7R0FPRztBQUVJLElBQU0sZ0JBQWdCLEdBQXRCLE1BQU0sZ0JBQWdCO0lBR1I7SUFDQTtJQUhuQixZQUVtQixtQkFBMEMsRUFDMUMsZUFBMEM7UUFEMUMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUF1QjtRQUMxQyxvQkFBZSxHQUFmLGVBQWUsQ0FBMkI7SUFLMUQsQ0FBQztJQUVKOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsZUFBZSxDQUNuQixhQUFxQixFQUNyQixTQUE2QixFQUM3QixTQUFpQjtRQUVqQixrREFBa0Q7UUFDbEQsNEVBQTRFO1FBRTVFLHNCQUFzQjtRQUN0QiwrREFBK0Q7UUFDL0QsSUFBSTtRQUVKLDJDQUEyQztRQUMzQyxrR0FBa0c7UUFDbEcsSUFBSTtRQUVKLHNEQUFzRDtRQUN0RCxJQUFJLFNBQVMsQ0FBQyxlQUFlLEtBQUssWUFBWSxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQzVFLE1BQU0sSUFBSSwwQkFBaUIsQ0FDekIsd0VBQXdFLENBQ3pFLENBQUM7UUFDSixDQUFDO1FBRUQsMkJBQTJCO1FBQzNCLG9GQUFvRjtRQUVwRixzREFBc0Q7UUFDdEQsTUFBTSxpQkFBaUIsR0FBRyxJQUFBLDBDQUFtQixFQUFDO1lBQzVDLGFBQWE7WUFDYixjQUFjLEVBQUUsU0FBUyxDQUFDLGNBQWM7WUFDeEMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxLQUFLO1lBQ3RCLGFBQWEsRUFBRSxTQUFTLENB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LENBQUMsR0FBRyxLQUFLLENBQUM7YUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWYsd0RBQXdEO1FBQ3hELFlBQVksQ0FBQyxPQUFPLENBQUMsMEJBQTBCLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFeEQsbUJBQW1CO1FBQ25CLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEdBQUcsTUFBTSxZQUFZLENBQUMsZUFBZSxFQUFFLENBQUM7UUFFNUQsT0FBTztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsSUFBSTtZQUNKLEtBQUs7U0FDTixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxlQUF1QixFQUFFLEtBQWE7UUFDMUUsMENBQTBDO1FBQzFDLGtFQUFrRTtRQUVsRSxrRkFBa0Y7UUFFbEYsd0JBQXdCO1FBQ3hCLHFFQUFxRTtRQUNyRSxJQUFJO1FBRUosMkNBQTJDO1FBQzNDLGlDQUFpQztRQUNqQyw0R0FBNEc7UUFDNUcsT0FBTztRQUNQLElBQUk7UUFFSiwyQ0FBMkM7UUFDM0MsaUNBQWlDO1FBQ2pDLGtIQUFrSDtRQUNsSCxPQUFPO1FBQ1AsSUFBSTtJQUNOLENBQUM7Q0FDRixDQUFBO0FBM1hZLDRDQUFnQjsyQkFBaEIsZ0JBQWdCO0lBRDVCLElBQUEsbUJBQVUsR0FBRTtJQUdSLFdBQUEsSUFBQSwwQkFBZ0IsRUFBQyw0QkFBUyxDQUFDLENBQUE7eURBQ1Usb0JBQVUsb0JBQVYsb0JBQVUsb0RBQ2QsdURBQXlCLG9CQUF6Qix1REFBeUI7R0FKbEQsZ0JBQWdCLENBMlg1QiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcbW9kdWxlc1xccGFnYW1lbnRvXFxzZXJ2aWNlc1xccGFnYW1lbnRvLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29uZmxpY3RFeGNlcHRpb24sIEluamVjdGFibGUsIE5vdEZvdW5kRXhjZXB0aW9uIH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xuaW1wb3J0IHsgSW5qZWN0UmVwb3NpdG9yeSB9IGZyb20gJ0BuZXN0anMvdHlwZW9ybSc7XG5pbXBvcnQgeyBSZXBvc2l0b3J5IH0gZnJvbSAndHlwZW9ybSc7XG5pbXBvcnQgeyBQYWdhbWVudG8gfSBmcm9tICcuLi8uLi8uLi9lbnRpdGllcy9wYWdhbWVudG8uZW50aXR5JztcbmltcG9ydCB7IFN0YXR1c1BhZ2FtZW50b0VudW0gfSBmcm9tICcuLi8uLi8uLi9lbnVtcy9zdGF0dXMtcGFnYW1lbnRvLmVudW0nO1xuaW1wb3J0IHsgUGFnYW1lbnRvQ3JlYXRlRHRvIH0gZnJvbSAnLi4vZHRvcy9wYWdhbWVudG8tY3JlYXRlLmR0byc7XG5pbXBvcnQgeyBTdGF0dXNUcmFuc2l0aW9uVmFsaWRhdG9yIH0gZnJvbSAnLi4vdmFsaWRhdG9ycy9zdGF0dXMtdHJhbnNpdGlvbi12YWxpZGF0b3InO1xuaW1wb3J0IHsgbm9ybWFsaXplRW51bUZpZWxkcyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy9lbnVtLW5vcm1hbGl6ZXIudXRpbCc7XG5cbi8qKlxuICogU2VydmnDp28gcGFyYSBnZXJlbmNpYW1lbnRvIGRlIG9wZXJhw6fDtWVzIHJlbGFjaW9uYWRhcyBhIHBhZ2FtZW50b3NcbiAqIFxuICogSW1wbGVtZW50YSBhIGzDs2dpY2EgZGUgbmVnw7NjaW8gcGFyYSBjcmlhw6fDo28sIGNvbnN1bHRhLCBhdHVhbGl6YcOnw6NvXG4gKiBlIGdlcmVuY2lhbWVudG8gZGUgY2ljbG8gZGUgdmlkYSBkb3MgcGFnYW1lbnRvcyBubyBzaXN0ZW1hLlxuICogXG4gKiBAYXV0aG9yIEVxdWlwZSBQR0JlblxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnYW1lbnRvU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3RSZXBvc2l0b3J5KFBhZ2FtZW50bylcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhZ2FtZW50b1JlcG9zaXRvcnk6IFJlcG9zaXRvcnk8UGFnYW1lbnRvPixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0YXR1c1ZhbGlkYXRvcjogU3RhdHVzVHJhbnNpdGlvblZhbGlkYXRvcixcbiAgICAvLyBPdXRyb3Mgc2VydmnDp29zIG5lY2Vzc8OhcmlvcyBzZXLDo28gaW5qZXRhZG9zIGFxdWlcbiAgICAvLyBwcml2YXRlIHJlYWRvbmx5IHNvbGljaXRhY2FvU2VydmljZTogU29saWNpdGFjYW9TZXJ2aWNlLFxuICAgIC8vIHByaXZhdGUgcmVhZG9ubHkgYXVkaXRvcmlhU2VydmljZTogQXVkaXRvcmlhU2VydmljZSxcbiAgICAvLyBldGMuXG4gICkge31cblxuICAvKipcbiAgICogQ3JpYSB1bSBub3ZvIHJlZ2lzdHJvIGRlIHBhZ2FtZW50byBwYXJhIHVtYSBzb2xpY2l0YcOnw6NvIGFwcm92YWRhXG4gICAqIFxuICAgKiBAcGFyYW0gc29saWNpdGFjYW9JZCBJRCBkYSBzb2xpY2l0YcOnw6NvIGFwcm92YWRhXG4gICAqIEBwYXJhbSBjcmVhdGVEdG8gRGFkb3MgcGFyYSBjcmlhw6fDo28gZG8gcGFnYW1lbnRvXG4gICAqIEBwYXJhbSB1c3VhcmlvSWQgSUQgZG8gdXN1w6FyaW8gcXVlIGVzdMOhIHJlYWxpemFuZG8gYSBvcGVyYcOnw6NvXG4gICAqIEByZXR1cm5zIFBhZ2FtZW50byBjcmlhZG9cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVBhZ2FtZW50byhcbiAgICBzb2xpY2l0YWNhb0lkOiBzdHJpbmcsXG4gICAgY3JlYXRlRHRvOiBQYWdhbWVudG9DcmVhdGVEdG8sXG4gICAgdXN1YXJpb0lkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxQYWdhbWVudG8+IHtcbiAgICAvLyBWYWxpZGFyIHNlIGEgc29saWNpdGHDp8OjbyBleGlzdGUgZSBlc3TDoSBhcHJvdmFkYVxuICAgIC8vIGNvbnN0IHNvbGljaXRhY2FvID0gYXdhaXQgdGhpcy5zb2xpY2l0YWNhb1NlcnZpY2UuZmluZE9uZShzb2xpY2l0YWNhb0lkKTtcbiAgICBcbiAgICAvLyBpZiAoIXNvbGljaXRhY2FvKSB7XG4gICAgLy8gICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oJ1NvbGljaXRhw6fDo28gbsOjbyBlbmNvbnRyYWRhJyk7XG4gICAgLy8gfVxuICAgIFxuICAgIC8vIGlmIChzb2xpY2l0YWNhby5zdGF0dXMgIT09ICdhcHJvdmFkYScpIHtcbiAgICAvLyAgIHRocm93IG5ldyBDb25mbGljdEV4Y2VwdGlvbignU29tZW50ZSBzb2xpY2l0YcOnw7VlcyBhcHJvdmFkYXMgcG9kZW0gdGVyIHBhZ2FtZW50b3MgbGliZXJhZG9zJyk7XG4gICAgLy8gfVxuXG4gICAgLy8gVmFsaWRhciBtw6l0b2RvIGRlIHBhZ2FtZW50byBlIGluZm9ybWHDp8O1ZXMgYmFuY8Ohcmlhc1xuICAgIGlmIChjcmVhdGVEdG8ubWV0b2RvUGFnYW1lbnRvICE9PSAncHJlc2VuY2lhbCcgJiYgIWNyZWF0ZUR0by5pbmZvQmFuY2FyaWFJZCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0RXhjZXB0aW9uKFxuICAgICAgICAnSW5mb3JtYcOnw7VlcyBiYW5jw6FyaWFzIHPDo28gb2JyaWdhdMOzcmlhcyBwYXJhIHBhZ2FtZW50b3MgbsOjbyBwcmVzZW5jaWFpcydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhciBsaW1pdGVzIGRlIHZhbG9yXG4gICAgLy8gYXdhaXQgdGhpcy52YWxpZGFyTGltaXRlc1BhZ2FtZW50byhzb2xpY2l0YWNhby50aXBvQmVuZWZpY2lvSWQsIGNyZWF0ZUR0by52YWxvcik7XG5cbiAgICAvLyBOb3JtYWxpemFyIGNhbXBvcyBkZSBlbnVtIGFudGVzIGRlIGNyaWFyIGEgZW50aWRhZGVcbiAgICBjb25zdCBkYWRvc05vcm1hbGl6YWRvcyA9IG5vcm1hbGl6ZUVudW1GaWVsZHMoe1xuICAgICAgc29saWNpdGFjYW9JZCxcbiAgICAgIGluZm9CYW5jYXJpYUlkOiBjcmVhdGVEdG8uaW5mb0JhbmNhcmlhSWQsXG4gICAgICB2YWxvcjogY3JlYXRlRHRvLnZhbG9yLFxuICAgICAgZGF0YUxpYmVyYWNhbzogY3JlYXRlRHRvLmRhdGFMaWJlcmFjYW8sXG4gICAgICBzdGF0dXM6IFN0YXR1c1BhZ2FtZW50b0VudW0uTElCRVJBRE8sIC8vIFN0YXR1cyBpbmljaWFsIGFvIGNyaWFyIG8gcGFnYW1lbnRvXG4gICAgICBtZXRvZG9QYWdhbWVudG86IGNyZWF0ZUR0by5tZXRvZG9QYWdhbWVudG8sXG4gICAgICBsaWJlcmFkb1BvcjogdXN1YXJpb0lkLFxuICAgICAgb2JzZXJ2YWNvZXM6IGNyZWF0ZUR0by5vYnNlcnZhY29lc1xuICAgIH0pO1xuXG4gICAgLy8gQ3JpYXIgbm92YSBlbnRpZGFkZSBkZSBwYWdhbWVudG9cbiAgICBjb25zdCBwYWdhbWVudG8gPSB0aGlzLnBhZ2FtZW50b1JlcG9zaXRvcnkuY3JlYXRlKGRhZG9zTm9ybWFsaXphZG9zKTtcblxuICAgIC8vIFNhbHZhciBvIHBhZ2FtZW50b1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucGFnYW1lbnRvUmVwb3NpdG9yeS5zYXZlKHBhZ2FtZW50byk7XG5cbiAgICAvLyBBdHVhbGl6YXIgc3RhdHVzIGRhIHNvbGljaXRhw6fDo29cbiAgICAvLyBhd2FpdCB0aGlzLnNvbGljaXRhY2FvU2VydmljZS5hdHVhbGl6YXJTdGF0dXNQYXJhUGFnYW1lbnRvUGVuZGVudGUoc29saWNpdGFjYW9JZCk7XG5cbiAgICAvLyBSZWdpc3RyYXIgb3BlcmHDp8OjbyBubyBsb2cgZGUgYXVkaXRvcmlhXG4gICAgLy8gYXdhaXQgdGhpcy5hdWRpdG9yaWFTZXJ2aWNlLnJlZ2lzdHJhck9wZXJhY2FvKHtcbiAgICAvLyAgIHRpcG9PcGVyYWNhbzogJ0NSSUFDQU9fUEFHQU1FTlRPJyxcbiAgICAvLyAgIHVzdWFyaW9JZCxcbiAgICAvLyAgIGVudGlkYWRlSWQ6IHJlc3VsdC5pZCxcbiAgICAvLyAgIHRpcG9FbnRpZGFkZTogJ1BBR0FNRU5UTycsXG4gICAgLy8gICBkYWRvc0FudGVyaW9yZXM6IG51bGwsXG4gICAgLy8gICBkYWRvc05vdm9zOiByZXN1bHRcbiAgICAvLyB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQXR1YWxpemEgbyBzdGF0dXMgZGUgdW0gcGFnYW1lbnRvIGV4aXN0ZW50ZVxuICAgKiBcbiAgICogQHBhcmFtIGlkIElEIGRvIHBhZ2FtZW50b1xuICAgKiBAcGFyYW0gbm92b1N0YXR1cyBOb3ZvIHN0YXR1cyBkbyBwYWdhbWVudG9cbiAgICogQHBhcmFtIHVzdWFyaW9JZCBJRCBkbyB1c3XDoXJpbyBxdWUgZXN0w6EgcmVhbGl6YW5kbyBhIG9wZXJhw6fDo29cbiAgICogQHJldHVybnMgUGFnYW1lbnRvIGF0dWFsaXphZG9cbiAgICovXG4gIGFzeW5jIGF0dWFsaXphclN0YXR1cyhcbiAgICBpZDogc3RyaW5nLFxuICAgIG5vdm9TdGF0dXM6IFN0YXR1c1BhZ2FtZW50b0VudW0sXG4gICAgdXN1YXJpb0lkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxQYWdhbWVudG8+IHtcbiAgICAvLyBCdXNjYXIgbyBwYWdhbWVudG8gcGVsbyBJRFxuICAgIGNvbnN0IHBhZ2FtZW50byA9IGF3YWl0IHRoaXMuZmluZE9uZShpZCk7XG4gICAgXG4gICAgaWYgKCFwYWdhbWVudG8pIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignUGFnYW1lbnRvIG7Do28gZW5jb250cmFkbycpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXIgYSB0cmFuc2nDp8OjbyBkZSBzdGF0dXNcbiAgICBjb25zdCB0cmFuc2l0aW9uUmVzdWx0ID0gdGhpcy5zdGF0dXNWYWxpZGF0b3IuY2FuVHJhbnNpdGlvbihcbiAgICAgIHBhZ2FtZW50by5zdGF0dXMsXG4gICAgICBub3ZvU3RhdHVzXG4gICAgKTtcblxuICAgIGlmICghdHJhbnNpdGlvblJlc3VsdC5hbGxvd2VkKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RFeGNlcHRpb24oXG4gICAgICAgIGBUcmFuc2nDp8OjbyBkZSBzdGF0dXMgbsOjbyBwZXJtaXRpZGE6ICR7dHJhbnNpdGlvblJlc3VsdC5yZWFzb259YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBTYWx2YXIgZGFkb3MgYW50ZXJpb3JlcyBwYXJhIGF1ZGl0b3JpYVxuICAgIGNvbnN0IGRhZG9zQW50ZXJpb3JlcyA9IHsgLi4ucGFnYW1lbnRvIH07XG5cbiAgICAvLyBOb3JtYWxpemFyIG8gbm92byBzdGF0dXMgYW50ZXMgZGUgYXR1YWxpemFyXG4gICAgY29uc3Qgc3RhdHVzTm9ybWFsaXphZG8gPSBub3JtYWxpemVFbnVtRmllbGRzKHsgc3RhdHVzOiBub3ZvU3RhdHVzIH0pLnN0YXR1cztcbiAgICBcbiAgICAvLyBBdHVhbGl6YXIgbyBzdGF0dXNcbiAgICBwYWdhbWVudG8uc3RhdHVzID0gc3RhdHVzTm9ybWFsaXphZG87XG4gICAgXG4gICAgLy8gU2FsdmFyIGEgYXR1YWxpemHDp8Ojb1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucGFnYW1lbnRvUmVwb3NpdG9yeS5zYXZlKHBhZ2FtZW50byk7XG5cbiAgICAvLyBBdHVhbGl6YXIgc3RhdHVzIGRhIHNvbGljaXRhw6fDo28sIHNlIG5lY2Vzc8OhcmlvXG4gICAgLy8gaWYgKG5vdm9TdGF0dXMgPT09IFN0YXR1c1BhZ2FtZW50b0VudW0uQ09ORklSTUFETykge1xuICAgIC8vICAgYXdhaXQgdGhpcy5zb2xpY2l0YWNhb1NlcnZpY2UuYXR1YWxpemFyU3RhdHVzUGFyYUNvbmNsdWlkbyhwYWdhbWVudG8uc29saWNpdGFjYW9JZCk7XG4gICAgLy8gfSBlbHNlIGlmIChub3ZvU3RhdHVzID09PSBTdGF0dXNQYWdhbWVudG9FbnVtLkNBTkNFTEFETykge1xuICAgIC8vICAgYXdhaXQgdGhpcy5zb2xpY2l0YWNhb1NlcnZpY2UuYXR1YWxpemFyU3RhdHVzUGFyYUFwcm92YWRvKHBhZ2FtZW50by5zb2xpY2l0YWNhb0lkKTtcbiAgICAvLyB9XG5cbiAgICAvLyBSZWdpc3RyYXIgb3BlcmHDp8OjbyBubyBsb2cgZGUgYXVkaXRvcmlhXG4gICAgLy8gYXdhaXQgdGhpcy5hdWRpdG9yaWFTZXJ2aWNlLnJlZ2lzdHJhck9wZXJhY2FvKHtcbiAgICAvLyAgIHRpcG9PcGVyYWNhbzogJ0FUVUFMSVpBQ0FPX1NUQVRVU19QQUdBTUVOVE8nLFxuICAgIC8vICAgdXN1YXJpb0lkLFxuICAgIC8vICAgZW50aWRhZGVJZDogaWQsXG4gICAgLy8gICB0aXBvRW50aWRhZGU6ICdQQUdBTUVOVE8nLFxuICAgIC8vICAgZGFkb3NBbnRlcmlvcmVzLFxuICAgIC8vICAgZGFkb3NOb3ZvczogcmVzdWx0XG4gICAgLy8gfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbGEgdW0gcGFnYW1lbnRvIGV4aXN0ZW50ZVxuICAgKiBcbiAgICogQHBhcmFtIGlkIElEIGRvIHBhZ2FtZW50byBhIHNlciBjYW5jZWxhZG9cbiAgICogQHBhcmFtIHVzdWFyaW9JZCBJRCBkbyB1c3XDoXJpbyBxdWUgZXN0w6EgcmVhbGl6YW5kbyBhIG9wZXJhw6fDo29cbiAgICogQHBhcmFtIG1vdGl2b0NhbmNlbGFtZW50byBNb3Rpdm8gZG8gY2FuY2VsYW1lbnRvXG4gICAqIEByZXR1cm5zIFBhZ2FtZW50byBjYW5jZWxhZG9cbiAgICovXG4gIGFzeW5jIGNhbmNlbGFyUGFnYW1lbnRvKFxuICAgIGlkOiBzdHJpbmcsXG4gICAgdXN1YXJpb0lkOiBzdHJpbmcsXG4gICAgbW90aXZvQ2FuY2VsYW1lbnRvOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxQYWdhbWVudG8+IHtcbiAgICAvLyBCdXNjYXIgbyBwYWdhbWVudG8gcGVsbyBJRFxuICAgIGNvbnN0IHBhZ2FtZW50byA9IGF3YWl0IHRoaXMuZmluZE9uZShpZCk7XG4gICAgXG4gICAgaWYgKCFwYWdhbWVudG8pIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignUGFnYW1lbnRvIG7Do28gZW5jb250cmFkbycpO1xuICAgIH1cblxuICAgIC8vIFZlcmlmaWNhciBzZSBvIHBhZ2FtZW50byBwb2RlIHNlciBjYW5jZWxhZG9cbiAgICBpZiAoIXRoaXMuc3RhdHVzVmFsaWRhdG9yLmNhbkJlQ2FuY2VsZWQocGFnYW1lbnRvLnN0YXR1cykpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdEV4Y2VwdGlvbihcbiAgICAgICAgJ0VzdGUgcGFnYW1lbnRvIG7Do28gcG9kZSBzZXIgY2FuY2VsYWRvIGRldmlkbyBhbyBzZXUgc3RhdHVzIGF0dWFsJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBTYWx2YXIgZGFkb3MgYW50ZXJpb3JlcyBwYXJhIGF1ZGl0b3JpYVxuICAgIGNvbnN0IGRhZG9zQW50ZXJpb3JlcyA9IHsgLi4ucGFnYW1lbnRvIH07XG5cbiAgICAvLyBBdHVhbGl6YXIgbyBzdGF0dXMgZSByZWdpc3RyYXIgbW90aXZvIGRvIGNhbmNlbGFtZW50b1xuICAgIHBhZ2FtZW50by5zdGF0dXMgPSBTdGF0dXNQYWdhbWVudG9FbnVtLkNBTkNFTEFETztcbiAgICBwYWdhbWVudG8ub2JzZXJ2YWNvZXMgPSBwYWdhbWVudG8ub2JzZXJ2YWNvZXMgXG4gICAgICA/IGAke3BhZ2FtZW50by5vYnNlcnZhY29lc31cXG5Nb3Rpdm8gZG8gY2FuY2VsYW1lbnRvOiAke21vdGl2b0NhbmNlbGFtZW50b31gXG4gICAgICA6IGBNb3Rpdm8gZG8gY2FuY2VsYW1lbnRvOiAke21vdGl2b0NhbmNlbGFtZW50b31gO1xuICAgIFxuICAgIC8vIFNhbHZhciBhIGF0dWFsaXphw6fDo29cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2FtZW50b1JlcG9zaXRvcnkuc2F2ZShwYWdhbWVudG8pO1xuXG4gICAgLy8gQXR1YWxpemFyIHN0YXR1cyBkYSBzb2xpY2l0YcOnw6NvXG4gICAgLy8gYXdhaXQgdGhpcy5zb2xpY2l0YWNhb1NlcnZpY2UuYXR1YWxpemFyU3RhdHVzUGFyYUFwcm92YWRvKHBhZ2FtZW50by5zb2xpY2l0YWNhb0lkKTtcblxuICAgIC8vIFJlZ2lzdHJhciBvcGVyYcOnw6NvIG5vIGxvZyBkZSBhdWRpdG9yaWFcbiAgICAvLyBhd2FpdCB0aGlzLmF1ZGl0b3JpYVNlcnZpY2UucmVnaXN0cmFyT3BlcmFjYW8oe1xuICAgIC8vICAgdGlwb09wZXJhY2FvOiAnQ0FOQ0VMQU1FTlRPX1BBR0FNRU5UTycsXG4gICAgLy8gICB1c3VhcmlvSWQsXG4gICAgLy8gICBlbnRpZGFkZUlkOiBpZCxcbiAgICAvLyAgIHRpcG9FbnRpZGFkZTogJ1BBR0FNRU5UTycsXG4gICAgLy8gICBkYWRvc0FudGVyaW9yZXMsXG4gICAgLy8gICBkYWRvc05vdm9zOiByZXN1bHQsXG4gICAgLy8gICBvYnNlcnZhY29lczogbW90aXZvQ2FuY2VsYW1lbnRvXG4gICAgLy8gfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1c2NhIHVtIHBhZ2FtZW50byBwZWxvIElEXG4gICAqIFxuICAgKiBAcGFyYW0gaWQgSUQgZG8gcGFnYW1lbnRvXG4gICAqIEByZXR1cm5zIFBhZ2FtZW50byBlbmNvbnRyYWRvIG91IG51bGxcbiAgICovXG4gIGFzeW5jIGZpbmRPbmUoaWQ6IHN0cmluZyk6IFByb21pc2U8UGFnYW1lbnRvIHwgbnVsbD4ge1xuICAgIHJldHVybiB0aGlzLnBhZ2FtZW50b1JlcG9zaXRvcnkuZmluZE9uZUJ5KHsgaWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogQnVzY2EgdW0gcGFnYW1lbnRvIHBlbG8gSUQgY29tIHRvZG9zIG9zIHJlbGFjaW9uYW1lbnRvc1xuICAgKiBcbiAgICogQHBhcmFtIGlkIElEIGRvIHBhZ2FtZW50b1xuICAgKiBAcmV0dXJucyBQYWdhbWVudG8gZW5jb250cmFkbyBjb20gcmVsYWNpb25hbWVudG9zIG91IG51bGxcbiAgICovXG4gIGFzeW5jIGZpbmRPbmVXaXRoUmVsYXRpb25zKGlkOiBzdHJpbmcpOiBQcm9taXNlPFBhZ2FtZW50byB8IG51bGw+IHtcbiAgICByZXR1cm4gdGhpcy5wYWdhbWVudG9SZXBvc2l0b3J5LmZpbmRPbmUoe1xuICAgICAgd2hlcmU6IHsgaWQgfSxcbiAgICAgIHJlbGF0aW9uczogWydjb21wcm92YW50ZXMnLCAnY29uZmlybWFjb2VzJ10sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGEgcGFnYW1lbnRvcyBjb20gZmlsdHJvcyBlIHBhZ2luYcOnw6NvXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcMOnw7VlcyBkZSBmaWx0cm9cbiAgICogQHJldHVybnMgTGlzdGEgZGUgcGFnYW1lbnRvcyBjb20gbWV0YS1pbmZvcm1hw6fDtWVzIGRlIHBhZ2luYcOnw6NvXG4gICAqL1xuICBhc3luYyBmaW5kQWxsKG9wdGlvbnM6IHtcbiAgICBzdGF0dXM/OiBTdGF0dXNQYWdhbWVudG9FbnVtO1xuICAgIHVuaWRhZGVJZD86IHN0cmluZztcbiAgICBkYXRhSW5pY2lvPzogRGF0ZTtcbiAgICBkYXRhRmltPzogRGF0ZTtcbiAgICBtZXRvZG9QYWdhbWVudG8/OiBzdHJpbmc7XG4gICAgcGFnZT86IG51bWJlcjtcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgfSk6IFByb21pc2U8eyBpdGVtczogUGFnYW1lbnRvW107IHRvdGFsOiBudW1iZXI7IHBhZ2U6IG51bWJlcjsgbGltaXQ6IG51bWJlciB9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhdHVzLFxuICAgICAgdW5pZGFkZUlkLFxuICAgICAgZGF0YUluaWNpbyxcbiAgICAgIGRhdGFGaW0sXG4gICAgICBtZXRvZG9QYWdhbWVudG8sXG4gICAgICBwYWdlID0gMSxcbiAgICAgIGxpbWl0ID0gMTBcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIC8vIENvbnN0cnVpciBhIHF1ZXJ5IGJhc2VcbiAgICBjb25zdCBxdWVyeUJ1aWxkZXIgPSB0aGlzLnBhZ2FtZW50b1JlcG9zaXRvcnkuY3JlYXRlUXVlcnlCdWlsZGVyKCdwYWdhbWVudG8nKTtcbiAgICBcbiAgICAvLyBBZGljaW9uYXIgY29uZGnDp8O1ZXNcbiAgICBpZiAoc3RhdHVzKSB7XG4gICAgICBxdWVyeUJ1aWxkZXIuYW5kV2hlcmUoJ3BhZ2FtZW50by5zdGF0dXMgPSA6c3RhdHVzJywgeyBzdGF0dXMgfSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChtZXRvZG9QYWdhbWVudG8pIHtcbiAgICAgIHF1ZXJ5QnVpbGRlci5hbmRXaGVyZSgncGFnYW1lbnRvLm1ldG9kb19wYWdhbWVudG8gPSA6bWV0b2RvUGFnYW1lbnRvJywgeyBtZXRvZG9QYWdhbWVudG8gfSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChkYXRhSW5pY2lvKSB7XG4gICAgICBxdWVyeUJ1aWxkZXIuYW5kV2hlcmUoJ3BhZ2FtZW50by5kYXRhX2xpYmVyYWNhbyA+PSA6ZGF0YUluaWNpbycsIHsgZGF0YUluaWNpbyB9KTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGRhdGFGaW0pIHtcbiAgICAgIHF1ZXJ5QnVpbGRlci5hbmRXaGVyZSgncGFnYW1lbnRvLmRhdGFfbGliZXJhY2FvIDw9IDpkYXRhRmltJywgeyBkYXRhRmltIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaWx0cm8gcG9yIHVuaWRhZGUgKHJlcXVlciBqb2luIGNvbSBzb2xpY2l0YcOnw6NvKVxuICAgIGlmICh1bmlkYWRlSWQpIHtcbiAgICAgIHF1ZXJ5QnVpbGRlclxuICAgICAgICAuaW5uZXJKb2luKCdzb2xpY2l0YWNhbycsICdzJywgJ3BhZ2FtZW50by5zb2xpY2l0YWNhb19pZCA9IHMuaWQnKVxuICAgICAgICAuYW5kV2hlcmUoJ3MudW5pZGFkZV9pZCA9IDp1bmlkYWRlSWQnLCB7IHVuaWRhZGVJZCB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRpY2lvbmFyIHBhZ2luYcOnw6NvXG4gICAgcXVlcnlCdWlsZGVyXG4gICAgICAuc2tpcCgocGFnZSAtIDEpICogbGltaXQpXG4gICAgICAudGFrZShsaW1pdCk7XG4gICAgXG4gICAgLy8gT3JkZW5hciBwb3IgZGF0YSBkZSBsaWJlcmHDp8OjbyAobWFpcyByZWNlbnRlcyBwcmltZWlybylcbiAgICBxdWVyeUJ1aWxkZXIub3JkZXJCeSgncGFnYW1lbnRvLmRhdGFfbGliZXJhY2FvJywgJ0RFU0MnKTtcbiAgICBcbiAgICAvLyBFeGVjdXRhciBhIHF1ZXJ5XG4gICAgY29uc3QgW2l0ZW1zLCB0b3RhbF0gPSBhd2FpdCBxdWVyeUJ1aWxkZXIuZ2V0TWFueUFuZENvdW50KCk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1zLFxuICAgICAgdG90YWwsXG4gICAgICBwYWdlLFxuICAgICAgbGltaXRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RhIHBhZ2FtZW50b3MgcGVuZGVudGVzIChsaWJlcmFkb3MgbWFzIG7Do28gY29uZmlybWFkb3MpXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcMOnw7VlcyBkZSBmaWx0cm9cbiAgICogQHJldHVybnMgTGlzdGEgZGUgcGFnYW1lbnRvcyBwZW5kZW50ZXNcbiAgICovXG4gIGFzeW5jIGZpbmRQZW5kZW50ZXMob3B0aW9uczoge1xuICAgIHVuaWRhZGVJZD86IHN0cmluZztcbiAgICB0aXBvQmVuZWZpY2lvSWQ/OiBzdHJpbmc7XG4gICAgcGFnZT86IG51bWJlcjtcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgfSk6IFByb21pc2U8eyBpdGVtczogUGFnYW1lbnRvW107IHRvdGFsOiBudW1iZXI7IHBhZ2U6IG51bWJlcjsgbGltaXQ6IG51bWJlciB9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdW5pZGFkZUlkLFxuICAgICAgdGlwb0JlbmVmaWNpb0lkLFxuICAgICAgcGFnZSA9IDEsXG4gICAgICBsaW1pdCA9IDEwXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICAvLyBDb25zdHJ1aXIgYSBxdWVyeSBiYXNlXG4gICAgY29uc3QgcXVlcnlCdWlsZGVyID0gdGhpcy5wYWdhbWVudG9SZXBvc2l0b3J5LmNyZWF0ZVF1ZXJ5QnVpbGRlcigncGFnYW1lbnRvJyk7XG4gICAgXG4gICAgLy8gRmlsdHJhciBhcGVuYXMgcGFnYW1lbnRvcyBsaWJlcmFkb3NcbiAgICBxdWVyeUJ1aWxkZXIud2hlcmUoJ3BhZ2FtZW50by5zdGF0dXMgPSA6c3RhdHVzJywgeyBzdGF0dXM6IFN0YXR1c1BhZ2FtZW50b0VudW0uTElCRVJBRE8gfSk7XG4gICAgXG4gICAgLy8gRmlsdHJvcyBhZGljaW9uYWlzIHF1ZSByZXF1ZXJlbSBqb2luc1xuICAgIGlmICh1bmlkYWRlSWQgfHwgdGlwb0JlbmVmaWNpb0lkKSB7XG4gICAgICBxdWVyeUJ1aWxkZXIuaW5uZXJKb2luKCdzb2xpY2l0YWNhbycsICdzJywgJ3BhZ2FtZW50by5zb2xpY2l0YWNhb19pZCA9IHMuaWQnKTtcbiAgICAgIFxuICAgICAgaWYgKHVuaWRhZGVJZCkge1xuICAgICAgICBxdWVyeUJ1aWxkZXIuYW5kV2hlcmUoJ3MudW5pZGFkZV9pZCA9IDp1bmlkYWRlSWQnLCB7IHVuaWRhZGVJZCB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHRpcG9CZW5lZmljaW9JZCkge1xuICAgICAgICBxdWVyeUJ1aWxkZXIuYW5kV2hlcmUoJ3MudGlwb19iZW5lZmljaW9faWQgPSA6dGlwb0JlbmVmaWNpb0lkJywgeyB0aXBvQmVuZWZpY2lvSWQgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEFkaWNpb25hciBwYWdpbmHDp8Ojb1xuICAgIHF1ZXJ5QnVpbGRlclxuICAgICAgLnNraXAoKHBhZ2UgLSAxKSAqIGxpbWl0KVxuICAgICAgLnRha2UobGltaXQpO1xuICAgIFxuICAgIC8vIE9yZGVuYXIgcG9yIGRhdGEgZGUgbGliZXJhw6fDo28gKG1haXMgYW50aWdvcyBwcmltZWlybylcbiAgICBxdWVyeUJ1aWxkZXIub3JkZXJCeSgncGFnYW1lbnRvLmRhdGFfbGliZXJhY2FvJywgJ0FTQycpO1xuICAgIFxuICAgIC8vIEV4ZWN1dGFyIGEgcXVlcnlcbiAgICBjb25zdCBbaXRlbXMsIHRvdGFsXSA9IGF3YWl0IHF1ZXJ5QnVpbGRlci5nZXRNYW55QW5kQ291bnQoKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbXMsXG4gICAgICB0b3RhbCxcbiAgICAgIHBhZ2UsXG4gICAgICBsaW1pdFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhIHNlIG8gdmFsb3IgZXN0w6EgZGVudHJvIGRvcyBsaW1pdGVzIHBlcm1pdGlkb3MgcGFyYSBvIHRpcG8gZGUgYmVuZWbDrWNpb1xuICAgKiBcbiAgICogQHBhcmFtIHRpcG9CZW5lZmljaW9JZCBJRCBkbyB0aXBvIGRlIGJlbmVmw61jaW9cbiAgICogQHBhcmFtIHZhbG9yIFZhbG9yIGEgc2VyIHZhbGlkYWRvXG4gICAqIEB0aHJvd3MgQ29uZmxpY3RFeGNlcHRpb24gc2UgbyB2YWxvciBleGNlZGVyIG9zIGxpbWl0ZXMgcGVybWl0aWRvc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB2YWxpZGFyTGltaXRlc1BhZ2FtZW50byh0aXBvQmVuZWZpY2lvSWQ6IHN0cmluZywgdmFsb3I6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEVzdGEgw6kgdW1hIGltcGxlbWVudGHDp8OjbyBkZSBwbGFjZWhvbGRlclxuICAgIC8vIFNlcsOhIGludGVncmFkYSBjb20gbyBDb25maWd1cmFjYW9Nb2R1bGUgb3UgVGlwb0JlbmVmaWNpb1NlcnZpY2VcbiAgICBcbiAgICAvLyBjb25zdCB0aXBvQmVuZWZpY2lvID0gYXdhaXQgdGhpcy50aXBvQmVuZWZpY2lvU2VydmljZS5maW5kT25lKHRpcG9CZW5lZmljaW9JZCk7XG4gICAgXG4gICAgLy8gaWYgKCF0aXBvQmVuZWZpY2lvKSB7XG4gICAgLy8gICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oJ1RpcG8gZGUgYmVuZWbDrWNpbyBuw6NvIGVuY29udHJhZG8nKTtcbiAgICAvLyB9XG4gICAgXG4gICAgLy8gaWYgKHZhbG9yID4gdGlwb0JlbmVmaWNpby52YWxvck1heGltbykge1xuICAgIC8vICAgdGhyb3cgbmV3IENvbmZsaWN0RXhjZXB0aW9uKFxuICAgIC8vICAgICBgTyB2YWxvciBleGNlZGUgbyBsaW1pdGUgbcOheGltbyBwZXJtaXRpZG8gKCR7dGlwb0JlbmVmaWNpby52YWxvck1heGltb30pIHBhcmEgZXN0ZSB0aXBvIGRlIGJlbmVmw61jaW9gXG4gICAgLy8gICApO1xuICAgIC8vIH1cbiAgICBcbiAgICAvLyBpZiAodmFsb3IgPCB0aXBvQmVuZWZpY2lvLnZhbG9yTWluaW1vKSB7XG4gICAgLy8gICB0aHJvdyBuZXcgQ29uZmxpY3RFeGNlcHRpb24oXG4gICAgLy8gICAgIGBPIHZhbG9yIGVzdMOhIGFiYWl4byBkbyBsaW1pdGUgbcOtbmltbyBwZXJtaXRpZG8gKCR7dGlwb0JlbmVmaWNpby52YWxvck1pbmltb30pIHBhcmEgZXN0ZSB0aXBvIGRlIGJlbmVmw61jaW9gXG4gICAgLy8gICApO1xuICAgIC8vIH1cbiAgfVxufVxuIl0sInZlcnNpb24iOjN9