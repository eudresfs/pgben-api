5c421b2462766504f3cbb322f4ba3028
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const testing_1 = require("@nestjs/testing");
const enhanced_metrics_interceptor_1 = require("../enhanced-metrics.interceptor");
const enhanced_metrics_service_1 = require("../enhanced-metrics.service");
const common_1 = require("@nestjs/common");
const rxjs_1 = require("rxjs");
const core_1 = require("@nestjs/core");
/**
 * Testes unitários para o interceptor de métricas aprimorado
 *
 * Verifica o funcionamento do interceptor que coleta métricas
 * avançadas sobre as requisições HTTP, com foco em segurança e compliance LGPD
 */
describe('EnhancedMetricsInterceptor', () => {
    let interceptor;
    let metricsService;
    let reflector;
    // Mock do serviço de métricas aprimoradas
    const mockMetricsService = {
        incrementHttpRequestsInProgress: jest.fn(),
        decrementHttpRequestsInProgress: jest.fn(),
        recordHttpRequest: jest.fn(),
        recordHttpRequestDuration: jest.fn(),
        recordSecurityEvent: jest.fn(),
        recordLgpdDataAccess: jest.fn(),
        recordAuthorizationFailure: jest.fn(),
    };
    // Mock do reflector
    const mockReflector = {
        get: jest.fn(),
    };
    beforeEach(async () => {
        jest.clearAllMocks();
        // Mock para Date.now() - primeiro retorna 1000, depois 1200
        jest
            .spyOn(Date, 'now')
            .mockImplementationOnce(() => 1000)
            .mockImplementationOnce(() => 1200);
        const module = await testing_1.Test.createTestingModule({
            providers: [
                enhanced_metrics_interceptor_1.EnhancedMetricsInterceptor,
                {
                    provide: enhanced_metrics_service_1.EnhancedMetricsService,
                    useValue: mockMetricsService,
                },
                {
                    provide: core_1.Reflector,
                    useValue: mockReflector,
                },
            ],
        }).compile();
        interceptor = module.get(enhanced_metrics_interceptor_1.EnhancedMetricsInterceptor);
        metricsService = module.get(enhanced_metrics_service_1.EnhancedMetricsService);
        reflector = module.get(core_1.Reflector);
    });
    afterEach(() => {
        jest.restoreAllMocks();
    });
    it('deve ser definido', () => {
        expect(interceptor).toBeDefined();
    });
    describe('intercept', () => {
        it('deve coletar métricas para uma requisição bem-sucedida', (done) => {
            // Mock do contexto de execução
            const mockRequest = {
                method: 'GET',
                originalUrl: '/api/cidadaos',
                route: {
                    path: '/api/cidadaos',
                },
                user: {
                    id: 'user123',
                    roles: ['admin'],
                },
                ip: '192.168.1.1',
                headers: {
                    'user-agent': 'test-agent',
                },
            };
            const mockResponse = {
                statusCode: 200,
                getHeaders: jest.fn().mockReturnValue({}),
            };
            const mockExecutionContext = {
                switchToHttp: jest.fn().mockReturnValue({
                    getRequest: jest.fn().mockReturnValue(mockRequest),
                    getResponse: jest.fn().mockReturnValue(mockResponse),
                }),
                getHandler: jest.fn(),
                getClass: jest.fn(),
            };
            // Mock do handler de chamada
            const mockCallHandler = {
                handle: jest.fn().mockReturnValue((0, rxjs_1.of)({ data: 'test' })),
            };
            // Mock do reflector para retornar metadados de LGPD
            mockReflector.get
                .mockReturnValueOnce(false) // isPublic
                .mockReturnValueOnce(['dados_pessoais']); // lgpdDataTypes
            // Executar o interceptor
            interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe({
                next: (data) => {
                    expect(data).toEqual({ data: 'test' });
                    // Verificar se as métricas foram coletadas corretamente
                    expect(mockMetricsService.incrementHttpRequestsInProgress).toHaveBeenCalledWith('GET', '/api/cidadaos', 'admin');
                    expect(mockMetricsService.decrementHttpRequestsInProgress).toHaveBeenCalledWith('GET', '/api/cidadaos', 'admin');
                    // O método recordHttpRequest não recebe ip e user-agent
                    expect(mockMetricsService.recordHttpRequest).toHaveBeenCalledWith('GET', '/api/cidadaos', 200, 'admin');
                    // Verificar se a duração foi registrada
                    // O método recordHttpRequestDuration não recebe ip e user-agent
                    expect(mockMetricsService.recordHttpRequestDuration).toHaveBeenCalledWith('GET', '/api/cidadaos', 200, 0.2, // 200ms em segundos
                    'admin');
                    // O método recordLgpdDataAccess não é chamado automaticamente no interceptor
                    // A verificação de acesso a dados LGPD deve ser feita manualmente
                    done();
                },
                error: (err) => {
                    done.fail(`Erro inesperado: ${err}`);
                },
            });
        });
        it('deve coletar métricas para uma requisição com erro', (done) => {
            // Mock do contexto de execução
            const mockRequest = {
                method: 'POST',
                originalUrl: '/api/cidadaos',
                route: {
                    path: '/api/cidadaos',
                },
                user: {
                    id: 'user123',
                    roles: ['user'],
                },
                ip: '192.168.1.2',
                headers: {
                    'user-agent': 'test-agent',
                },
            };
            const mockResponse = {
                statusCode: 500,
                getHeaders: jest.fn().mockReturnValue({}),
            };
            const mockExecutionContext = {
                switchToHttp: jest.fn().mockReturnValue({
                    getRequest: jest.fn().mockReturnValue(mockRequest),
                    getResponse: jest.fn().mockReturnValue(mockResponse),
                }),
                getHandler: jest.fn(),
                getClass: jest.fn(),
            };
            // Mock do handler de chamada com erro
            const mockError = new Error('Erro interno do servidor');
            mockError.status = 500;
            const mockCallHandler = {
                handle: jest.fn().mockReturnValue((0, rxjs_1.throwError)(() => mockError)),
            };
            // Mock do reflector - não é usado em caso de erro
            mockReflector.get.mockImplementation((key) => {
                if (key === 'isPublic') {
                    return false;
                }
                return undefined;
            });
            // Executar o interceptor
            interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe({
                next: () => {
                    done.fail('O interceptor deveria ter retornado um erro');
                },
                error: (error) => {
                    expect(error).toBe(mockError);
                    // Verificar se as métricas de erro foram registradas
                    expect(mockMetricsService.recordHttpRequest).toHaveBeenCalledWith('POST', '/api/cidadaos', 500, 'user');
                    // Verificar se a duração foi registrada
                    expect(mockMetricsService.recordHttpRequestDuration).toHaveBeenCalledWith('POST', '/api/cidadaos', 500, expect.any(Number), // Duração em segundos
                    'user');
                    // Verificar se o evento de segurança foi registrado
                    expect(mockMetricsService.recordSecurityEvent).toHaveBeenCalledWith('server_error', 'error', 'api');
                    done();
                },
            });
        });
        it('deve lidar com requisições não autenticadas', (done) => {
            // Mock do contexto de execução sem usuário autenticado
            const mockRequest = {
                method: 'GET',
                url: '/api/public',
                route: {
                    path: '/api/public',
                },
                ip: '192.168.1.3',
                headers: {
                    'user-agent': 'test-agent',
                },
            };
            const mockResponse = {
                statusCode: 200,
                getHeaders: jest.fn().mockReturnValue({}),
            };
            const mockExecutionContext = {
                switchToHttp: jest.fn().mockReturnValue({
                    getRequest: jest.fn().mockReturnValue(mockRequest),
                    getResponse: jest.fn().mockReturnValue(mockResponse),
                }),
                getHandler: jest.fn(),
                getClass: jest.fn(),
            };
            // Mock do handler de chamada
            const mockCallHandler = {
                handle: jest.fn().mockReturnValue((0, rxjs_1.of)({ data: 'public data' })),
            };
            // O interceptor não verifica isPublic, apenas registra métricas
            // A verificação de rotas públicas é feita por outros middlewares/guards
            mockReflector.get.mockImplementation((key) => {
                if (key === 'isPublic') {
                    return true;
                }
                return undefined;
            });
            // Executar o interceptor
            interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe({
                next: (data) => {
                    expect(data).toEqual({ data: 'public data' });
                    // Verificar se as métricas foram coletadas sem informações de usuário
                    expect(mockMetricsService.recordHttpRequest).toHaveBeenCalledWith('GET', '/api/public', 200, 'anonymous');
                    // Verificar se a duração foi registrada
                    expect(mockMetricsService.recordHttpRequestDuration).toHaveBeenCalledWith('GET', '/api/public', 200, expect.any(Number), // Duração em segundos
                    'anonymous');
                    // O interceptor não verifica isPublic, então não podemos garantir que recordLgpdDataAccess não foi chamado
                    // A verificação de rotas públicas é feita por outros middlewares/guards
                    done();
                },
                error: done,
            });
        });
        it('deve lidar com erros de autorização', (done) => {
            // Mock do contexto de execução com usuário não autorizado
            const mockRequest = {
                method: 'GET',
                originalUrl: '/api/admin',
                route: {
                    path: '/api/admin',
                },
                user: {
                    id: 'user123',
                    roles: ['user'],
                },
                ip: '192.168.1.4',
                headers: {
                    'user-agent': 'test-agent',
                },
            };
            const mockResponse = {
                statusCode: 403,
                getHeaders: jest.fn().mockReturnValue({}),
            };
            const mockExecutionContext = {
                switchToHttp: jest.fn().mockReturnValue({
                    getRequest: jest.fn().mockReturnValue(mockRequest),
                    getResponse: jest.fn().mockReturnValue(mockResponse),
                }),
                getHandler: jest.fn(),
                getClass: jest.fn(),
            };
            // Mock do handler de chamada com erro de autorização
            const mockError = new common_1.UnauthorizedException('Acesso não autorizado');
            mockError.status = 403;
            const mockCallHandler = {
                handle: jest.fn().mockReturnValue((0, rxjs_1.throwError)(() => mockError)),
            };
            // Mock do reflector para o teste de autorização
            mockReflector.get.mockImplementation((key) => {
                if (key === 'isPublic') {
                    return false;
                }
                if (key === 'roles') {
                    return ['admin'];
                }
                if (key === 'lgpdDataTypes') {
                    return [];
                }
                return undefined;
            });
            // Executar o interceptor
            interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe({
                next: () => {
                    done.fail('Não deveria chegar aqui');
                },
                error: (error) => {
                    expect(error).toBe(mockError);
                    // Verificar se o evento de segurança foi registrado
                    expect(mockMetricsService.recordSecurityEvent).toHaveBeenCalledWith('authorization_failure', 'warning', 'api');
                    // Verificar se a falha de autorização foi registrada
                    expect(mockMetricsService.recordAuthorizationFailure).toHaveBeenCalledWith('/api/admin', 'unknown', 'user');
                    done();
                },
            });
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXHNoYXJlZFxcbW9uaXRvcmluZ1xcdGVzdHNcXGVuaGFuY2VkLW1ldHJpY3MuaW50ZXJjZXB0b3Iuc3BlYy50cyIsIm1hcHBpbmdzIjoiOztBQUFBLDZDQUFzRDtBQUN0RCxrRkFBNkU7QUFDN0UsMEVBQXFFO0FBQ3JFLDJDQUl3QjtBQUN4QiwrQkFBc0M7QUFFdEMsdUNBQXlDO0FBRXpDOzs7OztHQUtHO0FBQ0gsUUFBUSxDQUFDLDRCQUE0QixFQUFFLEdBQUcsRUFBRTtJQUMxQyxJQUFJLFdBQXVDLENBQUM7SUFDNUMsSUFBSSxjQUFzQyxDQUFDO0lBQzNDLElBQUksU0FBb0IsQ0FBQztJQUV6QiwwQ0FBMEM7SUFDMUMsTUFBTSxrQkFBa0IsR0FBRztRQUN6QiwrQkFBK0IsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQzFDLCtCQUErQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDMUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUM1Qix5QkFBeUIsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ3BDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDOUIsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUMvQiwwQkFBMEIsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0tBQ3RDLENBQUM7SUFFRixvQkFBb0I7SUFDcEIsTUFBTSxhQUFhLEdBQUc7UUFDcEIsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7S0FDZixDQUFDO0lBRUYsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3BCLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUVyQiw0REFBNEQ7UUFDNUQsSUFBSTthQUNELEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDO2FBQ2xCLHNCQUFzQixDQUFDLEdBQUcsRUFBRSxDQUFD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LGVBQWUsRUFBRSxDQUFDO29CQUFBLE9BQU8sRUFBRSxDQUFDO2dCQUFBLENBQUM7Z0JBQ3pDLE9BQU8sU0FBUyxDQUFDO1lBQ25CLENBQUMsQ0FBQyxDQUFDO1lBRUgseUJBQXlCO1lBQ3pCLFdBQVcsQ0FBQyxTQUFTLENBQUMsb0JBQW9CLEVBQUUsZUFBZSxDQUFDLENBQUMsU0FBUyxDQUFDO2dCQUNyRSxJQUFJLEVBQUUsR0FBRyxFQUFFO29CQUNULElBQUksQ0FBQyxJQUFJLENBQUMseUJBQXlCLENBQUMsQ0FBQztnQkFDdkMsQ0FBQztnQkFDRCxLQUFLLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDZixNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO29CQUU5QixvREFBb0Q7b0JBQ3BELE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLG9CQUFvQixDQUNqRSx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULEtBQUssQ0FDTixDQUFDO29CQUVGLHFEQUFxRDtvQkFDckQsTUFBTSxDQUNKLGtCQUFrQixDQUFDLDBCQUEwQixDQUM5QyxDQUFDLG9CQUFvQixDQUFDLFlBQVksRUFBRSxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7b0JBRXhELElBQUksRUFBRSxDQUFDO2dCQUNULENBQUM7YUFDRixDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXHNoYXJlZFxcbW9uaXRvcmluZ1xcdGVzdHNcXGVuaGFuY2VkLW1ldHJpY3MuaW50ZXJjZXB0b3Iuc3BlYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXN0LCBUZXN0aW5nTW9kdWxlIH0gZnJvbSAnQG5lc3Rqcy90ZXN0aW5nJztcbmltcG9ydCB7IEVuaGFuY2VkTWV0cmljc0ludGVyY2VwdG9yIH0gZnJvbSAnLi4vZW5oYW5jZWQtbWV0cmljcy5pbnRlcmNlcHRvcic7XG5pbXBvcnQgeyBFbmhhbmNlZE1ldHJpY3NTZXJ2aWNlIH0gZnJvbSAnLi4vZW5oYW5jZWQtbWV0cmljcy5zZXJ2aWNlJztcbmltcG9ydCB7XG4gIEV4ZWN1dGlvbkNvbnRleHQsXG4gIENhbGxIYW5kbGVyLFxuICBVbmF1dGhvcml6ZWRFeGNlcHRpb24sXG59IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IG9mLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBSZXF1ZXN0LCBSZXNwb25zZSB9IGZyb20gJ2V4cHJlc3MnO1xuaW1wb3J0IHsgUmVmbGVjdG9yIH0gZnJvbSAnQG5lc3Rqcy9jb3JlJztcblxuLyoqXG4gKiBUZXN0ZXMgdW5pdMOhcmlvcyBwYXJhIG8gaW50ZXJjZXB0b3IgZGUgbcOpdHJpY2FzIGFwcmltb3JhZG9cbiAqXG4gKiBWZXJpZmljYSBvIGZ1bmNpb25hbWVudG8gZG8gaW50ZXJjZXB0b3IgcXVlIGNvbGV0YSBtw6l0cmljYXNcbiAqIGF2YW7Dp2FkYXMgc29icmUgYXMgcmVxdWlzacOnw7VlcyBIVFRQLCBjb20gZm9jbyBlbSBzZWd1cmFuw6dhIGUgY29tcGxpYW5jZSBMR1BEXG4gKi9cbmRlc2NyaWJlKCdFbmhhbmNlZE1ldHJpY3NJbnRlcmNlcHRvcicsICgpID0+IHtcbiAgbGV0IGludGVyY2VwdG9yOiBFbmhhbmNlZE1ldHJpY3NJbnRlcmNlcHRvcjtcbiAgbGV0IG1ldHJpY3NTZXJ2aWNlOiBFbmhhbmNlZE1ldHJpY3NTZXJ2aWNlO1xuICBsZXQgcmVmbGVjdG9yOiBSZWZsZWN0b3I7XG5cbiAgLy8gTW9jayBkbyBzZXJ2acOnbyBkZSBtw6l0cmljYXMgYXByaW1vcmFkYXNcbiAgY29uc3QgbW9ja01ldHJpY3NTZXJ2aWNlID0ge1xuICAgIGluY3JlbWVudEh0dHBSZXF1ZXN0c0luUHJvZ3Jlc3M6IGplc3QuZm4oKSxcbiAgICBkZWNyZW1lbnRIdHRwUmVxdWVzdHNJblByb2dyZXNzOiBqZXN0LmZuKCksXG4gICAgcmVjb3JkSHR0cFJlcXVlc3Q6IGplc3QuZm4oKSxcbiAgICByZWNvcmRIdHRwUmVxdWVzdER1cmF0aW9uOiBqZXN0LmZuKCksXG4gICAgcmVjb3JkU2VjdXJpdHlFdmVudDogamVzdC5mbigpLFxuICAgIHJlY29yZExncGREYXRhQWNjZXNzOiBqZXN0LmZuKCksXG4gICAgcmVjb3JkQXV0aG9yaXphdGlvbkZhaWx1cmU6IGplc3QuZm4oKSxcbiAgfTtcblxuICAvLyBNb2NrIGRvIHJlZmxlY3RvclxuICBjb25zdCBtb2NrUmVmbGVjdG9yID0ge1xuICAgIGdldDogamVzdC5mbigpLFxuICB9O1xuXG4gIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuXG4gICAgLy8gTW9jayBwYXJhIERhdGUubm93KCkgLSBwcmltZWlybyByZXRvcm5hIDEwMDAsIGRlcG9pcyAxMjAwXG4gICAgamVzdFxuICAgICAgLnNweU9uKERhdGUsICdub3cnKVxuICAgICAgLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4gMTAwMClcbiAgICAgIC5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IDEyMDApO1xuXG4gICAgY29uc3QgbW9kdWxlOiBUZXN0aW5nTW9kdWxlID0gYXdhaXQgVGVzdC5jcmVhdGVUZXN0aW5nTW9kdWxlKHtcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICBFbmhhbmNlZE1ldHJpY3NJbnRlcmNlcHRvcixcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IEVuaGFuY2VkTWV0cmljc1NlcnZpY2UsXG4gICAgICAgICAgdXNlVmFsdWU6IG1vY2tNZXRyaWNzU2VydmljZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IFJlZmxlY3RvcixcbiAgICAgICAgICB1c2VWYWx1ZTogbW9ja1JlZmxlY3RvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSkuY29tcGlsZSgpO1xuXG4gICAgaW50ZXJjZXB0b3IgPSBtb2R1bGUuZ2V0PEVuaGFuY2VkTWV0cmljc0ludGVyY2VwdG9yPihcbiAgICAgIEVuaGFuY2VkTWV0cmljc0ludGVyY2VwdG9yLFxuICAgICk7XG4gICAgbWV0cmljc1NlcnZpY2UgPSBtb2R1bGUuZ2V0PEVuaGFuY2VkTWV0cmljc1NlcnZpY2U+KEVuaGFuY2VkTWV0cmljc1NlcnZpY2UpO1xuICAgIHJlZmxlY3RvciA9IG1vZHVsZS5nZXQ8UmVmbGVjdG9yPihSZWZsZWN0b3IpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QucmVzdG9yZUFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGl0KCdkZXZlIHNlciBkZWZpbmlkbycsICgpID0+IHtcbiAgICBleHBlY3QoaW50ZXJjZXB0b3IpLnRvQmVEZWZpbmVkKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdpbnRlcmNlcHQnLCAoKSA9PiB7XG4gICAgaXQoJ2RldmUgY29sZXRhciBtw6l0cmljYXMgcGFyYSB1bWEgcmVxdWlzacOnw6NvIGJlbS1zdWNlZGlkYScsIChkb25lKSA9PiB7XG4gICAgICAvLyBNb2NrIGRvIGNvbnRleHRvIGRlIGV4ZWN1w6fDo29cbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBvcmlnaW5hbFVybDogJy9hcGkvY2lkYWRhb3MnLFxuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIHBhdGg6ICcvYXBpL2NpZGFkYW9zJyxcbiAgICAgICAgfSxcbiAgICAgICAgdXNlcjoge1xuICAgICAgICAgIGlkOiAndXNlcjEyMycsXG4gICAgICAgICAgcm9sZXM6IFsnYWRtaW4nXSxcbiAgICAgICAgfSxcbiAgICAgICAgaXA6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAndXNlci1hZ2VudCc6ICd0ZXN0LWFnZW50JyxcbiAgICAgICAgfSxcbiAgICAgIH0gYXMgdW5rbm93biBhcyBSZXF1ZXN0O1xuXG4gICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgZ2V0SGVhZGVyczogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7fSksXG4gICAgICB9IGFzIHVua25vd24gYXMgUmVzcG9uc2U7XG5cbiAgICAgIGNvbnN0IG1vY2tFeGVjdXRpb25Db250ZXh0ID0ge1xuICAgICAgICBzd2l0Y2hUb0h0dHA6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGdldFJlcXVlc3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobW9ja1JlcXVlc3QpLFxuICAgICAgICAgIGdldFJlc3BvbnNlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tSZXNwb25zZSksXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRIYW5kbGVyOiBqZXN0LmZuKCksXG4gICAgICAgIGdldENsYXNzOiBqZXN0LmZuKCksXG4gICAgICB9IGFzIHVua25vd24gYXMgRXhlY3V0aW9uQ29udGV4dDtcblxuICAgICAgLy8gTW9jayBkbyBoYW5kbGVyIGRlIGNoYW1hZGFcbiAgICAgIGNvbnN0IG1vY2tDYWxsSGFuZGxlciA9IHtcbiAgICAgICAgaGFuZGxlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG9mKHsgZGF0YTogJ3Rlc3QnIH0pKSxcbiAgICAgIH0gYXMgdW5rbm93biBhcyBDYWxsSGFuZGxlcjtcblxuICAgICAgLy8gTW9jayBkbyByZWZsZWN0b3IgcGFyYSByZXRvcm5hciBtZXRhZGFkb3MgZGUgTEdQRFxuICAgICAgbW9ja1JlZmxlY3Rvci5nZXRcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoZmFsc2UpIC8vIGlzUHVibGljXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKFsnZGFkb3NfcGVzc29haXMnXSk7IC8vIGxncGREYXRhVHlwZXNcblxuICAgICAgLy8gRXhlY3V0YXIgbyBpbnRlcmNlcHRvclxuICAgICAgaW50ZXJjZXB0b3IuaW50ZXJjZXB0KG1vY2tFeGVjdXRpb25Db250ZXh0LCBtb2NrQ2FsbEhhbmRsZXIpLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IChkYXRhKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGRhdGEpLnRvRXF1YWwoeyBkYXRhOiAndGVzdCcgfSk7XG5cbiAgICAgICAgICAvLyBWZXJpZmljYXIgc2UgYXMgbcOpdHJpY2FzIGZvcmFtIGNvbGV0YWRhcyBjb3JyZXRhbWVudGVcbiAgICAgICAgICBleHBlY3QoXG4gICAgICAgICAgICBtb2NrTWV0cmljc1NlcnZpY2UuaW5jcmVtZW50SHR0cFJlcXVlc3RzSW5Qcm9ncmVzcyxcbiAgICAgICAgICApLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdHRVQnLCAnL2FwaS9jaWRhZGFvcycsICdhZG1pbicpO1xuXG4gICAgICAgICAgZXhwZWN0KFxuICAgICAgICAgICAgbW9ja01ldHJpY3NTZXJ2aWNlLmRlY3JlbWVudEh0dHBSZXF1ZXN0c0luUHJvZ3Jlc3MsXG4gICAgICAgICAgKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnR0VUJywgJy9hcGkvY2lkYWRhb3MnLCAnYWRtaW4nKTtcblxuICAgICAgICAgIC8vIE8gbcOpdG9kbyByZWNvcmRIdHRwUmVxdWVzdCBuw6NvIHJlY2ViZSBpcCBlIHVzZXItYWdlbnRcbiAgICAgICAgICBleHBlY3QobW9ja01ldHJpY3NTZXJ2aWNlLnJlY29yZEh0dHBSZXF1ZXN0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICdHRVQnLFxuICAgICAgICAgICAgJy9hcGkvY2lkYWRhb3MnLFxuICAgICAgICAgICAgMjAwLFxuICAgICAgICAgICAgJ2FkbWluJyxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gVmVyaWZpY2FyIHNlIGEgZHVyYcOnw6NvIGZvaSByZWdpc3RyYWRhXG4gICAgICAgICAgLy8gTyBtw6l0b2RvIHJlY29yZEh0dHBSZXF1ZXN0RHVyYXRpb24gbsOjbyByZWNlYmUgaXAgZSB1c2VyLWFnZW50XG4gICAgICAgICAgZXhwZWN0KFxuICAgICAgICAgICAgbW9ja01ldHJpY3NTZXJ2aWNlLnJlY29yZEh0dHBSZXF1ZXN0RHVyYXRpb24sXG4gICAgICAgICAgKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICdHRVQnLFxuICAgICAgICAgICAgJy9hcGkvY2lkYWRhb3MnLFxuICAgICAgICAgICAgMjAwLFxuICAgICAgICAgICAgMC4yLCAvLyAyMDBtcyBlbSBzZWd1bmRvc1xuICAgICAgICAgICAgJ2FkbWluJyxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gTyBtw6l0b2RvIHJlY29yZExncGREYXRhQWNjZXNzIG7Do28gw6kgY2hhbWFkbyBhdXRvbWF0aWNhbWVudGUgbm8gaW50ZXJjZXB0b3JcbiAgICAgICAgICAvLyBBIHZlcmlmaWNhw6fDo28gZGUgYWNlc3NvIGEgZGFkb3MgTEdQRCBkZXZlIHNlciBmZWl0YSBtYW51YWxtZW50ZVxuXG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKGVycikgPT4ge1xuICAgICAgICAgIGRvbmUuZmFpbChgRXJybyBpbmVzcGVyYWRvOiAke2Vycn1gKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RldmUgY29sZXRhciBtw6l0cmljYXMgcGFyYSB1bWEgcmVxdWlzacOnw6NvIGNvbSBlcnJvJywgKGRvbmUpID0+IHtcbiAgICAgIC8vIE1vY2sgZG8gY29udGV4dG8gZGUgZXhlY3XDp8Ojb1xuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBvcmlnaW5hbFVybDogJy9hcGkvY2lkYWRhb3MnLFxuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIHBhdGg6ICcvYXBpL2NpZGFkYW9zJyxcbiAgICAgICAgfSxcbiAgICAgICAgdXNlcjoge1xuICAgICAgICAgIGlkOiAndXNlcjEyMycsXG4gICAgICAgICAgcm9sZXM6IFsndXNlciddLFxuICAgICAgICB9LFxuICAgICAgICBpcDogJzE5Mi4xNjguMS4yJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICd1c2VyLWFnZW50JzogJ3Rlc3QtYWdlbnQnLFxuICAgICAgICB9LFxuICAgICAgfSBhcyB1bmtub3duIGFzIFJlcXVlc3Q7XG5cbiAgICAgIGNvbnN0IG1vY2tSZXNwb25zZSA9IHtcbiAgICAgICAgc3RhdHVzQ29kZTogNTAwLFxuICAgICAgICBnZXRIZWFkZXJzOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHt9KSxcbiAgICAgIH0gYXMgdW5rbm93biBhcyBSZXNwb25zZTtcblxuICAgICAgY29uc3QgbW9ja0V4ZWN1dGlvbkNvbnRleHQgPSB7XG4gICAgICAgIHN3aXRjaFRvSHR0cDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZ2V0UmVxdWVzdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShtb2NrUmVxdWVzdCksXG4gICAgICAgICAgZ2V0UmVzcG9uc2U6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobW9ja1Jlc3BvbnNlKSxcbiAgICAgICAgfSksXG4gICAgICAgIGdldEhhbmRsZXI6IGplc3QuZm4oKSxcbiAgICAgICAgZ2V0Q2xhc3M6IGplc3QuZm4oKSxcbiAgICAgIH0gYXMgdW5rbm93biBhcyBFeGVjdXRpb25Db250ZXh0O1xuXG4gICAgICAvLyBNb2NrIGRvIGhhbmRsZXIgZGUgY2hhbWFkYSBjb20gZXJyb1xuICAgICAgY29uc3QgbW9ja0Vycm9yID0gbmV3IEVycm9yKCdFcnJvIGludGVybm8gZG8gc2Vydmlkb3InKTtcbiAgICAgIChtb2NrRXJyb3IgYXMgYW55KS5zdGF0dXMgPSA1MDA7XG5cbiAgICAgIGNvbnN0IG1vY2tDYWxsSGFuZGxlciA9IHtcbiAgICAgICAgaGFuZGxlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHRocm93RXJyb3IoKCkgPT4gbW9ja0Vycm9yKSksXG4gICAgICB9IGFzIHVua25vd24gYXMgQ2FsbEhhbmRsZXI7XG5cbiAgICAgIC8vIE1vY2sgZG8gcmVmbGVjdG9yIC0gbsOjbyDDqSB1c2FkbyBlbSBjYXNvIGRlIGVycm9cbiAgICAgIG1vY2tSZWZsZWN0b3IuZ2V0Lm1vY2tJbXBsZW1lbnRhdGlvbigoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2lzUHVibGljJykge3JldHVybiBmYWxzZTt9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gRXhlY3V0YXIgbyBpbnRlcmNlcHRvclxuICAgICAgaW50ZXJjZXB0b3IuaW50ZXJjZXB0KG1vY2tFeGVjdXRpb25Db250ZXh0LCBtb2NrQ2FsbEhhbmRsZXIpLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICBkb25lLmZhaWwoJ08gaW50ZXJjZXB0b3IgZGV2ZXJpYSB0ZXIgcmV0b3JuYWRvIHVtIGVycm8nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgIGV4cGVjdChlcnJvcikudG9CZShtb2NrRXJyb3IpO1xuXG4gICAgICAgICAgLy8gVmVyaWZpY2FyIHNlIGFzIG3DqXRyaWNhcyBkZSBlcnJvIGZvcmFtIHJlZ2lzdHJhZGFzXG4gICAgICAgICAgZXhwZWN0KG1vY2tNZXRyaWNzU2VydmljZS5yZWNvcmRIdHRwUmVxdWVzdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAnUE9TVCcsXG4gICAgICAgICAgICAnL2FwaS9jaWRhZGFvcycsXG4gICAgICAgICAgICA1MDAsXG4gICAgICAgICAgICAndXNlcicsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFZlcmlmaWNhciBzZSBhIGR1cmHDp8OjbyBmb2kgcmVnaXN0cmFkYVxuICAgICAgICAgIGV4cGVjdChcbiAgICAgICAgICAgIG1vY2tNZXRyaWNzU2VydmljZS5yZWNvcmRIdHRwUmVxdWVzdER1cmF0aW9uLFxuICAgICAgICAgICkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAnUE9TVCcsXG4gICAgICAgICAgICAnL2FwaS9jaWRhZGFvcycsXG4gICAgICAgICAgICA1MDAsXG4gICAgICAgICAgICBleHBlY3QuYW55KE51bWJlciksIC8vIER1cmHDp8OjbyBlbSBzZWd1bmRvc1xuICAgICAgICAgICAgJ3VzZXInLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBWZXJpZmljYXIgc2UgbyBldmVudG8gZGUgc2VndXJhbsOnYSBmb2kgcmVnaXN0cmFkb1xuICAgICAgICAgIGV4cGVjdChtb2NrTWV0cmljc1NlcnZpY2UucmVjb3JkU2VjdXJpdHlFdmVudCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAnc2VydmVyX2Vycm9yJyxcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAnYXBpJyxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGV2ZSBsaWRhciBjb20gcmVxdWlzacOnw7VlcyBuw6NvIGF1dGVudGljYWRhcycsIChkb25lKSA9PiB7XG4gICAgICAvLyBNb2NrIGRvIGNvbnRleHRvIGRlIGV4ZWN1w6fDo28gc2VtIHVzdcOhcmlvIGF1dGVudGljYWRvXG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgdXJsOiAnL2FwaS9wdWJsaWMnLFxuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIHBhdGg6ICcvYXBpL3B1YmxpYycsXG4gICAgICAgIH0sXG4gICAgICAgIGlwOiAnMTkyLjE2OC4xLjMnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ3VzZXItYWdlbnQnOiAndGVzdC1hZ2VudCcsXG4gICAgICAgIH0sXG4gICAgICB9IGFzIHVua25vd24gYXMgUmVxdWVzdDtcblxuICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGdldEhlYWRlcnM6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe30pLFxuICAgICAgfSBhcyB1bmtub3duIGFzIFJlc3BvbnNlO1xuXG4gICAgICBjb25zdCBtb2NrRXhlY3V0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgc3dpdGNoVG9IdHRwOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBnZXRSZXF1ZXN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tSZXF1ZXN0KSxcbiAgICAgICAgICBnZXRSZXNwb25zZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShtb2NrUmVzcG9uc2UpLFxuICAgICAgICB9KSxcbiAgICAgICAgZ2V0SGFuZGxlcjogamVzdC5mbigpLFxuICAgICAgICBnZXRDbGFzczogamVzdC5mbigpLFxuICAgICAgfSBhcyB1bmtub3duIGFzIEV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICAgIC8vIE1vY2sgZG8gaGFuZGxlciBkZSBjaGFtYWRhXG4gICAgICBjb25zdCBtb2NrQ2FsbEhhbmRsZXIgPSB7XG4gICAgICAgIGhhbmRsZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShvZih7IGRhdGE6ICdwdWJsaWMgZGF0YScgfSkpLFxuICAgICAgfSBhcyB1bmtub3duIGFzIENhbGxIYW5kbGVyO1xuXG4gICAgICAvLyBPIGludGVyY2VwdG9yIG7Do28gdmVyaWZpY2EgaXNQdWJsaWMsIGFwZW5hcyByZWdpc3RyYSBtw6l0cmljYXNcbiAgICAgIC8vIEEgdmVyaWZpY2HDp8OjbyBkZSByb3RhcyBww7pibGljYXMgw6kgZmVpdGEgcG9yIG91dHJvcyBtaWRkbGV3YXJlcy9ndWFyZHNcbiAgICAgIG1vY2tSZWZsZWN0b3IuZ2V0Lm1vY2tJbXBsZW1lbnRhdGlvbigoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2lzUHVibGljJykge3JldHVybiB0cnVlO31cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRhciBvIGludGVyY2VwdG9yXG4gICAgICBpbnRlcmNlcHRvci5pbnRlcmNlcHQobW9ja0V4ZWN1dGlvbkNvbnRleHQsIG1vY2tDYWxsSGFuZGxlcikuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKGRhdGEpID0+IHtcbiAgICAgICAgICBleHBlY3QoZGF0YSkudG9FcXVhbCh7IGRhdGE6ICdwdWJsaWMgZGF0YScgfSk7XG5cbiAgICAgICAgICAvLyBWZXJpZmljYXIgc2UgYXMgbcOpdHJpY2FzIGZvcmFtIGNvbGV0YWRhcyBzZW0gaW5mb3JtYcOnw7VlcyBkZSB1c3XDoXJpb1xuICAgICAgICAgIGV4cGVjdChtb2NrTWV0cmljc1NlcnZpY2UucmVjb3JkSHR0cFJlcXVlc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgJ0dFVCcsXG4gICAgICAgICAgICAnL2FwaS9wdWJsaWMnLFxuICAgICAgICAgICAgMjAwLFxuICAgICAgICAgICAgJ2Fub255bW91cycsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFZlcmlmaWNhciBzZSBhIGR1cmHDp8OjbyBmb2kgcmVnaXN0cmFkYVxuICAgICAgICAgIGV4cGVjdChcbiAgICAgICAgICAgIG1vY2tNZXRyaWNzU2VydmljZS5yZWNvcmRIdHRwUmVxdWVzdER1cmF0aW9uLFxuICAgICAgICAgICkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAnR0VUJyxcbiAgICAgICAgICAgICcvYXBpL3B1YmxpYycsXG4gICAgICAgICAgICAyMDAsXG4gICAgICAgICAgICBleHBlY3QuYW55KE51bWJlciksIC8vIER1cmHDp8OjbyBlbSBzZWd1bmRvc1xuICAgICAgICAgICAgJ2Fub255bW91cycsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIE8gaW50ZXJjZXB0b3IgbsOjbyB2ZXJpZmljYSBpc1B1YmxpYywgZW50w6NvIG7Do28gcG9kZW1vcyBnYXJhbnRpciBxdWUgcmVjb3JkTGdwZERhdGFBY2Nlc3MgbsOjbyBmb2kgY2hhbWFkb1xuICAgICAgICAgIC8vIEEgdmVyaWZpY2HDp8OjbyBkZSByb3RhcyBww7pibGljYXMgw6kgZmVpdGEgcG9yIG91dHJvcyBtaWRkbGV3YXJlcy9ndWFyZHNcblxuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGRvbmUsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdkZXZlIGxpZGFyIGNvbSBlcnJvcyBkZSBhdXRvcml6YcOnw6NvJywgKGRvbmUpID0+IHtcbiAgICAgIC8vIE1vY2sgZG8gY29udGV4dG8gZGUgZXhlY3XDp8OjbyBjb20gdXN1w6FyaW8gbsOjbyBhdXRvcml6YWRvXG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgb3JpZ2luYWxVcmw6ICcvYXBpL2FkbWluJyxcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBwYXRoOiAnL2FwaS9hZG1pbicsXG4gICAgICAgIH0sXG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBpZDogJ3VzZXIxMjMnLFxuICAgICAgICAgIHJvbGVzOiBbJ3VzZXInXSxcbiAgICAgICAgfSxcbiAgICAgICAgaXA6ICcxOTIuMTY4LjEuNCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAndXNlci1hZ2VudCc6ICd0ZXN0LWFnZW50JyxcbiAgICAgICAgfSxcbiAgICAgIH0gYXMgdW5rbm93biBhcyBSZXF1ZXN0O1xuXG4gICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgIHN0YXR1c0NvZGU6IDQwMyxcbiAgICAgICAgZ2V0SGVhZGVyczogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7fSksXG4gICAgICB9IGFzIHVua25vd24gYXMgUmVzcG9uc2U7XG5cbiAgICAgIGNvbnN0IG1vY2tFeGVjdXRpb25Db250ZXh0ID0ge1xuICAgICAgICBzd2l0Y2hUb0h0dHA6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGdldFJlcXVlc3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobW9ja1JlcXVlc3QpLFxuICAgICAgICAgIGdldFJlc3BvbnNlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tSZXNwb25zZSksXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRIYW5kbGVyOiBqZXN0LmZuKCksXG4gICAgICAgIGdldENsYXNzOiBqZXN0LmZuKCksXG4gICAgICB9IGFzIHVua25vd24gYXMgRXhlY3V0aW9uQ29udGV4dDtcblxuICAgICAgLy8gTW9jayBkbyBoYW5kbGVyIGRlIGNoYW1hZGEgY29tIGVycm8gZGUgYXV0b3JpemHDp8Ojb1xuICAgICAgY29uc3QgbW9ja0Vycm9yID0gbmV3IFVuYXV0aG9yaXplZEV4Y2VwdGlvbignQWNlc3NvIG7Do28gYXV0b3JpemFkbycpO1xuICAgICAgKG1vY2tFcnJvciBhcyBhbnkpLnN0YXR1cyA9IDQwMztcblxuICAgICAgY29uc3QgbW9ja0NhbGxIYW5kbGVyID0ge1xuICAgICAgICBoYW5kbGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUodGhyb3dFcnJvcigoKSA9PiBtb2NrRXJyb3IpKSxcbiAgICAgIH0gYXMgdW5rbm93biBhcyBDYWxsSGFuZGxlcjtcblxuICAgICAgLy8gTW9jayBkbyByZWZsZWN0b3IgcGFyYSBvIHRlc3RlIGRlIGF1dG9yaXphw6fDo29cbiAgICAgIG1vY2tSZWZsZWN0b3IuZ2V0Lm1vY2tJbXBsZW1lbnRhdGlvbigoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2lzUHVibGljJykge3JldHVybiBmYWxzZTt9XG4gICAgICAgIGlmIChrZXkgPT09ICdyb2xlcycpIHtyZXR1cm4gWydhZG1pbiddO31cbiAgICAgICAgaWYgKGtleSA9PT0gJ2xncGREYXRhVHlwZXMnKSB7cmV0dXJuIFtdO31cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRhciBvIGludGVyY2VwdG9yXG4gICAgICBpbnRlcmNlcHRvci5pbnRlcmNlcHQobW9ja0V4ZWN1dGlvbkNvbnRleHQsIG1vY2tDYWxsSGFuZGxlcikuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGRvbmUuZmFpbCgnTsOjbyBkZXZlcmlhIGNoZWdhciBhcXVpJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICBleHBlY3QoZXJyb3IpLnRvQmUobW9ja0Vycm9yKTtcblxuICAgICAgICAgIC8vIFZlcmlmaWNhciBzZSBvIGV2ZW50byBkZSBzZWd1cmFuw6dhIGZvaSByZWdpc3RyYWRvXG4gICAgICAgICAgZXhwZWN0KG1vY2tNZXRyaWNzU2VydmljZS5yZWNvcmRTZWN1cml0eUV2ZW50KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICdhdXRob3JpemF0aW9uX2ZhaWx1cmUnLFxuICAgICAgICAgICAgJ3dhcm5pbmcnLFxuICAgICAgICAgICAgJ2FwaScsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFZlcmlmaWNhciBzZSBhIGZhbGhhIGRlIGF1dG9yaXphw6fDo28gZm9pIHJlZ2lzdHJhZGFcbiAgICAgICAgICBleHBlY3QoXG4gICAgICAgICAgICBtb2NrTWV0cmljc1NlcnZpY2UucmVjb3JkQXV0aG9yaXphdGlvbkZhaWx1cmUsXG4gICAgICAgICAgKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9hZG1pbicsICd1bmtub3duJywgJ3VzZXInKTtcblxuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9