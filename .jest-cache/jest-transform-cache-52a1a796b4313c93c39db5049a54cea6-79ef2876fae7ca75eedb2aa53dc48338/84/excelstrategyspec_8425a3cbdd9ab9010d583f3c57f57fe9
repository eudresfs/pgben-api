8633a49b0433ee9b58d4498152043f70
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const testing_1 = require("@nestjs/testing");
const excel_strategy_1 = require("../strategies/excel.strategy");
const temp_files_service_1 = require("../services/temp-files.service");
/**
 * Testes unitários para a estratégia de relatórios em Excel
 *
 * Este arquivo contém testes que validam a funcionalidade da estratégia
 * responsável por gerar relatórios em formato Excel
 */
describe('ExcelStrategy', () => {
    // Mock para ExcelJS
    jest.mock('exceljs', () => {
        return {
            Workbook: jest.fn().mockImplementation(() => mockWorkbook),
        };
    });
    jest.mock('fs', () => ({
        readFileSync: jest.fn().mockReturnValue(Buffer.from('mock excel content')),
        promises: {
            unlink: jest.fn(),
        },
    }));
    let strategy;
    let tempFilesService;
    // Mock para fs e Excel
    const mockWorkbook = {
        addWorksheet: jest.fn().mockImplementation(() => mockWorksheet),
        xlsx: {
            writeFile: jest.fn().mockImplementation((path, callback) => {
                if (callback) {
                    callback();
                }
                return Promise.resolve();
            }),
        },
    };
    const mockWorksheet = {
        columns: [],
        addRow: jest.fn(),
        addRows: jest.fn(),
        mergeCells: jest.fn(),
        getCell: jest.fn().mockReturnValue({
            style: {},
            value: null,
            alignment: { vertical: null, horizontal: null },
        }),
        getRow: jest.fn().mockReturnValue({
            font: { bold: false },
            alignment: { vertical: null, horizontal: null },
            eachCell: jest.fn().mockImplementation((options, callback) => {
                callback({
                    style: {},
                    value: null,
                    alignment: { vertical: null, horizontal: null },
                }, 1);
            }),
        }),
        eachRow: jest.fn().mockImplementation((options, callback) => {
            callback({
                eachCell: jest.fn().mockImplementation((options, callback) => {
                    callback({
                        style: {},
                        value: null,
                        alignment: { vertical: null, horizontal: null },
                    }, 1);
                }),
                number: 1,
            }, 1);
        }),
    };
    beforeEach(async () => {
        const module = await testing_1.Test.createTestingModule({
            providers: [
                excel_strategy_1.ExcelStrategy,
                {
                    provide: temp_files_service_1.TempFilesService,
                    useValue: {
                        getTempFilePath: jest
                            .fn()
                            .mockReturnValue('temp/relatorios/test-123.xlsx'),
                        cleanupTempFile: jest.fn().mockResolvedValue(undefined),
                    },
                },
            ],
        }).compile();
        strategy = module.get(excel_strategy_1.ExcelStrategy);
        tempFilesService = module.get(temp_files_service_1.TempFilesService);
        // Reset mocks antes de cada teste
        jest.clearAllMocks();
    });
    it('deve ser definido', () => {
        expect(strategy).toBeDefined();
    });
    describe('gerar', () => {
        it('deve gerar um relatório Excel e retornar um buffer', async () => {
            const tipo = 'beneficios';
            const dados = {
                titulo: 'Relatório de Benefícios',
                cabecalho: { data: '01/01/2025' },
                itens: [{ id: 1, nome: 'Benefício Teste', valor: 100 }],
            };
            const opcoes = { orientacao: 'retrato', tamanho: 'A4' };
            const result = await strategy.gerar(tipo, dados, opcoes);
            expect(result).toBeInstanceOf(Buffer);
            expect(tempFilesService.getTempFilePath).toHaveBeenCalledWith(expect.stringContaining('relatorio'), 'xlsx');
            expect(tempFilesService.cleanupTempFile).toHaveBeenCalledWith(expect.stringContaining('temp/relatorios/test-123.xlsx'));
            expect(mockWorkbook.addWorksheet).toHaveBeenCalled();
            expect(mockWorkbook.xlsx.writeFile).toHaveBeenCalledWith(expect.stringContaining('temp/relatorios/test-123.xlsx'), expect.anything());
        });
        it('deve gerar relatório de benefícios corretamente', async () => {
            const tipo = 'beneficios';
            const dados = {
                titulo: 'Relatório de Benefícios Concedidos',
                periodo: '01/01/2025 a 31/01/2025',
                unidade: 'Unidade Teste',
                tipoBeneficio: 'Auxílio Moradia',
                itens: [
                    { id: 1, nome: 'Benefício 1', data: '01/01/2025', valor: 100 },
                    { id: 2, nome: 'Benefício 2', data: '15/01/2025', valor: 200 },
                ],
                total: 300,
            };
            const opcoes = {};
            await strategy.gerar(tipo, dados, opcoes);
            expect(mockWorkbook.addWorksheet).toHaveBeenCalledWith('Benefícios Concedidos');
            expect(mockWorksheet.addRow).toHaveBeenCalled();
            expect(mockWorksheet.addRows).toHaveBeenCalled();
        });
        it('deve gerar relatório de solicitações corretamente', async () => {
            const tipo = 'solicitacoes';
            const dados = {
                titulo: 'Relatório de Solicitações por Status',
                periodo: '01/01/2025 a 31/01/2025',
                unidade: 'Unidade Teste',
                itens: [
                    { status: 'Pendente', quantidade: 10 },
                    { status: 'Aprovado', quantidade: 20 },
                    { status: 'Reprovado', quantidade: 5 },
                ],
                total: 35,
            };
            const opcoes = {};
            await strategy.gerar(tipo, dados, opcoes);
            expect(mockWorkbook.addWorksheet).toHaveBeenCalledWith('Solicitações por Status');
            expect(mockWorksheet.addRow).toHaveBeenCalled();
            expect(mockWorksheet.addRows).toHaveBeenCalled();
        });
        it('deve gerar relatório de atendimentos corretamente', async () => {
            const tipo = 'atendimentos';
            const dados = {
                titulo: 'Relatório de Atendimentos por Unidade',
                periodo: '01/01/2025 a 31/01/2025',
                itens: [
                    {
                        unidade: 'Unidade A',
                        totalSolicitacoes: 15,
                        solicitacoesLiberadas: 10,
                        solicitacoesPendentes: 5,
                    },
                    {
                        unidade: 'Unidade B',
                        totalSolicitacoes: 20,
                        solicitacoesLiberadas: 15,
                        solicitacoesPendentes: 5,
                    },
                ],
                totais: {
                    totalSolicitacoes: 35,
                    solicitacoesLiberadas: 25,
                    solicitacoesPendentes: 10,
                },
            };
            const opcoes = {};
            await strategy.gerar(tipo, dados, opcoes);
            expect(mockWorkbook.addWorksheet).toHaveBeenCalledWith('Atendimentos por Unidade');
            expect(mockWorksheet.addRow).toHaveBeenCalled();
            expect(mockWorksheet.addRows).toHaveBeenCalled();
        });
        it('deve lidar com erros corretamente', async () => {
            const mockError = new Error('Erro ao gerar Excel');
            mockWorkbook.xlsx.writeFile.mockRejectedValueOnce(mockError);
            const tipo = 'beneficios';
            const dados = { titulo: 'Teste', itens: [] };
            const opcoes = {};
            await expect(strategy.gerar(tipo, dados, opcoes)).rejects.toThrow('Erro ao gerar Excel');
            expect(tempFilesService.cleanupTempFile).toHaveBeenCalledWith(expect.stringContaining('temp/relatorios/test-123.xlsx'));
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXHJlbGF0b3Jpb3MtdW5pZmljYWRvXFxfX3Rlc3RzX19cXGV4Y2VsLnN0cmF0ZWd5LnNwZWMudHMiLCJtYXBwaW5ncyI6Ijs7QUFBQSw2Q0FBc0Q7QUFDdEQsaUVBQTZEO0FBQzdELHVFQUFrRTtBQUdsRTs7Ozs7R0FLRztBQUNILFFBQVEsQ0FBQyxlQUFlLEVBQUUsR0FBRyxFQUFFO0lBNkQ3QixvQkFBb0I7SUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsR0FBRyxFQUFFO1FBQ3hCLE9BQU87WUFDTCxRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQztTQUMzRCxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ3JCLFlBQVksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUMxRSxRQUFRLEVBQUU7WUFDUixNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtTQUNsQjtLQUNGLENBQUMsQ0FBQyxDQUFDO0lBeEVKLElBQUksUUFBdUIsQ0FBQztJQUM1QixJQUFJLGdCQUFrQyxDQUFDO0lBRXZDLHVCQUF1QjtJQUN2QixNQUFNLFlBQVksR0FBRztRQUNuQixZQUFZLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQztRQUMvRCxJQUFJLEVBQUU7WUFDSixTQUFTLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUFDLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxF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O1lBRUYsTUFBTSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxDQUFDLG9CQUFvQixDQUMzRCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsK0JBQStCLENBQUMsQ0FDekQsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcbW9kdWxlc1xccmVsYXRvcmlvcy11bmlmaWNhZG9cXF9fdGVzdHNfX1xcZXhjZWwuc3RyYXRlZ3kuc3BlYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXN0LCBUZXN0aW5nTW9kdWxlIH0gZnJvbSAnQG5lc3Rqcy90ZXN0aW5nJztcbmltcG9ydCB7IEV4Y2VsU3RyYXRlZ3kgfSBmcm9tICcuLi9zdHJhdGVnaWVzL2V4Y2VsLnN0cmF0ZWd5JztcbmltcG9ydCB7IFRlbXBGaWxlc1NlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy90ZW1wLWZpbGVzLnNlcnZpY2UnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuXG4vKipcbiAqIFRlc3RlcyB1bml0w6FyaW9zIHBhcmEgYSBlc3RyYXTDqWdpYSBkZSByZWxhdMOzcmlvcyBlbSBFeGNlbFxuICpcbiAqIEVzdGUgYXJxdWl2byBjb250w6ltIHRlc3RlcyBxdWUgdmFsaWRhbSBhIGZ1bmNpb25hbGlkYWRlIGRhIGVzdHJhdMOpZ2lhXG4gKiByZXNwb25zw6F2ZWwgcG9yIGdlcmFyIHJlbGF0w7NyaW9zIGVtIGZvcm1hdG8gRXhjZWxcbiAqL1xuZGVzY3JpYmUoJ0V4Y2VsU3RyYXRlZ3knLCAoKSA9PiB7XG4gIGxldCBzdHJhdGVneTogRXhjZWxTdHJhdGVneTtcbiAgbGV0IHRlbXBGaWxlc1NlcnZpY2U6IFRlbXBGaWxlc1NlcnZpY2U7XG5cbiAgLy8gTW9jayBwYXJhIGZzIGUgRXhjZWxcbiAgY29uc3QgbW9ja1dvcmtib29rID0ge1xuICAgIGFkZFdvcmtzaGVldDogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBtb2NrV29ya3NoZWV0KSxcbiAgICB4bHN4OiB7XG4gICAgICB3cml0ZUZpbGU6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGgsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfSksXG4gICAgfSxcbiAgfTtcblxuICBjb25zdCBtb2NrV29ya3NoZWV0ID0ge1xuICAgIGNvbHVtbnM6IFtdLFxuICAgIGFkZFJvdzogamVzdC5mbigpLFxuICAgIGFkZFJvd3M6IGplc3QuZm4oKSxcbiAgICBtZXJnZUNlbGxzOiBqZXN0LmZuKCksXG4gICAgZ2V0Q2VsbDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBzdHlsZToge30sXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGFsaWdubWVudDogeyB2ZXJ0aWNhbDogbnVsbCwgaG9yaXpvbnRhbDogbnVsbCB9LFxuICAgIH0pLFxuICAgIGdldFJvdzogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBmb250OiB7IGJvbGQ6IGZhbHNlIH0sXG4gICAgICBhbGlnbm1lbnQ6IHsgdmVydGljYWw6IG51bGwsIGhvcml6b250YWw6IG51bGwgfSxcbiAgICAgIGVhY2hDZWxsOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdHlsZToge30sXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgIGFsaWdubWVudDogeyB2ZXJ0aWNhbDogbnVsbCwgaG9yaXpvbnRhbDogbnVsbCB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgMSxcbiAgICAgICAgKTtcbiAgICAgIH0pLFxuICAgIH0pLFxuICAgIGVhY2hSb3c6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBjYWxsYmFjayhcbiAgICAgICAge1xuICAgICAgICAgIGVhY2hDZWxsOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHlsZToge30sXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50OiB7IHZlcnRpY2FsOiBudWxsLCBob3Jpem9udGFsOiBudWxsIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIG51bWJlcjogMSxcbiAgICAgICAgfSxcbiAgICAgICAgMSxcbiAgICAgICk7XG4gICAgfSksXG4gIH07XG5cbiAgLy8gTW9jayBwYXJhIEV4Y2VsSlNcbiAgamVzdC5tb2NrKCdleGNlbGpzJywgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBXb3JrYm9vazogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBtb2NrV29ya2Jvb2spLFxuICAgIH07XG4gIH0pO1xuXG4gIGplc3QubW9jaygnZnMnLCAoKSA9PiAoe1xuICAgIHJlYWRGaWxlU3luYzogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShCdWZmZXIuZnJvbSgnbW9jayBleGNlbCBjb250ZW50JykpLFxuICAgIHByb21pc2VzOiB7XG4gICAgICB1bmxpbms6IGplc3QuZm4oKSxcbiAgICB9LFxuICB9KSk7XG5cbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9kdWxlOiBUZXN0aW5nTW9kdWxlID0gYXdhaXQgVGVzdC5jcmVhdGVUZXN0aW5nTW9kdWxlKHtcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICBFeGNlbFN0cmF0ZWd5LFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogVGVtcEZpbGVzU2VydmljZSxcbiAgICAgICAgICB1c2VWYWx1ZToge1xuICAgICAgICAgICAgZ2V0VGVtcEZpbGVQYXRoOiBqZXN0XG4gICAgICAgICAgICAgIC5mbigpXG4gICAgICAgICAgICAgIC5tb2NrUmV0dXJuVmFsdWUoJ3RlbXAvcmVsYXRvcmlvcy90ZXN0LTEyMy54bHN4JyksXG4gICAgICAgICAgICBjbGVhbnVwVGVtcEZpbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pLmNvbXBpbGUoKTtcblxuICAgIHN0cmF0ZWd5ID0gbW9kdWxlLmdldDxFeGNlbFN0cmF0ZWd5PihFeGNlbFN0cmF0ZWd5KTtcbiAgICB0ZW1wRmlsZXNTZXJ2aWNlID0gbW9kdWxlLmdldDxUZW1wRmlsZXNTZXJ2aWNlPihUZW1wRmlsZXNTZXJ2aWNlKTtcblxuICAgIC8vIFJlc2V0IG1vY2tzIGFudGVzIGRlIGNhZGEgdGVzdGVcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgaXQoJ2RldmUgc2VyIGRlZmluaWRvJywgKCkgPT4ge1xuICAgIGV4cGVjdChzdHJhdGVneSkudG9CZURlZmluZWQoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dlcmFyJywgKCkgPT4ge1xuICAgIGl0KCdkZXZlIGdlcmFyIHVtIHJlbGF0w7NyaW8gRXhjZWwgZSByZXRvcm5hciB1bSBidWZmZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0aXBvID0gJ2JlbmVmaWNpb3MnO1xuICAgICAgY29uc3QgZGFkb3MgPSB7XG4gICAgICAgIHRpdHVsbzogJ1JlbGF0w7NyaW8gZGUgQmVuZWbDrWNpb3MnLFxuICAgICAgICBjYWJlY2FsaG86IHsgZGF0YTogJzAxLzAxLzIwMjUnIH0sXG4gICAgICAgIGl0ZW5zOiBbeyBpZDogMSwgbm9tZTogJ0JlbmVmw61jaW8gVGVzdGUnLCB2YWxvcjogMTAwIH1dLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG9wY29lcyA9IHsgb3JpZW50YWNhbzogJ3JldHJhdG8nLCB0YW1hbmhvOiAnQTQnIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0cmF0ZWd5LmdlcmFyKHRpcG8sIGRhZG9zLCBvcGNvZXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlSW5zdGFuY2VPZihCdWZmZXIpO1xuICAgICAgZXhwZWN0KHRlbXBGaWxlc1NlcnZpY2UuZ2V0VGVtcEZpbGVQYXRoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ3JlbGF0b3JpbycpLFxuICAgICAgICAneGxzeCcsXG4gICAgICApO1xuICAgICAgZXhwZWN0KHRlbXBGaWxlc1NlcnZpY2UuY2xlYW51cFRlbXBGaWxlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ3RlbXAvcmVsYXRvcmlvcy90ZXN0LTEyMy54bHN4JyksXG4gICAgICApO1xuICAgICAgZXhwZWN0KG1vY2tXb3JrYm9vay5hZGRXb3Jrc2hlZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrV29ya2Jvb2sueGxzeC53cml0ZUZpbGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygndGVtcC9yZWxhdG9yaW9zL3Rlc3QtMTIzLnhsc3gnKSxcbiAgICAgICAgZXhwZWN0LmFueXRoaW5nKCksXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RldmUgZ2VyYXIgcmVsYXTDs3JpbyBkZSBiZW5lZsOtY2lvcyBjb3JyZXRhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0aXBvID0gJ2JlbmVmaWNpb3MnO1xuICAgICAgY29uc3QgZGFkb3MgPSB7XG4gICAgICAgIHRpdHVsbzogJ1JlbGF0w7NyaW8gZGUgQmVuZWbDrWNpb3MgQ29uY2VkaWRvcycsXG4gICAgICAgIHBlcmlvZG86ICcwMS8wMS8yMDI1IGEgMzEvMDEvMjAyNScsXG4gICAgICAgIHVuaWRhZGU6ICdVbmlkYWRlIFRlc3RlJyxcbiAgICAgICAgdGlwb0JlbmVmaWNpbzogJ0F1eMOtbGlvIE1vcmFkaWEnLFxuICAgICAgICBpdGVuczogW1xuICAgICAgICAgIHsgaWQ6IDEsIG5vbWU6ICdCZW5lZsOtY2lvIDEnLCBkYXRhOiAnMDEvMDEvMjAyNScsIHZhbG9yOiAxMDAgfSxcbiAgICAgICAgICB7IGlkOiAyLCBub21lOiAnQmVuZWbDrWNpbyAyJywgZGF0YTogJzE1LzAxLzIwMjUnLCB2YWxvcjogMjAwIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHRvdGFsOiAzMDAsXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3Bjb2VzID0ge307XG5cbiAgICAgIGF3YWl0IHN0cmF0ZWd5LmdlcmFyKHRpcG8sIGRhZG9zLCBvcGNvZXMpO1xuXG4gICAgICBleHBlY3QobW9ja1dvcmtib29rLmFkZFdvcmtzaGVldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdCZW5lZsOtY2lvcyBDb25jZWRpZG9zJyxcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja1dvcmtzaGVldC5hZGRSb3cpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrV29ya3NoZWV0LmFkZFJvd3MpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZXZlIGdlcmFyIHJlbGF0w7NyaW8gZGUgc29saWNpdGHDp8O1ZXMgY29ycmV0YW1lbnRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGlwbyA9ICdzb2xpY2l0YWNvZXMnO1xuICAgICAgY29uc3QgZGFkb3MgPSB7XG4gICAgICAgIHRpdHVsbzogJ1JlbGF0w7NyaW8gZGUgU29saWNpdGHDp8O1ZXMgcG9yIFN0YXR1cycsXG4gICAgICAgIHBlcmlvZG86ICcwMS8wMS8yMDI1IGEgMzEvMDEvMjAyNScsXG4gICAgICAgIHVuaWRhZGU6ICdVbmlkYWRlIFRlc3RlJyxcbiAgICAgICAgaXRlbnM6IFtcbiAgICAgICAgICB7IHN0YXR1czogJ1BlbmRlbnRlJywgcXVhbnRpZGFkZTogMTAgfSxcbiAgICAgICAgICB7IHN0YXR1czogJ0Fwcm92YWRvJywgcXVhbnRpZGFkZTogMjAgfSxcbiAgICAgICAgICB7IHN0YXR1czogJ1JlcHJvdmFkbycsIHF1YW50aWRhZGU6IDUgfSxcbiAgICAgICAgXSxcbiAgICAgICAgdG90YWw6IDM1LFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG9wY29lcyA9IHt9O1xuXG4gICAgICBhd2FpdCBzdHJhdGVneS5nZXJhcih0aXBvLCBkYWRvcywgb3Bjb2VzKTtcblxuICAgICAgZXhwZWN0KG1vY2tXb3JrYm9vay5hZGRXb3Jrc2hlZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnU29saWNpdGHDp8O1ZXMgcG9yIFN0YXR1cycsXG4gICAgICApO1xuICAgICAgZXhwZWN0KG1vY2tXb3Jrc2hlZXQuYWRkUm93KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QobW9ja1dvcmtzaGVldC5hZGRSb3dzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGV2ZSBnZXJhciByZWxhdMOzcmlvIGRlIGF0ZW5kaW1lbnRvcyBjb3JyZXRhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0aXBvID0gJ2F0ZW5kaW1lbnRvcyc7XG4gICAgICBjb25zdCBkYWRvcyA9IHtcbiAgICAgICAgdGl0dWxvOiAnUmVsYXTDs3JpbyBkZSBBdGVuZGltZW50b3MgcG9yIFVuaWRhZGUnLFxuICAgICAgICBwZXJpb2RvOiAnMDEvMDEvMjAyNSBhIDMxLzAxLzIwMjUnLFxuICAgICAgICBpdGVuczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHVuaWRhZGU6ICdVbmlkYWRlIEEnLFxuICAgICAgICAgICAgdG90YWxTb2xpY2l0YWNvZXM6IDE1LFxuICAgICAgICAgICAgc29saWNpdGFjb2VzTGliZXJhZGFzOiAxMCxcbiAgICAgICAgICAgIHNvbGljaXRhY29lc1BlbmRlbnRlczogNSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHVuaWRhZGU6ICdVbmlkYWRlIEInLFxuICAgICAgICAgICAgdG90YWxTb2xpY2l0YWNvZXM6IDIwLFxuICAgICAgICAgICAgc29saWNpdGFjb2VzTGliZXJhZGFzOiAxNSxcbiAgICAgICAgICAgIHNvbGljaXRhY29lc1BlbmRlbnRlczogNSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICB0b3RhaXM6IHtcbiAgICAgICAgICB0b3RhbFNvbGljaXRhY29lczogMzUsXG4gICAgICAgICAgc29saWNpdGFjb2VzTGliZXJhZGFzOiAyNSxcbiAgICAgICAgICBzb2xpY2l0YWNvZXNQZW5kZW50ZXM6IDEwLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG9wY29lcyA9IHt9O1xuXG4gICAgICBhd2FpdCBzdHJhdGVneS5nZXJhcih0aXBvLCBkYWRvcywgb3Bjb2VzKTtcblxuICAgICAgZXhwZWN0KG1vY2tXb3JrYm9vay5hZGRXb3Jrc2hlZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnQXRlbmRpbWVudG9zIHBvciBVbmlkYWRlJyxcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja1dvcmtzaGVldC5hZGRSb3cpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrV29ya3NoZWV0LmFkZFJvd3MpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZXZlIGxpZGFyIGNvbSBlcnJvcyBjb3JyZXRhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3IgPSBuZXcgRXJyb3IoJ0Vycm8gYW8gZ2VyYXIgRXhjZWwnKTtcbiAgICAgIG1vY2tXb3JrYm9vay54bHN4LndyaXRlRmlsZS5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobW9ja0Vycm9yKTtcblxuICAgICAgY29uc3QgdGlwbyA9ICdiZW5lZmljaW9zJztcbiAgICAgIGNvbnN0IGRhZG9zID0geyB0aXR1bG86ICdUZXN0ZScsIGl0ZW5zOiBbXSB9O1xuICAgICAgY29uc3Qgb3Bjb2VzID0ge307XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzdHJhdGVneS5nZXJhcih0aXBvLCBkYWRvcywgb3Bjb2VzKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnRXJybyBhbyBnZXJhciBFeGNlbCcsXG4gICAgICApO1xuXG4gICAgICBleHBlY3QodGVtcEZpbGVzU2VydmljZS5jbGVhbnVwVGVtcEZpbGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygndGVtcC9yZWxhdG9yaW9zL3Rlc3QtMTIzLnhsc3gnKSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=