{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\auth\\services\\jwt-blacklist.service.ts","mappings":";;;;;;;;;;;;;;;;;AAAA,2CAKwB;AACxB,6CAAmD;AACnD,qCAA6D;AAC7D,2CAA+C;AAC/C,qCAAyC;AACzC,8EAAmE;AAWnE;;;;;GAKG;AAEI,IAAM,mBAAmB,2BAAzB,MAAM,mBAAmB;IAOX;IACA;IACA;IARF,MAAM,GAAG,IAAI,eAAM,CAAC,qBAAmB,CAAC,IAAI,CAAC,CAAC;IAC9C,gBAAgB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,UAAU;IAC1D,WAAW,GAAS,IAAI,IAAI,EAAE,CAAC;IAEvC,YAEmB,sBAAgD,EAChD,aAA4B,EAC5B,UAAsB;QAFtB,2BAAsB,GAAtB,sBAAsB,CAA0B;QAChD,kBAAa,GAAb,aAAa,CAAe;QAC5B,eAAU,GAAV,UAAU,CAAY;QAEvC,iDAAiD;QACjD,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC3B,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,cAAc,CAClB,iBAAoC;QAEpC,IAAI,CAAC;YACH,4CAA4C;YAC5C,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC;gBAC9D,KAAK,EAAE,EAAE,GAAG,EAAE,iBAAiB,CAAC,GAAG,EAAE;aACtC,CAAC,CAAC;YAEH,IAAI,aAAa,EAAE,CAAC;gBAClB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,+BAA+B,iBAAiB,CAAC,GAAG,EAAE,EAAE;oBACvE,GAAG,EAAE,iBAAiB,CAAC,GAAG;oBAC1B,SAAS,EAAE,iBAAiB,CAAC,UAAU;oBACvC,cAAc,EAAE,aAAa,CAAC,MAAM;oBACpC,SAAS,EAAE,iBAAiB,CAAC,MAAM;iBACpC,CAAC,CAAC;gBAEH,OAAO;oBACL,OAAO,EAAE,4BAA4B;oBACrC,OAAO,EAAE,IAAI;oBACb,cAAc,EAAE,CAAC;iBAClB,CAAC;YACJ,CAAC;YAED,8BAA8B;YAC9B,MAAM,cAAc,GAAG,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC;gBACxD,GAAG,EAAE,iBAAiB,CAAC,GAAG;gBAC1B,UAAU,EAAE,iBAAiB,CAAC,UAAU;gBACxC,UAAU,EAAE,iBAAiB,CAAC,UAAU;gBACxC,UAAU,EAAE,IAAI,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC;gBAClD,MAAM,EAAE,iBAAiB,CAAC,MAAM;gBAChC,SAAS,EAAE,iBAAiB,CAAC,SAAS;gBACtC,UAAU,EAAE,iBAAiB,CAAC,UAAU;gBACxC,QAAQ,EAAE,iBAAiB,CAAC,QAAQ;aACrC,CAAC,CAAC;YAEH,MAAM,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YAEvD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,iCAAiC,iBAAiB,CAAC,GAAG,EAAE,EAAE;gBACxE,GAAG,EAAE,iBAAiB,CAAC,GAAG;gBAC1B,SAAS,EAAE,iBAAiB,CAAC,UAAU;gBACvC,SAAS,EAAE,iBAAiB,CAAC,UAAU;gBACvC,MAAM,EAAE,iBAAiB,CAAC,MAAM;gBAChC,SAAS,EAAE,iBAAiB,CAAC,UAAU;aACxC,CAAC,CAAC;YAEH,OAAO;gBACL,OAAO,EAAE,0CAA0C;gBACnD,OAAO,EAAE,IAAI;gBACb,cAAc,EAAE,CAAC;aAClB,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,wCAAwC,KAAK,CAAC,OAAO,EAAE,EAAE;gBACzE,GAAG,EAAE,iBAAiB,CAAC,GAAG;gBAC1B,KAAK,EAAE,KAAK,CAAC,KAAK;aACnB,CAAC,CAAC;YAEH,MAAM,IAAI,qCAA4B,CACpC,iCAAiC,CAClC,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,kBAAkB,CACtB,iBAAoC;QAEpC,IAAI,CAAC;YACH,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC;gBAC/D,KAAK,EAAE,EAAE,GAAG,EAAE,iBAAiB,CAAC,GAAG,EAAE;aACtC,CAAC,CAAC;YAEH,IAAI,CAAC,cAAc,EAAE,CAAC;gBACpB,OAAO;oBACL,cAAc,EAAE,KAAK;iBACtB,CAAC;YACJ,CAAC;YAED,sDAAsD;YACtD,MAAM,kBAAkB,GAAG,cAAc,CAAC,kBAAkB,EAAE,CAAC;YAE/D,IAAI,CAAC,kBAAkB,EAAE,CAAC;gBACxB,gDAAgD;gBAChD,MAAM,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;gBAEzD,OAAO;oBACL,cAAc,EAAE,KAAK;iBACtB,CAAC;YACJ,CAAC;YAED,OAAO;gBACL,cAAc,EAAE,IAAI;gBACpB,MAAM,EAAE,cAAc,CAAC,MAAM;gBAC7B,UAAU,EAAE,cAAc,CAAC,UAAU,CAAC,WAAW,EAAE;gBACnD,wBAAwB,EAAE,cAAc,CAAC,yBAAyB,EAAE;aACrE,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,gCAAgC,KAAK,CAAC,OAAO,EAAE,EAAE;gBACjE,GAAG,EAAE,iBAAiB,CAAC,GAAG;gBAC1B,KAAK,EAAE,KAAK,CAAC,KAAK;aACnB,CAAC,CAAC;YAEH,4DAA4D;YAC5D,gDAAgD;YAChD,OAAO;gBACL,cAAc,EAAE,KAAK;aACtB,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,oBAAoB,CACxB,aAAsC,EACtC,YAIE;QAEF,IAAI,CAAC;YACH,IAAI,CAAC,YAAY,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBAC/C,OAAO;oBACL,OAAO,EAAE,8CAA8C;oBACvD,OAAO,EAAE,IAAI;oBACb,cAAc,EAAE,CAAC;iBAClB,CAAC;YACJ,CAAC;YAED,0CAA0C;YAC1C,IAAI,kBAAkB,GAAG,YAAY,CAAC;YACtC,IAAI,aAAa,CAAC,UAAU,IAAI,aAAa,CAAC,UAAU,KAAK,KAAK,EAAE,CAAC;gBACnE,kBAAkB,GAAG,YAAY,CAAC,MAAM,CACtC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,UAAU,KAAK,aAAa,CAAC,UAAU,CACvD,CAAC;YACJ,CAAC;YAED,+BAA+B;YAC/B,MAAM,gBAAgB,GAAG,kBAAkB,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CACtD,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC;gBACjC,GAAG,EAAE,KAAK,CAAC,GAAG;gBACd,UAAU,EAAE,aAAa,CAAC,UAAU;gBACpC,UAAU,EAAE,KAAK,CAAC,UAAU;gBAC5B,UAAU,EAAE,KAAK,CAAC,UAAU;gBAC5B,MAAM,EAAE,aAAa,CAAC,MAAM;gBAC5B,SAAS,EAAE,aAAa,CAAC,SAAS;gBAClC,UAAU,EAAE,aAAa,CAAC,UAAU;gBACpC,QAAQ,EAAE;oBACR,iBAAiB,EAAE,IAAI;oBACvB,cAAc,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;iBACzC;aACF,CAAC,CACH,CAAC;YAEF,MAAM,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;YAEzD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,wCAAwC,EAAE;gBACxD,SAAS,EAAE,aAAa,CAAC,UAAU;gBACnC,SAAS,EAAE,aAAa,CAAC,UAAU,IAAI,KAAK;gBAC5C,MAAM,EAAE,aAAa,CAAC,MAAM;gBAC5B,aAAa,EAAE,gBAAgB,CAAC,MAAM;gBACtC,SAAS,EAAE,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;aAC9C,CAAC,CAAC;YAEH,OAAO;gBACL,OAAO,EAAE,GAAG,gBAAgB,CAAC,MAAM,qCAAqC;gBACxE,OAAO,EAAE,IAAI;gBACb,cAAc,EAAE,gBAAgB,CAAC,MAAM;aACxC,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,wCAAwC,KAAK,CAAC,OAAO,EAAE,EAAE;gBACzE,SAAS,EAAE,aAAa,CAAC,UAAU;gBACnC,KAAK,EAAE,KAAK,CAAC,KAAK;aACnB,CAAC,CAAC;YAEH,MAAM,IAAI,qCAA4B,CACpC,6CAA6C,CAC9C,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,mBAAmB,CAAC,GAAW;QACnC,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;YAEjE,IAAI,MAAM,CAAC,QAAQ,KAAK,CAAC,EAAE,CAAC;gBAC1B,MAAM,IAAI,0BAAiB,CAAC,mCAAmC,CAAC,CAAC;YACnE,CAAC;YAED,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,gCAAgC,GAAG,EAAE,CAAC,CAAC;YAEvD,OAAO;gBACL,OAAO,EAAE,yCAAyC;gBAClD,OAAO,EAAE,IAAI;gBACb,cAAc,EAAE,MAAM,CAAC,QAAQ,IAAI,CAAC;aACrC,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,uCAAuC,KAAK,CAAC,OAAO,EAAE,EAAE;gBACxE,GAAG;gBACH,KAAK,EAAE,KAAK,CAAC,KAAK;aACnB,CAAC,CAAC;YAEH,IAAI,KAAK,YAAY,0BAAiB,EAAE,CAAC;gBACvC,MAAM,KAAK,CAAC;YACd,CAAC;YAED,MAAM,IAAI,qCAA4B,CACpC,4CAA4C,CAC7C,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,qBAAqB,CACzB,QAA2B;QAQ3B,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,IAAI,CAAC,CAAC;YAChC,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,IAAI,EAAE,EAAE,GAAG,CAAC,CAAC;YAClD,MAAM,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC;YAEhC,MAAM,YAAY,GAAG,IAAI,CAAC,sBAAsB,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;YAEjF,kBAAkB;YAClB,IAAI,QAAQ,CAAC,UAAU,EAAE,CAAC;gBACxB,YAAY,CAAC,QAAQ,CAAC,oCAAoC,EAAE;oBAC1D,UAAU,EAAE,QAAQ,CAAC,UAAU;iBAChC,CAAC,CAAC;YACL,CAAC;YAED,IAAI,QAAQ,CAAC,UAAU,EAAE,CAAC;gBACxB,YAAY,CAAC,QAAQ,CAAC,oCAAoC,EAAE;oBAC1D,UAAU,EAAE,QAAQ,CAAC,UAAU;iBAChC,CAAC,CAAC;YACL,CAAC;YAED,IAAI,QAAQ,CAAC,MAAM,EAAE,CAAC;gBACpB,YAAY,CAAC,QAAQ,CAAC,4BAA4B,EAAE;oBAClD,MAAM,EAAE,QAAQ,CAAC,MAAM;iBACxB,CAAC,CAAC;YACL,CAAC;YAED,IAAI,QAAQ,CAAC,WAAW,EAAE,CAAC;gBACzB,YAAY,CAAC,QAAQ,CAAC,6BAA6B,EAAE;oBACnD,GAAG,EAAE,IAAI,IAAI,EAAE;iBAChB,CAAC,CAAC;YACL,CAAC;YAED,uDAAuD;YACvD,YAAY,CAAC,OAAO,CAAC,sBAAsB,EAAE,MAAM,CAAC,CAAC;YAErD,oBAAoB;YACpB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAEpC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,MAAM,YAAY,CAAC,eAAe,EAAE,CAAC;YAC3D,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;YAE5C,OAAO;gBACL,IAAI;gBACJ,KAAK;gBACL,IAAI;gBACJ,KAAK;gBACL,UAAU;aACX,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,sCAAsC,KAAK,CAAC,OAAO,EAAE,EAAE;gBACvE,QAAQ;gBACR,KAAK,EAAE,KAAK,CAAC,KAAK;aACnB,CAAC,CAAC;YAEH,MAAM,IAAI,qCAA4B,CACpC,qCAAqC,CACtC,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,iBAAiB;QACrB,IAAI,CAAC;YACH,MAAM,GAAG,GAAG,IAAI,IAAI,EAAE,CAAC;YAEvB,MAAM,CAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,YAAY,EAAE,aAAa,EAAE,WAAW,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;gBAC3F,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE;gBACnC,IAAI,CAAC,sBAAsB,CAAC,KAAK,CAAC;oBAChC,KAAK,EAAE,EAAE,UAAU,EAAE,IAAA,kBAAQ,EAAC,GAAG,CAAC,EAAE;iBACrC,CAAC;gBACF,IAAI,CAAC,sBAAsB,CAAC,KAAK,CAAC;oBAChC,KAAK,EAAE,EAAE,UAAU,EAAE,IAAA,kBAAQ,EAAC,GAAG,CAAC,EAAE;iBACrC,CAAC;gBACF,IAAI,CAAC,sBAAsB,CAAC,KAAK,CAAC;oBAChC,KAAK,EAAE,EAAE,UAAU,EAAE,QAAQ,EAAE;iBAChC,CAAC;gBACF,IAAI,CAAC,sBAAsB,CAAC,KAAK,CAAC;oBAChC,KAAK,EAAE,EAAE,UAAU,EAAE,SAAS,EAAE;iBACjC,CAAC;gBACF,IAAI,CAAC,cAAc,EAAE;aACtB,CAAC,CAAC;YAEH,OAAO;gBACL,KAAK;gBACL,MAAM;gBACN,OAAO;gBACP,aAAa,EAAE,YAAY;gBAC3B,cAAc,EAAE,aAAa;gBAC7B,SAAS,EAAE,WAAW;gBACtB,YAAY,EAAE,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE;aAC7C,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,4CAA4C,KAAK,CAAC,OAAO,EAAE,EAAE;gBAC7E,KAAK,EAAE,KAAK,CAAC,KAAK;aACnB,CAAC,CAAC;YAEH,MAAM,IAAI,qCAA4B,CACpC,oCAAoC,CACrC,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,oBAAoB;QACxB,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC;gBACtD,UAAU,EAAE,IAAA,kBAAQ,EAAC,IAAI,IAAI,EAAE,CAAC;aACjC,CAAC,CAAC;YAEH,MAAM,YAAY,GAAG,MAAM,CAAC,QAAQ,IAAI,CAAC,CAAC;YAC1C,IAAI,CAAC,WAAW,GAAG,IAAI,IAAI,EAAE,CAAC;YAE9B,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,yBAAyB,YAAY,6BAA6B,CAAC,CAAC;YAEpF,OAAO,YAAY,CAAC;QACtB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,iCAAiC,KAAK,CAAC,OAAO,EAAE,EAAE;gBAClE,KAAK,EAAE,KAAK,CAAC,KAAK;aACnB,CAAC,CAAC;YAEH,MAAM,IAAI,qCAA4B,CACpC,sCAAsC,CACvC,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;;OAGG;IACK,KAAK,CAAC,cAAc;QAC1B,IAAI,CAAC;YACH,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,sBAAsB;iBAC9C,kBAAkB,CAAC,WAAW,CAAC;iBAC/B,MAAM,CAAC,kBAAkB,EAAE,QAAQ,CAAC;iBACpC,SAAS,CAAC,UAAU,EAAE,OAAO,CAAC;iBAC9B,OAAO,CAAC,kBAAkB,CAAC;iBAC3B,UAAU,EAAE,CAAC;YAEhB,MAAM,KAAK,GAA2B,EAAE,CAAC;YACzC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;gBACvB,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YACpD,CAAC,CAAC,CAAC;YAEH,OAAO,KAAK,CAAC;QACf,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,0CAA0C,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;YAC7E,OAAO,EAAE,CAAC;QACZ,CAAC;IACH,CAAC;IAED;;OAEG;IACK,iBAAiB;QACvB,WAAW,CAAC,KAAK,IAAI,EAAE;YACrB,IAAI,CAAC;gBACH,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,oBAAoB,EAAE,CAAC;gBACvD,IAAI,YAAY,GAAG,CAAC,EAAE,CAAC;oBACrB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,oCAAoC,YAAY,mBAAmB,CAAC,CAAC;gBACvF,CAAC;YACH,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,4CAA4C,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;YACjF,CAAC;QACH,CAAC,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;IAC5B,CAAC;IAED;;;;OAIG;IACH,mBAAmB,CAAC,KAAa;QAC/B,IAAI,CAAC;YACH,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAQ,CAAC;YACrD,OAAO,OAAO,EAAE,GAAG,IAAI,IAAI,CAAC;QAC9B,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,iCAAiC,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;YACnE,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,2BAA2B,CAAC,KAAa;QAC7C,MAAM,GAAG,GAAG,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;QAC5C,IAAI,CAAC,GAAG,EAAE,CAAC;YACT,OAAO,KAAK,CAAC;QACf,CAAC;QAED,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;QACtD,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC;IAChC,CAAC;CACF,CAAA;AA9cY,kDAAmB;8BAAnB,mBAAmB;IAD/B,IAAA,mBAAU,GAAE;IAOR,WAAA,IAAA,0BAAgB,EAAC,mCAAY,CAAC,CAAA;yDACU,oBAAU,oBAAV,oBAAU,oDACnB,sBAAa,oBAAb,sBAAa,oDAChB,gBAAU,oBAAV,gBAAU;GAT9B,mBAAmB,CA8c/B","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\auth\\services\\jwt-blacklist.service.ts"],"sourcesContent":["import {\n  Injectable,\n  Logger,\n  InternalServerErrorException,\n  NotFoundException,\n} from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, LessThan, MoreThan, In } from 'typeorm';\nimport { ConfigService } from '@nestjs/config';\nimport { JwtService } from '@nestjs/jwt';\nimport { JwtBlacklist } from '../../entities/jwt-blacklist.entity';\nimport {\n  AddToBlacklistDto,\n  CheckBlacklistDto,\n  InvalidateUserTokensDto,\n  BlacklistResponseDto,\n  CheckBlacklistResponseDto,\n  BlacklistQueryDto,\n  BlacklistStatsDto,\n} from '../dtos/jwt-blacklist.dto';\n\n/**\n * Serviço de Blacklist de Tokens JWT\n * \n * Gerencia tokens JWT invalidados para prevenir reutilização\n * de tokens comprometidos, revogados ou de usuários deslogados\n */\n@Injectable()\nexport class JwtBlacklistService {\n  private readonly logger = new Logger(JwtBlacklistService.name);\n  private readonly CLEANUP_INTERVAL = 6 * 60 * 60 * 1000; // 6 horas\n  private lastCleanup: Date = new Date();\n\n  constructor(\n    @InjectRepository(JwtBlacklist)\n    private readonly jwtBlacklistRepository: Repository<JwtBlacklist>,\n    private readonly configService: ConfigService,\n    private readonly jwtService: JwtService,\n  ) {\n    // Iniciar limpeza automática de tokens expirados\n    this.startTokenCleanup();\n  }\n\n  /**\n   * Adiciona um token à blacklist\n   * @param addToBlacklistDto Dados do token a ser invalidado\n   * @returns Resposta da operação\n   */\n  async addToBlacklist(\n    addToBlacklistDto: AddToBlacklistDto,\n  ): Promise<BlacklistResponseDto> {\n    try {\n      // Verificar se o token já está na blacklist\n      const existingToken = await this.jwtBlacklistRepository.findOne({\n        where: { jti: addToBlacklistDto.jti },\n      });\n\n      if (existingToken) {\n        this.logger.warn(`Token já está na blacklist: ${addToBlacklistDto.jti}`, {\n          jti: addToBlacklistDto.jti,\n          usuarioId: addToBlacklistDto.usuario_id,\n          existingReason: existingToken.reason,\n          newReason: addToBlacklistDto.reason,\n        });\n\n        return {\n          message: 'Token já está na blacklist',\n          success: true,\n          affected_count: 0,\n        };\n      }\n\n      // Criar registro na blacklist\n      const blacklistEntry = this.jwtBlacklistRepository.create({\n        jti: addToBlacklistDto.jti,\n        usuario_id: addToBlacklistDto.usuario_id,\n        token_type: addToBlacklistDto.token_type,\n        expires_at: new Date(addToBlacklistDto.expires_at),\n        reason: addToBlacklistDto.reason,\n        client_ip: addToBlacklistDto.client_ip,\n        user_agent: addToBlacklistDto.user_agent,\n        metadata: addToBlacklistDto.metadata,\n      });\n\n      await this.jwtBlacklistRepository.save(blacklistEntry);\n\n      this.logger.log(`Token adicionado à blacklist: ${addToBlacklistDto.jti}`, {\n        jti: addToBlacklistDto.jti,\n        usuarioId: addToBlacklistDto.usuario_id,\n        tokenType: addToBlacklistDto.token_type,\n        reason: addToBlacklistDto.reason,\n        expiresAt: addToBlacklistDto.expires_at,\n      });\n\n      return {\n        message: 'Token adicionado à blacklist com sucesso',\n        success: true,\n        affected_count: 1,\n      };\n    } catch (error) {\n      this.logger.error(`Erro ao adicionar token à blacklist: ${error.message}`, {\n        jti: addToBlacklistDto.jti,\n        error: error.stack,\n      });\n      \n      throw new InternalServerErrorException(\n        'Erro interno ao invalidar token',\n      );\n    }\n  }\n\n  /**\n   * Verifica se um token está na blacklist\n   * @param checkBlacklistDto Dados do token a ser verificado\n   * @returns Status do token na blacklist\n   */\n  async isTokenBlacklisted(\n    checkBlacklistDto: CheckBlacklistDto,\n  ): Promise<CheckBlacklistResponseDto> {\n    try {\n      const blacklistEntry = await this.jwtBlacklistRepository.findOne({\n        where: { jti: checkBlacklistDto.jti },\n      });\n\n      if (!blacklistEntry) {\n        return {\n          is_blacklisted: false,\n        };\n      }\n\n      // Verificar se o token ainda está válido na blacklist\n      const isStillBlacklisted = blacklistEntry.isStillBlacklisted();\n\n      if (!isStillBlacklisted) {\n        // Token expirou, pode ser removido da blacklist\n        await this.jwtBlacklistRepository.remove(blacklistEntry);\n        \n        return {\n          is_blacklisted: false,\n        };\n      }\n\n      return {\n        is_blacklisted: true,\n        reason: blacklistEntry.reason,\n        expires_at: blacklistEntry.expires_at.toISOString(),\n        minutes_until_expiration: blacklistEntry.getMinutesUntilExpiration(),\n      };\n    } catch (error) {\n      this.logger.error(`Erro ao verificar blacklist: ${error.message}`, {\n        jti: checkBlacklistDto.jti,\n        error: error.stack,\n      });\n      \n      // Em caso de erro, assumir que o token não está blacklisted\n      // para não bloquear usuários desnecessariamente\n      return {\n        is_blacklisted: false,\n      };\n    }\n  }\n\n  /**\n   * Invalida todos os tokens de um usuário\n   * @param invalidateDto Dados da invalidação\n   * @param activeTokens Lista de tokens ativos do usuário\n   * @returns Resposta da operação\n   */\n  async invalidateUserTokens(\n    invalidateDto: InvalidateUserTokensDto,\n    activeTokens: Array<{\n      jti: string;\n      token_type: 'access' | 'refresh';\n      expires_at: Date;\n    }>,\n  ): Promise<BlacklistResponseDto> {\n    try {\n      if (!activeTokens || activeTokens.length === 0) {\n        return {\n          message: 'Nenhum token ativo encontrado para invalidar',\n          success: true,\n          affected_count: 0,\n        };\n      }\n\n      // Filtrar tokens por tipo se especificado\n      let tokensToInvalidate = activeTokens;\n      if (invalidateDto.token_type && invalidateDto.token_type !== 'all') {\n        tokensToInvalidate = activeTokens.filter(\n          token => token.token_type === invalidateDto.token_type,\n        );\n      }\n\n      // Criar registros na blacklist\n      const blacklistEntries = tokensToInvalidate.map(token => \n        this.jwtBlacklistRepository.create({\n          jti: token.jti,\n          usuario_id: invalidateDto.usuario_id,\n          token_type: token.token_type,\n          expires_at: token.expires_at,\n          reason: invalidateDto.reason,\n          client_ip: invalidateDto.client_ip,\n          user_agent: invalidateDto.user_agent,\n          metadata: {\n            bulk_invalidation: true,\n            invalidated_at: new Date().toISOString(),\n          },\n        }),\n      );\n\n      await this.jwtBlacklistRepository.save(blacklistEntries);\n\n      this.logger.log(`Tokens de usuário invalidados em massa`, {\n        usuarioId: invalidateDto.usuario_id,\n        tokenType: invalidateDto.token_type || 'all',\n        reason: invalidateDto.reason,\n        affectedCount: blacklistEntries.length,\n        tokenJtis: tokensToInvalidate.map(t => t.jti),\n      });\n\n      return {\n        message: `${blacklistEntries.length} token(s) invalidado(s) com sucesso`,\n        success: true,\n        affected_count: blacklistEntries.length,\n      };\n    } catch (error) {\n      this.logger.error(`Erro ao invalidar tokens do usuário: ${error.message}`, {\n        usuarioId: invalidateDto.usuario_id,\n        error: error.stack,\n      });\n      \n      throw new InternalServerErrorException(\n        'Erro interno ao invalidar tokens do usuário',\n      );\n    }\n  }\n\n  /**\n   * Remove um token específico da blacklist\n   * @param jti JWT ID do token\n   * @returns Resposta da operação\n   */\n  async removeFromBlacklist(jti: string): Promise<BlacklistResponseDto> {\n    try {\n      const result = await this.jwtBlacklistRepository.delete({ jti });\n\n      if (result.affected === 0) {\n        throw new NotFoundException('Token não encontrado na blacklist');\n      }\n\n      this.logger.log(`Token removido da blacklist: ${jti}`);\n\n      return {\n        message: 'Token removido da blacklist com sucesso',\n        success: true,\n        affected_count: result.affected || 0,\n      };\n    } catch (error) {\n      this.logger.error(`Erro ao remover token da blacklist: ${error.message}`, {\n        jti,\n        error: error.stack,\n      });\n      \n      if (error instanceof NotFoundException) {\n        throw error;\n      }\n      \n      throw new InternalServerErrorException(\n        'Erro interno ao remover token da blacklist',\n      );\n    }\n  }\n\n  /**\n   * Lista tokens na blacklist com filtros\n   * @param queryDto Filtros de consulta\n   * @returns Lista paginada de tokens\n   */\n  async listBlacklistedTokens(\n    queryDto: BlacklistQueryDto,\n  ): Promise<{\n    data: JwtBlacklist[];\n    total: number;\n    page: number;\n    limit: number;\n    totalPages: number;\n  }> {\n    try {\n      const page = queryDto.page || 1;\n      const limit = Math.min(queryDto.limit || 10, 100);\n      const skip = (page - 1) * limit;\n\n      const queryBuilder = this.jwtBlacklistRepository.createQueryBuilder('blacklist');\n\n      // Aplicar filtros\n      if (queryDto.usuario_id) {\n        queryBuilder.andWhere('blacklist.usuario_id = :usuario_id', {\n          usuario_id: queryDto.usuario_id,\n        });\n      }\n\n      if (queryDto.token_type) {\n        queryBuilder.andWhere('blacklist.token_type = :token_type', {\n          token_type: queryDto.token_type,\n        });\n      }\n\n      if (queryDto.reason) {\n        queryBuilder.andWhere('blacklist.reason = :reason', {\n          reason: queryDto.reason,\n        });\n      }\n\n      if (queryDto.only_active) {\n        queryBuilder.andWhere('blacklist.expires_at > :now', {\n          now: new Date(),\n        });\n      }\n\n      // Ordenar por data de criação (mais recentes primeiro)\n      queryBuilder.orderBy('blacklist.created_at', 'DESC');\n\n      // Aplicar paginação\n      queryBuilder.skip(skip).take(limit);\n\n      const [data, total] = await queryBuilder.getManyAndCount();\n      const totalPages = Math.ceil(total / limit);\n\n      return {\n        data,\n        total,\n        page,\n        limit,\n        totalPages,\n      };\n    } catch (error) {\n      this.logger.error(`Erro ao listar tokens blacklisted: ${error.message}`, {\n        queryDto,\n        error: error.stack,\n      });\n      \n      throw new InternalServerErrorException(\n        'Erro interno ao consultar blacklist',\n      );\n    }\n  }\n\n  /**\n   * Obtém estatísticas da blacklist\n   * @returns Estatísticas detalhadas\n   */\n  async getBlacklistStats(): Promise<BlacklistStatsDto> {\n    try {\n      const now = new Date();\n\n      const [total, expired, active, accessTokens, refreshTokens, reasonStats] = await Promise.all([\n        this.jwtBlacklistRepository.count(),\n        this.jwtBlacklistRepository.count({\n          where: { expires_at: LessThan(now) },\n        }),\n        this.jwtBlacklistRepository.count({\n          where: { expires_at: MoreThan(now) },\n        }),\n        this.jwtBlacklistRepository.count({\n          where: { token_type: 'access' },\n        }),\n        this.jwtBlacklistRepository.count({\n          where: { token_type: 'refresh' },\n        }),\n        this.getReasonStats(),\n      ]);\n\n      return {\n        total,\n        active,\n        expired,\n        access_tokens: accessTokens,\n        refresh_tokens: refreshTokens,\n        by_reason: reasonStats,\n        last_cleanup: this.lastCleanup.toISOString(),\n      };\n    } catch (error) {\n      this.logger.error(`Erro ao obter estatísticas da blacklist: ${error.message}`, {\n        error: error.stack,\n      });\n      \n      throw new InternalServerErrorException(\n        'Erro interno ao obter estatísticas',\n      );\n    }\n  }\n\n  /**\n   * Limpa tokens expirados da blacklist\n   * @returns Número de tokens removidos\n   */\n  async cleanupExpiredTokens(): Promise<number> {\n    try {\n      const result = await this.jwtBlacklistRepository.delete({\n        expires_at: LessThan(new Date()),\n      });\n\n      const deletedCount = result.affected || 0;\n      this.lastCleanup = new Date();\n\n      this.logger.log(`Limpeza da blacklist: ${deletedCount} tokens expirados removidos`);\n\n      return deletedCount;\n    } catch (error) {\n      this.logger.error(`Erro na limpeza da blacklist: ${error.message}`, {\n        error: error.stack,\n      });\n      \n      throw new InternalServerErrorException(\n        'Erro interno na limpeza da blacklist',\n      );\n    }\n  }\n\n  /**\n   * Obtém estatísticas por motivo de invalidação\n   * @returns Contagem por motivo\n   */\n  private async getReasonStats(): Promise<Record<string, number>> {\n    try {\n      const results = await this.jwtBlacklistRepository\n        .createQueryBuilder('blacklist')\n        .select('blacklist.reason', 'reason')\n        .addSelect('COUNT(*)', 'count')\n        .groupBy('blacklist.reason')\n        .getRawMany();\n\n      const stats: Record<string, number> = {};\n      results.forEach(result => {\n        stats[result.reason] = parseInt(result.count, 10);\n      });\n\n      return stats;\n    } catch (error) {\n      this.logger.error(`Erro ao obter estatísticas por motivo: ${error.message}`);\n      return {};\n    }\n  }\n\n  /**\n   * Inicia limpeza automática de tokens expirados\n   */\n  private startTokenCleanup(): void {\n    setInterval(async () => {\n      try {\n        const deletedCount = await this.cleanupExpiredTokens();\n        if (deletedCount > 0) {\n          this.logger.log(`Limpeza automática da blacklist: ${deletedCount} tokens removidos`);\n        }\n      } catch (error) {\n        this.logger.error(`Erro na limpeza automática da blacklist: ${error.message}`);\n      }\n    }, this.CLEANUP_INTERVAL);\n  }\n\n  /**\n   * Extrai JTI de um token JWT\n   * @param token Token JWT\n   * @returns JTI ou null se inválido\n   */\n  extractJtiFromToken(token: string): string | null {\n    try {\n      const decoded = this.jwtService.decode(token) as any;\n      return decoded?.jti || null;\n    } catch (error) {\n      this.logger.warn(`Erro ao extrair JTI do token: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Valida se um token JWT não está na blacklist\n   * Método utilitário para uso em guards\n   * @param token Token JWT completo\n   * @returns true se o token é válido (não blacklisted)\n   */\n  async validateTokenNotBlacklisted(token: string): Promise<boolean> {\n    const jti = this.extractJtiFromToken(token);\n    if (!jti) {\n      return false;\n    }\n\n    const result = await this.isTokenBlacklisted({ jti });\n    return !result.is_blacklisted;\n  }\n}"],"version":3}