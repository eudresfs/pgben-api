ee56e470dc35f1cc49993d7566497d25
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var SseGuard_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SseGuard = void 0;
const common_1 = require("@nestjs/common");
const jwt_1 = require("@nestjs/jwt");
/**
 * Guard para autenticação de conexões SSE
 *
 * Valida o token JWT fornecido via query parameter para estabelecer
 * conexões SSE seguras. O token deve ser válido e não expirado.
 */
let SseGuard = SseGuard_1 = class SseGuard {
    jwtService;
    logger = new common_1.Logger(SseGuard_1.name);
    constructor(jwtService) {
        this.jwtService = jwtService;
    }
    /**
     * Valida se a requisição pode prosseguir
     * @param context Contexto de execução da requisição
     * @returns true se autorizado, lança exceção caso contrário
     */
    canActivate(context) {
        const request = context.switchToHttp().getRequest();
        // Tenta obter o token do query parameter ou header Authorization
        const token = this.extractToken(request);
        if (!token) {
            this.logger.warn('Tentativa de conexão SSE sem token de acesso');
            throw new common_1.UnauthorizedException('Token de acesso obrigatório para conexões SSE');
        }
        try {
            // Verifica e decodifica o token JWT
            const payload = this.jwtService.verify(token);
            // Adiciona os dados do usuário à requisição
            request['user'] = {
                id: payload.sub || payload.id,
                email: payload.email,
                roles: payload.roles || [],
                ...payload,
            };
            this.logger.debug(`Conexão SSE autorizada para usuário: ${request['user'].id}`);
            return true;
        }
        catch (error) {
            this.logger.warn(`Token SSE inválido: ${error.message}`);
            if (error.name === 'TokenExpiredError') {
                throw new common_1.UnauthorizedException('Token expirado. Faça login novamente.');
            }
            if (error.name === 'JsonWebTokenError') {
                throw new common_1.UnauthorizedException('Token inválido ou malformado.');
            }
            throw new common_1.UnauthorizedException('Falha na autenticação do token.');
        }
    }
    /**
     * Extrai o token JWT da requisição
     * @param request Objeto da requisição HTTP
     * @returns Token JWT ou null se não encontrado
     */
    extractToken(request) {
        // Primeiro tenta obter do query parameter 'token'
        const queryToken = request.query.token;
        if (queryToken) {
            return queryToken;
        }
        // Depois tenta obter do header Authorization
        const authHeader = request.headers.authorization;
        if (authHeader && authHeader.startsWith('Bearer ')) {
            return authHeader.substring(7);
        }
        // Tenta obter de um cookie (se configurado)
        const cookieToken = request.cookies?.['access_token'];
        if (cookieToken) {
            return cookieToken;
        }
        return null;
    }
};
exports.SseGuard = SseGuard;
exports.SseGuard = SseGuard = SseGuard_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof jwt_1.JwtService !== "undefined" && jwt_1.JwtService) === "function" ? _a : Object])
], SseGuard);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXG5vdGlmaWNhY2FvXFxndWFyZHNcXHNzZS5ndWFyZC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLDJDQU13QjtBQUN4QixxQ0FBeUM7QUFHekM7Ozs7O0dBS0c7QUFFSSxJQUFNLFFBQVEsZ0JBQWQsTUFBTSxRQUFRO0lBR1U7SUFGWixNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsVUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXBELFlBQTZCLFVBQXNCO1FBQXRCLGVBQVUsR0FBVixVQUFVLENBQVk7SUFBRyxDQUFDO0lBRXZEOzs7O09BSUc7SUFDSCxXQUFXLENBQUMsT0FBeUI7UUFDbkMsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLFlBQVksRUFBRSxDQUFDLFVBQVUsRUFBVyxDQUFDO1FBRTdELGlFQUFpRTtRQUNqRSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXpDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNYLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDhDQUE4QyxDQUFDLENBQUM7WUFDakUsTUFBTSxJQUFJLDhCQUFxQixDQUM3QiwrQ0FBK0MsQ0FDaEQsQ0FBQztRQUNKLENBQUM7UUFFRCxJQUFJLENBQUM7WUFDSCxvQ0FBb0M7WUFDcEMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7WUFFOUMsNENBQTRDO1lBQzVDLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRztnQkFDaEIsRUFBRSxFQUFFLE9BQU8sQ0FBQyxHQUFHLElBQUksT0FBTyxDQUFDLEVBQUU7Z0JBQzdCLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSztnQkFDcEIsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLElBQUksRUFBRTtnQkFDMUIsR0FBRyxPQUFPO2FBQ1gsQ0FBQztZQUVGLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUNmLHdDQUF3QyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQzdELENBQUM7WUFDRixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsdUJBQXVCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBRXpELElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxtQkFBbUIsRUFBRSxDQUFDO2dCQUN2QyxNQUFNLElBQUksOEJBQXFCLENBQzdCLHVDQUF1QyxDQUN4QyxDQUFDO1lBQ0osQ0FBQztZQUVELElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxtQkFBbUIsRUFBRSxDQUFDO2dCQUN2QyxNQUFNLElBQUksOEJBQXFCLENBQUMsK0JBQStCLENBQUMsQ0FBQztZQUNuRSxDQUFDO1lBRUQsTUFBTSxJQUFJLDhCQUFxQixDQUFDLGlDQUFpQyxDQUFDLENBQUM7UUFDckUsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssWUFBWSxDQUFDLE9BQWdCO1FBQ25DLGtEQUFrRDtRQUNsRCxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQWUsQ0FBQztRQUNqRCxJQUFJLFVBQVUsRUFBRSxDQUFDO1lBQ2YsT0FBTyxVQUFVLENBQUM7UUFDcEIsQ0FBQztRQUVELDZDQUE2QztRQUM3QyxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztRQUNqRCxJQUFJLFVBQVUsSUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUM7WUFDbkQsT0FBTyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLENBQUM7UUFFRCw0Q0FBNEM7UUFDNUMsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3RELElBQUksV0FBVyxFQUFFLENBQUM7WUFDaEIsT0FBTyxXQUFXLENBQUM7UUFDckIsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztDQUNGLENBQUE7QUFsRlksNEJBQVE7bUJBQVIsUUFBUTtJQURwQixJQUFBLG1CQUFVLEdBQUU7eURBSThCLGdCQUFVLG9CQUFWLGdCQUFVO0dBSHhDLFFBQVEsQ0FrRnBCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZXVkcmVcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxtb2R1bGVzXFxub3RpZmljYWNhb1xcZ3VhcmRzXFxzc2UuZ3VhcmQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSW5qZWN0YWJsZSxcbiAgQ2FuQWN0aXZhdGUsXG4gIEV4ZWN1dGlvbkNvbnRleHQsXG4gIFVuYXV0aG9yaXplZEV4Y2VwdGlvbixcbiAgTG9nZ2VyLFxufSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBKd3RTZXJ2aWNlIH0gZnJvbSAnQG5lc3Rqcy9qd3QnO1xuaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gJ2V4cHJlc3MnO1xuXG4vKipcbiAqIEd1YXJkIHBhcmEgYXV0ZW50aWNhw6fDo28gZGUgY29uZXjDtWVzIFNTRVxuICpcbiAqIFZhbGlkYSBvIHRva2VuIEpXVCBmb3JuZWNpZG8gdmlhIHF1ZXJ5IHBhcmFtZXRlciBwYXJhIGVzdGFiZWxlY2VyXG4gKiBjb25leMO1ZXMgU1NFIHNlZ3VyYXMuIE8gdG9rZW4gZGV2ZSBzZXIgdsOhbGlkbyBlIG7Do28gZXhwaXJhZG8uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTc2VHdWFyZCBpbXBsZW1lbnRzIENhbkFjdGl2YXRlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXIgPSBuZXcgTG9nZ2VyKFNzZUd1YXJkLm5hbWUpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgand0U2VydmljZTogSnd0U2VydmljZSkge31cblxuICAvKipcbiAgICogVmFsaWRhIHNlIGEgcmVxdWlzacOnw6NvIHBvZGUgcHJvc3NlZ3VpclxuICAgKiBAcGFyYW0gY29udGV4dCBDb250ZXh0byBkZSBleGVjdcOnw6NvIGRhIHJlcXVpc2nDp8Ojb1xuICAgKiBAcmV0dXJucyB0cnVlIHNlIGF1dG9yaXphZG8sIGxhbsOnYSBleGNlw6fDo28gY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBjYW5BY3RpdmF0ZShjb250ZXh0OiBFeGVjdXRpb25Db250ZXh0KTogYm9vbGVhbiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGNvbnRleHQuc3dpdGNoVG9IdHRwKCkuZ2V0UmVxdWVzdDxSZXF1ZXN0PigpO1xuXG4gICAgLy8gVGVudGEgb2J0ZXIgbyB0b2tlbiBkbyBxdWVyeSBwYXJhbWV0ZXIgb3UgaGVhZGVyIEF1dGhvcml6YXRpb25cbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuZXh0cmFjdFRva2VuKHJlcXVlc3QpO1xuXG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignVGVudGF0aXZhIGRlIGNvbmV4w6NvIFNTRSBzZW0gdG9rZW4gZGUgYWNlc3NvJyk7XG4gICAgICB0aHJvdyBuZXcgVW5hdXRob3JpemVkRXhjZXB0aW9uKFxuICAgICAgICAnVG9rZW4gZGUgYWNlc3NvIG9icmlnYXTDs3JpbyBwYXJhIGNvbmV4w7VlcyBTU0UnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gVmVyaWZpY2EgZSBkZWNvZGlmaWNhIG8gdG9rZW4gSldUXG4gICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5qd3RTZXJ2aWNlLnZlcmlmeSh0b2tlbik7XG5cbiAgICAgIC8vIEFkaWNpb25hIG9zIGRhZG9zIGRvIHVzdcOhcmlvIMOgIHJlcXVpc2nDp8Ojb1xuICAgICAgcmVxdWVzdFsndXNlciddID0ge1xuICAgICAgICBpZDogcGF5bG9hZC5zdWIgfHwgcGF5bG9hZC5pZCxcbiAgICAgICAgZW1haWw6IHBheWxvYWQuZW1haWwsXG4gICAgICAgIHJvbGVzOiBwYXlsb2FkLnJvbGVzIHx8IFtdLFxuICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgIGBDb25leMOjbyBTU0UgYXV0b3JpemFkYSBwYXJhIHVzdcOhcmlvOiAke3JlcXVlc3RbJ3VzZXInXS5pZH1gLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBUb2tlbiBTU0UgaW52w6FsaWRvOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG5cbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnVG9rZW5FeHBpcmVkRXJyb3InKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmF1dGhvcml6ZWRFeGNlcHRpb24oXG4gICAgICAgICAgJ1Rva2VuIGV4cGlyYWRvLiBGYcOnYSBsb2dpbiBub3ZhbWVudGUuJyxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdKc29uV2ViVG9rZW5FcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEV4Y2VwdGlvbignVG9rZW4gaW52w6FsaWRvIG91IG1hbGZvcm1hZG8uJyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBVbmF1dGhvcml6ZWRFeGNlcHRpb24oJ0ZhbGhhIG5hIGF1dGVudGljYcOnw6NvIGRvIHRva2VuLicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWkgbyB0b2tlbiBKV1QgZGEgcmVxdWlzacOnw6NvXG4gICAqIEBwYXJhbSByZXF1ZXN0IE9iamV0byBkYSByZXF1aXNpw6fDo28gSFRUUFxuICAgKiBAcmV0dXJucyBUb2tlbiBKV1Qgb3UgbnVsbCBzZSBuw6NvIGVuY29udHJhZG9cbiAgICovXG4gIHByaXZhdGUgZXh0cmFjdFRva2VuKHJlcXVlc3Q6IFJlcXVlc3QpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAvLyBQcmltZWlybyB0ZW50YSBvYnRlciBkbyBxdWVyeSBwYXJhbWV0ZXIgJ3Rva2VuJ1xuICAgIGNvbnN0IHF1ZXJ5VG9rZW4gPSByZXF1ZXN0LnF1ZXJ5LnRva2VuIGFzIHN0cmluZztcbiAgICBpZiAocXVlcnlUb2tlbikge1xuICAgICAgcmV0dXJuIHF1ZXJ5VG9rZW47XG4gICAgfVxuXG4gICAgLy8gRGVwb2lzIHRlbnRhIG9idGVyIGRvIGhlYWRlciBBdXRob3JpemF0aW9uXG4gICAgY29uc3QgYXV0aEhlYWRlciA9IHJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICAgIGlmIChhdXRoSGVhZGVyICYmIGF1dGhIZWFkZXIuc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICByZXR1cm4gYXV0aEhlYWRlci5zdWJzdHJpbmcoNyk7XG4gICAgfVxuXG4gICAgLy8gVGVudGEgb2J0ZXIgZGUgdW0gY29va2llIChzZSBjb25maWd1cmFkbylcbiAgICBjb25zdCBjb29raWVUb2tlbiA9IHJlcXVlc3QuY29va2llcz8uWydhY2Nlc3NfdG9rZW4nXTtcbiAgICBpZiAoY29va2llVG9rZW4pIHtcbiAgICAgIHJldHVybiBjb29raWVUb2tlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9