{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\metricas\\services\\metricas-definicao.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\metricas\\services\\metricas-definicao.service.ts"],"sourcesContent":["import {\n  Injectable,\n  Logger,\n  NotFoundException,\n  BadRequestException,\n} from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, Like, FindOptionsWhere, Not, IsNull } from 'typeorm';\nimport { EventEmitter2 } from '@nestjs/event-emitter';\n\nimport {\n  MetricaDefinicao,\n  CategoriaMetrica,\n  TipoMetrica,\n} from '../../../entities/metrica-definicao.entity';\nimport { MetricaConfiguracao } from '../../../entities/metrica-configuracao.entity';\nimport { MetricaSnapshot } from '../../../entities/metrica-snapshot.entity';\nimport {\n  CriarMetricaDefinicaoDto,\n  AtualizarMetricaDefinicaoDto,\n  FiltroMetricasDto,\n} from '../dto/metrica-definicao.dto';\nimport {\n  CriarMetricaConfiguracaoDto,\n  AtualizarMetricaConfiguracaoDto,\n} from '../dto/metrica-configuracao.dto';\nimport { MetricasCacheService } from './metricas-cache.service';\n\n/**\n * Serviço responsável pelo gerenciamento de definições de métricas\n *\n * Este serviço gerencia o ciclo de vida das definições de métricas,\n * incluindo criação, atualização, consulta e remoção.\n */\n@Injectable()\nexport class MetricasService {\n  private readonly logger = new Logger(MetricasService.name);\n\n  constructor(\n    @InjectRepository(MetricaDefinicao)\n    private readonly metricaDefinicaoRepository: Repository<MetricaDefinicao>,\n\n    @InjectRepository(MetricaConfiguracao)\n    private readonly metricaConfiguracaoRepository: Repository<MetricaConfiguracao>,\n\n    @InjectRepository(MetricaSnapshot)\n    private readonly metricaSnapshotRepository: Repository<MetricaSnapshot>,\n\n    private readonly cacheService: MetricasCacheService,\n    private readonly eventEmitter: EventEmitter2,\n  ) {}\n\n  /**\n   * Cria uma nova definição de métrica\n   *\n   * @param dto Dados da métrica a ser criada\n   * @param usuarioId ID do usuário que está criando a métrica\n   * @param usuarioNome Nome do usuário que está criando a métrica\n   * @returns Métrica criada\n   */\n  async criarMetrica(\n    dto: CriarMetricaDefinicaoDto,\n    usuarioId: string,\n    usuarioNome: string,\n  ): Promise<MetricaDefinicao> {\n    this.logger.log(`Criando métrica: ${dto.codigo}`);\n\n    // Verificar se já existe métrica com o mesmo código\n    const metricaExistente = await this.metricaDefinicaoRepository.findOne({\n      where: { codigo: dto.codigo },\n    });\n\n    if (metricaExistente) {\n      throw new BadRequestException(\n        `Já existe uma métrica com o código '${dto.codigo}'`,\n      );\n    }\n\n    // Validar configurações específicas para cada tipo de métrica\n    await this.validarDadosMetrica(dto);\n\n    // Criar nova métrica\n    const metrica = this.metricaDefinicaoRepository.create({\n      ...dto,\n      versao: 1,\n      criado_por: `${usuarioNome} (${usuarioId})`,\n      atualizado_por: `${usuarioNome} (${usuarioId})`,\n    });\n\n    // Salvar métrica\n    const metricaSalva = await this.metricaDefinicaoRepository.save(metrica);\n\n    // Emitir evento para notificar criação da métrica\n    this.eventEmitter.emit('metrica.criada', {\n      metrica_id: metricaSalva.id,\n      metrica_codigo: metricaSalva.codigo,\n      usuario_id: usuarioId,\n    });\n\n    this.logger.log(\n      `Métrica criada com sucesso: ${metricaSalva.codigo} (ID: ${metricaSalva.id})`,\n    );\n\n    return metricaSalva;\n  }\n\n  /**\n   * Atualiza uma definição de métrica existente\n   *\n   * @param id ID da métrica a ser atualizada\n   * @param dto Dados para atualização\n   * @param usuarioId ID do usuário que está atualizando a métrica\n   * @param usuarioNome Nome do usuário que está atualizando a métrica\n   * @returns Métrica atualizada\n   */\n  async atualizarMetrica(\n    id: string,\n    dto: AtualizarMetricaDefinicaoDto,\n    usuarioId: string,\n    usuarioNome: string,\n  ): Promise<MetricaDefinicao> {\n    this.logger.log(`Atualizando métrica com ID: ${id}`);\n\n    // Buscar métrica existente\n    const metrica = await this.metricaDefinicaoRepository.findOne({\n      where: { id },\n    });\n\n    if (!metrica) {\n      throw new NotFoundException(`Métrica com ID ${id} não encontrada`);\n    }\n\n    // Verificar se está tentando alterar o tipo da métrica\n    if (dto.tipo && dto.tipo !== metrica.tipo) {\n      // Verificar se já existem snapshots para esta métrica\n      const countSnapshots = await this.metricaSnapshotRepository.count({\n        where: { definicao_id: id },\n      });\n\n      if (countSnapshots > 0) {\n        throw new BadRequestException(\n          'Não é possível alterar o tipo de uma métrica que já possui valores coletados',\n        );\n      }\n    }\n\n    // Combinar dados atuais com atualizações\n    const metricaAtualizada = {\n      ...metrica,\n      ...dto,\n      versao: metrica.versao + 1,\n      atualizado_por: `${usuarioNome} (${usuarioId})`,\n    };\n\n    // Validar configurações específicas para cada tipo de métrica\n    await this.validarDadosMetrica(metricaAtualizada);\n\n    // Salvar métrica atualizada\n    const resultado =\n      await this.metricaDefinicaoRepository.save(metricaAtualizada);\n\n    // Invalidar cache da métrica\n    this.cacheService.invalidarCacheMetrica(id);\n\n    // Emitir evento para notificar atualização da métrica\n    this.eventEmitter.emit('metrica.atualizada', {\n      metrica_id: resultado.id,\n      metrica_codigo: resultado.codigo,\n      usuario_id: usuarioId,\n    });\n\n    this.logger.log(\n      `Métrica atualizada com sucesso: ${resultado.codigo} (ID: ${resultado.id})`,\n    );\n\n    return resultado;\n  }\n\n  /**\n   * Busca uma métrica pelo ID\n   *\n   * @param id ID da métrica\n   * @returns Métrica encontrada ou null\n   */\n  async buscarMetricaPorId(id: string): Promise<MetricaDefinicao> {\n    const metrica = await this.metricaDefinicaoRepository.findOne({\n      where: { id },\n      relations: ['configuracoes'],\n    });\n\n    if (!metrica) {\n      throw new NotFoundException(`Métrica com ID ${id} não encontrada`);\n    }\n\n    return metrica;\n  }\n\n  /**\n   * Busca uma métrica pelo código\n   *\n   * @param codigo Código da métrica\n   * @returns Métrica encontrada ou null\n   */\n  async buscarMetricaPorCodigo(\n    codigo: string,\n  ): Promise<MetricaDefinicao | null> {\n    return this.cacheService.obterMetrica(codigo);\n  }\n\n  /**\n   * Lista métricas com filtros e paginação\n   *\n   * @param filtros Filtros para busca\n   * @returns Lista paginada de métricas\n   */\n  async listarMetricas(\n    filtros: FiltroMetricasDto,\n  ): Promise<{ items: MetricaDefinicao[]; total: number }> {\n    const pagina = filtros.pagina || 1;\n    const limite = filtros.limite || 10;\n    const skip = (pagina - 1) * limite;\n\n    // Construir condições de busca\n    const where: FindOptionsWhere<MetricaDefinicao> = {};\n\n    if (filtros.codigo) {\n      where.codigo = Like(`%${filtros.codigo}%`);\n    }\n\n    if (filtros.nome) {\n      where.nome = Like(`%${filtros.nome}%`);\n    }\n\n    if (filtros.categoria) {\n      where.categoria = filtros.categoria;\n    }\n\n    if (filtros.tipo) {\n      where.tipo = filtros.tipo;\n    }\n\n    if (filtros.ativa !== undefined) {\n      where.ativa = filtros.ativa;\n    }\n\n    if (filtros.tag) {\n      // Filtrar por tag (equivalente a \"tags LIKE '%tag%'\")\n      // Implementação simplificada, em um cenário real seria melhor usar uma abordagem específica do banco de dados\n      where.tags = Like(`%${filtros.tag}%`);\n    }\n\n    // Buscar total de registros\n    const total = await this.metricaDefinicaoRepository.count({ where });\n\n    // Buscar métricas\n    const items = await this.metricaDefinicaoRepository.find({\n      where,\n      order: {\n        codigo: 'ASC',\n      },\n      skip,\n      take: limite,\n    });\n\n    return { items, total };\n  }\n\n  /**\n   * Remove uma métrica (exclusão lógica)\n   *\n   * @param id ID da métrica a ser removida\n   */\n  async removerMetrica(id: string): Promise<void> {\n    this.logger.log(`Removendo métrica com ID: ${id}`);\n\n    // Buscar métrica existente\n    const metrica = await this.metricaDefinicaoRepository.findOne({\n      where: { id },\n    });\n\n    if (!metrica) {\n      throw new NotFoundException(`Métrica com ID ${id} não encontrada`);\n    }\n\n    // Inativar métrica (exclusão lógica)\n    await this.metricaDefinicaoRepository.update(id, {\n      ativa: false,\n    });\n\n    // Invalidar cache da métrica\n    this.cacheService.invalidarCacheMetrica(id);\n\n    // Emitir evento para notificar remoção da métrica\n    this.eventEmitter.emit('metrica.removida', {\n      metrica_id: id,\n      metrica_codigo: metrica.codigo,\n    });\n\n    this.logger.log(\n      `Métrica removida com sucesso: ${metrica.codigo} (ID: ${id})`,\n    );\n  }\n\n  /**\n   * Cria configuração para uma métrica\n   *\n   * @param dto Dados da configuração\n   * @param usuarioId ID do usuário que está criando a configuração\n   * @param usuarioNome Nome do usuário que está criando a configuração\n   * @returns Configuração criada\n   */\n  async criarConfiguracao(\n    dto: CriarMetricaConfiguracaoDto,\n    usuarioId: string,\n    usuarioNome: string,\n  ): Promise<MetricaConfiguracao> {\n    this.logger.log(`Criando configuração para métrica: ${dto.metrica_id}`);\n\n    // Verificar se a métrica existe\n    const metrica = await this.metricaDefinicaoRepository.findOne({\n      where: { id: dto.metrica_id },\n    });\n\n    if (!metrica) {\n      throw new NotFoundException(\n        `Métrica com ID ${dto.metrica_id} não encontrada`,\n      );\n    }\n\n    // Verificar se já existe configuração para esta métrica\n    const configExistente = await this.metricaConfiguracaoRepository.findOne({\n      where: { metrica_id: dto.metrica_id },\n    });\n\n    if (configExistente) {\n      throw new BadRequestException(\n        `Já existe uma configuração para a métrica ${metrica.codigo}. Use a atualização.`,\n      );\n    }\n\n    // Validar configurações específicas para cada tipo de agendamento\n    await this.validarDadosConfiguracao(dto);\n\n    // Criar nova configuração\n    const config = this.metricaConfiguracaoRepository.create({\n      ...dto,\n      criado_por: `${usuarioNome} (${usuarioId})`,\n      atualizado_por: `${usuarioNome} (${usuarioId})`,\n    });\n\n    // Salvar configuração\n    const configSalva = await this.metricaConfiguracaoRepository.save(config);\n\n    // Emitir evento para notificar criação da configuração\n    this.eventEmitter.emit('metrica.configuracao.criada', {\n      metrica_id: dto.metrica_id,\n      configuracao_id: configSalva.id,\n      usuario_id: usuarioId,\n    });\n\n    this.logger.log(\n      `Configuração criada com sucesso para métrica: ${metrica.codigo}`,\n    );\n\n    return configSalva;\n  }\n\n  /**\n   * Atualiza configuração de uma métrica\n   *\n   * @param id ID da configuração a ser atualizada\n   * @param dto Dados para atualização\n   * @param usuarioId ID do usuário que está atualizando a configuração\n   * @param usuarioNome Nome do usuário que está atualizando a configuração\n   * @returns Configuração atualizada\n   */\n  async atualizarConfiguracao(\n    id: string,\n    dto: AtualizarMetricaConfiguracaoDto,\n    usuarioId: string,\n    usuarioNome: string,\n  ): Promise<MetricaConfiguracao> {\n    this.logger.log(`Atualizando configuração com ID: ${id}`);\n\n    // Buscar configuração existente\n    const config = await this.metricaConfiguracaoRepository.findOne({\n      where: { id },\n      relations: ['metrica'],\n    });\n\n    if (!config) {\n      throw new NotFoundException(`Configuração com ID ${id} não encontrada`);\n    }\n\n    // Combinar dados atuais com atualizações\n    const configAtualizada = {\n      ...config,\n      ...dto,\n      atualizado_por: `${usuarioNome} (${usuarioId})`,\n    };\n\n    // Validar configurações específicas para cada tipo de agendamento\n    await this.validarDadosConfiguracao(configAtualizada);\n\n    // Salvar configuração atualizada\n    const resultado =\n      await this.metricaConfiguracaoRepository.save(configAtualizada);\n\n    // Invalidar cache da métrica\n    this.cacheService.invalidarCacheMetrica(config.metrica_id);\n\n    // Emitir evento para notificar atualização da configuração\n    this.eventEmitter.emit('metrica.configuracao.atualizada', {\n      metrica_id: config.metrica_id,\n      configuracao_id: resultado.id,\n      usuario_id: usuarioId,\n    });\n\n    // Carregar a entidade metrica para acessar suas propriedades, se disponível\n    let codigoMetrica = config.metrica_id;\n    if (config.metrica) {\n      const metrica = await config.metrica;\n      codigoMetrica = metrica.codigo || config.metrica_id;\n    }\n\n    this.logger.log(\n      `Configuração atualizada com sucesso para métrica: ${codigoMetrica}`,\n    );\n\n    return resultado;\n  }\n\n  /**\n   * Busca configuração de uma métrica\n   *\n   * @param metricaId ID da métrica\n   * @returns Configuração encontrada ou null\n   */\n  async buscarConfiguracaoPorMetrica(\n    metricaId: string,\n  ): Promise<MetricaConfiguracao> {\n    const config = await this.metricaConfiguracaoRepository.findOne({\n      where: { metrica_id: metricaId },\n      relations: ['metrica'],\n    });\n\n    if (!config) {\n      throw new NotFoundException(\n        `Configuração para métrica ${metricaId} não encontrada`,\n      );\n    }\n\n    return config;\n  }\n\n  /**\n   * Valida dados específicos para cada tipo de métrica\n   *\n   * @param metrica Dados da métrica a ser validada\n   */\n  private async validarDadosMetrica(\n    metrica: CriarMetricaDefinicaoDto | MetricaDefinicao,\n  ): Promise<void> {\n    // Validar formato do código (snake_case)\n    const codigoRegex = /^[a-z][a-z0-9_]*$/;\n    if (!codigoRegex.test(metrica.codigo)) {\n      throw new BadRequestException(\n        'Código da métrica deve estar em formato snake_case (apenas letras minúsculas, números e underscore)',\n      );\n    }\n\n    switch (metrica.tipo) {\n      case TipoMetrica.CONTAGEM:\n      case TipoMetrica.SOMA:\n      case TipoMetrica.MEDIA:\n      case TipoMetrica.MINIMO:\n      case TipoMetrica.MAXIMO:\n      case TipoMetrica.CARDINALIDADE:\n        // Validar consulta SQL\n        if (!metrica.sql_consulta) {\n          throw new BadRequestException(\n            `Métricas do tipo ${metrica.tipo} requerem uma consulta SQL`,\n          );\n        }\n        break;\n\n      case TipoMetrica.PERCENTIL:\n        // Validar consulta SQL e parâmetro de percentil\n        if (!metrica.sql_consulta) {\n          throw new BadRequestException(\n            'Métricas do tipo PERCENTIL requerem uma consulta SQL',\n          );\n        }\n\n        if (!metrica.parametros_especificos?.percentil) {\n          throw new BadRequestException(\n            'Métricas do tipo PERCENTIL requerem o parâmetro \"percentil\" (ex: 95)',\n          );\n        }\n\n        const percentil = Number(metrica.parametros_especificos.percentil);\n        if (isNaN(percentil) || percentil < 0 || percentil > 100) {\n          throw new BadRequestException(\n            'O valor do percentil deve ser um número entre 0 e 100',\n          );\n        }\n        break;\n\n      case TipoMetrica.COMPOSTA:\n        // Validar fórmula e métricas dependentes\n        if (!metrica.formula_calculo) {\n          throw new BadRequestException(\n            'Métricas do tipo COMPOSTA requerem uma fórmula de cálculo',\n          );\n        }\n\n        if (\n          !metrica.metricas_dependentes ||\n          metrica.metricas_dependentes.length === 0\n        ) {\n          throw new BadRequestException(\n            'Métricas do tipo COMPOSTA requerem a definição de métricas dependentes',\n          );\n        }\n\n        // Verificar se as métricas dependentes existem\n        for (const codigoDependente of metrica.metricas_dependentes) {\n          // Ignorar a própria métrica sendo editada\n          if (codigoDependente === metrica.codigo) {\n            continue;\n          }\n\n          const dependente = await this.metricaDefinicaoRepository.findOne({\n            where: { codigo: codigoDependente },\n          });\n\n          if (!dependente) {\n            throw new BadRequestException(\n              `Métrica dependente '${codigoDependente}' não encontrada`,\n            );\n          }\n        }\n        break;\n\n      case TipoMetrica.TAXA_VARIACAO:\n        // Validar consulta SQL\n        if (!metrica.sql_consulta) {\n          throw new BadRequestException(\n            'Métricas do tipo TAXA_VARIACAO requerem uma consulta SQL',\n          );\n        }\n        break;\n\n      default:\n        throw new BadRequestException(\n          `Tipo de métrica não suportado: ${metrica.tipo}`,\n        );\n    }\n  }\n\n  /**\n   * Valida dados específicos para cada tipo de agendamento\n   *\n   * @param config Dados da configuração a ser validada\n   */\n  private async validarDadosConfiguracao(\n    config: CriarMetricaConfiguracaoDto | MetricaConfiguracao,\n  ): Promise<void> {\n    if (config.tipo_agendamento === 'cron' && !config.expressao_cron) {\n      throw new BadRequestException(\n        'Agendamento do tipo CRON requer a definição de uma expressão cron',\n      );\n    }\n\n    if (config.tipo_agendamento === 'evento' && !config.nome_evento) {\n      throw new BadRequestException(\n        'Agendamento do tipo EVENTO requer a definição do nome do evento',\n      );\n    }\n\n    if (\n      config.estrategia_amostragem !== 'completa' &&\n      !config.tamanho_amostra\n    ) {\n      throw new BadRequestException(\n        `Estratégia de amostragem '${config.estrategia_amostragem}' requer a definição do tamanho da amostra`,\n      );\n    }\n\n    // Validar alertas\n    if (config.alertas && config.alertas.length > 0) {\n      for (const alerta of config.alertas) {\n        if (!alerta.tipo) {\n          throw new BadRequestException(\n            'Cada alerta deve ter um tipo definido',\n          );\n        }\n\n        if (alerta.valor === undefined || alerta.valor === null) {\n          throw new BadRequestException(\n            `Alerta do tipo '${alerta.tipo}' requer um valor de referência`,\n          );\n        }\n\n        if (!alerta.severidade) {\n          throw new BadRequestException(\n            `Alerta do tipo '${alerta.tipo}' requer uma severidade definida`,\n          );\n        }\n      }\n    }\n  }\n}\n"],"version":3}