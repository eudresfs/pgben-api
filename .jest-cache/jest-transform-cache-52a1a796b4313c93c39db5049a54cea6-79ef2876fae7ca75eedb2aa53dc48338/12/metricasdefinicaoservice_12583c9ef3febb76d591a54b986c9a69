17b5725f5b5df4da609aad59d1876cc8
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MetricasService_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricasService = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const event_emitter_1 = require("@nestjs/event-emitter");
const metrica_definicao_entity_1 = require("../../../entities/metrica-definicao.entity");
const metrica_configuracao_entity_1 = require("../../../entities/metrica-configuracao.entity");
const metrica_snapshot_entity_1 = require("../../../entities/metrica-snapshot.entity");
const metricas_cache_service_1 = require("./metricas-cache.service");
/**
 * Serviço responsável pelo gerenciamento de definições de métricas
 *
 * Este serviço gerencia o ciclo de vida das definições de métricas,
 * incluindo criação, atualização, consulta e remoção.
 */
let MetricasService = MetricasService_1 = class MetricasService {
    metricaDefinicaoRepository;
    metricaConfiguracaoRepository;
    metricaSnapshotRepository;
    cacheService;
    eventEmitter;
    logger = new common_1.Logger(MetricasService_1.name);
    constructor(metricaDefinicaoRepository, metricaConfiguracaoRepository, metricaSnapshotRepository, cacheService, eventEmitter) {
        this.metricaDefinicaoRepository = metricaDefinicaoRepository;
        this.metricaConfiguracaoRepository = metricaConfiguracaoRepository;
        this.metricaSnapshotRepository = metricaSnapshotRepository;
        this.cacheService = cacheService;
        this.eventEmitter = eventEmitter;
    }
    /**
     * Cria uma nova definição de métrica
     *
     * @param dto Dados da métrica a ser criada
     * @param usuarioId ID do usuário que está criando a métrica
     * @param usuarioNome Nome do usuário que está criando a métrica
     * @returns Métrica criada
     */
    async criarMetrica(dto, usuarioId, usuarioNome) {
        this.logger.log(`Criando métrica: ${dto.codigo}`);
        // Verificar se já existe métrica com o mesmo código
        const metricaExistente = await this.metricaDefinicaoRepository.findOne({
            where: { codigo: dto.codigo },
        });
        if (metricaExistente) {
            throw new common_1.BadRequestException(`Já existe uma métrica com o código '${dto.codigo}'`);
        }
        // Validar configurações específicas para cada tipo de métrica
        await this.validarDadosMetrica(dto);
        // Criar nova métrica
        const metrica = this.metricaDefinicaoRepository.create({
            ...dto,
            versao: 1,
            criado_por: `${usuarioNome} (${usuarioId})`,
            atualizado_por: `${usuarioNome} (${usuarioId})`,
        });
        // Salvar métrica
        const metricaSalva = await this.metricaDefinicaoRepository.save(metrica);
        // Emitir evento para notificar criação da métrica
        this.eventEmitter.emit('metrica.criada', {
            metrica_id: metricaSalva.id,
            metrica_codigo: metricaSalva.codigo,
            usuario_id: usuarioId,
        });
        this.logger.log(`Métrica criada com sucesso: ${metricaSalva.codigo} (ID: ${metricaSalva.id})`);
        return metricaSalva;
    }
    /**
     * Atualiza uma definição de métrica existente
     *
     * @param id ID da métrica a ser atualizada
     * @param dto Dados para atualização
     * @param usuarioId ID do usuário que está atualizando a métrica
     * @param usuarioNome Nome do usuário que está atualizando a métrica
     * @returns Métrica atualizada
     */
    async atualizarMetrica(id, dto, usuarioId, usuarioNome) {
        this.logger.log(`Atualizando métrica com ID: ${id}`);
        // Buscar métrica existente
        const metrica = await this.metricaDefinicaoRepository.findOne({
            where: { id },
        });
        if (!metrica) {
            throw new common_1.NotFoundException(`Métrica com ID ${id} não encontrada`);
        }
        // Verificar se está tentando alterar o tipo da métrica
        if (dto.tipo && dto.tipo !== metrica.tipo) {
            // Verificar se já existem snapshots para esta métrica
            const countSnapshots = await this.metricaSnapshotRepository.count({
                where: { definicao_id: id },
            });
            if (countSnapshots > 0) {
                throw new common_1.BadRequestException('Não é possível alterar o tipo de uma métrica que já possui valores coletados');
            }
        }
        // Combinar dados atuais com atualizações
        const metricaAtualizada = {
            ...metrica,
            ...dto,
            versao: metrica.versao + 1,
            atualizado_por: `${usuarioNome} (${usuarioId})`,
        };
        // Validar configurações específicas para cada tipo de métrica
        await this.validarDadosMetrica(metricaAtualizada);
        // Salvar métrica atualizada
        const resultado = await this.metricaDefinicaoRepository.save(metricaAtualizada);
        // Invalidar cache da métrica
        this.cacheService.invalidarCacheMetrica(id);
        // Emitir evento para notificar atualização da métrica
        this.eventEmitter.emit('metrica.atualizada', {
            metrica_id: resultado.id,
            metrica_codigo: resultado.codigo,
            usuario_id: usuarioId,
        });
        this.logger.log(`Métrica atualizada com sucesso: ${resultado.codigo} (ID: ${resultado.id})`);
        return resultado;
    }
    /**
     * Busca uma métrica pelo ID
     *
     * @param id ID da métrica
     * @returns Métrica encontrada ou null
     */
    async buscarMetricaPorId(id) {
        const metrica = await this.metricaDefinicaoRepository.findOne({
            where: { id },
            relations: ['configuracoes'],
        });
        if (!metrica) {
            throw new common_1.NotFoundException(`Métrica com ID ${id} não encontrada`);
        }
        return metrica;
    }
    /**
     * Busca uma métrica pelo código
     *
     * @param codigo Código da métrica
     * @returns Métrica encontrada ou null
     */
    async buscarMetricaPorCodigo(codigo) {
        return this.cacheService.obterMetrica(codigo);
    }
    /**
     * Lista métricas com filtros e paginação
     *
     * @param filtros Filtros para busca
     * @returns Lista paginada de métricas
     */
    async listarMetricas(filtros) {
        const pagina = filtros.pagina || 1;
        const limite = filtros.limite || 10;
        const skip = (pagina - 1) * limite;
        // Construir condições de busca
        const where = {};
        if (filtros.codigo) {
            where.codigo = (0, typeorm_2.Like)(`%${filtros.codigo}%`);
        }
        if (filtros.nome) {
            where.nome = (0, typeorm_2.Like)(`%${filtros.nome}%`);
        }
        if (filtros.categoria) {
            where.categoria = filtros.categoria;
        }
        if (filtros.tipo) {
            where.tipo = filtros.tipo;
        }
        if (filtros.ativa !== undefined) {
            where.ativa = filtros.ativa;
        }
        if (filtros.tag) {
            // Filtrar por tag (equivalente a "tags LIKE '%tag%'")
            // Implementação simplificada, em um cenário real seria melhor usar uma abordagem específica do banco de dados
            where.tags = (0, typeorm_2.Like)(`%${filtros.tag}%`);
        }
        // Buscar total de registros
        const total = await this.metricaDefinicaoRepository.count({ where });
        // Buscar métricas
        const items = await this.metricaDefinicaoRepository.find({
            where,
            order: {
                codigo: 'ASC',
            },
            skip,
            take: limite,
        });
        return { items, total };
    }
    /**
     * Remove uma métrica (exclusão lógica)
     *
     * @param id ID da métrica a ser removida
     */
    async removerMetrica(id) {
        this.logger.log(`Removendo métrica com ID: ${id}`);
        // Buscar métrica existente
        const metrica = await this.metricaDefinicaoRepository.findOne({
            where: { id },
        });
        if (!metrica) {
            throw new common_1.NotFoundException(`Métrica com ID ${id} não encontrada`);
        }
        // Inativar métrica (exclusão lógica)
        await this.metricaDefinicaoRepository.update(id, {
            ativa: false,
        });
        // Invalidar cache da métrica
        this.cacheService.invalidarCacheMetrica(id);
        // Emitir evento para notificar remoção da métrica
        this.eventEmitter.emit('metrica.removida', {
            metrica_id: id,
            metrica_codigo: metrica.codigo,
        });
        this.logger.log(`Métrica removida com sucesso: ${metrica.codigo} (ID: ${id})`);
    }
    /**
     * Cria configuração para uma métrica
     *
     * @param dto Dados da configuração
     * @param usuarioId ID do usuário que está criando a configuração
     * @param usuarioNome Nome do usuário que está criando a configuração
     * @returns Configuração criada
     */
    async criarConfiguracao(dto, usuarioId, usuarioNome) {
        this.logger.log(`Criando configuração para métrica: ${dto.metrica_id}`);
        // Verificar se a métrica existe
        const metrica = await this.metricaDefinicaoRepository.findOne({
            where: { id: dto.metrica_id },
        });
        if (!metrica) {
            throw new common_1.NotFoundException(`Métrica com ID ${dto.metrica_id} não encontrada`);
        }
        // Verificar se já existe configuração para esta métrica
        const configExistente = await this.metricaConfiguracaoRepository.findOne({
            where: { metrica_id: dto.metrica_id },
        });
        if (configExistente) {
            throw new common_1.BadRequestException(`Já existe uma configuração para a métrica ${metrica.codigo}. Use a atualização.`);
        }
        // Validar configurações específicas para cada tipo de agendamento
        await this.validarDadosConfiguracao(dto);
        // Criar nova configuração
        const config = this.metricaConfiguracaoRepository.create({
            ...dto,
            criado_por: `${usuarioNome} (${usuarioId})`,
            atualizado_por: `${usuarioNome} (${usuarioId})`,
        });
        // Salvar configuração
        const configSalva = await this.metricaConfiguracaoRepository.save(config);
        // Emitir evento para notificar criação da configuração
        this.eventEmitter.emit('metrica.configuracao.criada', {
            metrica_id: dto.metrica_id,
            configuracao_id: configSalva.id,
            usuario_id: usuarioId,
        });
        this.logger.log(`Configuração criada com sucesso para métrica: ${metrica.codigo}`);
        return configSalva;
    }
    /**
     * Atualiza configuração de uma métrica
     *
     * @param id ID da configuração a ser atualizada
     * @param dto Dados para atualização
     * @param usuarioId ID do usuário que está atualizando a configuração
     * @param usuarioNome Nome do usuário que está atualizando a configuração
     * @returns Configuração atualizada
     */
    async atualizarConfiguracao(id, dto, usuarioId, usuarioNome) {
        this.logger.log(`Atualizando configuração com ID: ${id}`);
        // Buscar configuração existente
        const config = await this.metricaConfiguracaoRepository.findOne({
            where: { id },
            relations: ['metrica'],
        });
        if (!config) {
            throw new common_1.NotFoundException(`Configuração com ID ${id} não encontrada`);
        }
        // Combinar dados atuais com atualizações
        const configAtualizada = {
            ...config,
            ...dto,
            atualizado_por: `${usuarioNome} (${usuarioId})`,
        };
        // Validar configurações específicas para cada tipo de agendamento
        await this.validarDadosConfiguracao(configAtualizada);
        // Salvar configuração atualizada
        const resultado = await this.metricaConfiguracaoRepository.save(configAtualizada);
        // Invalidar cache da métrica
        this.cacheService.invalidarCacheMetrica(config.metrica_id);
        // Emitir evento para notificar atualização da configuração
        this.eventEmitter.emit('metrica.configuracao.atualizada', {
            metrica_id: config.metrica_id,
            configuracao_id: resultado.id,
            usuario_id: usuarioId,
        });
        // Carregar a entidade metrica para acessar suas propriedades, se disponível
        let codigoMetrica = config.metrica_id;
        if (config.metrica) {
            const metrica = await config.metrica;
            codigoMetrica = metrica.codigo || config.metrica_id;
        }
        this.logger.log(`Configuração atualizada com sucesso para métrica: ${codigoMetrica}`);
        return resultado;
    }
    /**
     * Busca configuração de uma métrica
     *
     * @param metricaId ID da métrica
     * @returns Configuração encontrada ou null
     */
    async buscarConfiguracaoPorMetrica(metricaId) {
        const config = await this.metricaConfiguracaoRepository.findOne({
            where: { metrica_id: metricaId },
            relations: ['metrica'],
        });
        if (!config) {
            throw new common_1.NotFoundException(`Configuração para métrica ${metricaId} não encontrada`);
        }
        return config;
    }
    /**
     * Valida dados específicos para cada tipo de métrica
     *
     * @param metrica Dados da métrica a ser validada
     */
    async validarDadosMetrica(metrica) {
        // Validar formato do código (snake_case)
        const codigoRegex = /^[a-z][a-z0-9_]*$/;
        if (!codigoRegex.test(metrica.codigo)) {
            throw new common_1.BadRequestException('Código da métrica deve estar em formato snake_case (apenas letras minúsculas, números e underscore)');
        }
        switch (metrica.tipo) {
            case metrica_definicao_entity_1.TipoMetrica.CONTAGEM:
            case metrica_definicao_entity_1.TipoMetrica.SOMA:
            case metrica_definicao_entity_1.TipoMetrica.MEDIA:
            case metrica_definicao_entity_1.TipoMetrica.MINIMO:
            case metrica_definicao_entity_1.TipoMetrica.MAXIMO:
            case metrica_definicao_entity_1.TipoMetrica.CARDINALIDADE:
                // Validar consulta SQL
                if (!metrica.sql_consulta) {
                    throw new common_1.BadRequestException(`Métricas do tipo ${metrica.tipo} requerem uma consulta SQL`);
                }
                break;
            case metrica_definicao_entity_1.TipoMetrica.PERCENTIL:
                // Validar consulta SQL e parâmetro de percentil
                if (!metrica.sql_consulta) {
                    throw new common_1.BadRequestException('Métricas do tipo PERCENTIL requerem uma consulta SQL');
                }
                if (!metrica.parametros_especificos?.percentil) {
                    throw new common_1.BadRequestException('Métricas do tipo PERCENTIL requerem o parâmetro "percentil" (ex: 95)');
                }
                const percentil = Number(metrica.parametros_especificos.percentil);
                if (isNaN(percentil) || percentil < 0 || percentil > 100) {
                    throw new common_1.BadRequestException('O valor do percentil deve ser um número entre 0 e 100');
                }
                break;
            case metrica_definicao_entity_1.TipoMetrica.COMPOSTA:
                // Validar fórmula e métricas dependentes
                if (!metrica.formula_calculo) {
                    throw new common_1.BadRequestException('Métricas do tipo COMPOSTA requerem uma fórmula de cálculo');
                }
                if (!metrica.metricas_dependentes ||
                    metrica.metricas_dependentes.length === 0) {
                    throw new common_1.BadRequestException('Métricas do tipo COMPOSTA requerem a definição de métricas dependentes');
                }
                // Verificar se as métricas dependentes existem
                for (const codigoDependente of metrica.metricas_dependentes) {
                    // Ignorar a própria métrica sendo editada
                    if (codigoDependente === metrica.codigo) {
                        continue;
                    }
                    const dependente = await this.metricaDefinicaoRepository.findOne({
                        where: { codigo: codigoDependente },
                    });
                    if (!dependente) {
                        throw new common_1.BadRequestException(`Métrica dependente '${codigoDependente}' não encontrada`);
                    }
                }
                break;
            case metrica_definicao_entity_1.TipoMetrica.TAXA_VARIACAO:
                // Validar consulta SQL
                if (!metrica.sql_consulta) {
                    throw new common_1.BadRequestException('Métricas do tipo TAXA_VARIACAO requerem uma consulta SQL');
                }
                break;
            default:
                throw new common_1.BadRequestException(`Tipo de métrica não suportado: ${metrica.tipo}`);
        }
    }
    /**
     * Valida dados específicos para cada tipo de agendamento
     *
     * @param config Dados da configuração a ser validada
     */
    async validarDadosConfiguracao(config) {
        if (config.tipo_agendamento === 'cron' && !config.expressao_cron) {
            throw new common_1.BadRequestException('Agendamento do tipo CRON requer a definição de uma expressão cron');
        }
        if (config.tipo_agendamento === 'evento' && !config.nome_evento) {
            throw new common_1.BadRequestException('Agendamento do tipo EVENTO requer a definição do nome do evento');
        }
        if (config.estrategia_amostragem !== 'completa' &&
            !config.tamanho_amostra) {
            throw new common_1.BadRequestException(`Estratégia de amostragem '${config.estrategia_amostragem}' requer a definição do tamanho da amostra`);
        }
        // Validar alertas
        if (config.alertas && config.alertas.length > 0) {
            for (const alerta of config.alertas) {
                if (!alerta.tipo) {
                    throw new common_1.BadRequestException('Cada alerta deve ter um tipo definido');
                }
                if (alerta.valor === undefined || alerta.valor === null) {
                    throw new common_1.BadRequestException(`Alerta do tipo '${alerta.tipo}' requer um valor de referência`);
                }
                if (!alerta.severidade) {
                    throw new common_1.BadRequestException(`Alerta do tipo '${alerta.tipo}' requer uma severidade definida`);
                }
            }
        }
    }
};
exports.MetricasService = MetricasService;
exports.MetricasService = MetricasService = MetricasService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(metrica_definicao_entity_1.MetricaDefinicao)),
    __param(1, (0, typeorm_1.InjectRepository)(metrica_configuracao_entity_1.MetricaConfiguracao)),
    __param(2, (0, typeorm_1.InjectRepository)(metrica_snapshot_entity_1.MetricaSnapshot)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof metricas_cache_service_1.MetricasCacheService !== "undefined" && metricas_cache_service_1.MetricasCacheService) === "function" ? _d : Object, typeof (_e = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _e : Object])
], MetricasService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXG1ldHJpY2FzXFxzZXJ2aWNlc1xcbWV0cmljYXMtZGVmaW5pY2FvLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FLd0I7QUFDeEIsNkNBQW1EO0FBQ25ELHFDQUEwRTtBQUMxRSx5REFBc0Q7QUFFdEQseUZBSW9EO0FBQ3BELCtGQUFvRjtBQUNwRix1RkFBNEU7QUFVNUUscUVBQWdFO0FBRWhFOzs7OztHQUtHO0FBRUksSUFBTSxlQUFlLHVCQUFyQixNQUFNLGVBQWU7SUFLUDtJQUdBO0lBR0E7SUFFQTtJQUNBO0lBYkYsTUFBTSxHQUFHLElBQUksZUFBTSxDQUFDLGlCQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFM0QsWUFFbUIsMEJBQXdELEVBR3hELDZCQUE4RCxFQUc5RCx5QkFBc0QsRUFFdEQsWUFBa0MsRUFDbEMsWUFBMkI7UUFUM0IsK0JBQTBCLEdBQTFCLDBCQUEwQixDQUE4QjtRQUd4RCxrQ0FBNkIsR0FBN0IsNkJBQTZCLENBQWlDO1FBRzlELDhCQUF5QixHQUF6Qix5QkFBeUIsQ0FBNkI7UUFFdEQsaUJBQVksR0FBWixZQUFZLENBQXNCO1FBQ2xDLGlCQUFZLEdBQVosWUFBWSxDQUFlO0lBQzNDLENBQUM7SUFFSjs7Ozs7OztPQU9HO0lBQ0gsS0FBSyxDQUFDLFlBQVksQ0FDaEIsR0FBNkIsRUFDN0IsU0FBaUIsRUFDakIsV0FBbUI7UUFFbkIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBRWxELG9EQUFvRDtRQUNwRCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sSUFBSSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sQ0FBQztZQUNyRSxLQUFLLEVBQUUsRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLE1BQU0sRUFBRTtTQUM5QixDQUFDLENBQUM7UUFFSCxJQUFJLGdCQUFnQixFQUFFLENBQUM7WUFDckIsTUFBTSxJQUFJLDRCQUFtQixDQUMzQix1Q0FBdUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUNyRCxDQUFDO1FBQ0osQ0FBQztRQUVELDhEQUE4RDtRQUM5RCxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVwQyxxQkFBcUI7UUFDckIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQztZQUNyRCxHQUFHLEdBQUc7WUFDTixNQUFNLEVBQUUsQ0FBQztZQUNULFVBQVUsRUFBRSxHQUFHLFdBQVcsS0FBSyxTQUFTLEdBQUc7WUFDM0MsY0FBYyxFQUFFLEdBQUcsV0FBVyxLQUFLLFNBQVMsR0FBRztTQUNoRCxDQUFDLENBQUM7UUFFSCxpQkFBaUI7UUFDakIsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFJLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXpFLGtEQUFrRDtRQUNsRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUN2QyxVQUFVLEVBQUUsWUFBWSxDQUFDLEVBQUU7WUFDM0IsY0FBYyxFQUFFLFlBQVksQ0FBQyxNQUFNO1lBQ25DLFVBQVUsRUFBRSxTQUFTO1NBQ3RCLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUNiLCtCQUErQixZQUFZLENBQUMsTUFBTSxTQUFTLFlBQVksQ0FBQyxFQUFFLEdBQUcsQ0FDOUUsQ0FBQztRQUVGLE9BQU8sWUFBWSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILEtBQUssQ0FBQyxnQkFBZ0IsQ0FDcEIsRUFBVSxFQUNWLEdBQWlDLEVBQ2pDLFNBQWlCLEVBQ2pCLFdBQW1CO1FBRW5CLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLCtCQUErQixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXJELDJCQUEyQjtRQUMzQixNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLENBQUM7WUFDNUQsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFO1NBQ2QsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2IsTUFBTSxJQUFJLDBCQUFpQixDQUFDLGtCQUFrQixFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDckUsQ0FBQztRQUVELHVEQUF1RDtRQUN2RCxJQUFJLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDMUMsc0RBQXNEO1lBQ3RELE1BQU0sY0FBYyxHQUFHLE1BQU0sSUFBSSxDQUFDLHlCQUF5QixDQUFDLEtBQUssQ0FBQztnQkFDaEUsS0FBSyxFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsRUFBRTthQUM1QixDQUFDLENBQUM7WUFFSCxJQUFJLGNBQWMsR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDdkIsTUFBTSxJQUFJLDRCQUFtQixDQUMzQiw4RUFBOEUsQ0FDL0UsQ0FBQztZQUNKLENBQUM7UUFDSCxDQUFDO1FBRUQseUNBQXlDO1FBQ3pDLE1BQU0saUJBQWlCLEdBQUc7WUFDeEIsR0FBRyxPQUFPO1lBQ1YsR0FBRyxHQUFHO1lBQ04sTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQztZQUMxQixjQUFjLEVBQUUsR0FBRyxXQUFXLEtBQUssU0FBUyxHQUFHO1NBQ2hELENBQUM7UUFFRiw4REFBOEQ7UUFDOUQsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUVsRCw0QkFBNEI7UUFDNUIsTUFBTSxTQUFTLEdBQ2IsTUFBTSxJQUFJLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFFaEUsNkJBQTZCO1FBQzdCLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFNUMsc0RBQXNEO1FBQ3RELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFO1lBQzNDLFVBQVUsRUFBRSxTQUFTLENBQUMsRUFBRTtZQUN4QixjQUFjLEVBQUUsU0FBUyxDQUFDLE1BQU07WUFDaEMsVUFBVSxFQUFFLFNBQVM7U0FDdEIsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQ2IsbUNBQW1DLFNBQVMsQ0FBQyxNQUFNLFNBQVMsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUM1RSxDQUFDO1FBRUYsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLGtCQUFrQixDQUFDLEVBQVU7UUFDakMsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsMEJBQTBCLENBQUMsT0FBTyxDQUFDO1lBQzVELEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRTtZQUNiLFNBQVMsRUFBRSxDQUFDLGVBQWUsQ0FBQztTQUM3QixDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDYixNQUFNLElBQUksMEJBQWlCLENBQUMsa0JBQWtCLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUNyRSxDQUFDO1FBRUQsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLHNCQUFzQixDQUMxQixNQUFjO1FBRWQsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsY0FBYyxDQUNsQixPQUEwQjtRQUUxQixNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQztRQUNuQyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQztRQUNwQyxNQUFNLElBQUksR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7UUFFbkMsK0JBQStCO1FBQy9CLE1BQU0sS0FBSyxHQUF1QyxFQUFFLENBQUM7UUFFckQsSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDbkIsS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFBLGNBQUksRUFBQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQzdDLENBQUM7UUFFRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNqQixLQUFLLENBQUMsSUFBSSxHQUFHLElBQUEsY0FBSSxFQUFDLElBQUksT0FBTyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7UUFDekMsQ0FBQztRQUVELElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ3RCLEtBQUssQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztRQUN0QyxDQUFDO1FBRUQsSUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDakIsS0FBSyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQzVCLENBQUM7UUFFRCxJQUFJLE9BQU8sQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFLENBQUM7WUFDaEMsS0FBSyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBQzlCLENBQUM7UUFFRCxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNoQixzREFBc0Q7WUFDdEQsOEdBQThHO1lBQzlHLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBQSxjQUFJLEVBQUMsSUFBSSxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztRQUN4QyxDQUFDO1FBRUQsNEJBQTRCO1FBQzVCLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLDBCQUEwQixDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7UUFFckUsa0JBQWtCO1FBQ2xCLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLDBCQUEwQixDQUFDLElBQUksQ0FBQztZQUN2RCxLQUFLO1lBQ0wsS0FBSyxFQUFFO2dCQUNMLE1BQU0sRUFBRSxLQUFLO2FBQ2Q7WUFDRCxJQUFJO1lBQ0osSUFBSSxFQUFFLE1BQU07U0FDYixDQUFDLENBQUM7UUFFSCxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGNBQWMsQ0FBQyxFQUFVO1FBQzdCLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLDZCQUE2QixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRW5ELDJCQUEyQjtRQUMzQixNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLENBQUM7WUFDNUQsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFO1NBQ2QsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2IsTUFBTSxJQUFJLDBCQUFpQixDQUFDLGtCQUFrQixFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDckUsQ0FBQztRQUVELHFDQUFxQztRQUNyQyxNQUFNLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFO1lBQy9DLEtBQUssRUFBRSxLQUFLO1NBQ2IsQ0FBQyxDQUFDO1FBRUgsNkJBQTZCO1FBQzdCLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFNUMsa0RBQWtEO1FBQ2xELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFO1lBQ3pDLFVBQVUsRUFBRSxFQUFFO1lBQ2QsY0FBYyxFQUFFLE9BQU8sQ0FBQyxNQUFNO1NBQy9CLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUNiLGlDQUFpQyxPQUFPLENBQUMsTUFBTSxTQUFTLEVBQUUsR0FBRyxDQUM5RCxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsaUJBQWlCLENBQ3JCLEdBQWdDLEVBQ2hDLFNBQWlCLEVBQ2pCLFdBQW1CO1FBRW5CLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLHNDQUFzQyxHQUFHLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUV4RSxnQ0FBZ0M7UUFDaEMsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsMEJBQTBCLENBQUMsT0FBTyxDQUFDO1lBQzVELEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLENBQUMsVUFBVSxFQUFFO1NBQzlCLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNiLE1BQU0sSUFBSSwwQkFBaUIsQ0FDekIsa0JBQWtCLEdBQUcsQ0FBQyxVQUFVLGlCQUFpQixDQUNsRCxDQUFDO1FBQ0osQ0FBQztRQUVELHdEQUF3RDtRQUN4RCxNQUFNLGVBQWUsR0FBRyxNQUFNLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxPQUFPLENBQUM7WUFDdkUsS0FBSyxFQUFFLEVBQUUsVUFBVSxFQUFFLEdBQUcsQ0FBQyxVQUFVLEVBQUU7U0FDdEMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxlQUFlLEVBQUUsQ0FBQztZQUNwQixNQUFNLElBQUksNEJBQW1CLENBQzNCLDZDQUE2QyxPQUFPLENBQUMsTUFBTSxzQkFBc0IsQ0FDbEYsQ0FBQztRQUNKLENBQUM7UUFFRCxrRUFBa0U7UUFDbEUsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFekMsMEJBQTBCO1FBQzFCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxNQUFNLENBQUM7WUFDdkQsR0FBRyxHQUFHO1lBQ04sVUFBVSxFQUFFLEdBQUcsV0FBVyxLQUFLLFNBQVMsR0FBRztZQUMzQyxjQUFjLEVBQUUsR0FBRyxXQUFXLEtBQUssU0FBUyxHQUFHO1NBQ2hELENBQUMsQ0FBQztRQUVILHNCQUFzQjtRQUN0QixNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFMUUsdURBQXVEO1FBQ3ZELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLDZCQUE2QixFQUFFO1lBQ3BELFVBQVUsRUFBRSxHQUFHLENBQUMsVUFBVTtZQUMxQixlQUFlLEVBQUUsV0FBVyxDQUFDLEVBQUU7WUFDL0IsVUFBVSxFQUFFLFNBQVM7U0FDdEIsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQ2IsaURBQWlELE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FDbEUsQ0FBQztRQUVGLE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILEtBQUssQ0FBQyxxQkFBcUIsQ0FDekIsRUFBVSxFQUNWLEdBQW9DLEVBQ3BDLFNBQWlCLEVBQ2pCLFdBQW1CO1FBRW5CLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLG9DQUFvQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRTFELGdDQUFnQztRQUNoQyxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxPQUFPLENBQUM7WUFDOUQsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFO1lBQ2IsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDO1NBQ3ZCLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNaLE1BQU0sSUFBSSwwQkFBaUIsQ0FBQyx1QkFBdUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQzFFLENBQUM7UUFFRCx5Q0FBeUM7UUFDekMsTUFBTSxnQkFBZ0IsR0FBRztZQUN2QixHQUFHLE1BQU07WUFDVCxHQUFHLEdBQUc7WUFDTixjQUFjLEVBQUUsR0FBRyxXQUFXLEtBQUssU0FBUyxHQUFHO1NBQ2hELENBQUM7UUFFRixrRUFBa0U7UUFDbEUsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUV0RCxpQ0FBaUM7UUFDakMsTUFBTSxTQUFTLEdBQ2IsTUFBTSxJQUFJLENBQUMsNkJBQTZCLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFbEUsNkJBQTZCO1FBQzdCLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTNELDJEQUEyRDtRQUMzRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxpQ0FBaUMsRUFBRTtZQUN4RCxVQUFVLEVBQUUsTUFBTSxDQUFDLFVBQVU7WUFDN0IsZUFBZSxFQUFFLFNBQVMsQ0FBQyxFQUFFO1lBQzdCLFVBQVUsRUFBRSxTQUFTO1NBQ3RCLENBQUMsQ0FBQztRQUVILDRFQUE0RTtRQUM1RSxJQUFJLGFBQWEsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO1FBQ3RDLElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ25CLE1BQU0sT0FBTyxHQUFHLE1BQU0sTUFBTSxDQUFDLE9BQU8sQ0FBQztZQUNyQyxhQUFhLEdBQUcsT0FBTyxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDO1FBQ3RELENBQUM7UUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FDYixxREFBcUQsYUFBYSxFQUFFLENBQ3JFLENBQUM7UUFFRixPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsNEJBQTRCLENBQ2hDLFNBQWlCO1FBRWpCLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLDZCQUE2QixDQUFDLE9BQU8sQ0FBQztZQUM5RCxLQUFLLEVBQUUsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFO1lBQ2hDLFNBQVMsRUFBRSxDQUFDLFNBQVMsQ0FBQztTQUN2QixDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDWixNQUFNLElBQUksMEJBQWlCLENBQ3pCLDZCQUE2QixTQUFTLGlCQUFpQixDQUN4RCxDQUFDO1FBQ0osQ0FBQztRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssS0FBSyxDQUFDLG1CQUFtQixDQUMvQixPQUFvRDtRQUVwRCx5Q0FBeUM7UUFDekMsTUFBTSxXQUFXLEdBQUcsbUJBQW1CLENBQUM7UUFDeEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7WUFDdEMsTUFBTSxJQUFJLDRCQUFtQixDQUMzQixxR0FBcUcsQ0FDdEcsQ0FBQztRQUNKLENBQUM7UUFFRCxRQUFRLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNyQixLQUFLLHNDQUFXLENBQUMsUUFBUSxDQUFDO1lBQzFCLEtBQUssc0NBQVcsQ0FBQyxJQUFJLENBQUM7WUFDdEIsS0FBSyxzQ0FBVyxDQUFDLEtBQUssQ0FBQztZQUN2QixLQUFLLHNDQUFXLENBQUMsTUFBTSxDQUFDO1lBQ3hCLEtBQUssc0NBQVcsQ0FBQyxNQUFNLENBQUM7WUFDeEIsS0FBSyxzQ0FBVyxDQUFDLGFBQWE7Z0JBQzVCLHVCQUF1QjtnQkFDdkIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQztvQkFDMUIsTUFBTSxJQUFJLDRCQUFtQixDQUMzQixvQkFBb0IsT0FBTyxDQUFDLElBQUksNEJBQTRCLENBQzdELENBQUM7Z0JBQ0osQ0FBQztnQkFDRCxNQUFNO1lBRVIsS0FBSyxzQ0FBVyxDQUFDLFNBQVM7Z0JBQ3hCLGdEQUFnRDtnQkFDaEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQztvQkFDMUIsTUFBTSxJQUFJLDRCQUFtQixDQUMzQixzREFBc0QsQ0FDdkQsQ0FBQztnQkFDSixDQUFDO2dCQUVELElBQUksQ0FBQyxPQUFPLENBQUMsc0JBQXNCLEVBQUUsU0FBUyxFQUFFLENBQUM7b0JBQy9DLE1BQU0sSUFBSSw0QkFBbUIsQ0FDM0Isc0VBQXNFLENBQ3ZFLENBQUM7Z0JBQ0osQ0FBQztnQkFFRCxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLHNCQUFzQixDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUNuRSxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLEdBQUcsQ0FBQyxJQUFJLFNBQVMsR0FBRyxHQUFHLEVBQUUsQ0FBQztvQkFDekQsTUFBTSxJQUFJLDRCQUFtQixDQUMzQix1REFBdUQsQ0FDeEQsQ0FBQztnQkFDSixDQUFDO2dCQUNELE1BQU07WUFFUixLQUFLLHNDQUFXLENBQUMsUUFBUTtnQkFDdkIseUNBQXlDO2dCQUN6QyxJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxDQUFDO29CQUM3QixNQUFNLElBQUksNEJBQW1CLENBQzNCLDJEQUEyRCxDQUM1RCxDQUFDO2dCQUNKLENBQUM7Z0JBRUQsSUFDRSxDQUFDLE9BQU8sQ0FBQyxvQkFBb0I7b0JBQzdCLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUN6QyxDQUFDO29CQUNELE1BQU0sSUFBSSw0QkFBbUIsQ0FDM0Isd0VBQXdFLENBQ3pFLENBQUM7Z0JBQ0osQ0FBQztnQkFFRCwrQ0FBK0M7Z0JBQy9DLEtBQUssTUFBTSxnQkFBZ0IsSUFBSSxPQUFPLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztvQkFDNUQsMENBQTBDO29CQUMxQyxJQUFJLGdCQUFnQixLQUFLLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQzt3QkFDeEMsU0FBUztvQkFDWCxDQUFDO29CQUVELE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBSSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sQ0FBQzt3QkFDL0QsS0FBSyxFQUFFLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixFQUFFO3FCQUNwQyxDQUFDLENBQUM7b0JBRUgsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO3dCQUNoQixNQUFNLElBQUksNEJBQW1CLENBQzNCLHVCQUF1QixnQkFBZ0Isa0JBQWtCLENBQzFELENBQUM7b0JBQ0osQ0FBQztnQkFDSCxDQUFDO2dCQUNELE1BQU07WUFFUixLQUFLLHNDQUFXLENBQUMsYUFBYTtnQkFDNUIsdUJBQXVCO2dCQUN2QixJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxDQUFDO29CQUMxQixNQUFNLElBQUksNEJBQW1CLENBQzNCLDBEQUEwRCxDQUMzRCxDQUFDO2dCQUNKLENBQUM7Z0JBQ0QsTUFBTTtZQUVSO2dCQUNFLE1BQU0sSUFBSSw0QkFBbUIsQ0FDM0Isa0NBQWtDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FDakQsQ0FBQztRQUNOLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLEtBQUssQ0FBQyx3QkFBd0IsQ0FDcEMsTUFBeUQ7UUFFekQsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLEtBQUssTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ2pFLE1BQU0sSUFBSSw0QkFBbUIsQ0FDM0IsbUVBQW1FLENBQ3BFLENBQUM7UUFDSixDQUFDO1FBRUQsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLEtBQUssUUFBUSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ2hFLE1BQU0sSUFBSSw0QkFBbUIsQ0FDM0IsaUVBQWlFLENBQ2xFLENBQUM7UUFDSixDQUFDO1FBRUQsSUFDRSxNQUFNLENBQUMscUJBQXFCLEtBQUssVUFBVTtZQUMzQyxDQUFDLE1BQU0sQ0FBQyxlQUFlLEVBQ3ZCLENBQUM7WUFDRCxNQUFNLElBQUksNEJBQW1CLENBQzNCLDZCQUE2QixNQUFNLENBQUMscUJBQXFCLDRDQUE0QyxDQUN0RyxDQUFDO1FBQ0osQ0FBQztRQUVELGtCQUFrQjtRQUNsQixJQUFJLE1BQU0sQ0FBQyxPQUFPLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDaEQsS0FBSyxNQUFNLE1BQU0sSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3BDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7b0JBQ2pCLE1BQU0sSUFBSSw0QkFBbUIsQ0FDM0IsdUNBQXVDLENBQ3hDLENBQUM7Z0JBQ0osQ0FBQztnQkFFRCxJQUFJLE1BQU0sQ0FBQyxLQUFLLEtBQUssU0FBUyxJQUFJLE1BQU0sQ0FBQyxLQUFLLEtBQUssSUFBSSxFQUFFLENBQUM7b0JBQ3hELE1BQU0sSUFBSSw0QkFBbUIsQ0FDM0IsbUJBQW1CLE1BQU0sQ0FBQyxJQUFJLGlDQUFpQyxDQUNoRSxDQUFDO2dCQUNKLENBQUM7Z0JBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQztvQkFDdkIsTUFBTSxJQUFJLDRCQUFtQixDQUMzQixtQkFBbUIsTUFBTSxDQUFDLElBQUksa0NBQWtDLENBQ2pFLENBQUM7Z0JBQ0osQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztDQUNGLENBQUE7QUFqa0JZLDBDQUFlOzBCQUFmLGVBQWU7SUFEM0IsSUFBQSxtQkFBVSxHQUFFO0lBS1IsV0FBQSxJQUFBLDBCQUFnQixFQUFDLDJDQUFnQixDQUFDLENBQUE7SUFHbEMsV0FBQSxJQUFBLDBCQUFnQixFQUFDLGlEQUFtQixDQUFDLENBQUE7SUFHckMsV0FBQSxJQUFBLDBCQUFnQixFQUFDLHlDQUFlLENBQUMsQ0FBQTt5REFMVyxvQkFBVSxvQkFBVixvQkFBVSxvREFHUCxvQkFBVSxvQkFBVixvQkFBVSxvREFHZCxvQkFBVSxvQkFBVixvQkFBVSxvREFFdkIsNkNBQW9CLG9CQUFwQiw2Q0FBb0Isb0RBQ3BCLDZCQUFhLG9CQUFiLDZCQUFhO0dBZG5DLGVBQWUsQ0Fpa0IzQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcbW9kdWxlc1xcbWV0cmljYXNcXHNlcnZpY2VzXFxtZXRyaWNhcy1kZWZpbmljYW8uc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBJbmplY3RhYmxlLFxuICBMb2dnZXIsXG4gIE5vdEZvdW5kRXhjZXB0aW9uLFxuICBCYWRSZXF1ZXN0RXhjZXB0aW9uLFxufSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3RSZXBvc2l0b3J5IH0gZnJvbSAnQG5lc3Rqcy90eXBlb3JtJztcbmltcG9ydCB7IFJlcG9zaXRvcnksIExpa2UsIEZpbmRPcHRpb25zV2hlcmUsIE5vdCwgSXNOdWxsIH0gZnJvbSAndHlwZW9ybSc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIyIH0gZnJvbSAnQG5lc3Rqcy9ldmVudC1lbWl0dGVyJztcblxuaW1wb3J0IHtcbiAgTWV0cmljYURlZmluaWNhbyxcbiAgQ2F0ZWdvcmlhTWV0cmljYSxcbiAgVGlwb01ldHJpY2EsXG59IGZyb20gJy4uLy4uLy4uL2VudGl0aWVzL21ldHJpY2EtZGVmaW5pY2FvLmVudGl0eSc7XG5pbXBvcnQgeyBNZXRyaWNhQ29uZmlndXJhY2FvIH0gZnJvbSAnLi4vLi4vLi4vZW50aXRpZXMvbWV0cmljYS1jb25maWd1cmFjYW8uZW50aXR5JztcbmltcG9ydCB7IE1ldHJpY2FTbmFwc2hvdCB9IGZyb20gJy4uLy4uLy4uL2VudGl0aWVzL21ldHJpY2Etc25hcHNob3QuZW50aXR5JztcbmltcG9ydCB7XG4gIENyaWFyTWV0cmljYURlZmluaWNhb0R0byxcbiAgQXR1YWxpemFyTWV0cmljYURlZmluaWNhb0R0byxcbiAgRmlsdHJvTWV0cmljYXNEdG8sXG59IGZyb20gJy4uL2R0by9tZXRyaWNhLWRlZmluaWNhby5kdG8nO1xuaW1wb3J0IHtcbiAgQ3JpYXJNZXRyaWNhQ29uZmlndXJhY2FvRHRvLFxuICBBdHVhbGl6YXJNZXRyaWNhQ29uZmlndXJhY2FvRHRvLFxufSBmcm9tICcuLi9kdG8vbWV0cmljYS1jb25maWd1cmFjYW8uZHRvJztcbmltcG9ydCB7IE1ldHJpY2FzQ2FjaGVTZXJ2aWNlIH0gZnJvbSAnLi9tZXRyaWNhcy1jYWNoZS5zZXJ2aWNlJztcblxuLyoqXG4gKiBTZXJ2acOnbyByZXNwb25zw6F2ZWwgcGVsbyBnZXJlbmNpYW1lbnRvIGRlIGRlZmluacOnw7VlcyBkZSBtw6l0cmljYXNcbiAqXG4gKiBFc3RlIHNlcnZpw6dvIGdlcmVuY2lhIG8gY2ljbG8gZGUgdmlkYSBkYXMgZGVmaW5pw6fDtWVzIGRlIG3DqXRyaWNhcyxcbiAqIGluY2x1aW5kbyBjcmlhw6fDo28sIGF0dWFsaXphw6fDo28sIGNvbnN1bHRhIGUgcmVtb8Onw6NvLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTWV0cmljYXNTZXJ2aWNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXIgPSBuZXcgTG9nZ2VyKE1ldHJpY2FzU2VydmljZS5uYW1lKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0UmVwb3NpdG9yeShNZXRyaWNhRGVmaW5pY2FvKVxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWV0cmljYURlZmluaWNhb1JlcG9zaXRvcnk6IFJlcG9zaXRvcnk8TWV0cmljYURlZmluaWNhbz4sXG5cbiAgICBASW5qZWN0UmVwb3NpdG9yeShNZXRyaWNhQ29uZmlndXJhY2FvKVxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWV0cmljYUNvbmZpZ3VyYWNhb1JlcG9zaXRvcnk6IFJlcG9zaXRvcnk8TWV0cmljYUNvbmZpZ3VyYWNhbz4sXG5cbiAgICBASW5qZWN0UmVwb3NpdG9yeShNZXRyaWNhU25hcHNob3QpXG4gICAgcHJpdmF0ZSByZWFkb25seSBtZXRyaWNhU25hcHNob3RSZXBvc2l0b3J5OiBSZXBvc2l0b3J5PE1ldHJpY2FTbmFwc2hvdD4sXG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGNhY2hlU2VydmljZTogTWV0cmljYXNDYWNoZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjIsXG4gICkge31cblxuICAvKipcbiAgICogQ3JpYSB1bWEgbm92YSBkZWZpbmnDp8OjbyBkZSBtw6l0cmljYVxuICAgKlxuICAgKiBAcGFyYW0gZHRvIERhZG9zIGRhIG3DqXRyaWNhIGEgc2VyIGNyaWFkYVxuICAgKiBAcGFyYW0gdXN1YXJpb0lkIElEIGRvIHVzdcOhcmlvIHF1ZSBlc3TDoSBjcmlhbmRvIGEgbcOpdHJpY2FcbiAgICogQHBhcmFtIHVzdWFyaW9Ob21lIE5vbWUgZG8gdXN1w6FyaW8gcXVlIGVzdMOhIGNyaWFuZG8gYSBtw6l0cmljYVxuICAgKiBAcmV0dXJucyBNw6l0cmljYSBjcmlhZGFcbiAgICovXG4gIGFzeW5jIGNyaWFyTWV0cmljYShcbiAgICBkdG86IENyaWFyTWV0cmljYURlZmluaWNhb0R0byxcbiAgICB1c3VhcmlvSWQ6IHN0cmluZyxcbiAgICB1c3VhcmlvTm9tZTogc3RyaW5nLFxuICApOiBQcm9taXNlPE1ldHJpY2FEZWZpbmljYW8+IHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYENyaWFuZG8gbcOpdHJpY2E6ICR7ZHRvLmNvZGlnb31gKTtcblxuICAgIC8vIFZlcmlmaWNhciBzZSBqw6EgZXhpc3RlIG3DqXRyaWNhIGNvbSBvIG1lc21vIGPDs2RpZ29cbiAgICBjb25zdCBtZXRyaWNhRXhpc3RlbnRlID0gYXdhaXQgdGhpcy5tZXRyaWNhRGVmaW5pY2FvUmVwb3NpdG9yeS5maW5kT25lKHtcbiAgICAgIHdoZXJlOiB7IGNvZGlnbzogZHRvLmNvZGlnbyB9LFxuICAgIH0pO1xuXG4gICAgaWYgKG1ldHJpY2FFeGlzdGVudGUpIHtcbiAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKFxuICAgICAgICBgSsOhIGV4aXN0ZSB1bWEgbcOpdHJpY2EgY29tIG8gY8OzZGlnbyAnJHtkdG8uY29kaWdvfSdgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGFyIGNvbmZpZ3VyYcOnw7VlcyBlc3BlY8OtZmljYXMgcGFyYSBjYWRhIHRpcG8gZGUgbcOpdHJpY2FcbiAgICBhd2FpdCB0aGlzLnZhbGlkYXJEYWRvc01ldHJpY2EoZHRvKTtcblxuICAgIC8vIENyaWFyIG5vdmEgbcOpdHJpY2FcbiAgICBjb25zdCBtZXRyaWNhID0gdGhpcy5tZXRyaWNhRGVmaW5pY2FvUmVwb3NpdG9yeS5jcmVhdGUoe1xuICAgICAgLi4uZHRvLFxuICAgICAgdmVyc2FvOiAxLFxuICAgICAgY3JpYWRvX3BvcjogYCR7dXN1YXJpb05vbWV9ICgke3VzdWFyaW9JZH0pYCxcbiAgICAgIGF0dWFsaXphZG9fcG9yOiBgJHt1c3VhcmlvTm9tZX0gKCR7dXN1YXJpb0lkfSlgLFxuICAgIH0pO1xuXG4gICAgLy8gU2FsdmFyIG3DqXRyaWNhXG4gICAgY29uc3QgbWV0cmljYVNhbHZhID0gYXdhaXQgdGhpcy5tZXRyaWNhRGVmaW5pY2FvUmVwb3NpdG9yeS5zYXZlKG1ldHJpY2EpO1xuXG4gICAgLy8gRW1pdGlyIGV2ZW50byBwYXJhIG5vdGlmaWNhciBjcmlhw6fDo28gZGEgbcOpdHJpY2FcbiAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdtZXRyaWNhLmNyaWFkYScsIHtcbiAgICAgIG1ldHJpY2FfaWQ6IG1ldHJpY2FTYWx2YS5pZCxcbiAgICAgIG1ldHJpY2FfY29kaWdvOiBtZXRyaWNhU2FsdmEuY29kaWdvLFxuICAgICAgdXN1YXJpb19pZDogdXN1YXJpb0lkLFxuICAgIH0pO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgYE3DqXRyaWNhIGNyaWFkYSBjb20gc3VjZXNzbzogJHttZXRyaWNhU2FsdmEuY29kaWdvfSAoSUQ6ICR7bWV0cmljYVNhbHZhLmlkfSlgLFxuICAgICk7XG5cbiAgICByZXR1cm4gbWV0cmljYVNhbHZhO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dWFsaXphIHVtYSBkZWZpbmnDp8OjbyBkZSBtw6l0cmljYSBleGlzdGVudGVcbiAgICpcbiAgICogQHBhcmFtIGlkIElEIGRhIG3DqXRyaWNhIGEgc2VyIGF0dWFsaXphZGFcbiAgICogQHBhcmFtIGR0byBEYWRvcyBwYXJhIGF0dWFsaXphw6fDo29cbiAgICogQHBhcmFtIHVzdWFyaW9JZCBJRCBkbyB1c3XDoXJpbyBxdWUgZXN0w6EgYXR1YWxpemFuZG8gYSBtw6l0cmljYVxuICAgKiBAcGFyYW0gdXN1YXJpb05vbWUgTm9tZSBkbyB1c3XDoXJpbyBxdWUgZXN0w6EgYXR1YWxpemFuZG8gYSBtw6l0cmljYVxuICAgKiBAcmV0dXJucyBNw6l0cmljYSBhdHVhbGl6YWRhXG4gICAqL1xuICBhc3luYyBhdHVhbGl6YXJNZXRyaWNhKFxuICAgIGlkOiBzdHJpbmcsXG4gICAgZHRvOiBBdHVhbGl6YXJNZXRyaWNhRGVmaW5pY2FvRHRvLFxuICAgIHVzdWFyaW9JZDogc3RyaW5nLFxuICAgIHVzdWFyaW9Ob21lOiBzdHJpbmcsXG4gICk6IFByb21pc2U8TWV0cmljYURlZmluaWNhbz4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgQXR1YWxpemFuZG8gbcOpdHJpY2EgY29tIElEOiAke2lkfWApO1xuXG4gICAgLy8gQnVzY2FyIG3DqXRyaWNhIGV4aXN0ZW50ZVxuICAgIGNvbnN0IG1ldHJpY2EgPSBhd2FpdCB0aGlzLm1ldHJpY2FEZWZpbmljYW9SZXBvc2l0b3J5LmZpbmRPbmUoe1xuICAgICAgd2hlcmU6IHsgaWQgfSxcbiAgICB9KTtcblxuICAgIGlmICghbWV0cmljYSkge1xuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKGBNw6l0cmljYSBjb20gSUQgJHtpZH0gbsOjbyBlbmNvbnRyYWRhYCk7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZpY2FyIHNlIGVzdMOhIHRlbnRhbmRvIGFsdGVyYXIgbyB0aXBvIGRhIG3DqXRyaWNhXG4gICAgaWYgKGR0by50aXBvICYmIGR0by50aXBvICE9PSBtZXRyaWNhLnRpcG8pIHtcbiAgICAgIC8vIFZlcmlmaWNhciBzZSBqw6EgZXhpc3RlbSBzbmFwc2hvdHMgcGFyYSBlc3RhIG3DqXRyaWNhXG4gICAgICBjb25zdCBjb3VudFNuYXBzaG90cyA9IGF3YWl0IHRoaXMubWV0cmljYVNuYXBzaG90UmVwb3NpdG9yeS5jb3VudCh7XG4gICAgICAgIHdoZXJlOiB7IGRlZmluaWNhb19pZDogaWQgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY291bnRTbmFwc2hvdHMgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKFxuICAgICAgICAgICdOw6NvIMOpIHBvc3PDrXZlbCBhbHRlcmFyIG8gdGlwbyBkZSB1bWEgbcOpdHJpY2EgcXVlIGrDoSBwb3NzdWkgdmFsb3JlcyBjb2xldGFkb3MnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbWJpbmFyIGRhZG9zIGF0dWFpcyBjb20gYXR1YWxpemHDp8O1ZXNcbiAgICBjb25zdCBtZXRyaWNhQXR1YWxpemFkYSA9IHtcbiAgICAgIC4uLm1ldHJpY2EsXG4gICAgICAuLi5kdG8sXG4gICAgICB2ZXJzYW86IG1ldHJpY2EudmVyc2FvICsgMSxcbiAgICAgIGF0dWFsaXphZG9fcG9yOiBgJHt1c3VhcmlvTm9tZX0gKCR7dXN1YXJpb0lkfSlgLFxuICAgIH07XG5cbiAgICAvLyBWYWxpZGFyIGNvbmZpZ3VyYcOnw7VlcyBlc3BlY8OtZmljYXMgcGFyYSBjYWRhIHRpcG8gZGUgbcOpdHJpY2FcbiAgICBhd2FpdCB0aGlzLnZhbGlkYXJEYWRvc01ldHJpY2EobWV0cmljYUF0dWFsaXphZGEpO1xuXG4gICAgLy8gU2FsdmFyIG3DqXRyaWNhIGF0dWFsaXphZGFcbiAgICBjb25zdCByZXN1bHRhZG8gPVxuICAgICAgYXdhaXQgdGhpcy5tZXRyaWNhRGVmaW5pY2FvUmVwb3NpdG9yeS5zYXZlKG1ldHJpY2FBdHVhbGl6YWRhKTtcblxuICAgIC8vIEludmFsaWRhciBjYWNoZSBkYSBtw6l0cmljYVxuICAgIHRoaXMuY2FjaGVTZXJ2aWNlLmludmFsaWRhckNhY2hlTWV0cmljYShpZCk7XG5cbiAgICAvLyBFbWl0aXIgZXZlbnRvIHBhcmEgbm90aWZpY2FyIGF0dWFsaXphw6fDo28gZGEgbcOpdHJpY2FcbiAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdtZXRyaWNhLmF0dWFsaXphZGEnLCB7XG4gICAgICBtZXRyaWNhX2lkOiByZXN1bHRhZG8uaWQsXG4gICAgICBtZXRyaWNhX2NvZGlnbzogcmVzdWx0YWRvLmNvZGlnbyxcbiAgICAgIHVzdWFyaW9faWQ6IHVzdWFyaW9JZCxcbiAgICB9KTtcblxuICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgIGBNw6l0cmljYSBhdHVhbGl6YWRhIGNvbSBzdWNlc3NvOiAke3Jlc3VsdGFkby5jb2RpZ299IChJRDogJHtyZXN1bHRhZG8uaWR9KWAsXG4gICAgKTtcblxuICAgIHJldHVybiByZXN1bHRhZG87XG4gIH1cblxuICAvKipcbiAgICogQnVzY2EgdW1hIG3DqXRyaWNhIHBlbG8gSURcbiAgICpcbiAgICogQHBhcmFtIGlkIElEIGRhIG3DqXRyaWNhXG4gICAqIEByZXR1cm5zIE3DqXRyaWNhIGVuY29udHJhZGEgb3UgbnVsbFxuICAgKi9cbiAgYXN5bmMgYnVzY2FyTWV0cmljYVBvcklkKGlkOiBzdHJpbmcpOiBQcm9taXNlPE1ldHJpY2FEZWZpbmljYW8+IHtcbiAgICBjb25zdCBtZXRyaWNhID0gYXdhaXQgdGhpcy5tZXRyaWNhRGVmaW5pY2FvUmVwb3NpdG9yeS5maW5kT25lKHtcbiAgICAgIHdoZXJlOiB7IGlkIH0sXG4gICAgICByZWxhdGlvbnM6IFsnY29uZmlndXJhY29lcyddLFxuICAgIH0pO1xuXG4gICAgaWYgKCFtZXRyaWNhKSB7XG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oYE3DqXRyaWNhIGNvbSBJRCAke2lkfSBuw6NvIGVuY29udHJhZGFgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0cmljYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdXNjYSB1bWEgbcOpdHJpY2EgcGVsbyBjw7NkaWdvXG4gICAqXG4gICAqIEBwYXJhbSBjb2RpZ28gQ8OzZGlnbyBkYSBtw6l0cmljYVxuICAgKiBAcmV0dXJucyBNw6l0cmljYSBlbmNvbnRyYWRhIG91IG51bGxcbiAgICovXG4gIGFzeW5jIGJ1c2Nhck1ldHJpY2FQb3JDb2RpZ28oXG4gICAgY29kaWdvOiBzdHJpbmcsXG4gICk6IFByb21pc2U8TWV0cmljYURlZmluaWNhbyB8IG51bGw+IHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZVNlcnZpY2Uub2J0ZXJNZXRyaWNhKGNvZGlnbyk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGEgbcOpdHJpY2FzIGNvbSBmaWx0cm9zIGUgcGFnaW5hw6fDo29cbiAgICpcbiAgICogQHBhcmFtIGZpbHRyb3MgRmlsdHJvcyBwYXJhIGJ1c2NhXG4gICAqIEByZXR1cm5zIExpc3RhIHBhZ2luYWRhIGRlIG3DqXRyaWNhc1xuICAgKi9cbiAgYXN5bmMgbGlzdGFyTWV0cmljYXMoXG4gICAgZmlsdHJvczogRmlsdHJvTWV0cmljYXNEdG8sXG4gICk6IFByb21pc2U8eyBpdGVtczogTWV0cmljYURlZmluaWNhb1tdOyB0b3RhbDogbnVtYmVyIH0+IHtcbiAgICBjb25zdCBwYWdpbmEgPSBmaWx0cm9zLnBhZ2luYSB8fCAxO1xuICAgIGNvbnN0IGxpbWl0ZSA9IGZpbHRyb3MubGltaXRlIHx8IDEwO1xuICAgIGNvbnN0IHNraXAgPSAocGFnaW5hIC0gMSkgKiBsaW1pdGU7XG5cbiAgICAvLyBDb25zdHJ1aXIgY29uZGnDp8O1ZXMgZGUgYnVzY2FcbiAgICBjb25zdCB3aGVyZTogRmluZE9wdGlvbnNXaGVyZTxNZXRyaWNhRGVmaW5pY2FvPiA9IHt9O1xuXG4gICAgaWYgKGZpbHRyb3MuY29kaWdvKSB7XG4gICAgICB3aGVyZS5jb2RpZ28gPSBMaWtlKGAlJHtmaWx0cm9zLmNvZGlnb30lYCk7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRyb3Mubm9tZSkge1xuICAgICAgd2hlcmUubm9tZSA9IExpa2UoYCUke2ZpbHRyb3Mubm9tZX0lYCk7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRyb3MuY2F0ZWdvcmlhKSB7XG4gICAgICB3aGVyZS5jYXRlZ29yaWEgPSBmaWx0cm9zLmNhdGVnb3JpYTtcbiAgICB9XG5cbiAgICBpZiAoZmlsdHJvcy50aXBvKSB7XG4gICAgICB3aGVyZS50aXBvID0gZmlsdHJvcy50aXBvO1xuICAgIH1cblxuICAgIGlmIChmaWx0cm9zLmF0aXZhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdoZXJlLmF0aXZhID0gZmlsdHJvcy5hdGl2YTtcbiAgICB9XG5cbiAgICBpZiAoZmlsdHJvcy50YWcpIHtcbiAgICAgIC8vIEZpbHRyYXIgcG9yIHRhZyAoZXF1aXZhbGVudGUgYSBcInRhZ3MgTElLRSAnJXRhZyUnXCIpXG4gICAgICAvLyBJbXBsZW1lbnRhw6fDo28gc2ltcGxpZmljYWRhLCBlbSB1bSBjZW7DoXJpbyByZWFsIHNlcmlhIG1lbGhvciB1c2FyIHVtYSBhYm9yZGFnZW0gZXNwZWPDrWZpY2EgZG8gYmFuY28gZGUgZGFkb3NcbiAgICAgIHdoZXJlLnRhZ3MgPSBMaWtlKGAlJHtmaWx0cm9zLnRhZ30lYCk7XG4gICAgfVxuXG4gICAgLy8gQnVzY2FyIHRvdGFsIGRlIHJlZ2lzdHJvc1xuICAgIGNvbnN0IHRvdGFsID0gYXdhaXQgdGhpcy5tZXRyaWNhRGVmaW5pY2FvUmVwb3NpdG9yeS5jb3VudCh7IHdoZXJlIH0pO1xuXG4gICAgLy8gQnVzY2FyIG3DqXRyaWNhc1xuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5tZXRyaWNhRGVmaW5pY2FvUmVwb3NpdG9yeS5maW5kKHtcbiAgICAgIHdoZXJlLFxuICAgICAgb3JkZXI6IHtcbiAgICAgICAgY29kaWdvOiAnQVNDJyxcbiAgICAgIH0sXG4gICAgICBza2lwLFxuICAgICAgdGFrZTogbGltaXRlLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgaXRlbXMsIHRvdGFsIH07XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVtYSBtw6l0cmljYSAoZXhjbHVzw6NvIGzDs2dpY2EpXG4gICAqXG4gICAqIEBwYXJhbSBpZCBJRCBkYSBtw6l0cmljYSBhIHNlciByZW1vdmlkYVxuICAgKi9cbiAgYXN5bmMgcmVtb3Zlck1ldHJpY2EoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgUmVtb3ZlbmRvIG3DqXRyaWNhIGNvbSBJRDogJHtpZH1gKTtcblxuICAgIC8vIEJ1c2NhciBtw6l0cmljYSBleGlzdGVudGVcbiAgICBjb25zdCBtZXRyaWNhID0gYXdhaXQgdGhpcy5tZXRyaWNhRGVmaW5pY2FvUmVwb3NpdG9yeS5maW5kT25lKHtcbiAgICAgIHdoZXJlOiB7IGlkIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIW1ldHJpY2EpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbihgTcOpdHJpY2EgY29tIElEICR7aWR9IG7Do28gZW5jb250cmFkYWApO1xuICAgIH1cblxuICAgIC8vIEluYXRpdmFyIG3DqXRyaWNhIChleGNsdXPDo28gbMOzZ2ljYSlcbiAgICBhd2FpdCB0aGlzLm1ldHJpY2FEZWZpbmljYW9SZXBvc2l0b3J5LnVwZGF0ZShpZCwge1xuICAgICAgYXRpdmE6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgLy8gSW52YWxpZGFyIGNhY2hlIGRhIG3DqXRyaWNhXG4gICAgdGhpcy5jYWNoZVNlcnZpY2UuaW52YWxpZGFyQ2FjaGVNZXRyaWNhKGlkKTtcblxuICAgIC8vIEVtaXRpciBldmVudG8gcGFyYSBub3RpZmljYXIgcmVtb8Onw6NvIGRhIG3DqXRyaWNhXG4gICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnbWV0cmljYS5yZW1vdmlkYScsIHtcbiAgICAgIG1ldHJpY2FfaWQ6IGlkLFxuICAgICAgbWV0cmljYV9jb2RpZ286IG1ldHJpY2EuY29kaWdvLFxuICAgIH0pO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgYE3DqXRyaWNhIHJlbW92aWRhIGNvbSBzdWNlc3NvOiAke21ldHJpY2EuY29kaWdvfSAoSUQ6ICR7aWR9KWAsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmlhIGNvbmZpZ3VyYcOnw6NvIHBhcmEgdW1hIG3DqXRyaWNhXG4gICAqXG4gICAqIEBwYXJhbSBkdG8gRGFkb3MgZGEgY29uZmlndXJhw6fDo29cbiAgICogQHBhcmFtIHVzdWFyaW9JZCBJRCBkbyB1c3XDoXJpbyBxdWUgZXN0w6EgY3JpYW5kbyBhIGNvbmZpZ3VyYcOnw6NvXG4gICAqIEBwYXJhbSB1c3VhcmlvTm9tZSBOb21lIGRvIHVzdcOhcmlvIHF1ZSBlc3TDoSBjcmlhbmRvIGEgY29uZmlndXJhw6fDo29cbiAgICogQHJldHVybnMgQ29uZmlndXJhw6fDo28gY3JpYWRhXG4gICAqL1xuICBhc3luYyBjcmlhckNvbmZpZ3VyYWNhbyhcbiAgICBkdG86IENyaWFyTWV0cmljYUNvbmZpZ3VyYWNhb0R0byxcbiAgICB1c3VhcmlvSWQ6IHN0cmluZyxcbiAgICB1c3VhcmlvTm9tZTogc3RyaW5nLFxuICApOiBQcm9taXNlPE1ldHJpY2FDb25maWd1cmFjYW8+IHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYENyaWFuZG8gY29uZmlndXJhw6fDo28gcGFyYSBtw6l0cmljYTogJHtkdG8ubWV0cmljYV9pZH1gKTtcblxuICAgIC8vIFZlcmlmaWNhciBzZSBhIG3DqXRyaWNhIGV4aXN0ZVxuICAgIGNvbnN0IG1ldHJpY2EgPSBhd2FpdCB0aGlzLm1ldHJpY2FEZWZpbmljYW9SZXBvc2l0b3J5LmZpbmRPbmUoe1xuICAgICAgd2hlcmU6IHsgaWQ6IGR0by5tZXRyaWNhX2lkIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIW1ldHJpY2EpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbihcbiAgICAgICAgYE3DqXRyaWNhIGNvbSBJRCAke2R0by5tZXRyaWNhX2lkfSBuw6NvIGVuY29udHJhZGFgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZmljYXIgc2UgasOhIGV4aXN0ZSBjb25maWd1cmHDp8OjbyBwYXJhIGVzdGEgbcOpdHJpY2FcbiAgICBjb25zdCBjb25maWdFeGlzdGVudGUgPSBhd2FpdCB0aGlzLm1ldHJpY2FDb25maWd1cmFjYW9SZXBvc2l0b3J5LmZpbmRPbmUoe1xuICAgICAgd2hlcmU6IHsgbWV0cmljYV9pZDogZHRvLm1ldHJpY2FfaWQgfSxcbiAgICB9KTtcblxuICAgIGlmIChjb25maWdFeGlzdGVudGUpIHtcbiAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKFxuICAgICAgICBgSsOhIGV4aXN0ZSB1bWEgY29uZmlndXJhw6fDo28gcGFyYSBhIG3DqXRyaWNhICR7bWV0cmljYS5jb2RpZ299LiBVc2UgYSBhdHVhbGl6YcOnw6NvLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXIgY29uZmlndXJhw6fDtWVzIGVzcGVjw61maWNhcyBwYXJhIGNhZGEgdGlwbyBkZSBhZ2VuZGFtZW50b1xuICAgIGF3YWl0IHRoaXMudmFsaWRhckRhZG9zQ29uZmlndXJhY2FvKGR0byk7XG5cbiAgICAvLyBDcmlhciBub3ZhIGNvbmZpZ3VyYcOnw6NvXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5tZXRyaWNhQ29uZmlndXJhY2FvUmVwb3NpdG9yeS5jcmVhdGUoe1xuICAgICAgLi4uZHRvLFxuICAgICAgY3JpYWRvX3BvcjogYCR7dXN1YXJpb05vbWV9ICgke3VzdWFyaW9JZH0pYCxcbiAgICAgIGF0dWFsaXphZG9fcG9yOiBgJHt1c3VhcmlvTm9tZX0gKCR7dXN1YXJpb0lkfSlgLFxuICAgIH0pO1xuXG4gICAgLy8gU2FsdmFyIGNvbmZpZ3VyYcOnw6NvXG4gICAgY29uc3QgY29uZmlnU2FsdmEgPSBhd2FpdCB0aGlzLm1ldHJpY2FDb25maWd1cmFjYW9SZXBvc2l0b3J5LnNhdmUoY29uZmlnKTtcblxuICAgIC8vIEVtaXRpciBldmVudG8gcGFyYSBub3RpZmljYXIgY3JpYcOnw6NvIGRhIGNvbmZpZ3VyYcOnw6NvXG4gICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnbWV0cmljYS5jb25maWd1cmFjYW8uY3JpYWRhJywge1xuICAgICAgbWV0cmljYV9pZDogZHRvLm1ldHJpY2FfaWQsXG4gICAgICBjb25maWd1cmFjYW9faWQ6IGNvbmZpZ1NhbHZhLmlkLFxuICAgICAgdXN1YXJpb19pZDogdXN1YXJpb0lkLFxuICAgIH0pO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgYENvbmZpZ3VyYcOnw6NvIGNyaWFkYSBjb20gc3VjZXNzbyBwYXJhIG3DqXRyaWNhOiAke21ldHJpY2EuY29kaWdvfWAsXG4gICAgKTtcblxuICAgIHJldHVybiBjb25maWdTYWx2YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHVhbGl6YSBjb25maWd1cmHDp8OjbyBkZSB1bWEgbcOpdHJpY2FcbiAgICpcbiAgICogQHBhcmFtIGlkIElEIGRhIGNvbmZpZ3VyYcOnw6NvIGEgc2VyIGF0dWFsaXphZGFcbiAgICogQHBhcmFtIGR0byBEYWRvcyBwYXJhIGF0dWFsaXphw6fDo29cbiAgICogQHBhcmFtIHVzdWFyaW9JZCBJRCBkbyB1c3XDoXJpbyBxdWUgZXN0w6EgYXR1YWxpemFuZG8gYSBjb25maWd1cmHDp8Ojb1xuICAgKiBAcGFyYW0gdXN1YXJpb05vbWUgTm9tZSBkbyB1c3XDoXJpbyBxdWUgZXN0w6EgYXR1YWxpemFuZG8gYSBjb25maWd1cmHDp8Ojb1xuICAgKiBAcmV0dXJucyBDb25maWd1cmHDp8OjbyBhdHVhbGl6YWRhXG4gICAqL1xuICBhc3luYyBhdHVhbGl6YXJDb25maWd1cmFjYW8oXG4gICAgaWQ6IHN0cmluZyxcbiAgICBkdG86IEF0dWFsaXphck1ldHJpY2FDb25maWd1cmFjYW9EdG8sXG4gICAgdXN1YXJpb0lkOiBzdHJpbmcsXG4gICAgdXN1YXJpb05vbWU6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxNZXRyaWNhQ29uZmlndXJhY2FvPiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBBdHVhbGl6YW5kbyBjb25maWd1cmHDp8OjbyBjb20gSUQ6ICR7aWR9YCk7XG5cbiAgICAvLyBCdXNjYXIgY29uZmlndXJhw6fDo28gZXhpc3RlbnRlXG4gICAgY29uc3QgY29uZmlnID0gYXdhaXQgdGhpcy5tZXRyaWNhQ29uZmlndXJhY2FvUmVwb3NpdG9yeS5maW5kT25lKHtcbiAgICAgIHdoZXJlOiB7IGlkIH0sXG4gICAgICByZWxhdGlvbnM6IFsnbWV0cmljYSddLFxuICAgIH0pO1xuXG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbihgQ29uZmlndXJhw6fDo28gY29tIElEICR7aWR9IG7Do28gZW5jb250cmFkYWApO1xuICAgIH1cblxuICAgIC8vIENvbWJpbmFyIGRhZG9zIGF0dWFpcyBjb20gYXR1YWxpemHDp8O1ZXNcbiAgICBjb25zdCBjb25maWdBdHVhbGl6YWRhID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgLi4uZHRvLFxuICAgICAgYXR1YWxpemFkb19wb3I6IGAke3VzdWFyaW9Ob21lfSAoJHt1c3VhcmlvSWR9KWAsXG4gICAgfTtcblxuICAgIC8vIFZhbGlkYXIgY29uZmlndXJhw6fDtWVzIGVzcGVjw61maWNhcyBwYXJhIGNhZGEgdGlwbyBkZSBhZ2VuZGFtZW50b1xuICAgIGF3YWl0IHRoaXMudmFsaWRhckRhZG9zQ29uZmlndXJhY2FvKGNvbmZpZ0F0dWFsaXphZGEpO1xuXG4gICAgLy8gU2FsdmFyIGNvbmZpZ3VyYcOnw6NvIGF0dWFsaXphZGFcbiAgICBjb25zdCByZXN1bHRhZG8gPVxuICAgICAgYXdhaXQgdGhpcy5tZXRyaWNhQ29uZmlndXJhY2FvUmVwb3NpdG9yeS5zYXZlKGNvbmZpZ0F0dWFsaXphZGEpO1xuXG4gICAgLy8gSW52YWxpZGFyIGNhY2hlIGRhIG3DqXRyaWNhXG4gICAgdGhpcy5jYWNoZVNlcnZpY2UuaW52YWxpZGFyQ2FjaGVNZXRyaWNhKGNvbmZpZy5tZXRyaWNhX2lkKTtcblxuICAgIC8vIEVtaXRpciBldmVudG8gcGFyYSBub3RpZmljYXIgYXR1YWxpemHDp8OjbyBkYSBjb25maWd1cmHDp8Ojb1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ21ldHJpY2EuY29uZmlndXJhY2FvLmF0dWFsaXphZGEnLCB7XG4gICAgICBtZXRyaWNhX2lkOiBjb25maWcubWV0cmljYV9pZCxcbiAgICAgIGNvbmZpZ3VyYWNhb19pZDogcmVzdWx0YWRvLmlkLFxuICAgICAgdXN1YXJpb19pZDogdXN1YXJpb0lkLFxuICAgIH0pO1xuXG4gICAgLy8gQ2FycmVnYXIgYSBlbnRpZGFkZSBtZXRyaWNhIHBhcmEgYWNlc3NhciBzdWFzIHByb3ByaWVkYWRlcywgc2UgZGlzcG9uw612ZWxcbiAgICBsZXQgY29kaWdvTWV0cmljYSA9IGNvbmZpZy5tZXRyaWNhX2lkO1xuICAgIGlmIChjb25maWcubWV0cmljYSkge1xuICAgICAgY29uc3QgbWV0cmljYSA9IGF3YWl0IGNvbmZpZy5tZXRyaWNhO1xuICAgICAgY29kaWdvTWV0cmljYSA9IG1ldHJpY2EuY29kaWdvIHx8IGNvbmZpZy5tZXRyaWNhX2lkO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgIGBDb25maWd1cmHDp8OjbyBhdHVhbGl6YWRhIGNvbSBzdWNlc3NvIHBhcmEgbcOpdHJpY2E6ICR7Y29kaWdvTWV0cmljYX1gLFxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzdWx0YWRvO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1c2NhIGNvbmZpZ3VyYcOnw6NvIGRlIHVtYSBtw6l0cmljYVxuICAgKlxuICAgKiBAcGFyYW0gbWV0cmljYUlkIElEIGRhIG3DqXRyaWNhXG4gICAqIEByZXR1cm5zIENvbmZpZ3VyYcOnw6NvIGVuY29udHJhZGEgb3UgbnVsbFxuICAgKi9cbiAgYXN5bmMgYnVzY2FyQ29uZmlndXJhY2FvUG9yTWV0cmljYShcbiAgICBtZXRyaWNhSWQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxNZXRyaWNhQ29uZmlndXJhY2FvPiB7XG4gICAgY29uc3QgY29uZmlnID0gYXdhaXQgdGhpcy5tZXRyaWNhQ29uZmlndXJhY2FvUmVwb3NpdG9yeS5maW5kT25lKHtcbiAgICAgIHdoZXJlOiB7IG1ldHJpY2FfaWQ6IG1ldHJpY2FJZCB9LFxuICAgICAgcmVsYXRpb25zOiBbJ21ldHJpY2EnXSxcbiAgICB9KTtcblxuICAgIGlmICghY29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oXG4gICAgICAgIGBDb25maWd1cmHDp8OjbyBwYXJhIG3DqXRyaWNhICR7bWV0cmljYUlkfSBuw6NvIGVuY29udHJhZGFgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYSBkYWRvcyBlc3BlY8OtZmljb3MgcGFyYSBjYWRhIHRpcG8gZGUgbcOpdHJpY2FcbiAgICpcbiAgICogQHBhcmFtIG1ldHJpY2EgRGFkb3MgZGEgbcOpdHJpY2EgYSBzZXIgdmFsaWRhZGFcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdmFsaWRhckRhZG9zTWV0cmljYShcbiAgICBtZXRyaWNhOiBDcmlhck1ldHJpY2FEZWZpbmljYW9EdG8gfCBNZXRyaWNhRGVmaW5pY2FvLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBWYWxpZGFyIGZvcm1hdG8gZG8gY8OzZGlnbyAoc25ha2VfY2FzZSlcbiAgICBjb25zdCBjb2RpZ29SZWdleCA9IC9eW2Etel1bYS16MC05X10qJC87XG4gICAgaWYgKCFjb2RpZ29SZWdleC50ZXN0KG1ldHJpY2EuY29kaWdvKSkge1xuICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFeGNlcHRpb24oXG4gICAgICAgICdDw7NkaWdvIGRhIG3DqXRyaWNhIGRldmUgZXN0YXIgZW0gZm9ybWF0byBzbmFrZV9jYXNlIChhcGVuYXMgbGV0cmFzIG1pbsO6c2N1bGFzLCBuw7ptZXJvcyBlIHVuZGVyc2NvcmUpJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChtZXRyaWNhLnRpcG8pIHtcbiAgICAgIGNhc2UgVGlwb01ldHJpY2EuQ09OVEFHRU06XG4gICAgICBjYXNlIFRpcG9NZXRyaWNhLlNPTUE6XG4gICAgICBjYXNlIFRpcG9NZXRyaWNhLk1FRElBOlxuICAgICAgY2FzZSBUaXBvTWV0cmljYS5NSU5JTU86XG4gICAgICBjYXNlIFRpcG9NZXRyaWNhLk1BWElNTzpcbiAgICAgIGNhc2UgVGlwb01ldHJpY2EuQ0FSRElOQUxJREFERTpcbiAgICAgICAgLy8gVmFsaWRhciBjb25zdWx0YSBTUUxcbiAgICAgICAgaWYgKCFtZXRyaWNhLnNxbF9jb25zdWx0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKFxuICAgICAgICAgICAgYE3DqXRyaWNhcyBkbyB0aXBvICR7bWV0cmljYS50aXBvfSByZXF1ZXJlbSB1bWEgY29uc3VsdGEgU1FMYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFRpcG9NZXRyaWNhLlBFUkNFTlRJTDpcbiAgICAgICAgLy8gVmFsaWRhciBjb25zdWx0YSBTUUwgZSBwYXLDom1ldHJvIGRlIHBlcmNlbnRpbFxuICAgICAgICBpZiAoIW1ldHJpY2Euc3FsX2NvbnN1bHRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFeGNlcHRpb24oXG4gICAgICAgICAgICAnTcOpdHJpY2FzIGRvIHRpcG8gUEVSQ0VOVElMIHJlcXVlcmVtIHVtYSBjb25zdWx0YSBTUUwnLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1ldHJpY2EucGFyYW1ldHJvc19lc3BlY2lmaWNvcz8ucGVyY2VudGlsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFeGNlcHRpb24oXG4gICAgICAgICAgICAnTcOpdHJpY2FzIGRvIHRpcG8gUEVSQ0VOVElMIHJlcXVlcmVtIG8gcGFyw6JtZXRybyBcInBlcmNlbnRpbFwiIChleDogOTUpJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGVyY2VudGlsID0gTnVtYmVyKG1ldHJpY2EucGFyYW1ldHJvc19lc3BlY2lmaWNvcy5wZXJjZW50aWwpO1xuICAgICAgICBpZiAoaXNOYU4ocGVyY2VudGlsKSB8fCBwZXJjZW50aWwgPCAwIHx8IHBlcmNlbnRpbCA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKFxuICAgICAgICAgICAgJ08gdmFsb3IgZG8gcGVyY2VudGlsIGRldmUgc2VyIHVtIG7Dum1lcm8gZW50cmUgMCBlIDEwMCcsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUaXBvTWV0cmljYS5DT01QT1NUQTpcbiAgICAgICAgLy8gVmFsaWRhciBmw7NybXVsYSBlIG3DqXRyaWNhcyBkZXBlbmRlbnRlc1xuICAgICAgICBpZiAoIW1ldHJpY2EuZm9ybXVsYV9jYWxjdWxvKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFeGNlcHRpb24oXG4gICAgICAgICAgICAnTcOpdHJpY2FzIGRvIHRpcG8gQ09NUE9TVEEgcmVxdWVyZW0gdW1hIGbDs3JtdWxhIGRlIGPDoWxjdWxvJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFtZXRyaWNhLm1ldHJpY2FzX2RlcGVuZGVudGVzIHx8XG4gICAgICAgICAgbWV0cmljYS5tZXRyaWNhc19kZXBlbmRlbnRlcy5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFeGNlcHRpb24oXG4gICAgICAgICAgICAnTcOpdHJpY2FzIGRvIHRpcG8gQ09NUE9TVEEgcmVxdWVyZW0gYSBkZWZpbmnDp8OjbyBkZSBtw6l0cmljYXMgZGVwZW5kZW50ZXMnLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZmljYXIgc2UgYXMgbcOpdHJpY2FzIGRlcGVuZGVudGVzIGV4aXN0ZW1cbiAgICAgICAgZm9yIChjb25zdCBjb2RpZ29EZXBlbmRlbnRlIG9mIG1ldHJpY2EubWV0cmljYXNfZGVwZW5kZW50ZXMpIHtcbiAgICAgICAgICAvLyBJZ25vcmFyIGEgcHLDs3ByaWEgbcOpdHJpY2Egc2VuZG8gZWRpdGFkYVxuICAgICAgICAgIGlmIChjb2RpZ29EZXBlbmRlbnRlID09PSBtZXRyaWNhLmNvZGlnbykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGVwZW5kZW50ZSA9IGF3YWl0IHRoaXMubWV0cmljYURlZmluaWNhb1JlcG9zaXRvcnkuZmluZE9uZSh7XG4gICAgICAgICAgICB3aGVyZTogeyBjb2RpZ286IGNvZGlnb0RlcGVuZGVudGUgfSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghZGVwZW5kZW50ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFeGNlcHRpb24oXG4gICAgICAgICAgICAgIGBNw6l0cmljYSBkZXBlbmRlbnRlICcke2NvZGlnb0RlcGVuZGVudGV9JyBuw6NvIGVuY29udHJhZGFgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVGlwb01ldHJpY2EuVEFYQV9WQVJJQUNBTzpcbiAgICAgICAgLy8gVmFsaWRhciBjb25zdWx0YSBTUUxcbiAgICAgICAgaWYgKCFtZXRyaWNhLnNxbF9jb25zdWx0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKFxuICAgICAgICAgICAgJ03DqXRyaWNhcyBkbyB0aXBvIFRBWEFfVkFSSUFDQU8gcmVxdWVyZW0gdW1hIGNvbnN1bHRhIFNRTCcsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFeGNlcHRpb24oXG4gICAgICAgICAgYFRpcG8gZGUgbcOpdHJpY2EgbsOjbyBzdXBvcnRhZG86ICR7bWV0cmljYS50aXBvfWAsXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYSBkYWRvcyBlc3BlY8OtZmljb3MgcGFyYSBjYWRhIHRpcG8gZGUgYWdlbmRhbWVudG9cbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyBEYWRvcyBkYSBjb25maWd1cmHDp8OjbyBhIHNlciB2YWxpZGFkYVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB2YWxpZGFyRGFkb3NDb25maWd1cmFjYW8oXG4gICAgY29uZmlnOiBDcmlhck1ldHJpY2FDb25maWd1cmFjYW9EdG8gfCBNZXRyaWNhQ29uZmlndXJhY2FvLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoY29uZmlnLnRpcG9fYWdlbmRhbWVudG8gPT09ICdjcm9uJyAmJiAhY29uZmlnLmV4cHJlc3Nhb19jcm9uKSB7XG4gICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEV4Y2VwdGlvbihcbiAgICAgICAgJ0FnZW5kYW1lbnRvIGRvIHRpcG8gQ1JPTiByZXF1ZXIgYSBkZWZpbmnDp8OjbyBkZSB1bWEgZXhwcmVzc8OjbyBjcm9uJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy50aXBvX2FnZW5kYW1lbnRvID09PSAnZXZlbnRvJyAmJiAhY29uZmlnLm5vbWVfZXZlbnRvKSB7XG4gICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEV4Y2VwdGlvbihcbiAgICAgICAgJ0FnZW5kYW1lbnRvIGRvIHRpcG8gRVZFTlRPIHJlcXVlciBhIGRlZmluacOnw6NvIGRvIG5vbWUgZG8gZXZlbnRvJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgY29uZmlnLmVzdHJhdGVnaWFfYW1vc3RyYWdlbSAhPT0gJ2NvbXBsZXRhJyAmJlxuICAgICAgIWNvbmZpZy50YW1hbmhvX2Ftb3N0cmFcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKFxuICAgICAgICBgRXN0cmF0w6lnaWEgZGUgYW1vc3RyYWdlbSAnJHtjb25maWcuZXN0cmF0ZWdpYV9hbW9zdHJhZ2VtfScgcmVxdWVyIGEgZGVmaW5pw6fDo28gZG8gdGFtYW5obyBkYSBhbW9zdHJhYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhciBhbGVydGFzXG4gICAgaWYgKGNvbmZpZy5hbGVydGFzICYmIGNvbmZpZy5hbGVydGFzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgYWxlcnRhIG9mIGNvbmZpZy5hbGVydGFzKSB7XG4gICAgICAgIGlmICghYWxlcnRhLnRpcG8pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEV4Y2VwdGlvbihcbiAgICAgICAgICAgICdDYWRhIGFsZXJ0YSBkZXZlIHRlciB1bSB0aXBvIGRlZmluaWRvJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsZXJ0YS52YWxvciA9PT0gdW5kZWZpbmVkIHx8IGFsZXJ0YS52YWxvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKFxuICAgICAgICAgICAgYEFsZXJ0YSBkbyB0aXBvICcke2FsZXJ0YS50aXBvfScgcmVxdWVyIHVtIHZhbG9yIGRlIHJlZmVyw6puY2lhYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbGVydGEuc2V2ZXJpZGFkZSkge1xuICAgICAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXhjZXB0aW9uKFxuICAgICAgICAgICAgYEFsZXJ0YSBkbyB0aXBvICcke2FsZXJ0YS50aXBvfScgcmVxdWVyIHVtYSBzZXZlcmlkYWRlIGRlZmluaWRhYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwidmVyc2lvbiI6M30=