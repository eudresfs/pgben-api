fa973d3c8dc58b821890258fad9bca6a
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricaDefinicao = exports.GranularidadeTemporal = exports.CategoriaMetrica = exports.TipoMetrica = void 0;
const typeorm_1 = require("typeorm");
const metrica_snapshot_entity_1 = require("./metrica-snapshot.entity");
const metrica_configuracao_entity_1 = require("./metrica-configuracao.entity");
/**
 * Tipos de métricas suportados pelo sistema
 */
var TipoMetrica;
(function (TipoMetrica) {
    /** Contagem simples de ocorrências */
    TipoMetrica["CONTAGEM"] = "contagem";
    /** Soma de valores */
    TipoMetrica["SOMA"] = "soma";
    /** Média de valores */
    TipoMetrica["MEDIA"] = "media";
    /** Valor mínimo */
    TipoMetrica["MINIMO"] = "minimo";
    /** Valor máximo */
    TipoMetrica["MAXIMO"] = "maximo";
    /** Métrica calculada a partir de outras métricas usando fórmula personalizada */
    TipoMetrica["COMPOSTA"] = "composta";
    /** Percentil (requer parâmetro adicional) */
    TipoMetrica["PERCENTIL"] = "percentil";
    /** Contagem de valores distintos */
    TipoMetrica["CARDINALIDADE"] = "cardinalidade";
    /** Taxa de variação entre períodos */
    TipoMetrica["TAXA_VARIACAO"] = "taxa_variacao";
})(TipoMetrica || (exports.TipoMetrica = TipoMetrica = {}));
/**
 * Categorias de métricas para organização
 */
var CategoriaMetrica;
(function (CategoriaMetrica) {
    CategoriaMetrica["FINANCEIRO"] = "financeiro";
    CategoriaMetrica["OPERACIONAL"] = "operacional";
    CategoriaMetrica["DESEMPENHO"] = "desempenho";
    CategoriaMetrica["QUALIDADE"] = "qualidade";
    CategoriaMetrica["USUARIO"] = "usuario";
    CategoriaMetrica["BENEFICIO"] = "beneficio";
    CategoriaMetrica["PROCESSAMENTO"] = "processamento";
    CategoriaMetrica["SISTEMA"] = "sistema";
})(CategoriaMetrica || (exports.CategoriaMetrica = CategoriaMetrica = {}));
/**
 * Granularidades temporais suportadas para agregação
 */
var GranularidadeTemporal;
(function (GranularidadeTemporal) {
    GranularidadeTemporal["MINUTO"] = "minuto";
    GranularidadeTemporal["HORA"] = "hora";
    GranularidadeTemporal["DIA"] = "dia";
    GranularidadeTemporal["SEMANA"] = "semana";
    GranularidadeTemporal["MES"] = "mes";
    GranularidadeTemporal["TRIMESTRE"] = "trimestre";
    GranularidadeTemporal["ANO"] = "ano";
})(GranularidadeTemporal || (exports.GranularidadeTemporal = GranularidadeTemporal = {}));
/**
 * Definição de uma métrica no sistema
 *
 * Esta entidade armazena a definição de cada métrica, incluindo sua fórmula
 * de cálculo, tipo, categoria, e configurações de coleta e armazenamento.
 */
let MetricaDefinicao = class MetricaDefinicao {
    id;
    /**
     * Código único da métrica (snake_case)
     * Exemplo: 'tempo_medio_processamento_beneficio'
     */
    codigo;
    /**
     * Nome de exibição da métrica
     * Exemplo: 'Tempo Médio de Processamento de Benefício'
     */
    nome;
    /**
     * Descrição detalhada da métrica
     */
    descricao;
    /**
     * Tipo da métrica (contagem, soma, média, etc.)
     */
    tipo;
    /**
     * Categoria da métrica para organização
     */
    categoria;
    /**
     * Unidade de medida da métrica
     * Exemplo: 'segundos', 'reais', 'percentual', 'quantidade'
     */
    unidade;
    /**
     * Prefixo a ser exibido antes do valor
     * Exemplo: 'R$', '$'
     */
    prefixo;
    /**
     * Sufixo a ser exibido após o valor
     * Exemplo: '%', 'ms'
     */
    sufixo;
    /**
     * Número de casas decimais a serem exibidas
     */
    casas_decimais;
    /**
     * Consulta SQL para coletar dados (para métricas baseadas em banco de dados)
     */
    sql_consulta;
    /**
     * Fórmula para cálculo (para métricas compostas)
     * Pode referenciar outras métricas usando seus códigos
     * Exemplo: 'metrica_a / metrica_b * 100'
     */
    formula_calculo;
    /**
     * Fonte de dados da métrica
     * Exemplo: 'banco_dados', 'api', 'evento', 'arquivo'
     */
    fonte_dados;
    /**
     * Especificação de como agregar os dados em diferentes períodos
     * Exemplo: 'soma', 'media', 'ultimo', 'primeiro'
     */
    agregacao_temporal;
    /**
     * Granularidade mínima de coleta/armazenamento
     */
    granularidade;
    /**
     * Referência a outras métricas utilizadas no cálculo (caso seja composta)
     * Armazenado como array de códigos de métricas
     */
    metricas_dependentes;
    /**
     * Flag que indica se a métrica está ativa para coleta
     */
    ativa;
    /**
     * Parâmetros específicos para o tipo de métrica
     * Armazenado como JSON
     * Exemplo para PERCENTIL: { "percentil": 95 }
     */
    parametros_especificos;
    /**
     * Tags para filtrar e categorizar métricas
     */
    tags;
    /**
     * Versão atual da definição da métrica
     */
    versao;
    /**
     * Data da última coleta bem-sucedida
     */
    ultima_coleta;
    /**
     * Flag que indica se a métrica é calculada em tempo real ou pré-calculada
     */
    calculo_tempo_real;
    /**
     * Usuário que criou a métrica
     */
    criado_por;
    /**
     * Usuário que atualizou a métrica pela última vez
     */
    atualizado_por;
    /**
     * Data de criação do registro
     */
    created_at;
    /**
     * Data da última atualização do registro
     */
    updated_at;
    /**
     * Relacionamento com snapshots históricos da métrica
     *
     * Usando lazy loading para evitar dependências circulares
     */
    snapshots;
    /**
     * Relacionamento com configurações de coleta e armazenamento
     *
     * Usando lazy loading para evitar dependências circulares
     */
    configuracoes;
};
exports.MetricaDefinicao = MetricaDefinicao;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)('uuid'),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ length: 100, unique: true }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "codigo", void 0);
__decorate([
    (0, typeorm_1.Column)({ length: 100 }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "nome", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text' }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "descricao", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: TipoMetrica,
        enumName: 'tipo_metrica',
        default: TipoMetrica.CONTAGEM,
    }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "tipo", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: CategoriaMetrica,
        enumName: 'categoria_metrica',
        default: CategoriaMetrica.OPERACIONAL,
    }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "categoria", void 0);
__decorate([
    (0, typeorm_1.Column)({ length: 50, nullable: true }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "unidade", void 0);
__decorate([
    (0, typeorm_1.Column)({ length: 10, nullable: true }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "prefixo", void 0);
__decorate([
    (0, typeorm_1.Column)({ length: 10, nullable: true }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "sufixo", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 2 }),
    __metadata("design:type", Number)
], MetricaDefinicao.prototype, "casas_decimais", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "sql_consulta", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'text', nullable: true }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "formula_calculo", void 0);
__decorate([
    (0, typeorm_1.Column)({ length: 50, default: 'banco_dados' }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "fonte_dados", void 0);
__decorate([
    (0, typeorm_1.Column)({ length: 20, default: 'soma' }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "agregacao_temporal", void 0);
__decorate([
    (0, typeorm_1.Column)({
        type: 'enum',
        enum: GranularidadeTemporal,
        enumName: 'granularidade_temporal',
        default: GranularidadeTemporal.DIA,
    }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "granularidade", void 0);
__decorate([
    (0, typeorm_1.Column)('simple-array', { nullable: true }),
    __metadata("design:type", Array)
], MetricaDefinicao.prototype, "metricas_dependentes", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: true }),
    __metadata("design:type", Boolean)
], MetricaDefinicao.prototype, "ativa", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'jsonb', nullable: true }),
    __metadata("design:type", typeof (_a = typeof Record !== "undefined" && Record) === "function" ? _a : Object)
], MetricaDefinicao.prototype, "parametros_especificos", void 0);
__decorate([
    (0, typeorm_1.Column)('simple-array', { nullable: true }),
    __metadata("design:type", Array)
], MetricaDefinicao.prototype, "tags", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: 1 }),
    __metadata("design:type", Number)
], MetricaDefinicao.prototype, "versao", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: 'timestamp', nullable: true }),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], MetricaDefinicao.prototype, "ultima_coleta", void 0);
__decorate([
    (0, typeorm_1.Column)({ default: false }),
    __metadata("design:type", Boolean)
], MetricaDefinicao.prototype, "calculo_tempo_real", void 0);
__decorate([
    (0, typeorm_1.Column)({ length: 100, nullable: true }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "criado_por", void 0);
__decorate([
    (0, typeorm_1.Column)({ length: 100, nullable: true }),
    __metadata("design:type", String)
], MetricaDefinicao.prototype, "atualizado_por", void 0);
__decorate([
    (0, typeorm_1.CreateDateColumn)(),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], MetricaDefinicao.prototype, "created_at", void 0);
__decorate([
    (0, typeorm_1.UpdateDateColumn)(),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], MetricaDefinicao.prototype, "updated_at", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => metrica_snapshot_entity_1.MetricaSnapshot, (snapshot) => snapshot.definicao, {
        lazy: true,
    }),
    __metadata("design:type", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], MetricaDefinicao.prototype, "snapshots", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => metrica_configuracao_entity_1.MetricaConfiguracao, (config) => config.metrica, {
        lazy: true,
    }),
    __metadata("design:type", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], MetricaDefinicao.prototype, "configuracoes", void 0);
exports.MetricaDefinicao = MetricaDefinicao = __decorate([
    (0, typeorm_1.Entity)('metrica_definicao'),
    (0, typeorm_1.Index)(['codigo'], { unique: true })
], MetricaDefinicao);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXGVudGl0aWVzXFxtZXRyaWNhLWRlZmluaWNhby5lbnRpdHkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLHFDQVFpQjtBQUNqQix1RUFBNEQ7QUFDNUQsK0VBQW9FO0FBRXBFOztHQUVHO0FBQ0gsSUFBWSxXQTJCWDtBQTNCRCxXQUFZLFdBQVc7SUFDckIsc0NBQXNDO0lBQ3RDLG9DQUFxQixDQUFBO0lBRXJCLHNCQUFzQjtJQUN0Qiw0QkFBYSxDQUFBO0lBRWIsdUJBQXVCO0lBQ3ZCLDhCQUFlLENBQUE7SUFFZixtQkFBbUI7SUFDbkIsZ0NBQWlCLENBQUE7SUFFakIsbUJBQW1CO0lBQ25CLGdDQUFpQixDQUFBO0lBRWpCLGlGQUFpRjtJQUNqRixvQ0FBcUIsQ0FBQTtJQUVyQiw2Q0FBNkM7SUFDN0Msc0NBQXVCLENBQUE7SUFFdkIsb0NBQW9DO0lBQ3BDLDhDQUErQixDQUFBO0lBRS9CLHNDQUFzQztJQUN0Qyw4Q0FBK0IsQ0FBQTtBQUNqQyxDQUFDLEVBM0JXLFdBQVcsMkJBQVgsV0FBVyxRQTJCdEI7QUFFRDs7R0FFRztBQUNILElBQVksZ0JBU1g7QUFURCxXQUFZLGdCQUFnQjtJQUMxQiw2Q0FBeUIsQ0FBQTtJQUN6QiwrQ0FBMkIsQ0FBQTtJQUMzQiw2Q0FBeUIsQ0FBQTtJQUN6QiwyQ0FBdUIsQ0FBQTtJQUN2Qix1Q0FBbUIsQ0FBQTtJQUNuQiwyQ0FBdUIsQ0FBQTtJQUN2QixtREFBK0IsQ0FBQTtJQUMvQix1Q0FBbUIsQ0FBQTtBQUNyQixDQUFDLEVBVFcsZ0JBQWdCLGdDQUFoQixnQkFBZ0IsUUFTM0I7QUFFRDs7R0FFRztBQUNILElBQVkscUJBUVg7QUFSRCxXQUFZLHFCQUFxQjtJQUMvQiwwQ0FBaUIsQ0FBQTtJQUNqQixzQ0FBYSxDQUFBO0lBQ2Isb0NBQVcsQ0FBQTtJQUNYLDBDQUFpQixDQUFBO0lBQ2pCLG9DQUFXLENB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ZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxlbnRpdGllc1xcbWV0cmljYS1kZWZpbmljYW8uZW50aXR5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEVudGl0eSxcbiAgQ29sdW1uLFxuICBQcmltYXJ5R2VuZXJhdGVkQ29sdW1uLFxuICBDcmVhdGVEYXRlQ29sdW1uLFxuICBVcGRhdGVEYXRlQ29sdW1uLFxuICBPbmVUb01hbnksXG4gIEluZGV4LFxufSBmcm9tICd0eXBlb3JtJztcbmltcG9ydCB7IE1ldHJpY2FTbmFwc2hvdCB9IGZyb20gJy4vbWV0cmljYS1zbmFwc2hvdC5lbnRpdHknO1xuaW1wb3J0IHsgTWV0cmljYUNvbmZpZ3VyYWNhbyB9IGZyb20gJy4vbWV0cmljYS1jb25maWd1cmFjYW8uZW50aXR5JztcblxuLyoqXG4gKiBUaXBvcyBkZSBtw6l0cmljYXMgc3Vwb3J0YWRvcyBwZWxvIHNpc3RlbWFcbiAqL1xuZXhwb3J0IGVudW0gVGlwb01ldHJpY2Ege1xuICAvKiogQ29udGFnZW0gc2ltcGxlcyBkZSBvY29ycsOqbmNpYXMgKi9cbiAgQ09OVEFHRU0gPSAnY29udGFnZW0nLFxuXG4gIC8qKiBTb21hIGRlIHZhbG9yZXMgKi9cbiAgU09NQSA9ICdzb21hJyxcblxuICAvKiogTcOpZGlhIGRlIHZhbG9yZXMgKi9cbiAgTUVESUEgPSAnbWVkaWEnLFxuXG4gIC8qKiBWYWxvciBtw61uaW1vICovXG4gIE1JTklNTyA9ICdtaW5pbW8nLFxuXG4gIC8qKiBWYWxvciBtw6F4aW1vICovXG4gIE1BWElNTyA9ICdtYXhpbW8nLFxuXG4gIC8qKiBNw6l0cmljYSBjYWxjdWxhZGEgYSBwYXJ0aXIgZGUgb3V0cmFzIG3DqXRyaWNhcyB1c2FuZG8gZsOzcm11bGEgcGVyc29uYWxpemFkYSAqL1xuICBDT01QT1NUQSA9ICdjb21wb3N0YScsXG5cbiAgLyoqIFBlcmNlbnRpbCAocmVxdWVyIHBhcsOibWV0cm8gYWRpY2lvbmFsKSAqL1xuICBQRVJDRU5USUwgPSAncGVyY2VudGlsJyxcblxuICAvKiogQ29udGFnZW0gZGUgdmFsb3JlcyBkaXN0aW50b3MgKi9cbiAgQ0FSRElOQUxJREFERSA9ICdjYXJkaW5hbGlkYWRlJyxcblxuICAvKiogVGF4YSBkZSB2YXJpYcOnw6NvIGVudHJlIHBlcsOtb2RvcyAqL1xuICBUQVhBX1ZBUklBQ0FPID0gJ3RheGFfdmFyaWFjYW8nLFxufVxuXG4vKipcbiAqIENhdGVnb3JpYXMgZGUgbcOpdHJpY2FzIHBhcmEgb3JnYW5pemHDp8Ojb1xuICovXG5leHBvcnQgZW51bSBDYXRlZ29yaWFNZXRyaWNhIHtcbiAgRklOQU5DRUlSTyA9ICdmaW5hbmNlaXJvJyxcbiAgT1BFUkFDSU9OQUwgPSAnb3BlcmFjaW9uYWwnLFxuICBERVNFTVBFTkhPID0gJ2Rlc2VtcGVuaG8nLFxuICBRVUFMSURBREUgPSAncXVhbGlkYWRlJyxcbiAgVVNVQVJJTyA9ICd1c3VhcmlvJyxcbiAgQkVORUZJQ0lPID0gJ2JlbmVmaWNpbycsXG4gIFBST0NFU1NBTUVOVE8gPSAncHJvY2Vzc2FtZW50bycsXG4gIFNJU1RFTUEgPSAnc2lzdGVtYScsXG59XG5cbi8qKlxuICogR3JhbnVsYXJpZGFkZXMgdGVtcG9yYWlzIHN1cG9ydGFkYXMgcGFyYSBhZ3JlZ2HDp8Ojb1xuICovXG5leHBvcnQgZW51bSBHcmFudWxhcmlkYWRlVGVtcG9yYWwge1xuICBNSU5VVE8gPSAnbWludXRvJyxcbiAgSE9SQSA9ICdob3JhJyxcbiAgRElBID0gJ2RpYScsXG4gIFNFTUFOQSA9ICdzZW1hbmEnLFxuICBNRVMgPSAnbWVzJyxcbiAgVFJJTUVTVFJFID0gJ3RyaW1lc3RyZScsXG4gIEFOTyA9ICdhbm8nLFxufVxuXG4vKipcbiAqIERlZmluacOnw6NvIGRlIHVtYSBtw6l0cmljYSBubyBzaXN0ZW1hXG4gKlxuICogRXN0YSBlbnRpZGFkZSBhcm1hemVuYSBhIGRlZmluacOnw6NvIGRlIGNhZGEgbcOpdHJpY2EsIGluY2x1aW5kbyBzdWEgZsOzcm11bGFcbiAqIGRlIGPDoWxjdWxvLCB0aXBvLCBjYXRlZ29yaWEsIGUgY29uZmlndXJhw6fDtWVzIGRlIGNvbGV0YSBlIGFybWF6ZW5hbWVudG8uXG4gKi9cbkBFbnRpdHkoJ21ldHJpY2FfZGVmaW5pY2FvJylcbkBJbmRleChbJ2NvZGlnbyddLCB7IHVuaXF1ZTogdHJ1ZSB9KVxuZXhwb3J0IGNsYXNzIE1ldHJpY2FEZWZpbmljYW8ge1xuICBAUHJpbWFyeUdlbmVyYXRlZENvbHVtbigndXVpZCcpXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEPDs2RpZ28gw7puaWNvIGRhIG3DqXRyaWNhIChzbmFrZV9jYXNlKVxuICAgKiBFeGVtcGxvOiAndGVtcG9fbWVkaW9fcHJvY2Vzc2FtZW50b19iZW5lZmljaW8nXG4gICAqL1xuICBAQ29sdW1uKHsgbGVuZ3RoOiAxMDAsIHVuaXF1ZTogdHJ1ZSB9KVxuICBjb2RpZ286IHN0cmluZztcblxuICAvKipcbiAgICogTm9tZSBkZSBleGliacOnw6NvIGRhIG3DqXRyaWNhXG4gICAqIEV4ZW1wbG86ICdUZW1wbyBNw6lkaW8gZGUgUHJvY2Vzc2FtZW50byBkZSBCZW5lZsOtY2lvJ1xuICAgKi9cbiAgQENvbHVtbih7IGxlbmd0aDogMTAwIH0pXG4gIG5vbWU6IHN0cmluZztcblxuICAvKipcbiAgICogRGVzY3Jpw6fDo28gZGV0YWxoYWRhIGRhIG3DqXRyaWNhXG4gICAqL1xuICBAQ29sdW1uKHsgdHlwZTogJ3RleHQnIH0pXG4gIGRlc2NyaWNhbzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaXBvIGRhIG3DqXRyaWNhIChjb250YWdlbSwgc29tYSwgbcOpZGlhLCBldGMuKVxuICAgKi9cbiAgQENvbHVtbih7XG4gICAgdHlwZTogJ2VudW0nLFxuICAgIGVudW06IFRpcG9NZXRyaWNhLFxuICAgIGVudW1OYW1lOiAndGlwb19tZXRyaWNhJyxcbiAgICBkZWZhdWx0OiBUaXBvTWV0cmljYS5DT05UQUdFTSxcbiAgfSlcbiAgdGlwbzogVGlwb01ldHJpY2E7XG5cbiAgLyoqXG4gICAqIENhdGVnb3JpYSBkYSBtw6l0cmljYSBwYXJhIG9yZ2FuaXphw6fDo29cbiAgICovXG4gIEBDb2x1bW4oe1xuICAgIHR5cGU6ICdlbnVtJyxcbiAgICBlbnVtOiBDYXRlZ29yaWFNZXRyaWNhLFxuICAgIGVudW1OYW1lOiAnY2F0ZWdvcmlhX21ldHJpY2EnLFxuICAgIGRlZmF1bHQ6IENhdGVnb3JpYU1ldHJpY2EuT1BFUkFDSU9OQUwsXG4gIH0pXG4gIGNhdGVnb3JpYTogQ2F0ZWdvcmlhTWV0cmljYTtcblxuICAvKipcbiAgICogVW5pZGFkZSBkZSBtZWRpZGEgZGEgbcOpdHJpY2FcbiAgICogRXhlbXBsbzogJ3NlZ3VuZG9zJywgJ3JlYWlzJywgJ3BlcmNlbnR1YWwnLCAncXVhbnRpZGFkZSdcbiAgICovXG4gIEBDb2x1bW4oeyBsZW5ndGg6IDUwLCBudWxsYWJsZTogdHJ1ZSB9KVxuICB1bmlkYWRlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFByZWZpeG8gYSBzZXIgZXhpYmlkbyBhbnRlcyBkbyB2YWxvclxuICAgKiBFeGVtcGxvOiAnUiQnLCAnJCdcbiAgICovXG4gIEBDb2x1bW4oeyBsZW5ndGg6IDEwLCBudWxsYWJsZTogdHJ1ZSB9KVxuICBwcmVmaXhvOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFN1Zml4byBhIHNlciBleGliaWRvIGFww7NzIG8gdmFsb3JcbiAgICogRXhlbXBsbzogJyUnLCAnbXMnXG4gICAqL1xuICBAQ29sdW1uKHsgbGVuZ3RoOiAxMCwgbnVsbGFibGU6IHRydWUgfSlcbiAgc3VmaXhvOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE7Dum1lcm8gZGUgY2FzYXMgZGVjaW1haXMgYSBzZXJlbSBleGliaWRhc1xuICAgKi9cbiAgQENvbHVtbih7IGRlZmF1bHQ6IDIgfSlcbiAgY2FzYXNfZGVjaW1haXM6IG51bWJlcjtcblxuICAvKipcbiAgICogQ29uc3VsdGEgU1FMIHBhcmEgY29sZXRhciBkYWRvcyAocGFyYSBtw6l0cmljYXMgYmFzZWFkYXMgZW0gYmFuY28gZGUgZGFkb3MpXG4gICAqL1xuICBAQ29sdW1uKHsgdHlwZTogJ3RleHQnLCBudWxsYWJsZTogdHJ1ZSB9KVxuICBzcWxfY29uc3VsdGE6IHN0cmluZztcblxuICAvKipcbiAgICogRsOzcm11bGEgcGFyYSBjw6FsY3VsbyAocGFyYSBtw6l0cmljYXMgY29tcG9zdGFzKVxuICAgKiBQb2RlIHJlZmVyZW5jaWFyIG91dHJhcyBtw6l0cmljYXMgdXNhbmRvIHNldXMgY8OzZGlnb3NcbiAgICogRXhlbXBsbzogJ21ldHJpY2FfYSAvIG1ldHJpY2FfYiAqIDEwMCdcbiAgICovXG4gIEBDb2x1bW4oeyB0eXBlOiAndGV4dCcsIG51bGxhYmxlOiB0cnVlIH0pXG4gIGZvcm11bGFfY2FsY3Vsbzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGb250ZSBkZSBkYWRvcyBkYSBtw6l0cmljYVxuICAgKiBFeGVtcGxvOiAnYmFuY29fZGFkb3MnLCAnYXBpJywgJ2V2ZW50bycsICdhcnF1aXZvJ1xuICAgKi9cbiAgQENvbHVtbih7IGxlbmd0aDogNTAsIGRlZmF1bHQ6ICdiYW5jb19kYWRvcycgfSlcbiAgZm9udGVfZGFkb3M6IHN0cmluZztcblxuICAvKipcbiAgICogRXNwZWNpZmljYcOnw6NvIGRlIGNvbW8gYWdyZWdhciBvcyBkYWRvcyBlbSBkaWZlcmVudGVzIHBlcsOtb2Rvc1xuICAgKiBFeGVtcGxvOiAnc29tYScsICdtZWRpYScsICd1bHRpbW8nLCAncHJpbWVpcm8nXG4gICAqL1xuICBAQ29sdW1uKHsgbGVuZ3RoOiAyMCwgZGVmYXVsdDogJ3NvbWEnIH0pXG4gIGFncmVnYWNhb190ZW1wb3JhbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHcmFudWxhcmlkYWRlIG3DrW5pbWEgZGUgY29sZXRhL2FybWF6ZW5hbWVudG9cbiAgICovXG4gIEBDb2x1bW4oe1xuICAgIHR5cGU6ICdlbnVtJyxcbiAgICBlbnVtOiBHcmFudWxhcmlkYWRlVGVtcG9yYWwsXG4gICAgZW51bU5hbWU6ICdncmFudWxhcmlkYWRlX3RlbXBvcmFsJyxcbiAgICBkZWZhdWx0OiBHcmFudWxhcmlkYWRlVGVtcG9yYWwuRElBLFxuICB9KVxuICBncmFudWxhcmlkYWRlOiBHcmFudWxhcmlkYWRlVGVtcG9yYWw7XG5cbiAgLyoqXG4gICAqIFJlZmVyw6puY2lhIGEgb3V0cmFzIG3DqXRyaWNhcyB1dGlsaXphZGFzIG5vIGPDoWxjdWxvIChjYXNvIHNlamEgY29tcG9zdGEpXG4gICAqIEFybWF6ZW5hZG8gY29tbyBhcnJheSBkZSBjw7NkaWdvcyBkZSBtw6l0cmljYXNcbiAgICovXG4gIEBDb2x1bW4oJ3NpbXBsZS1hcnJheScsIHsgbnVsbGFibGU6IHRydWUgfSlcbiAgbWV0cmljYXNfZGVwZW5kZW50ZXM6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBGbGFnIHF1ZSBpbmRpY2Egc2UgYSBtw6l0cmljYSBlc3TDoSBhdGl2YSBwYXJhIGNvbGV0YVxuICAgKi9cbiAgQENvbHVtbih7IGRlZmF1bHQ6IHRydWUgfSlcbiAgYXRpdmE6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFBhcsOibWV0cm9zIGVzcGVjw61maWNvcyBwYXJhIG8gdGlwbyBkZSBtw6l0cmljYVxuICAgKiBBcm1hemVuYWRvIGNvbW8gSlNPTlxuICAgKiBFeGVtcGxvIHBhcmEgUEVSQ0VOVElMOiB7IFwicGVyY2VudGlsXCI6IDk1IH1cbiAgICovXG4gIEBDb2x1bW4oeyB0eXBlOiAnanNvbmInLCBudWxsYWJsZTogdHJ1ZSB9KVxuICBwYXJhbWV0cm9zX2VzcGVjaWZpY29zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG4gIC8qKlxuICAgKiBUYWdzIHBhcmEgZmlsdHJhciBlIGNhdGVnb3JpemFyIG3DqXRyaWNhc1xuICAgKi9cbiAgQENvbHVtbignc2ltcGxlLWFycmF5JywgeyBudWxsYWJsZTogdHJ1ZSB9KVxuICB0YWdzOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogVmVyc8OjbyBhdHVhbCBkYSBkZWZpbmnDp8OjbyBkYSBtw6l0cmljYVxuICAgKi9cbiAgQENvbHVtbih7IGRlZmF1bHQ6IDEgfSlcbiAgdmVyc2FvOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIERhdGEgZGEgw7psdGltYSBjb2xldGEgYmVtLXN1Y2VkaWRhXG4gICAqL1xuICBAQ29sdW1uKHsgdHlwZTogJ3RpbWVzdGFtcCcsIG51bGxhYmxlOiB0cnVlIH0pXG4gIHVsdGltYV9jb2xldGE6IERhdGU7XG5cbiAgLyoqXG4gICAqIEZsYWcgcXVlIGluZGljYSBzZSBhIG3DqXRyaWNhIMOpIGNhbGN1bGFkYSBlbSB0ZW1wbyByZWFsIG91IHByw6ktY2FsY3VsYWRhXG4gICAqL1xuICBAQ29sdW1uKHsgZGVmYXVsdDogZmFsc2UgfSlcbiAgY2FsY3Vsb190ZW1wb19yZWFsOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBVc3XDoXJpbyBxdWUgY3Jpb3UgYSBtw6l0cmljYVxuICAgKi9cbiAgQENvbHVtbih7IGxlbmd0aDogMTAwLCBudWxsYWJsZTogdHJ1ZSB9KVxuICBjcmlhZG9fcG9yOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVzdcOhcmlvIHF1ZSBhdHVhbGl6b3UgYSBtw6l0cmljYSBwZWxhIMO6bHRpbWEgdmV6XG4gICAqL1xuICBAQ29sdW1uKHsgbGVuZ3RoOiAxMDAsIG51bGxhYmxlOiB0cnVlIH0pXG4gIGF0dWFsaXphZG9fcG9yOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERhdGEgZGUgY3JpYcOnw6NvIGRvIHJlZ2lzdHJvXG4gICAqL1xuICBAQ3JlYXRlRGF0ZUNvbHVtbigpXG4gIGNyZWF0ZWRfYXQ6IERhdGU7XG5cbiAgLyoqXG4gICAqIERhdGEgZGEgw7psdGltYSBhdHVhbGl6YcOnw6NvIGRvIHJlZ2lzdHJvXG4gICAqL1xuICBAVXBkYXRlRGF0ZUNvbHVtbigpXG4gIHVwZGF0ZWRfYXQ6IERhdGU7XG5cbiAgLyoqXG4gICAqIFJlbGFjaW9uYW1lbnRvIGNvbSBzbmFwc2hvdHMgaGlzdMOzcmljb3MgZGEgbcOpdHJpY2FcbiAgICpcbiAgICogVXNhbmRvIGxhenkgbG9hZGluZyBwYXJhIGV2aXRhciBkZXBlbmTDqm5jaWFzIGNpcmN1bGFyZXNcbiAgICovXG4gIEBPbmVUb01hbnkoKCkgPT4gTWV0cmljYVNuYXBzaG90LCAoc25hcHNob3QpID0+IHNuYXBzaG90LmRlZmluaWNhbywge1xuICAgIGxhenk6IHRydWUsXG4gIH0pXG4gIHNuYXBzaG90czogUHJvbWlzZTxNZXRyaWNhU25hcHNob3RbXT47XG5cbiAgLyoqXG4gICAqIFJlbGFjaW9uYW1lbnRvIGNvbSBjb25maWd1cmHDp8O1ZXMgZGUgY29sZXRhIGUgYXJtYXplbmFtZW50b1xuICAgKlxuICAgKiBVc2FuZG8gbGF6eSBsb2FkaW5nIHBhcmEgZXZpdGFyIGRlcGVuZMOqbmNpYXMgY2lyY3VsYXJlc1xuICAgKi9cbiAgQE9uZVRvTWFueSgoKSA9PiBNZXRyaWNhQ29uZmlndXJhY2FvLCAoY29uZmlnKSA9PiBjb25maWcubWV0cmljYSwge1xuICAgIGxhenk6IHRydWUsXG4gIH0pXG4gIGNvbmZpZ3VyYWNvZXM6IFByb21pc2U8TWV0cmljYUNvbmZpZ3VyYWNhb1tdPjtcbn1cbiJdLCJ2ZXJzaW9uIjozfQ==