{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\auth\\services\\password-reset.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\auth\\services\\password-reset.service.ts"],"sourcesContent":["import {\n  Injectable,\n  BadRequestException,\n  NotFoundException,\n  UnauthorizedException,\n  Logger,\n  InternalServerErrorException,\n} from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, LessThan, DataSource } from 'typeorm';\nimport { ConfigService } from '@nestjs/config';\nimport { Cron, CronExpression } from '@nestjs/schedule';\nimport { JwtService } from '@nestjs/jwt';\nimport * as crypto from 'crypto';\nimport * as bcrypt from 'bcrypt';\nimport { PasswordResetToken } from '../../entities/password-reset-token.entity';\nimport { Usuario } from '../../entities/usuario.entity';\nimport { UsuarioRepository } from '../../modules/usuario/repositories/usuario.repository';\nimport { EmailService } from '../../common/services/email.service';\nimport { AuditService } from '../../audit/services/audit.service';\nimport { ClientInfo } from '../../common/interfaces/client-info.interface';\nimport { AuditAction, AuditSeverity } from '../../entities/audit-log.entity';\n\nexport interface RequestPasswordResetDto {\n  email: string;\n}\n\nexport interface ResetPasswordDto {\n  token: string;\n  newPassword: string;\n  confirmPassword: string;\n}\n\nexport interface PasswordResetStats {\n  totalRequests: number;\n  activeTokens: number;\n  expiredTokens: number;\n  usedTokens: number;\n  requestsLast24h: number;\n  averageTimeToUse: number; // em minutos\n}\n\n@Injectable()\nexport class PasswordResetService {\n  private readonly logger = new Logger(PasswordResetService.name);\n  private readonly tokenExpirationMinutes: number;\n  private readonly maxAttemptsPerToken: number;\n  private readonly maxRequestsPerHour: number;\n\n  constructor(\n    @InjectRepository(PasswordResetToken)\n    private readonly passwordResetTokenRepository: Repository<PasswordResetToken>,\n    private readonly usuarioRepository: UsuarioRepository,\n    private readonly emailService: EmailService,\n    private readonly auditService: AuditService,\n    private readonly configService: ConfigService,\n    private readonly jwtService: JwtService,\n    private readonly dataSource: DataSource,\n  ) {\n    this.tokenExpirationMinutes = this.configService.get<number>(\n      'PASSWORD_RESET_EXPIRATION_MINUTES',\n      15,\n    );\n    this.maxAttemptsPerToken = this.configService.get<number>(\n      'PASSWORD_RESET_MAX_ATTEMPTS',\n      3,\n    );\n    this.maxRequestsPerHour = this.configService.get<number>(\n      'PASSWORD_RESET_MAX_REQUESTS_PER_HOUR',\n      5,\n    );\n    \n    // Iniciar limpeza automática de tokens expirados\n    this.startTokenCleanup();\n  }\n\n  /**\n   * Solicita recuperação de senha\n   */\n  async requestPasswordReset(\n    requestDto: RequestPasswordResetDto,\n    clientInfo: ClientInfo,\n  ): Promise<{ message: string; expiresInMinutes: number }> {\n    const { email } = requestDto;\n\n    try {\n      // Buscar usuário pelo email\n      const usuario = await this.usuarioRepository.findByEmail(email.toLowerCase());\n\n      // Por segurança, sempre retornamos sucesso mesmo se o email não existir\n      if (!usuario) {\n        this.logger.warn(`Tentativa de reset para email inexistente: ${email}`, {\n          ip: clientInfo.ip,\n          userAgent: clientInfo.userAgent,\n        });\n\n        await this.auditService.logSecurityEvent(\n          AuditAction.PASSWORD_RESET,\n          `Tentativa de reset para email inexistente: ${email}`,\n          undefined,\n          AuditSeverity.MEDIUM,\n          { email },\n          { ip: clientInfo.ip, userAgent: clientInfo.userAgent }\n        );\n\n        return {\n          message: 'Se o email existir, você receberá instruções para redefinir sua senha.',\n          expiresInMinutes: this.tokenExpirationMinutes,\n        };\n      }\n\n      // Verificar rate limiting\n      await this.checkRateLimit(usuario.id, clientInfo.ip);\n\n      // Invalidar tokens anteriores do usuário\n      await this.invalidateUserTokens(usuario.id, 'new_request');\n\n      // Gerar novo token\n      const token = this.generateSecureToken();\n      const tokenHash = await this.hashToken(token);\n      const expiresAt = new Date(Date.now() + this.tokenExpirationMinutes * 60 * 1000);\n\n      // Salvar token no banco\n      const passwordResetToken = this.passwordResetTokenRepository.create({\n        token: token.substring(0, 8) + '...', // Armazenar apenas parte do token para auditoria\n        token_hash: tokenHash,\n        usuario_id: usuario.id,\n        expires_at: expiresAt,\n        client_ip: clientInfo.ip,\n        user_agent: clientInfo.userAgent,\n        metadata: {\n          origin: clientInfo.origin,\n          referer: clientInfo.referer,\n        },\n      });\n\n      await this.passwordResetTokenRepository.save(passwordResetToken);\n\n      // Enviar email\n      await this.sendPasswordResetEmail(usuario, token, expiresAt);\n\n      // Log de auditoria\n      await this.auditService.logUserAction(\n        usuario.id,\n        AuditAction.PASSWORD_RESET,\n        'password_reset_token',\n        passwordResetToken.id,\n        'Solicitação de recuperação de senha',\n        { ip: clientInfo.ip, userAgent: clientInfo.userAgent }\n      );\n\n      this.logger.log(`Token de recuperação gerado para usuário ${usuario.id}`);\n\n      return {\n        message: 'Se o email existir, você receberá instruções para redefinir sua senha.',\n        expiresInMinutes: this.tokenExpirationMinutes,\n      };\n    } catch (error) {\n      this.logger.error('Erro ao solicitar recuperação de senha', error.stack);\n      \n      await this.auditService.logSecurityEvent(\n        AuditAction.PASSWORD_RESET,\n        `Erro ao processar solicitação de reset: ${error.message}`,\n        undefined,\n        AuditSeverity.HIGH,\n        { email, error: error.message },\n        { ip: clientInfo.ip, userAgent: clientInfo.userAgent }\n      );\n\n      throw new InternalServerErrorException(\n        'Erro interno. Tente novamente mais tarde.',\n      );\n    }\n  }\n\n  /**\n   * Redefine a senha usando o token\n   */\n  async resetPassword(\n    resetDto: ResetPasswordDto,\n    clientInfo: ClientInfo,\n  ): Promise<{ message: string }> {\n    const { token, newPassword, confirmPassword } = resetDto;\n\n    // Validar senhas\n    if (newPassword !== confirmPassword) {\n      throw new BadRequestException('As senhas não coincidem');\n    }\n\n    if (newPassword.length < 8) {\n      throw new BadRequestException('A senha deve ter pelo menos 8 caracteres');\n    }\n\n    try {\n      // Buscar token válido\n      const resetToken = await this.findValidToken(token);\n      if (!resetToken) {\n        await this.auditService.logSecurityEvent(\n          AuditAction.PASSWORD_RESET,\n          'Tentativa de uso de token inválido para reset de senha',\n          undefined,\n          AuditSeverity.HIGH,\n          { tokenPrefix: token.substring(0, 8) },\n          { ip: clientInfo.ip, userAgent: clientInfo.userAgent }\n        );\n        throw new UnauthorizedException('Token inválido ou expirado');\n      }\n\n      // Carregar usuário pelo ID\n      const usuario = await this.usuarioRepository.findById(resetToken.usuario_id);\n\n      if (!usuario) {\n        throw new NotFoundException('Usuário não encontrado');\n      }\n\n      // Verificar se a nova senha é diferente da atual\n      const isSamePassword = await bcrypt.compare(newPassword, usuario.senhaHash);\n      if (isSamePassword) {\n        throw new BadRequestException(\n          'A nova senha deve ser diferente da senha atual',\n        );\n      }\n\n      // Hash da nova senha\n      const hashedPassword = await bcrypt.hash(newPassword, 12);\n\n      // Atualizar senha do usuário usando query builder\n      await this.passwordResetTokenRepository\n        .manager\n        .createQueryBuilder()\n        .update('usuario')\n        .set({\n          senha: hashedPassword,\n          updated_at: new Date()\n        })\n        .where(\"id = :id\", { id: usuario.id })\n        .execute();\n\n      // Marcar token como usado\n      resetToken.markAsUsed('password_changed');\n      await this.passwordResetTokenRepository.save(resetToken);\n\n      // Invalidar outros tokens do usuário\n      await this.invalidateUserTokens(usuario.id, 'password_changed', resetToken.id);\n\n      // Enviar email de confirmação\n      await this.sendPasswordResetConfirmationEmail(usuario, clientInfo);\n\n      // Log de auditoria\n      await this.auditService.logUserAction(\n        usuario.id,\n        AuditAction.PASSWORD_RESET,\n        'usuario',\n        usuario.id,\n        'Senha redefinida com sucesso',\n        { ip: clientInfo.ip, userAgent: clientInfo.userAgent }\n      );\n\n      await this.auditService.logSecurityEvent(\n        AuditAction.PASSWORD_RESET,\n        `Senha redefinida com sucesso para o usuário ${usuario.email}`,\n        usuario.id,\n        AuditSeverity.MEDIUM,\n        { email: usuario.email },\n        { ip: clientInfo.ip, userAgent: clientInfo.userAgent }\n      );\n\n      this.logger.log(`Senha redefinida com sucesso para usuário ${usuario.id}`);\n\n      return {\n        message: 'Senha redefinida com sucesso. Você pode fazer login com sua nova senha.',\n      };\n    } catch (error) {\n      // Registrar erro e redirecionar\n      const foundToken = await this.findValidToken(token);\n      if (foundToken) {\n        foundToken.markAsUsed('password_reset_error');\n        await this.passwordResetTokenRepository.save(foundToken);\n      }\n\n      this.logger.error('Erro ao redefinir senha', error.stack);\n      \n      await this.auditService.logSecurityEvent(\n        AuditAction.PASSWORD_RESET,\n        `Erro ao redefinir senha: ${error.message}`,\n        foundToken?.usuario?.id,\n        AuditSeverity.HIGH,\n        { tokenPrefix: token.substring(0, 8), error: error.message },\n        { ip: clientInfo.ip, userAgent: clientInfo.userAgent }\n      );\n\n      if (error instanceof BadRequestException || \n          error instanceof UnauthorizedException || \n          error instanceof NotFoundException) {\n        throw error;\n      }\n\n      throw new InternalServerErrorException(\n        'Erro interno. Tente novamente mais tarde.',\n      );\n    }\n  }\n\n  /**\n   * Valida se um token é válido\n   */\n  async validateToken(token: string): Promise<{ valid: boolean; expiresInMinutes?: number }> {\n    try {\n      const resetToken = await this.findValidToken(token);\n      \n      if (!resetToken) {\n        return { valid: false };\n      }\n\n      return {\n        valid: true,\n        expiresInMinutes: resetToken.getMinutesUntilExpiration(),\n      };\n    } catch (error) {\n      this.logger.error('Erro ao validar token', error.stack);\n      return { valid: false };\n    }\n  }\n\n  /**\n   * Obtém estatísticas de recuperação de senha\n   */\n  async getPasswordResetStats(): Promise<PasswordResetStats> {\n    const now = new Date();\n    const last24h = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    const [totalRequests, activeTokens, expiredTokens, usedTokens, requestsLast24h] = \n      await Promise.all([\n        this.passwordResetTokenRepository.count(),\n        this.passwordResetTokenRepository.count({\n          where: {\n            is_used: false,\n            expires_at: LessThan(now),\n          },\n        }),\n        this.passwordResetTokenRepository.count({\n          where: {\n            is_used: false,\n            expires_at: LessThan(now),\n          },\n        }),\n        this.passwordResetTokenRepository.count({\n          where: { is_used: true },\n        }),\n        this.passwordResetTokenRepository.count({\n          where: {\n            created_at: LessThan(last24h),\n          },\n        }),\n      ]);\n\n    // Calcular tempo médio de uso\n    const usedTokensWithTime = await this.passwordResetTokenRepository\n      .createQueryBuilder('token')\n      .select('AVG(EXTRACT(EPOCH FROM (token.used_at - token.created_at)) / 60)', 'avgMinutes')\n      .where('token.is_used = true AND token.used_at IS NOT NULL')\n      .getRawOne();\n\n    const averageTimeToUse = parseFloat(usedTokensWithTime?.avgMinutes || '0');\n\n    return {\n      totalRequests,\n      activeTokens,\n      expiredTokens,\n      usedTokens,\n      requestsLast24h,\n      averageTimeToUse,\n    };\n  }\n\n  /**\n   * Limpeza automática de tokens expirados (executa a cada hora)\n   */\n  @Cron(CronExpression.EVERY_HOUR)\n  async cleanupExpiredTokens(): Promise<number> {\n    try {\n      const now = new Date();\n      const result = await this.passwordResetTokenRepository.delete({\n        expires_at: LessThan(now),\n        is_used: false,\n      });\n\n      if (result.affected && result.affected > 0) {\n        this.logger.log(`Removidos ${result.affected} tokens de recuperação expirados`);\n      }\n      \n      return result.affected || 0;\n    } catch (error) {\n      this.logger.error('Erro na limpeza de tokens expirados', error.stack);\n      return 0;\n    }\n  }\n\n  /**\n   * Limpeza de tokens antigos usados (executa diariamente)\n   */\n  @Cron(CronExpression.EVERY_DAY_AT_2AM)\n  async cleanupOldUsedTokens(): Promise<number> {\n    try {\n      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n      const result = await this.passwordResetTokenRepository.delete({\n        is_used: true,\n        used_at: LessThan(thirtyDaysAgo),\n      });\n\n      if (result.affected && result.affected > 0) {\n        this.logger.log(`Removidos ${result.affected} tokens de recuperação antigos`);\n      }\n      \n      return result.affected || 0;\n    } catch (error) {\n      this.logger.error('Erro na limpeza de tokens antigos', error.stack);\n      return 0;\n    }\n  }\n\n  // Métodos privados\n\n  private generateSecureToken(): string {\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  private async hashToken(token: string): Promise<string> {\n    return bcrypt.hash(token, 10);\n  }\n\n  private async findValidToken(token: string): Promise<PasswordResetToken | null> {\n    const tokens = await this.passwordResetTokenRepository.find({\n      where: {\n        is_used: false,\n        expires_at: LessThan(new Date()),\n      },\n      relations: ['usuario'],\n    });\n\n    for (const resetToken of tokens) {\n      const isValid = await bcrypt.compare(token, resetToken.token_hash);\n      if (isValid && resetToken.isValid()) {\n        // Incrementar tentativas\n        resetToken.incrementAttempts();\n        await this.passwordResetTokenRepository.save(resetToken);\n        \n        // Verificar limite de tentativas\n        if (resetToken.attempts > this.maxAttemptsPerToken) {\n          resetToken.markAsUsed('max_attempts_exceeded');\n          await this.passwordResetTokenRepository.save(resetToken);\n          return null;\n        }\n        \n        return resetToken;\n      }\n    }\n\n    return null;\n  }\n\n  private async checkRateLimit(usuarioId: string, ip: string): Promise<void> {\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    \n    const recentRequests = await this.passwordResetTokenRepository.count({\n      where: [\n        {\n          usuario_id: usuarioId,\n          created_at: LessThan(oneHourAgo),\n        },\n        {\n          client_ip: ip,\n          created_at: LessThan(oneHourAgo),\n        },\n      ],\n    });\n\n    if (recentRequests >= this.maxRequestsPerHour) {\n      throw new BadRequestException(\n        'Muitas solicitações de recuperação. Tente novamente mais tarde.',\n      );\n    }\n  }\n\n  private async invalidateUserTokens(\n    usuarioId: string,\n    reason: string,\n    excludeTokenId?: string,\n  ): Promise<void> {\n    const query = this.passwordResetTokenRepository\n      .createQueryBuilder()\n      .update(PasswordResetToken)\n      .set({\n        is_used: true,\n        invalidation_reason: reason,\n        updated_at: new Date(),\n      })\n      .where('usuario_id = :usuarioId', { usuarioId })\n      .andWhere('is_used = false');\n\n    if (excludeTokenId) {\n      query.andWhere('id != :excludeTokenId', { excludeTokenId });\n    }\n\n    await query.execute();\n  }\n\n  private async sendPasswordResetEmail(\n    usuario: Usuario,\n    token: string,\n    expiresAt: Date,\n  ): Promise<void> {\n    const expiresInMinutes = Math.ceil((expiresAt.getTime() - Date.now()) / (1000 * 60));\n\n    await this.emailService.sendPasswordResetEmail(\n      usuario.email,\n      usuario.nome,\n      token,\n      expiresInMinutes\n    );\n  }\n\n  private async sendPasswordResetConfirmationEmail(\n    usuario: Usuario,\n    clientInfo: ClientInfo,\n  ): Promise<void> {\n    await this.emailService.sendPasswordResetConfirmationEmail(\n      usuario.email,\n      usuario.nome\n    );\n  }\n\n  /**\n   * Inicia a limpeza automática de tokens expirados\n   * Migrado do PasswordRecoveryService\n   */\n  private startTokenCleanup(): void {\n    const CLEANUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 horas\n    \n    // Executar limpeza a cada 24 horas\n    setInterval(async () => {\n      try {\n        await this.cleanupExpiredTokens();\n      } catch (error) {\n        this.logger.error(`Erro na limpeza automática de tokens: ${error.message}`);\n      }\n    }, CLEANUP_INTERVAL);\n    \n    // Executar limpeza de tokens usados a cada 24 horas\n    setInterval(async () => {\n      try {\n        await this.cleanupOldUsedTokens();\n      } catch (error) {\n        this.logger.error(`Erro na limpeza de tokens usados: ${error.message}`);\n      }\n    }, CLEANUP_INTERVAL);\n  }\n  \n\n\n  /**\n   * Obtém estatísticas de tokens de recuperação\n   * Migrado do PasswordRecoveryService\n   * @returns Estatísticas dos tokens\n   */\n  async getTokenStats(): Promise<{\n    total: number;\n    active: number;\n    expired: number;\n    used: number;\n  }> {\n    const now = new Date();\n    \n    const [total, active, expired, used] = await Promise.all([\n      this.passwordResetTokenRepository.count(),\n      this.passwordResetTokenRepository.count({\n        where: {\n          is_used: false,\n          expires_at: LessThan(now),\n        },\n      }),\n      this.passwordResetTokenRepository.count({\n        where: {\n          expires_at: LessThan(now),\n        },\n      }),\n      this.passwordResetTokenRepository.count({\n        where: {\n          is_used: true,\n        },\n      }),\n    ]);\n\n    return { total, active, expired, used };\n  }\n}"],"version":3}