{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\pagamento\\services\\pagamento.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\pagamento\\services\\pagamento.service.ts"],"sourcesContent":["import {\n  ConflictException,\n  Injectable,\n  NotFoundException,\n} from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Pagamento } from '../../../entities/pagamento.entity';\nimport { StatusPagamentoEnum } from '../../../enums/status-pagamento.enum';\nimport { PagamentoCreateDto } from '../dtos/pagamento-create.dto';\nimport { StatusTransitionValidator } from '../validators/status-transition-validator';\nimport { normalizeEnumFields } from '../../../shared/utils/enum-normalizer.util';\n\n/**\n * Serviço para gerenciamento de operações relacionadas a pagamentos\n *\n * Implementa a lógica de negócio para criação, consulta, atualização\n * e gerenciamento de ciclo de vida dos pagamentos no sistema.\n *\n * @author Equipe PGBen\n */\n@Injectable()\nexport class PagamentoService {\n  constructor(\n    @InjectRepository(Pagamento)\n    private readonly pagamentoRepository: Repository<Pagamento>,\n    private readonly statusValidator: StatusTransitionValidator,\n    // Outros serviços necessários serão injetados aqui\n    // private readonly solicitacaoService: SolicitacaoService,\n    // private readonly auditoriaService: AuditoriaService,\n    // etc.\n  ) {}\n\n  /**\n   * Cria um novo registro de pagamento para uma solicitação aprovada\n   *\n   * @param solicitacaoId ID da solicitação aprovada\n   * @param createDto Dados para criação do pagamento\n   * @param usuarioId ID do usuário que está realizando a operação\n   * @returns Pagamento criado\n   */\n  async createPagamento(\n    solicitacaoId: string,\n    createDto: PagamentoCreateDto,\n    usuarioId: string,\n  ): Promise<Pagamento> {\n    // Validar se a solicitação existe e está aprovada\n    // const solicitacao = await this.solicitacaoService.findOne(solicitacaoId);\n\n    // if (!solicitacao) {\n    //   throw new NotFoundException('Solicitação não encontrada');\n    // }\n\n    // if (solicitacao.status !== 'aprovada') {\n    //   throw new ConflictException('Somente solicitações aprovadas podem ter pagamentos liberados');\n    // }\n\n    // Validar método de pagamento e informações bancárias\n    if (\n      createDto.metodoPagamento !== 'presencial' &&\n      !createDto.infoBancariaId\n    ) {\n      throw new ConflictException(\n        'Informações bancárias são obrigatórias para pagamentos não presenciais',\n      );\n    }\n\n    // Validar limites de valor\n    // await this.validarLimitesPagamento(solicitacao.tipoBeneficioId, createDto.valor);\n\n    // Normalizar campos de enum antes de criar a entidade\n    const dadosNormalizados = normalizeEnumFields({\n      solicitacaoId,\n      infoBancariaId: createDto.infoBancariaId,\n      valor: createDto.valor,\n      dataLiberacao: createDto.dataLiberacao,\n      status: StatusPagamentoEnum.LIBERADO, // Status inicial ao criar o pagamento\n      metodoPagamento: createDto.metodoPagamento,\n      liberadoPor: usuarioId,\n      observacoes: createDto.observacoes,\n    });\n\n    // Criar nova entidade de pagamento\n    const pagamento = this.pagamentoRepository.create(dadosNormalizados);\n\n    // Salvar o pagamento\n    const result = await this.pagamentoRepository.save(pagamento);\n\n    // Atualizar status da solicitação\n    // await this.solicitacaoService.atualizarStatusParaPagamentoPendente(solicitacaoId);\n\n    // Registrar operação no log de auditoria\n    // await this.auditoriaService.registrarOperacao({\n    //   tipoOperacao: 'CRIACAO_PAGAMENTO',\n    //   usuarioId,\n    //   entidadeId: result.id,\n    //   tipoEntidade: 'PAGAMENTO',\n    //   dadosAnteriores: null,\n    //   dadosNovos: result\n    // });\n\n    return result;\n  }\n\n  /**\n   * Atualiza o status de um pagamento existente\n   *\n   * @param id ID do pagamento\n   * @param novoStatus Novo status do pagamento\n   * @param usuarioId ID do usuário que está realizando a operação\n   * @returns Pagamento atualizado\n   */\n  async atualizarStatus(\n    id: string,\n    novoStatus: StatusPagamentoEnum,\n    usuarioId: string,\n  ): Promise<Pagamento> {\n    // Buscar o pagamento pelo ID\n    const pagamento = await this.findOne(id);\n\n    if (!pagamento) {\n      throw new NotFoundException('Pagamento não encontrado');\n    }\n\n    // Validar a transição de status\n    const transitionResult = this.statusValidator.canTransition(\n      pagamento.status,\n      novoStatus,\n    );\n\n    if (!transitionResult.allowed) {\n      throw new ConflictException(\n        `Transição de status não permitida: ${transitionResult.reason}`,\n      );\n    }\n\n    // Salvar dados anteriores para auditoria\n    const dadosAnteriores = { ...pagamento };\n\n    // Normalizar o novo status antes de atualizar\n    const statusNormalizado = normalizeEnumFields({\n      status: novoStatus,\n    }).status;\n\n    // Atualizar o status\n    pagamento.status = statusNormalizado;\n\n    // Salvar a atualização\n    const result = await this.pagamentoRepository.save(pagamento);\n\n    // Atualizar status da solicitação, se necessário\n    // if (novoStatus === StatusPagamentoEnum.CONFIRMADO) {\n    //   await this.solicitacaoService.atualizarStatusParaConcluido(pagamento.solicitacaoId);\n    // } else if (novoStatus === StatusPagamentoEnum.CANCELADO) {\n    //   await this.solicitacaoService.atualizarStatusParaAprovado(pagamento.solicitacaoId);\n    // }\n\n    // Registrar operação no log de auditoria\n    // await this.auditoriaService.registrarOperacao({\n    //   tipoOperacao: 'ATUALIZACAO_STATUS_PAGAMENTO',\n    //   usuarioId,\n    //   entidadeId: id,\n    //   tipoEntidade: 'PAGAMENTO',\n    //   dadosAnteriores,\n    //   dadosNovos: result\n    // });\n\n    return result;\n  }\n\n  /**\n   * Cancela um pagamento existente\n   *\n   * @param id ID do pagamento a ser cancelado\n   * @param usuarioId ID do usuário que está realizando a operação\n   * @param motivoCancelamento Motivo do cancelamento\n   * @returns Pagamento cancelado\n   */\n  async cancelarPagamento(\n    id: string,\n    usuarioId: string,\n    motivoCancelamento: string,\n  ): Promise<Pagamento> {\n    // Buscar o pagamento pelo ID\n    const pagamento = await this.findOne(id);\n\n    if (!pagamento) {\n      throw new NotFoundException('Pagamento não encontrado');\n    }\n\n    // Verificar se o pagamento pode ser cancelado\n    if (!this.statusValidator.canBeCanceled(pagamento.status)) {\n      throw new ConflictException(\n        'Este pagamento não pode ser cancelado devido ao seu status atual',\n      );\n    }\n\n    // Salvar dados anteriores para auditoria\n    const dadosAnteriores = { ...pagamento };\n\n    // Atualizar o status e registrar motivo do cancelamento\n    pagamento.status = StatusPagamentoEnum.CANCELADO;\n    pagamento.observacoes = pagamento.observacoes\n      ? `${pagamento.observacoes}\\nMotivo do cancelamento: ${motivoCancelamento}`\n      : `Motivo do cancelamento: ${motivoCancelamento}`;\n\n    // Salvar a atualização\n    const result = await this.pagamentoRepository.save(pagamento);\n\n    // Atualizar status da solicitação\n    // await this.solicitacaoService.atualizarStatusParaAprovado(pagamento.solicitacaoId);\n\n    // Registrar operação no log de auditoria\n    // await this.auditoriaService.registrarOperacao({\n    //   tipoOperacao: 'CANCELAMENTO_PAGAMENTO',\n    //   usuarioId,\n    //   entidadeId: id,\n    //   tipoEntidade: 'PAGAMENTO',\n    //   dadosAnteriores,\n    //   dadosNovos: result,\n    //   observacoes: motivoCancelamento\n    // });\n\n    return result;\n  }\n\n  /**\n   * Busca um pagamento pelo ID\n   *\n   * @param id ID do pagamento\n   * @returns Pagamento encontrado ou null\n   */\n  async findOne(id: string): Promise<Pagamento | null> {\n    return this.pagamentoRepository.findOneBy({ id });\n  }\n\n  /**\n   * Busca um pagamento pelo ID com todos os relacionamentos\n   *\n   * @param id ID do pagamento\n   * @returns Pagamento encontrado com relacionamentos ou null\n   */\n  async findOneWithRelations(id: string): Promise<Pagamento | null> {\n    return this.pagamentoRepository.findOne({\n      where: { id },\n      relations: ['comprovantes', 'confirmacoes'],\n    });\n  }\n\n  /**\n   * Lista pagamentos com filtros e paginação\n   *\n   * @param options Opções de filtro\n   * @returns Lista de pagamentos com meta-informações de paginação\n   */\n  async findAll(options: {\n    status?: StatusPagamentoEnum;\n    unidadeId?: string;\n    dataInicio?: Date;\n    dataFim?: Date;\n    metodoPagamento?: string;\n    page?: number;\n    limit?: number;\n  }): Promise<{\n    items: Pagamento[];\n    total: number;\n    page: number;\n    limit: number;\n  }> {\n    const {\n      status,\n      unidadeId,\n      dataInicio,\n      dataFim,\n      metodoPagamento,\n      page = 1,\n      limit = 10,\n    } = options;\n\n    // Construir a query base\n    const queryBuilder =\n      this.pagamentoRepository.createQueryBuilder('pagamento');\n\n    // Adicionar condições\n    if (status) {\n      queryBuilder.andWhere('pagamento.status = :status', { status });\n    }\n\n    if (metodoPagamento) {\n      queryBuilder.andWhere('pagamento.metodo_pagamento = :metodoPagamento', {\n        metodoPagamento,\n      });\n    }\n\n    if (dataInicio) {\n      queryBuilder.andWhere('pagamento.data_liberacao >= :dataInicio', {\n        dataInicio,\n      });\n    }\n\n    if (dataFim) {\n      queryBuilder.andWhere('pagamento.data_liberacao <= :dataFim', {\n        dataFim,\n      });\n    }\n\n    // Filtro por unidade (requer join com solicitação)\n    if (unidadeId) {\n      queryBuilder\n        .innerJoin('solicitacao', 's', 'pagamento.solicitacao_id = s.id')\n        .andWhere('s.unidade_id = :unidadeId', { unidadeId });\n    }\n\n    // Adicionar paginação\n    queryBuilder.skip((page - 1) * limit).take(limit);\n\n    // Ordenar por data de liberação (mais recentes primeiro)\n    queryBuilder.orderBy('pagamento.data_liberacao', 'DESC');\n\n    // Executar a query\n    const [items, total] = await queryBuilder.getManyAndCount();\n\n    return {\n      items,\n      total,\n      page,\n      limit,\n    };\n  }\n\n  /**\n   * Lista pagamentos pendentes (liberados mas não confirmados)\n   *\n   * @param options Opções de filtro\n   * @returns Lista de pagamentos pendentes\n   */\n  async findPendentes(options: {\n    unidadeId?: string;\n    tipoBeneficioId?: string;\n    page?: number;\n    limit?: number;\n  }): Promise<{\n    items: Pagamento[];\n    total: number;\n    page: number;\n    limit: number;\n  }> {\n    const { unidadeId, tipoBeneficioId, page = 1, limit = 10 } = options;\n\n    // Construir a query base\n    const queryBuilder =\n      this.pagamentoRepository.createQueryBuilder('pagamento');\n\n    // Filtrar apenas pagamentos liberados\n    queryBuilder.where('pagamento.status = :status', {\n      status: StatusPagamentoEnum.LIBERADO,\n    });\n\n    // Filtros adicionais que requerem joins\n    if (unidadeId || tipoBeneficioId) {\n      queryBuilder.innerJoin(\n        'solicitacao',\n        's',\n        'pagamento.solicitacao_id = s.id',\n      );\n\n      if (unidadeId) {\n        queryBuilder.andWhere('s.unidade_id = :unidadeId', { unidadeId });\n      }\n\n      if (tipoBeneficioId) {\n        queryBuilder.andWhere('s.tipo_beneficio_id = :tipoBeneficioId', {\n          tipoBeneficioId,\n        });\n      }\n    }\n\n    // Adicionar paginação\n    queryBuilder.skip((page - 1) * limit).take(limit);\n\n    // Ordenar por data de liberação (mais antigos primeiro)\n    queryBuilder.orderBy('pagamento.data_liberacao', 'ASC');\n\n    // Executar a query\n    const [items, total] = await queryBuilder.getManyAndCount();\n\n    return {\n      items,\n      total,\n      page,\n      limit,\n    };\n  }\n\n  /**\n   * Valida se o valor está dentro dos limites permitidos para o tipo de benefício\n   *\n   * @param tipoBeneficioId ID do tipo de benefício\n   * @param valor Valor a ser validado\n   * @throws ConflictException se o valor exceder os limites permitidos\n   */\n  private async validarLimitesPagamento(\n    tipoBeneficioId: string,\n    valor: number,\n  ): Promise<void> {\n    // Esta é uma implementação de placeholder\n    // Será integrada com o ConfiguracaoModule ou TipoBeneficioService\n    // const tipoBeneficio = await this.tipoBeneficioService.findOne(tipoBeneficioId);\n    // if (!tipoBeneficio) {\n    //   throw new NotFoundException('Tipo de benefício não encontrado');\n    // }\n    // if (valor > tipoBeneficio.valorMaximo) {\n    //   throw new ConflictException(\n    //     `O valor excede o limite máximo permitido (${tipoBeneficio.valorMaximo}) para este tipo de benefício`\n    //   );\n    // }\n    // if (valor < tipoBeneficio.valorMinimo) {\n    //   throw new ConflictException(\n    //     `O valor está abaixo do limite mínimo permitido (${tipoBeneficio.valorMinimo}) para este tipo de benefício`\n    //   );\n    // }\n  }\n}\n"],"version":3}