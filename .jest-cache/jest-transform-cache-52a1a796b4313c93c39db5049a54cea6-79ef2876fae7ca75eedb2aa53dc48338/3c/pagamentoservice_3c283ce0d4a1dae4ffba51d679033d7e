a4ad58d5e84b6faf9e38cb659701fe9e
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PagamentoService = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const pagamento_entity_1 = require("../../../entities/pagamento.entity");
const status_pagamento_enum_1 = require("../../../enums/status-pagamento.enum");
const status_transition_validator_1 = require("../validators/status-transition-validator");
const enum_normalizer_util_1 = require("../../../shared/utils/enum-normalizer.util");
/**
 * Serviço para gerenciamento de operações relacionadas a pagamentos
 *
 * Implementa a lógica de negócio para criação, consulta, atualização
 * e gerenciamento de ciclo de vida dos pagamentos no sistema.
 *
 * @author Equipe PGBen
 */
let PagamentoService = class PagamentoService {
    pagamentoRepository;
    statusValidator;
    constructor(pagamentoRepository, statusValidator) {
        this.pagamentoRepository = pagamentoRepository;
        this.statusValidator = statusValidator;
    }
    /**
     * Cria um novo registro de pagamento para uma solicitação aprovada
     *
     * @param solicitacaoId ID da solicitação aprovada
     * @param createDto Dados para criação do pagamento
     * @param usuarioId ID do usuário que está realizando a operação
     * @returns Pagamento criado
     */
    async createPagamento(solicitacaoId, createDto, usuarioId) {
        // Validar se a solicitação existe e está aprovada
        // const solicitacao = await this.solicitacaoService.findOne(solicitacaoId);
        // if (!solicitacao) {
        //   throw new NotFoundException('Solicitação não encontrada');
        // }
        // if (solicitacao.status !== 'aprovada') {
        //   throw new ConflictException('Somente solicitações aprovadas podem ter pagamentos liberados');
        // }
        // Validar método de pagamento e informações bancárias
        if (createDto.metodoPagamento !== 'presencial' &&
            !createDto.infoBancariaId) {
            throw new common_1.ConflictException('Informações bancárias são obrigatórias para pagamentos não presenciais');
        }
        // Validar limites de valor
        // await this.validarLimitesPagamento(solicitacao.tipoBeneficioId, createDto.valor);
        // Normalizar campos de enum antes de criar a entidade
        const dadosNormalizados = (0, enum_normalizer_util_1.normalizeEnumFields)({
            solicitacaoId,
            infoBancariaId: createDto.infoBancariaId,
            valor: createDto.valor,
            dataLiberacao: createDto.dataLiberacao,
            status: status_pagamento_enum_1.StatusPagamentoEnum.LIBERADO, // Status inicial ao criar o pagamento
            metodoPagamento: createDto.metodoPagamento,
            liberadoPor: usuarioId,
            observacoes: createDto.observacoes,
        });
        // Criar nova entidade de pagamento
        const pagamento = this.pagamentoRepository.create(dadosNormalizados);
        // Salvar o pagamento
        const result = await this.pagamentoRepository.save(pagamento);
        // Atualizar status da solicitação
        // await this.solicitacaoService.atualizarStatusParaPagamentoPendente(solicitacaoId);
        // Registrar operação no log de auditoria
        // await this.auditoriaService.registrarOperacao({
        //   tipoOperacao: 'CRIACAO_PAGAMENTO',
        //   usuarioId,
        //   entidadeId: result.id,
        //   tipoEntidade: 'PAGAMENTO',
        //   dadosAnteriores: null,
        //   dadosNovos: result
        // });
        return result;
    }
    /**
     * Atualiza o status de um pagamento existente
     *
     * @param id ID do pagamento
     * @param novoStatus Novo status do pagamento
     * @param usuarioId ID do usuário que está realizando a operação
     * @returns Pagamento atualizado
     */
    async atualizarStatus(id, novoStatus, usuarioId) {
        // Buscar o pagamento pelo ID
        const pagamento = await this.findOne(id);
        if (!pagamento) {
            throw new common_1.NotFoundException('Pagamento não encontrado');
        }
        // Validar a transição de status
        const transitionResult = this.statusValidator.canTransition(pagamento.status, novoStatus);
        if (!transitionResult.allowed) {
            throw new common_1.ConflictException(`Transição de status não permitida: ${transitionResult.reason}`);
        }
        // Salvar dados anteriores para auditoria
        const dadosAnteriores = { ...pagamento };
        // Normalizar o novo status antes de atualizar
        const statusNormalizado = (0, enum_normalizer_util_1.normalizeEnumFields)({
            status: novoStatus,
        }).status;
        // Atualizar o status
        pagamento.status = statusNormalizado;
        // Salvar a atualização
        const result = await this.pagamentoRepository.save(pagamento);
        // Atualizar status da solicitação, se necessário
        // if (novoStatus === StatusPagamentoEnum.CONFIRMADO) {
        //   await this.solicitacaoService.atualizarStatusParaConcluido(pagamento.solicitacaoId);
        // } else if (novoStatus === StatusPagamentoEnum.CANCELADO) {
        //   await this.solicitacaoService.atualizarStatusParaAprovado(pagamento.solicitacaoId);
        // }
        // Registrar operação no log de auditoria
        // await this.auditoriaService.registrarOperacao({
        //   tipoOperacao: 'ATUALIZACAO_STATUS_PAGAMENTO',
        //   usuarioId,
        //   entidadeId: id,
        //   tipoEntidade: 'PAGAMENTO',
        //   dadosAnteriores,
        //   dadosNovos: result
        // });
        return result;
    }
    /**
     * Cancela um pagamento existente
     *
     * @param id ID do pagamento a ser cancelado
     * @param usuarioId ID do usuário que está realizando a operação
     * @param motivoCancelamento Motivo do cancelamento
     * @returns Pagamento cancelado
     */
    async cancelarPagamento(id, usuarioId, motivoCancelamento) {
        // Buscar o pagamento pelo ID
        const pagamento = await this.findOne(id);
        if (!pagamento) {
            throw new common_1.NotFoundException('Pagamento não encontrado');
        }
        // Verificar se o pagamento pode ser cancelado
        if (!this.statusValidator.canBeCanceled(pagamento.status)) {
            throw new common_1.ConflictException('Este pagamento não pode ser cancelado devido ao seu status atual');
        }
        // Salvar dados anteriores para auditoria
        const dadosAnteriores = { ...pagamento };
        // Atualizar o status e registrar motivo do cancelamento
        pagamento.status = status_pagamento_enum_1.StatusPagamentoEnum.CANCELADO;
        pagamento.observacoes = pagamento.observacoes
            ? `${pagamento.observacoes}\nMotivo do cancelamento: ${motivoCancelamento}`
            : `Motivo do cancelamento: ${motivoCancelamento}`;
        // Salvar a atualização
        const result = await this.pagamentoRepository.save(pagamento);
        // Atualizar status da solicitação
        // await this.solicitacaoService.atualizarStatusParaAprovado(pagamento.solicitacaoId);
        // Registrar operação no log de auditoria
        // await this.auditoriaService.registrarOperacao({
        //   tipoOperacao: 'CANCELAMENTO_PAGAMENTO',
        //   usuarioId,
        //   entidadeId: id,
        //   tipoEntidade: 'PAGAMENTO',
        //   dadosAnteriores,
        //   dadosNovos: result,
        //   observacoes: motivoCancelamento
        // });
        return result;
    }
    /**
     * Busca um pagamento pelo ID
     *
     * @param id ID do pagamento
     * @returns Pagamento encontrado ou null
     */
    async findOne(id) {
        return this.pagamentoRepository.findOneBy({ id });
    }
    /**
     * Busca um pagamento pelo ID com todos os relacionamentos
     *
     * @param id ID do pagamento
     * @returns Pagamento encontrado com relacionamentos ou null
     */
    async findOneWithRelations(id) {
        return this.pagamentoRepository.findOne({
            where: { id },
            relations: ['comprovantes', 'confirmacoes'],
        });
    }
    /**
     * Lista pagamentos com filtros e paginação
     *
     * @param options Opções de filtro
     * @returns Lista de pagamentos com meta-informações de paginação
     */
    async findAll(options) {
        const { status, unidadeId, dataInicio, dataFim, metodoPagamento, page = 1, limit = 10, } = options;
        // Construir a query base
        const queryBuilder = this.pagamentoRepository.createQueryBuilder('pagamento');
        // Adicionar condições
        if (status) {
            queryBuilder.andWhere('pagamento.status = :status', { status });
        }
        if (metodoPagamento) {
            queryBuilder.andWhere('pagamento.metodo_pagamento = :metodoPagamento', {
                metodoPagamento,
            });
        }
        if (dataInicio) {
            queryBuilder.andWhere('pagamento.data_liberacao >= :dataInicio', {
                dataInicio,
            });
        }
        if (dataFim) {
            queryBuilder.andWhere('pagamento.data_liberacao <= :dataFim', {
                dataFim,
            });
        }
        // Filtro por unidade (requer join com solicitação)
        if (unidadeId) {
            queryBuilder
                .innerJoin('solicitacao', 's', 'pagamento.solicitacao_id = s.id')
                .andWhere('s.unidade_id = :unidadeId', { unidadeId });
        }
        // Adicionar paginação
        queryBuilder.skip((page - 1) * limit).take(limit);
        // Ordenar por data de liberação (mais recentes primeiro)
        queryBuilder.orderBy('pagamento.data_liberacao', 'DESC');
        // Executar a query
        const [items, total] = await queryBuilder.getManyAndCount();
        return {
            items,
            total,
            page,
            limit,
        };
    }
    /**
     * Lista pagamentos pendentes (liberados mas não confirmados)
     *
     * @param options Opções de filtro
     * @returns Lista de pagamentos pendentes
     */
    async findPendentes(options) {
        const { unidadeId, tipoBeneficioId, page = 1, limit = 10 } = options;
        // Construir a query base
        const queryBuilder = this.pagamentoRepository.createQueryBuilder('pagamento');
        // Filtrar apenas pagamentos liberados
        queryBuilder.where('pagamento.status = :status', {
            status: status_pagamento_enum_1.StatusPagamentoEnum.LIBERADO,
        });
        // Filtros adicionais que requerem joins
        if (unidadeId || tipoBeneficioId) {
            queryBuilder.innerJoin('solicitacao', 's', 'pagamento.solicitacao_id = s.id');
            if (unidadeId) {
                queryBuilder.andWhere('s.unidade_id = :unidadeId', { unidadeId });
            }
            if (tipoBeneficioId) {
                queryBuilder.andWhere('s.tipo_beneficio_id = :tipoBeneficioId', {
                    tipoBeneficioId,
                });
            }
        }
        // Adicionar paginação
        queryBuilder.skip((page - 1) * limit).take(limit);
        // Ordenar por data de liberação (mais antigos primeiro)
        queryBuilder.orderBy('pagamento.data_liberacao', 'ASC');
        // Executar a query
        const [items, total] = await queryBuilder.getManyAndCount();
        return {
            items,
            total,
            page,
            limit,
        };
    }
    /**
     * Valida se o valor está dentro dos limites permitidos para o tipo de benefício
     *
     * @param tipoBeneficioId ID do tipo de benefício
     * @param valor Valor a ser validado
     * @throws ConflictException se o valor exceder os limites permitidos
     */
    async validarLimitesPagamento(tipoBeneficioId, valor) {
        // Esta é uma implementação de placeholder
        // Será integrada com o ConfiguracaoModule ou TipoBeneficioService
        // const tipoBeneficio = await this.tipoBeneficioService.findOne(tipoBeneficioId);
        // if (!tipoBeneficio) {
        //   throw new NotFoundException('Tipo de benefício não encontrado');
        // }
        // if (valor > tipoBeneficio.valorMaximo) {
        //   throw new ConflictException(
        //     `O valor excede o limite máximo permitido (${tipoBeneficio.valorMaximo}) para este tipo de benefício`
        //   );
        // }
        // if (valor < tipoBeneficio.valorMinimo) {
        //   throw new ConflictException(
        //     `O valor está abaixo do limite mínimo permitido (${tipoBeneficio.valorMinimo}) para este tipo de benefício`
        //   );
        // }
    }
};
exports.PagamentoService = PagamentoService;
exports.PagamentoService = PagamentoService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(pagamento_entity_1.Pagamento)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof status_transition_validator_1.StatusTransitionValidator !== "undefined" && status_transition_validator_1.StatusTransitionValidator) === "function" ? _b : Object])
], PagamentoService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXHBhZ2FtZW50b1xcc2VydmljZXNcXHBhZ2FtZW50by5zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FJd0I7QUFDeEIsNkNBQW1EO0FBQ25ELHFDQUFxQztBQUNyQyx5RUFBK0Q7QUFDL0QsZ0ZBQTJFO0FBRTNFLDJGQUFzRjtBQUN0RixxRkFBaUY7QUFFakY7Ozs7Ozs7R0FPRztBQUVJLElBQU0sZ0JBQWdCLEdBQXRCLE1BQU0sZ0JBQWdCO0lBR1I7SUFDQTtJQUhuQixZQUVtQixtQkFBMEMsRUFDMUMsZUFBMEM7UUFEMUMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUF1QjtRQUMxQyxvQkFBZSxHQUFmLGVBQWUsQ0FBMkI7SUFLMUQsQ0FBQztJQUVKOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsZUFBZSxDQUNuQixhQUFxQixFQUNyQixTQUE2QixFQUM3QixTQUFpQjtRQUVqQixrREFBa0Q7UUFDbEQsNEVBQTRFO1FBRTVFLHNCQUFzQjtRQUN0QiwrREFBK0Q7UUFDL0QsSUFBSTtRQUVKLDJDQUEyQztRQUMzQyxrR0FBa0c7UUFDbEcsSUFBSTtRQUVKLHNEQUFzRDtRQUN0RCxJQUNFLFNBQVMsQ0FBQyxlQUFlLEtBQUssWUFBWTtZQUMxQyxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQ3pCLENBQUM7WUFDRCxNQUFNLElBQUksMEJBQWlCLENBQ3pCLHdFQUF3RSxDQUN6RSxDQUFDO1FBQ0osQ0FBQztRQUVELDJCQUEyQjtRQUMzQixvRkFBb0Y7UUFFcEYsc0RBQXNEO1FBQ3RELE1BQU0saUJBQWlCLEdBQUcsSUFBQSwwQ0FBbUIsRUFBQztZQUM1QyxhQUFhO1lBQ2IsY0FBYyxFQUFFLFNBQVMsQ0FBQyxjQUFjO1lBQ3hDLEtBQUssRUFBRSxTQUFTLENBQUMsS0FBSztZQUN0QixhQUFhLEVBQUUsU0FBUyxD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SUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVsRCx3REFBd0Q7UUFDeEQsWUFBWSxDQUFDLE9BQU8sQ0FBQywwQkFBMEIsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUV4RCxtQkFBbUI7UUFDbkIsTUFBTSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsR0FBRyxNQUFNLFlBQVksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUU1RCxPQUFPO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxJQUFJO1lBQ0osS0FBSztTQUNOLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssS0FBSyxDQUFDLHVCQUF1QixDQUNuQyxlQUF1QixFQUN2QixLQUFhO1FBRWIsMENBQTBDO1FBQzFDLGtFQUFrRTtRQUNsRSxrRkFBa0Y7UUFDbEYsd0JBQXdCO1FBQ3hCLHFFQUFxRTtRQUNyRSxJQUFJO1FBQ0osMkNBQTJDO1FBQzNDLGlDQUFpQztRQUNqQyw0R0FBNEc7UUFDNUcsT0FBTztRQUNQLElBQUk7UUFDSiwyQ0FBMkM7UUFDM0MsaUNBQWlDO1FBQ2pDLGtIQUFrSDtRQUNsSCxPQUFPO1FBQ1AsSUFBSTtJQUNOLENBQUM7Q0FDRixDQUFBO0FBaFpZLDRDQUFnQjsyQkFBaEIsZ0JBQWdCO0lBRDVCLElBQUEsbUJBQVUsR0FBRTtJQUdSLFdBQUEsSUFBQSwwQkFBZ0IsRUFBQyw0QkFBUyxDQUFDLENBQUE7eURBQ1Usb0JBQVUsb0JBQVYsb0JBQVUsb0RBQ2QsdURBQXlCLG9CQUF6Qix1REFBeUI7R0FKbEQsZ0JBQWdCLENBZ1o1QiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcbW9kdWxlc1xccGFnYW1lbnRvXFxzZXJ2aWNlc1xccGFnYW1lbnRvLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29uZmxpY3RFeGNlcHRpb24sXG4gIEluamVjdGFibGUsXG4gIE5vdEZvdW5kRXhjZXB0aW9uLFxufSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3RSZXBvc2l0b3J5IH0gZnJvbSAnQG5lc3Rqcy90eXBlb3JtJztcbmltcG9ydCB7IFJlcG9zaXRvcnkgfSBmcm9tICd0eXBlb3JtJztcbmltcG9ydCB7IFBhZ2FtZW50byB9IGZyb20gJy4uLy4uLy4uL2VudGl0aWVzL3BhZ2FtZW50by5lbnRpdHknO1xuaW1wb3J0IHsgU3RhdHVzUGFnYW1lbnRvRW51bSB9IGZyb20gJy4uLy4uLy4uL2VudW1zL3N0YXR1cy1wYWdhbWVudG8uZW51bSc7XG5pbXBvcnQgeyBQYWdhbWVudG9DcmVhdGVEdG8gfSBmcm9tICcuLi9kdG9zL3BhZ2FtZW50by1jcmVhdGUuZHRvJztcbmltcG9ydCB7IFN0YXR1c1RyYW5zaXRpb25WYWxpZGF0b3IgfSBmcm9tICcuLi92YWxpZGF0b3JzL3N0YXR1cy10cmFuc2l0aW9uLXZhbGlkYXRvcic7XG5pbXBvcnQgeyBub3JtYWxpemVFbnVtRmllbGRzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2VudW0tbm9ybWFsaXplci51dGlsJztcblxuLyoqXG4gKiBTZXJ2acOnbyBwYXJhIGdlcmVuY2lhbWVudG8gZGUgb3BlcmHDp8O1ZXMgcmVsYWNpb25hZGFzIGEgcGFnYW1lbnRvc1xuICpcbiAqIEltcGxlbWVudGEgYSBsw7NnaWNhIGRlIG5lZ8OzY2lvIHBhcmEgY3JpYcOnw6NvLCBjb25zdWx0YSwgYXR1YWxpemHDp8Ojb1xuICogZSBnZXJlbmNpYW1lbnRvIGRlIGNpY2xvIGRlIHZpZGEgZG9zIHBhZ2FtZW50b3Mgbm8gc2lzdGVtYS5cbiAqXG4gKiBAYXV0aG9yIEVxdWlwZSBQR0JlblxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnYW1lbnRvU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3RSZXBvc2l0b3J5KFBhZ2FtZW50bylcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhZ2FtZW50b1JlcG9zaXRvcnk6IFJlcG9zaXRvcnk8UGFnYW1lbnRvPixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0YXR1c1ZhbGlkYXRvcjogU3RhdHVzVHJhbnNpdGlvblZhbGlkYXRvcixcbiAgICAvLyBPdXRyb3Mgc2VydmnDp29zIG5lY2Vzc8OhcmlvcyBzZXLDo28gaW5qZXRhZG9zIGFxdWlcbiAgICAvLyBwcml2YXRlIHJlYWRvbmx5IHNvbGljaXRhY2FvU2VydmljZTogU29saWNpdGFjYW9TZXJ2aWNlLFxuICAgIC8vIHByaXZhdGUgcmVhZG9ubHkgYXVkaXRvcmlhU2VydmljZTogQXVkaXRvcmlhU2VydmljZSxcbiAgICAvLyBldGMuXG4gICkge31cblxuICAvKipcbiAgICogQ3JpYSB1bSBub3ZvIHJlZ2lzdHJvIGRlIHBhZ2FtZW50byBwYXJhIHVtYSBzb2xpY2l0YcOnw6NvIGFwcm92YWRhXG4gICAqXG4gICAqIEBwYXJhbSBzb2xpY2l0YWNhb0lkIElEIGRhIHNvbGljaXRhw6fDo28gYXByb3ZhZGFcbiAgICogQHBhcmFtIGNyZWF0ZUR0byBEYWRvcyBwYXJhIGNyaWHDp8OjbyBkbyBwYWdhbWVudG9cbiAgICogQHBhcmFtIHVzdWFyaW9JZCBJRCBkbyB1c3XDoXJpbyBxdWUgZXN0w6EgcmVhbGl6YW5kbyBhIG9wZXJhw6fDo29cbiAgICogQHJldHVybnMgUGFnYW1lbnRvIGNyaWFkb1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlUGFnYW1lbnRvKFxuICAgIHNvbGljaXRhY2FvSWQ6IHN0cmluZyxcbiAgICBjcmVhdGVEdG86IFBhZ2FtZW50b0NyZWF0ZUR0byxcbiAgICB1c3VhcmlvSWQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxQYWdhbWVudG8+IHtcbiAgICAvLyBWYWxpZGFyIHNlIGEgc29saWNpdGHDp8OjbyBleGlzdGUgZSBlc3TDoSBhcHJvdmFkYVxuICAgIC8vIGNvbnN0IHNvbGljaXRhY2FvID0gYXdhaXQgdGhpcy5zb2xpY2l0YWNhb1NlcnZpY2UuZmluZE9uZShzb2xpY2l0YWNhb0lkKTtcblxuICAgIC8vIGlmICghc29saWNpdGFjYW8pIHtcbiAgICAvLyAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignU29saWNpdGHDp8OjbyBuw6NvIGVuY29udHJhZGEnKTtcbiAgICAvLyB9XG5cbiAgICAvLyBpZiAoc29saWNpdGFjYW8uc3RhdHVzICE9PSAnYXByb3ZhZGEnKSB7XG4gICAgLy8gICB0aHJvdyBuZXcgQ29uZmxpY3RFeGNlcHRpb24oJ1NvbWVudGUgc29saWNpdGHDp8O1ZXMgYXByb3ZhZGFzIHBvZGVtIHRlciBwYWdhbWVudG9zIGxpYmVyYWRvcycpO1xuICAgIC8vIH1cblxuICAgIC8vIFZhbGlkYXIgbcOpdG9kbyBkZSBwYWdhbWVudG8gZSBpbmZvcm1hw6fDtWVzIGJhbmPDoXJpYXNcbiAgICBpZiAoXG4gICAgICBjcmVhdGVEdG8ubWV0b2RvUGFnYW1lbnRvICE9PSAncHJlc2VuY2lhbCcgJiZcbiAgICAgICFjcmVhdGVEdG8uaW5mb0JhbmNhcmlhSWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdEV4Y2VwdGlvbihcbiAgICAgICAgJ0luZm9ybWHDp8O1ZXMgYmFuY8OhcmlhcyBzw6NvIG9icmlnYXTDs3JpYXMgcGFyYSBwYWdhbWVudG9zIG7Do28gcHJlc2VuY2lhaXMnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGFyIGxpbWl0ZXMgZGUgdmFsb3JcbiAgICAvLyBhd2FpdCB0aGlzLnZhbGlkYXJMaW1pdGVzUGFnYW1lbnRvKHNvbGljaXRhY2FvLnRpcG9CZW5lZmljaW9JZCwgY3JlYXRlRHRvLnZhbG9yKTtcblxuICAgIC8vIE5vcm1hbGl6YXIgY2FtcG9zIGRlIGVudW0gYW50ZXMgZGUgY3JpYXIgYSBlbnRpZGFkZVxuICAgIGNvbnN0IGRhZG9zTm9ybWFsaXphZG9zID0gbm9ybWFsaXplRW51bUZpZWxkcyh7XG4gICAgICBzb2xpY2l0YWNhb0lkLFxuICAgICAgaW5mb0JhbmNhcmlhSWQ6IGNyZWF0ZUR0by5pbmZvQmFuY2FyaWFJZCxcbiAgICAgIHZhbG9yOiBjcmVhdGVEdG8udmFsb3IsXG4gICAgICBkYXRhTGliZXJhY2FvOiBjcmVhdGVEdG8uZGF0YUxpYmVyYWNhbyxcbiAgICAgIHN0YXR1czogU3RhdHVzUGFnYW1lbnRvRW51bS5MSUJFUkFETywgLy8gU3RhdHVzIGluaWNpYWwgYW8gY3JpYXIgbyBwYWdhbWVudG9cbiAgICAgIG1ldG9kb1BhZ2FtZW50bzogY3JlYXRlRHRvLm1ldG9kb1BhZ2FtZW50byxcbiAgICAgIGxpYmVyYWRvUG9yOiB1c3VhcmlvSWQsXG4gICAgICBvYnNlcnZhY29lczogY3JlYXRlRHRvLm9ic2VydmFjb2VzLFxuICAgIH0pO1xuXG4gICAgLy8gQ3JpYXIgbm92YSBlbnRpZGFkZSBkZSBwYWdhbWVudG9cbiAgICBjb25zdCBwYWdhbWVudG8gPSB0aGlzLnBhZ2FtZW50b1JlcG9zaXRvcnkuY3JlYXRlKGRhZG9zTm9ybWFsaXphZG9zKTtcblxuICAgIC8vIFNhbHZhciBvIHBhZ2FtZW50b1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucGFnYW1lbnRvUmVwb3NpdG9yeS5zYXZlKHBhZ2FtZW50byk7XG5cbiAgICAvLyBBdHVhbGl6YXIgc3RhdHVzIGRhIHNvbGljaXRhw6fDo29cbiAgICAvLyBhd2FpdCB0aGlzLnNvbGljaXRhY2FvU2VydmljZS5hdHVhbGl6YXJTdGF0dXNQYXJhUGFnYW1lbnRvUGVuZGVudGUoc29saWNpdGFjYW9JZCk7XG5cbiAgICAvLyBSZWdpc3RyYXIgb3BlcmHDp8OjbyBubyBsb2cgZGUgYXVkaXRvcmlhXG4gICAgLy8gYXdhaXQgdGhpcy5hdWRpdG9yaWFTZXJ2aWNlLnJlZ2lzdHJhck9wZXJhY2FvKHtcbiAgICAvLyAgIHRpcG9PcGVyYWNhbzogJ0NSSUFDQU9fUEFHQU1FTlRPJyxcbiAgICAvLyAgIHVzdWFyaW9JZCxcbiAgICAvLyAgIGVudGlkYWRlSWQ6IHJlc3VsdC5pZCxcbiAgICAvLyAgIHRpcG9FbnRpZGFkZTogJ1BBR0FNRU5UTycsXG4gICAgLy8gICBkYWRvc0FudGVyaW9yZXM6IG51bGwsXG4gICAgLy8gICBkYWRvc05vdm9zOiByZXN1bHRcbiAgICAvLyB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQXR1YWxpemEgbyBzdGF0dXMgZGUgdW0gcGFnYW1lbnRvIGV4aXN0ZW50ZVxuICAgKlxuICAgKiBAcGFyYW0gaWQgSUQgZG8gcGFnYW1lbnRvXG4gICAqIEBwYXJhbSBub3ZvU3RhdHVzIE5vdm8gc3RhdHVzIGRvIHBhZ2FtZW50b1xuICAgKiBAcGFyYW0gdXN1YXJpb0lkIElEIGRvIHVzdcOhcmlvIHF1ZSBlc3TDoSByZWFsaXphbmRvIGEgb3BlcmHDp8Ojb1xuICAgKiBAcmV0dXJucyBQYWdhbWVudG8gYXR1YWxpemFkb1xuICAgKi9cbiAgYXN5bmMgYXR1YWxpemFyU3RhdHVzKFxuICAgIGlkOiBzdHJpbmcsXG4gICAgbm92b1N0YXR1czogU3RhdHVzUGFnYW1lbnRvRW51bSxcbiAgICB1c3VhcmlvSWQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxQYWdhbWVudG8+IHtcbiAgICAvLyBCdXNjYXIgbyBwYWdhbWVudG8gcGVsbyBJRFxuICAgIGNvbnN0IHBhZ2FtZW50byA9IGF3YWl0IHRoaXMuZmluZE9uZShpZCk7XG5cbiAgICBpZiAoIXBhZ2FtZW50bykge1xuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCdQYWdhbWVudG8gbsOjbyBlbmNvbnRyYWRvJyk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhciBhIHRyYW5zacOnw6NvIGRlIHN0YXR1c1xuICAgIGNvbnN0IHRyYW5zaXRpb25SZXN1bHQgPSB0aGlzLnN0YXR1c1ZhbGlkYXRvci5jYW5UcmFuc2l0aW9uKFxuICAgICAgcGFnYW1lbnRvLnN0YXR1cyxcbiAgICAgIG5vdm9TdGF0dXMsXG4gICAgKTtcblxuICAgIGlmICghdHJhbnNpdGlvblJlc3VsdC5hbGxvd2VkKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RFeGNlcHRpb24oXG4gICAgICAgIGBUcmFuc2nDp8OjbyBkZSBzdGF0dXMgbsOjbyBwZXJtaXRpZGE6ICR7dHJhbnNpdGlvblJlc3VsdC5yZWFzb259YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gU2FsdmFyIGRhZG9zIGFudGVyaW9yZXMgcGFyYSBhdWRpdG9yaWFcbiAgICBjb25zdCBkYWRvc0FudGVyaW9yZXMgPSB7IC4uLnBhZ2FtZW50byB9O1xuXG4gICAgLy8gTm9ybWFsaXphciBvIG5vdm8gc3RhdHVzIGFudGVzIGRlIGF0dWFsaXphclxuICAgIGNvbnN0IHN0YXR1c05vcm1hbGl6YWRvID0gbm9ybWFsaXplRW51bUZpZWxkcyh7XG4gICAgICBzdGF0dXM6IG5vdm9TdGF0dXMsXG4gICAgfSkuc3RhdHVzO1xuXG4gICAgLy8gQXR1YWxpemFyIG8gc3RhdHVzXG4gICAgcGFnYW1lbnRvLnN0YXR1cyA9IHN0YXR1c05vcm1hbGl6YWRvO1xuXG4gICAgLy8gU2FsdmFyIGEgYXR1YWxpemHDp8Ojb1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucGFnYW1lbnRvUmVwb3NpdG9yeS5zYXZlKHBhZ2FtZW50byk7XG5cbiAgICAvLyBBdHVhbGl6YXIgc3RhdHVzIGRhIHNvbGljaXRhw6fDo28sIHNlIG5lY2Vzc8OhcmlvXG4gICAgLy8gaWYgKG5vdm9TdGF0dXMgPT09IFN0YXR1c1BhZ2FtZW50b0VudW0uQ09ORklSTUFETykge1xuICAgIC8vICAgYXdhaXQgdGhpcy5zb2xpY2l0YWNhb1NlcnZpY2UuYXR1YWxpemFyU3RhdHVzUGFyYUNvbmNsdWlkbyhwYWdhbWVudG8uc29saWNpdGFjYW9JZCk7XG4gICAgLy8gfSBlbHNlIGlmIChub3ZvU3RhdHVzID09PSBTdGF0dXNQYWdhbWVudG9FbnVtLkNBTkNFTEFETykge1xuICAgIC8vICAgYXdhaXQgdGhpcy5zb2xpY2l0YWNhb1NlcnZpY2UuYXR1YWxpemFyU3RhdHVzUGFyYUFwcm92YWRvKHBhZ2FtZW50by5zb2xpY2l0YWNhb0lkKTtcbiAgICAvLyB9XG5cbiAgICAvLyBSZWdpc3RyYXIgb3BlcmHDp8OjbyBubyBsb2cgZGUgYXVkaXRvcmlhXG4gICAgLy8gYXdhaXQgdGhpcy5hdWRpdG9yaWFTZXJ2aWNlLnJlZ2lzdHJhck9wZXJhY2FvKHtcbiAgICAvLyAgIHRpcG9PcGVyYWNhbzogJ0FUVUFMSVpBQ0FPX1NUQVRVU19QQUdBTUVOVE8nLFxuICAgIC8vICAgdXN1YXJpb0lkLFxuICAgIC8vICAgZW50aWRhZGVJZDogaWQsXG4gICAgLy8gICB0aXBvRW50aWRhZGU6ICdQQUdBTUVOVE8nLFxuICAgIC8vICAgZGFkb3NBbnRlcmlvcmVzLFxuICAgIC8vICAgZGFkb3NOb3ZvczogcmVzdWx0XG4gICAgLy8gfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbGEgdW0gcGFnYW1lbnRvIGV4aXN0ZW50ZVxuICAgKlxuICAgKiBAcGFyYW0gaWQgSUQgZG8gcGFnYW1lbnRvIGEgc2VyIGNhbmNlbGFkb1xuICAgKiBAcGFyYW0gdXN1YXJpb0lkIElEIGRvIHVzdcOhcmlvIHF1ZSBlc3TDoSByZWFsaXphbmRvIGEgb3BlcmHDp8Ojb1xuICAgKiBAcGFyYW0gbW90aXZvQ2FuY2VsYW1lbnRvIE1vdGl2byBkbyBjYW5jZWxhbWVudG9cbiAgICogQHJldHVybnMgUGFnYW1lbnRvIGNhbmNlbGFkb1xuICAgKi9cbiAgYXN5bmMgY2FuY2VsYXJQYWdhbWVudG8oXG4gICAgaWQ6IHN0cmluZyxcbiAgICB1c3VhcmlvSWQ6IHN0cmluZyxcbiAgICBtb3Rpdm9DYW5jZWxhbWVudG86IHN0cmluZyxcbiAgKTogUHJvbWlzZTxQYWdhbWVudG8+IHtcbiAgICAvLyBCdXNjYXIgbyBwYWdhbWVudG8gcGVsbyBJRFxuICAgIGNvbnN0IHBhZ2FtZW50byA9IGF3YWl0IHRoaXMuZmluZE9uZShpZCk7XG5cbiAgICBpZiAoIXBhZ2FtZW50bykge1xuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCdQYWdhbWVudG8gbsOjbyBlbmNvbnRyYWRvJyk7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZpY2FyIHNlIG8gcGFnYW1lbnRvIHBvZGUgc2VyIGNhbmNlbGFkb1xuICAgIGlmICghdGhpcy5zdGF0dXNWYWxpZGF0b3IuY2FuQmVDYW5jZWxlZChwYWdhbWVudG8uc3RhdHVzKSkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0RXhjZXB0aW9uKFxuICAgICAgICAnRXN0ZSBwYWdhbWVudG8gbsOjbyBwb2RlIHNlciBjYW5jZWxhZG8gZGV2aWRvIGFvIHNldSBzdGF0dXMgYXR1YWwnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBTYWx2YXIgZGFkb3MgYW50ZXJpb3JlcyBwYXJhIGF1ZGl0b3JpYVxuICAgIGNvbnN0IGRhZG9zQW50ZXJpb3JlcyA9IHsgLi4ucGFnYW1lbnRvIH07XG5cbiAgICAvLyBBdHVhbGl6YXIgbyBzdGF0dXMgZSByZWdpc3RyYXIgbW90aXZvIGRvIGNhbmNlbGFtZW50b1xuICAgIHBhZ2FtZW50by5zdGF0dXMgPSBTdGF0dXNQYWdhbWVudG9FbnVtLkNBTkNFTEFETztcbiAgICBwYWdhbWVudG8ub2JzZXJ2YWNvZXMgPSBwYWdhbWVudG8ub2JzZXJ2YWNvZXNcbiAgICAgID8gYCR7cGFnYW1lbnRvLm9ic2VydmFjb2VzfVxcbk1vdGl2byBkbyBjYW5jZWxhbWVudG86ICR7bW90aXZvQ2FuY2VsYW1lbnRvfWBcbiAgICAgIDogYE1vdGl2byBkbyBjYW5jZWxhbWVudG86ICR7bW90aXZvQ2FuY2VsYW1lbnRvfWA7XG5cbiAgICAvLyBTYWx2YXIgYSBhdHVhbGl6YcOnw6NvXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdhbWVudG9SZXBvc2l0b3J5LnNhdmUocGFnYW1lbnRvKTtcblxuICAgIC8vIEF0dWFsaXphciBzdGF0dXMgZGEgc29saWNpdGHDp8Ojb1xuICAgIC8vIGF3YWl0IHRoaXMuc29saWNpdGFjYW9TZXJ2aWNlLmF0dWFsaXphclN0YXR1c1BhcmFBcHJvdmFkbyhwYWdhbWVudG8uc29saWNpdGFjYW9JZCk7XG5cbiAgICAvLyBSZWdpc3RyYXIgb3BlcmHDp8OjbyBubyBsb2cgZGUgYXVkaXRvcmlhXG4gICAgLy8gYXdhaXQgdGhpcy5hdWRpdG9yaWFTZXJ2aWNlLnJlZ2lzdHJhck9wZXJhY2FvKHtcbiAgICAvLyAgIHRpcG9PcGVyYWNhbzogJ0NBTkNFTEFNRU5UT19QQUdBTUVOVE8nLFxuICAgIC8vICAgdXN1YXJpb0lkLFxuICAgIC8vICAgZW50aWRhZGVJZDogaWQsXG4gICAgLy8gICB0aXBvRW50aWRhZGU6ICdQQUdBTUVOVE8nLFxuICAgIC8vICAgZGFkb3NBbnRlcmlvcmVzLFxuICAgIC8vICAgZGFkb3NOb3ZvczogcmVzdWx0LFxuICAgIC8vICAgb2JzZXJ2YWNvZXM6IG1vdGl2b0NhbmNlbGFtZW50b1xuICAgIC8vIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdXNjYSB1bSBwYWdhbWVudG8gcGVsbyBJRFxuICAgKlxuICAgKiBAcGFyYW0gaWQgSUQgZG8gcGFnYW1lbnRvXG4gICAqIEByZXR1cm5zIFBhZ2FtZW50byBlbmNvbnRyYWRvIG91IG51bGxcbiAgICovXG4gIGFzeW5jIGZpbmRPbmUoaWQ6IHN0cmluZyk6IFByb21pc2U8UGFnYW1lbnRvIHwgbnVsbD4ge1xuICAgIHJldHVybiB0aGlzLnBhZ2FtZW50b1JlcG9zaXRvcnkuZmluZE9uZUJ5KHsgaWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogQnVzY2EgdW0gcGFnYW1lbnRvIHBlbG8gSUQgY29tIHRvZG9zIG9zIHJlbGFjaW9uYW1lbnRvc1xuICAgKlxuICAgKiBAcGFyYW0gaWQgSUQgZG8gcGFnYW1lbnRvXG4gICAqIEByZXR1cm5zIFBhZ2FtZW50byBlbmNvbnRyYWRvIGNvbSByZWxhY2lvbmFtZW50b3Mgb3UgbnVsbFxuICAgKi9cbiAgYXN5bmMgZmluZE9uZVdpdGhSZWxhdGlvbnMoaWQ6IHN0cmluZyk6IFByb21pc2U8UGFnYW1lbnRvIHwgbnVsbD4ge1xuICAgIHJldHVybiB0aGlzLnBhZ2FtZW50b1JlcG9zaXRvcnkuZmluZE9uZSh7XG4gICAgICB3aGVyZTogeyBpZCB9LFxuICAgICAgcmVsYXRpb25zOiBbJ2NvbXByb3ZhbnRlcycsICdjb25maXJtYWNvZXMnXSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0YSBwYWdhbWVudG9zIGNvbSBmaWx0cm9zIGUgcGFnaW5hw6fDo29cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgT3DDp8O1ZXMgZGUgZmlsdHJvXG4gICAqIEByZXR1cm5zIExpc3RhIGRlIHBhZ2FtZW50b3MgY29tIG1ldGEtaW5mb3JtYcOnw7VlcyBkZSBwYWdpbmHDp8Ojb1xuICAgKi9cbiAgYXN5bmMgZmluZEFsbChvcHRpb25zOiB7XG4gICAgc3RhdHVzPzogU3RhdHVzUGFnYW1lbnRvRW51bTtcbiAgICB1bmlkYWRlSWQ/OiBzdHJpbmc7XG4gICAgZGF0YUluaWNpbz86IERhdGU7XG4gICAgZGF0YUZpbT86IERhdGU7XG4gICAgbWV0b2RvUGFnYW1lbnRvPzogc3RyaW5nO1xuICAgIHBhZ2U/OiBudW1iZXI7XG4gICAgbGltaXQ/OiBudW1iZXI7XG4gIH0pOiBQcm9taXNlPHtcbiAgICBpdGVtczogUGFnYW1lbnRvW107XG4gICAgdG90YWw6IG51bWJlcjtcbiAgICBwYWdlOiBudW1iZXI7XG4gICAgbGltaXQ6IG51bWJlcjtcbiAgfT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXR1cyxcbiAgICAgIHVuaWRhZGVJZCxcbiAgICAgIGRhdGFJbmljaW8sXG4gICAgICBkYXRhRmltLFxuICAgICAgbWV0b2RvUGFnYW1lbnRvLFxuICAgICAgcGFnZSA9IDEsXG4gICAgICBsaW1pdCA9IDEwLFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgLy8gQ29uc3RydWlyIGEgcXVlcnkgYmFzZVxuICAgIGNvbnN0IHF1ZXJ5QnVpbGRlciA9XG4gICAgICB0aGlzLnBhZ2FtZW50b1JlcG9zaXRvcnkuY3JlYXRlUXVlcnlCdWlsZGVyKCdwYWdhbWVudG8nKTtcblxuICAgIC8vIEFkaWNpb25hciBjb25kacOnw7Vlc1xuICAgIGlmIChzdGF0dXMpIHtcbiAgICAgIHF1ZXJ5QnVpbGRlci5hbmRXaGVyZSgncGFnYW1lbnRvLnN0YXR1cyA9IDpzdGF0dXMnLCB7IHN0YXR1cyB9KTtcbiAgICB9XG5cbiAgICBpZiAobWV0b2RvUGFnYW1lbnRvKSB7XG4gICAgICBxdWVyeUJ1aWxkZXIuYW5kV2hlcmUoJ3BhZ2FtZW50by5tZXRvZG9fcGFnYW1lbnRvID0gOm1ldG9kb1BhZ2FtZW50bycsIHtcbiAgICAgICAgbWV0b2RvUGFnYW1lbnRvLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGFJbmljaW8pIHtcbiAgICAgIHF1ZXJ5QnVpbGRlci5hbmRXaGVyZSgncGFnYW1lbnRvLmRhdGFfbGliZXJhY2FvID49IDpkYXRhSW5pY2lvJywge1xuICAgICAgICBkYXRhSW5pY2lvLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGFGaW0pIHtcbiAgICAgIHF1ZXJ5QnVpbGRlci5hbmRXaGVyZSgncGFnYW1lbnRvLmRhdGFfbGliZXJhY2FvIDw9IDpkYXRhRmltJywge1xuICAgICAgICBkYXRhRmltLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmlsdHJvIHBvciB1bmlkYWRlIChyZXF1ZXIgam9pbiBjb20gc29saWNpdGHDp8OjbylcbiAgICBpZiAodW5pZGFkZUlkKSB7XG4gICAgICBxdWVyeUJ1aWxkZXJcbiAgICAgICAgLmlubmVySm9pbignc29saWNpdGFjYW8nLCAncycsICdwYWdhbWVudG8uc29saWNpdGFjYW9faWQgPSBzLmlkJylcbiAgICAgICAgLmFuZFdoZXJlKCdzLnVuaWRhZGVfaWQgPSA6dW5pZGFkZUlkJywgeyB1bmlkYWRlSWQgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRpY2lvbmFyIHBhZ2luYcOnw6NvXG4gICAgcXVlcnlCdWlsZGVyLnNraXAoKHBhZ2UgLSAxKSAqIGxpbWl0KS50YWtlKGxpbWl0KTtcblxuICAgIC8vIE9yZGVuYXIgcG9yIGRhdGEgZGUgbGliZXJhw6fDo28gKG1haXMgcmVjZW50ZXMgcHJpbWVpcm8pXG4gICAgcXVlcnlCdWlsZGVyLm9yZGVyQnkoJ3BhZ2FtZW50by5kYXRhX2xpYmVyYWNhbycsICdERVNDJyk7XG5cbiAgICAvLyBFeGVjdXRhciBhIHF1ZXJ5XG4gICAgY29uc3QgW2l0ZW1zLCB0b3RhbF0gPSBhd2FpdCBxdWVyeUJ1aWxkZXIuZ2V0TWFueUFuZENvdW50KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXRlbXMsXG4gICAgICB0b3RhbCxcbiAgICAgIHBhZ2UsXG4gICAgICBsaW1pdCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RhIHBhZ2FtZW50b3MgcGVuZGVudGVzIChsaWJlcmFkb3MgbWFzIG7Do28gY29uZmlybWFkb3MpXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIE9ww6fDtWVzIGRlIGZpbHRyb1xuICAgKiBAcmV0dXJucyBMaXN0YSBkZSBwYWdhbWVudG9zIHBlbmRlbnRlc1xuICAgKi9cbiAgYXN5bmMgZmluZFBlbmRlbnRlcyhvcHRpb25zOiB7XG4gICAgdW5pZGFkZUlkPzogc3RyaW5nO1xuICAgIHRpcG9CZW5lZmljaW9JZD86IHN0cmluZztcbiAgICBwYWdlPzogbnVtYmVyO1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICB9KTogUHJvbWlzZTx7XG4gICAgaXRlbXM6IFBhZ2FtZW50b1tdO1xuICAgIHRvdGFsOiBudW1iZXI7XG4gICAgcGFnZTogbnVtYmVyO1xuICAgIGxpbWl0OiBudW1iZXI7XG4gIH0+IHtcbiAgICBjb25zdCB7IHVuaWRhZGVJZCwgdGlwb0JlbmVmaWNpb0lkLCBwYWdlID0gMSwgbGltaXQgPSAxMCB9ID0gb3B0aW9ucztcblxuICAgIC8vIENvbnN0cnVpciBhIHF1ZXJ5IGJhc2VcbiAgICBjb25zdCBxdWVyeUJ1aWxkZXIgPVxuICAgICAgdGhpcy5wYWdhbWVudG9SZXBvc2l0b3J5LmNyZWF0ZVF1ZXJ5QnVpbGRlcigncGFnYW1lbnRvJyk7XG5cbiAgICAvLyBGaWx0cmFyIGFwZW5hcyBwYWdhbWVudG9zIGxpYmVyYWRvc1xuICAgIHF1ZXJ5QnVpbGRlci53aGVyZSgncGFnYW1lbnRvLnN0YXR1cyA9IDpzdGF0dXMnLCB7XG4gICAgICBzdGF0dXM6IFN0YXR1c1BhZ2FtZW50b0VudW0uTElCRVJBRE8sXG4gICAgfSk7XG5cbiAgICAvLyBGaWx0cm9zIGFkaWNpb25haXMgcXVlIHJlcXVlcmVtIGpvaW5zXG4gICAgaWYgKHVuaWRhZGVJZCB8fCB0aXBvQmVuZWZpY2lvSWQpIHtcbiAgICAgIHF1ZXJ5QnVpbGRlci5pbm5lckpvaW4oXG4gICAgICAgICdzb2xpY2l0YWNhbycsXG4gICAgICAgICdzJyxcbiAgICAgICAgJ3BhZ2FtZW50by5zb2xpY2l0YWNhb19pZCA9IHMuaWQnLFxuICAgICAgKTtcblxuICAgICAgaWYgKHVuaWRhZGVJZCkge1xuICAgICAgICBxdWVyeUJ1aWxkZXIuYW5kV2hlcmUoJ3MudW5pZGFkZV9pZCA9IDp1bmlkYWRlSWQnLCB7IHVuaWRhZGVJZCB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpcG9CZW5lZmljaW9JZCkge1xuICAgICAgICBxdWVyeUJ1aWxkZXIuYW5kV2hlcmUoJ3MudGlwb19iZW5lZmljaW9faWQgPSA6dGlwb0JlbmVmaWNpb0lkJywge1xuICAgICAgICAgIHRpcG9CZW5lZmljaW9JZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRpY2lvbmFyIHBhZ2luYcOnw6NvXG4gICAgcXVlcnlCdWlsZGVyLnNraXAoKHBhZ2UgLSAxKSAqIGxpbWl0KS50YWtlKGxpbWl0KTtcblxuICAgIC8vIE9yZGVuYXIgcG9yIGRhdGEgZGUgbGliZXJhw6fDo28gKG1haXMgYW50aWdvcyBwcmltZWlybylcbiAgICBxdWVyeUJ1aWxkZXIub3JkZXJCeSgncGFnYW1lbnRvLmRhdGFfbGliZXJhY2FvJywgJ0FTQycpO1xuXG4gICAgLy8gRXhlY3V0YXIgYSBxdWVyeVxuICAgIGNvbnN0IFtpdGVtcywgdG90YWxdID0gYXdhaXQgcXVlcnlCdWlsZGVyLmdldE1hbnlBbmRDb3VudCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1zLFxuICAgICAgdG90YWwsXG4gICAgICBwYWdlLFxuICAgICAgbGltaXQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGEgc2UgbyB2YWxvciBlc3TDoSBkZW50cm8gZG9zIGxpbWl0ZXMgcGVybWl0aWRvcyBwYXJhIG8gdGlwbyBkZSBiZW5lZsOtY2lvXG4gICAqXG4gICAqIEBwYXJhbSB0aXBvQmVuZWZpY2lvSWQgSUQgZG8gdGlwbyBkZSBiZW5lZsOtY2lvXG4gICAqIEBwYXJhbSB2YWxvciBWYWxvciBhIHNlciB2YWxpZGFkb1xuICAgKiBAdGhyb3dzIENvbmZsaWN0RXhjZXB0aW9uIHNlIG8gdmFsb3IgZXhjZWRlciBvcyBsaW1pdGVzIHBlcm1pdGlkb3NcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdmFsaWRhckxpbWl0ZXNQYWdhbWVudG8oXG4gICAgdGlwb0JlbmVmaWNpb0lkOiBzdHJpbmcsXG4gICAgdmFsb3I6IG51bWJlcixcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gRXN0YSDDqSB1bWEgaW1wbGVtZW50YcOnw6NvIGRlIHBsYWNlaG9sZGVyXG4gICAgLy8gU2Vyw6EgaW50ZWdyYWRhIGNvbSBvIENvbmZpZ3VyYWNhb01vZHVsZSBvdSBUaXBvQmVuZWZpY2lvU2VydmljZVxuICAgIC8vIGNvbnN0IHRpcG9CZW5lZmljaW8gPSBhd2FpdCB0aGlzLnRpcG9CZW5lZmljaW9TZXJ2aWNlLmZpbmRPbmUodGlwb0JlbmVmaWNpb0lkKTtcbiAgICAvLyBpZiAoIXRpcG9CZW5lZmljaW8pIHtcbiAgICAvLyAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignVGlwbyBkZSBiZW5lZsOtY2lvIG7Do28gZW5jb250cmFkbycpO1xuICAgIC8vIH1cbiAgICAvLyBpZiAodmFsb3IgPiB0aXBvQmVuZWZpY2lvLnZhbG9yTWF4aW1vKSB7XG4gICAgLy8gICB0aHJvdyBuZXcgQ29uZmxpY3RFeGNlcHRpb24oXG4gICAgLy8gICAgIGBPIHZhbG9yIGV4Y2VkZSBvIGxpbWl0ZSBtw6F4aW1vIHBlcm1pdGlkbyAoJHt0aXBvQmVuZWZpY2lvLnZhbG9yTWF4aW1vfSkgcGFyYSBlc3RlIHRpcG8gZGUgYmVuZWbDrWNpb2BcbiAgICAvLyAgICk7XG4gICAgLy8gfVxuICAgIC8vIGlmICh2YWxvciA8IHRpcG9CZW5lZmljaW8udmFsb3JNaW5pbW8pIHtcbiAgICAvLyAgIHRocm93IG5ldyBDb25mbGljdEV4Y2VwdGlvbihcbiAgICAvLyAgICAgYE8gdmFsb3IgZXN0w6EgYWJhaXhvIGRvIGxpbWl0ZSBtw61uaW1vIHBlcm1pdGlkbyAoJHt0aXBvQmVuZWZpY2lvLnZhbG9yTWluaW1vfSkgcGFyYSBlc3RlIHRpcG8gZGUgYmVuZWbDrWNpb2BcbiAgICAvLyAgICk7XG4gICAgLy8gfVxuICB9XG59XG4iXSwidmVyc2lvbiI6M30=