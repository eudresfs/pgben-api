d3ffb6d84cd7922f24036e96ed2155c6
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PermissionService_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionService = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const permission_repository_1 = require("../repositories/permission.repository");
const role_permission_repository_1 = require("../repositories/role-permission.repository");
const user_permission_repository_1 = require("../repositories/user-permission.repository");
const permission_scope_repository_1 = require("../repositories/permission-scope.repository");
const user_permission_entity_1 = require("../../entities/user-permission.entity");
const cache_manager_1 = require("@nestjs/cache-manager");
const cache_manager_2 = require("cache-manager");
/**
 * Serviço responsável por verificar permissões de usuários.
 *
 * Este serviço implementa a lógica de verificação de permissões granulares,
 * considerando permissões diretas, permissões de role e permissões compostas.
 * Também implementa cache para otimizar o desempenho das verificações.
 */
let PermissionService = PermissionService_1 = class PermissionService {
    permissionRepository;
    rolePermissionRepository;
    userPermissionRepository;
    permissionScopeRepository;
    cacheManager;
    logger = new common_1.Logger(PermissionService_1.name);
    CACHE_TTL = 300; // 5 minutos em segundos
    constructor(permissionRepository, rolePermissionRepository, userPermissionRepository, permissionScopeRepository, cacheManager) {
        this.permissionRepository = permissionRepository;
        this.rolePermissionRepository = rolePermissionRepository;
        this.userPermissionRepository = userPermissionRepository;
        this.permissionScopeRepository = permissionScopeRepository;
        this.cacheManager = cacheManager;
        this.logger.log('PermissionService inicializado');
        // Verificar se o cache está funcionando
        this.cacheManager.set('permission_service_test', 'ok', 10)
            .then(() => this.logger.log('Cache inicializado com sucesso'))
            .catch(err => this.logger.warn(`Erro ao inicializar cache: ${err.message}. Usando fallback.`));
    }
    /**
     * Verifica se um usuário tem uma permissão específica.
     *
     * @param options Opções de verificação de permissão
     * @returns true se o usuário tem a permissão, false caso contrário
     */
    async hasPermission(options) {
        try {
            const { userId, permissionName, scopeType = user_permission_entity_1.TipoEscopo.GLOBAL, scopeId } = options;
            // Validação de parâmetros
            if (!userId || !permissionName) {
                this.logger.warn(`Tentativa de verificar permissão com parâmetros inválidos: userId=${userId}, permissionName=${permissionName}`);
                return false;
            }
            // Validação de escopo
            if (scopeType === user_permission_entity_1.TipoEscopo.UNIDADE && !scopeId) {
                this.logger.warn(`Tentativa de verificar permissão com escopo UNIT sem fornecer scopeId: userId=${userId}, permissionName=${permissionName}`);
                return false;
            }
            // Verificar cache
            const cacheKey = this.generateCacheKey(userId, permissionName, scopeType, scopeId);
            let cachedResult;
            try {
                cachedResult = await this.cacheManager.get(cacheKey);
                if (cachedResult !== undefined && cachedResult !== null) {
                    return cachedResult;
                }
            }
            catch (error) {
                this.logger.warn(`Erro ao acessar cache: ${error.message}. Usando verificação direta.`);
            }
            // Verificar permissões compostas
            if (permissionName.includes(',')) {
                const permissions = permissionName.split(',');
                for (const perm of permissions) {
                    const hasIndividualPermission = await this.hasPermission({
                        userId,
                        permissionName: perm.trim(),
                        scopeType,
                        scopeId,
                    });
                    if (hasIndividualPermission) {
                        try {
                            await this.cacheManager.set(cacheKey, true, 300);
                        }
                        catch (error) {
                            this.logger.warn(`Erro ao escrever no cache: ${error.message}`);
                        }
                        return true;
                    }
                }
                try {
                    await this.cacheManager.set(cacheKey, false, 300);
                }
                catch (error) {
                    this.logger.warn(`Erro ao escrever no cache: ${error.message}`);
                }
                return false;
            }
            // Verifica permissões diretas do usuário
            const hasDirectPermission = await this.checkDirectPermission(userId, permissionName, scopeType, scopeId);
            if (hasDirectPermission) {
                await this.cacheManager.set(cacheKey, true, this.CACHE_TTL);
                return true;
            }
            // Verifica permissões da role do usuário
            const hasRolePermission = await this.checkRolePermission(userId, permissionName);
            if (hasRolePermission) {
                await this.cacheManager.set(cacheKey, true, this.CACHE_TTL);
                return true;
            }
            // Verifica permissões compostas (wildcards)
            const hasCompositePermission = await this.checkCompositePermission(userId, permissionName, scopeType, scopeId);
            if (hasCompositePermission) {
                await this.cacheManager.set(cacheKey, true, this.CACHE_TTL);
                return true;
            }
            // Se chegou aqui, o usuário não tem a permissão
            await this.cacheManager.set(cacheKey, false, this.CACHE_TTL);
            return false;
        }
        catch (error) {
            this.logger.error(`Erro ao verificar permissão: ${error.message}`, {
                options, // Usar o objeto options completo em vez das propriedades individuais
                stack: error.stack
            });
            return false;
        }
    }
    /**
     * Verifica se um usuário tem uma permissão direta.
     *
     * @param userId ID do usuário
     * @param permissionName Nome da permissão
     * @param scopeType Tipo de escopo
     * @param scopeId ID do escopo (opcional para escopo GLOBAL)
     * @returns true se o usuário tem a permissão direta, false caso contrário
     */
    async checkDirectPermission(userId, permissionName, scopeType, scopeId) {
        try {
            // Busca a permissão pelo nome
            const permission = await this.permissionRepository.findByName(permissionName);
            if (!permission) {
                this.logger.warn(`Permissão não encontrada: ${permissionName}`);
                return false;
            }
            // Verifica se o usuário tem a permissão direta
            const userPermission = await this.userPermissionRepository.findByUserAndPermission(userId, permission.id, scopeType, scopeId || undefined);
            // Se não encontrou a permissão ou ela não está concedida, retorna false
            if (!userPermission || !userPermission.granted) {
                return false;
            }
            // Verifica se a permissão está expirada
            if (userPermission.validUntil && userPermission.validUntil < new Date()) {
                this.logger.debug(`Permissão expirada: ${permissionName} para usuário ${userId}`);
                return false;
            }
            return true;
        }
        catch (error) {
            this.logger.error(`Erro ao verificar permissão direta: ${error.message}`, {
                userId,
                permissionName,
                scopeType,
                scopeId,
                stack: error.stack
            });
            return false;
        }
    }
    /**
     * Verifica se um usuário tem uma permissão através da sua role.
     *
     * @param userId ID do usuário
     * @param permissionName Nome da permissão
     * @returns true se o usuário tem a permissão através da sua role, false caso contrário
     */
    async checkRolePermission(userId, permissionName) {
        try {
            // Busca a permissão pelo nome
            const permission = await this.permissionRepository.findByName(permissionName);
            if (!permission) {
                this.logger.warn(`Permissão não encontrada: ${permissionName}`);
                return false;
            }
            // Verifica se existe uma role com a permissão usando o método findPermissionsByUserRoles
            const permissions = await this.rolePermissionRepository.findPermissionsByUserRoles(userId);
            // Verifica se a permissão específica está na lista de permissões da role
            return permissions.some(p => p.id === permission.id || p.name === permissionName);
        }
        catch (error) {
            this.logger.error(`Erro ao verificar permissão de role: ${error.message}`, {
                userId,
                permissionName,
                stack: error.stack
            });
            return false;
        }
    }
    /**
     * Verifica se um usuário tem uma permissão composta (com wildcard).
     *
     * @param userId ID do usuário
     * @param permissionName Nome da permissão específica que está sendo verificada
     * @param scopeType Tipo de escopo
     * @param scopeId ID do escopo (opcional para escopo GLOBAL)
     * @returns true se o usuário tem a permissão composta, false caso contrário
     */
    async checkCompositePermission(userId, permissionName, scopeType, scopeId) {
        try {
            // Divide o nome da permissão em partes (ex: 'modulo.recurso.operacao')
            const parts = permissionName.split('.');
            if (parts.length < 2) {
                return false; // Formato inválido
            }
            // Constrói os wildcards possíveis
            const wildcards = [];
            // Permissão super admin - verifica primeiro para otimização
            wildcards.push('*.*');
            // Wildcard para módulo (ex: 'modulo.*')
            wildcards.push(`${parts[0]}.*`);
            // Wildcard para recurso (ex: 'modulo.recurso.*')
            if (parts.length >= 2) {
                wildcards.push(`${parts[0]}.${parts[1]}.*`);
            }
            // Wildcard para operação (ex: '*.operacao')
            if (parts.length >= 2) {
                wildcards.push(`*.${parts[parts.length - 1]}`);
            }
            // Verifica cada wildcard
            for (const wildcard of wildcards) {
                // Verifica permissão direta
                const hasDirectWildcard = await this.checkDirectPermission(userId, wildcard, scopeType, scopeId);
                if (hasDirectWildcard) {
                    this.logger.debug(`Usuário ${userId} tem permissão wildcard direta: ${wildcard}`);
                    return true;
                }
                // Verifica permissão de role
                const hasRoleWildcard = await this.checkRolePermission(userId, wildcard);
                if (hasRoleWildcard) {
                    this.logger.debug(`Usuário ${userId} tem permissão wildcard via role: ${wildcard}`);
                    return true;
                }
            }
            return false;
        }
        catch (error) {
            this.logger.error(`Erro ao verificar permissão composta: ${error.message}`, {
                userId,
                permissionName,
                scopeType,
                scopeId,
                stack: error.stack
            });
            return false;
        }
    }
    /**
     * Gera uma chave de cache para uma verificação de permissão.
     *
     * @param userId ID do usuário
     * @param permissionName Nome da permissão
     * @param scopeType Tipo de escopo
     * @param scopeId ID do escopo (opcional para escopo GLOBAL)
     * @returns Chave de cache
     */
    generateCacheKey(userId, permissionName, scopeType, scopeId) {
        return `permission:${userId}:${permissionName}:${scopeType}:${scopeId || 'global'}`;
    }
    /**
     * Limpa o cache de permissões de um usuário.
     *
     * @param userId ID do usuário
     */
    async clearUserPermissionCache(userId) {
        try {
            // Implementação simplificada para evitar uso de métodos que podem não estar disponíveis
            // em todas as implementações de cache
            this.logger.debug(`Limpando cache para o usuário: ${userId}`);
            // Como não temos acesso direto a um método para limpar todo o cache,
            // vamos usar uma abordagem alternativa que funciona com a maioria das implementações
            // Definimos uma chave com TTL muito curto para forçar a limpeza do cache
            await this.cacheManager.set(`user-cache-clear:${userId}:${Date.now()}`, true, 1);
            this.logger.debug(`Cache de permissões limpo para o usuário ${userId}`);
        }
        catch (error) {
            this.logger.error(`Erro ao limpar cache de permissões do usuário: ${error.message}`, {
                userId,
                stack: error.stack
            });
        }
    }
    /**
     * Limpa o cache de permissões para uma permissão específica.
     *
     * @param permissionName Nome da permissão
     */
    async clearPermissionCache(permissionName) {
        try {
            // Obter todas as chaves de cache relacionadas à permissão
            // Isso é uma simplificação, pois o cache-manager não suporta busca por padrão
            // Em uma implementação real, seria necessário usar um adaptador que suporte isso
            // Limpar o cache
            // Como não podemos buscar chaves, vamos apenas registrar que o cache deveria ser limpo
            this.logger.log(`Cache da permissão ${permissionName} deveria ser limpo`);
        }
        catch (error) {
            this.logger.error(`Erro ao limpar cache da permissão: ${error.message}`, {
                permissionName,
                stack: error.stack
            });
        }
    }
    /**
     * Obtém todas as permissões ativas de um usuário.
     *
     * @param userId ID do usuário
     * @param includeInactive Se true, inclui permissões inativas (revogadas ou expiradas)
     * @returns Lista de permissões do usuário
     */
    async getUserPermissions(userId, includeInactive = false) {
        try {
            // Busca permissões diretas do usuário
            const userPermissions = await this.userPermissionRepository.findByUserId(userId);
            // Filtra permissões ativas, se necessário
            const filteredUserPermissions = includeInactive
                ? userPermissions
                : userPermissions.filter(up => up.granted && (!up.validUntil || up.validUntil > new Date()));
            // Obtém IDs das permissões
            const permissionIds = filteredUserPermissions.map(up => up.permissionId);
            // Busca permissões de role do usuário
            const rolePermissions = await this.rolePermissionRepository.findPermissionsByUserRoles(userId);
            // Adiciona IDs de permissões de role
            rolePermissions.forEach(permission => {
                if (!permissionIds.includes(permission.id)) {
                    permissionIds.push(permission.id);
                }
            });
            // Busca detalhes das permissões
            if (permissionIds.length === 0) {
                return [];
            }
            return this.permissionRepository.findByIds(permissionIds);
        }
        catch (error) {
            this.logger.error(`Erro ao obter permissões do usuário: ${error.message}`, {
                userId,
                includeInactive,
                stack: error.stack
            });
            return [];
        }
    }
    /**
     * Obtém todas as permissões disponíveis no sistema.
     *
     * @returns Lista de todas as permissões
     */
    async getAllPermissions() {
        try {
            // Busca todas as permissões no banco, usando a query builder para ter mais controle
            // e evitar problemas com nomes de propriedades
            const permissions = await this.permissionRepository
                .createQueryBuilder('permission')
                .select(['permission.id', 'permission.nome', 'permission.descricao'])
                .getMany();
            return permissions;
        }
        catch (error) {
            this.logger.error(`Erro ao buscar todas as permissões: ${error.message}`, {
                stack: error.stack
            });
            return [];
        }
    }
    /**
     * Cria uma nova permissão no sistema.
     *
     * @param name Nome da permissão (deve seguir o formato modulo.operacao)
     * @param description Descrição da permissão
     * @param createdBy ID do usuário que está criando a permissão
     * @returns A permissão criada ou null se ocorrer um erro
     */
    async createPermission(name, description, createdBy) {
        try {
            // Validação de parâmetros
            if (!name || !createdBy) {
                this.logger.warn(`Tentativa de criar permissão com parâmetros inválidos: name=${name}, createdBy=${createdBy}`);
                return null;
            }
            // Verifica se a permissão já existe
            const existingPermission = await this.permissionRepository.findByName(name);
            if (existingPermission) {
                this.logger.warn(`Tentativa de criar permissão já existente: ${name}`);
                return existingPermission;
            }
            // Cria a nova permissão
            const newPermission = this.permissionRepository.create({
                nome: name,
                descricao: description || `Permissão ${name}`
            });
            // Salva a permissão no banco de dados
            const savedPermission = await this.permissionRepository.save(newPermission);
            this.logger.log(`Permissão ${name} criada com sucesso por ${createdBy}`);
            return savedPermission;
        }
        catch (error) {
            this.logger.error(`Erro ao criar permissão: ${error.message}`, {
                name,
                description,
                createdBy,
                stack: error.stack
            });
            return null;
        }
    }
    /**
     * Cria uma permissão se ela não existir.
     *
     * @param name Nome da permissão
     * @param description Descrição da permissão
     * @param createdBy ID do usuário que está criando a permissão
     * @returns A permissão criada ou existente, ou null se ocorrer um erro
     */
    async createPermissionIfNotExists(name, description, createdBy) {
        try {
            // Busca a permissão pelo nome
            const existingPermission = await this.permissionRepository.findByName(name);
            if (existingPermission) {
                return existingPermission;
            }
            // Se não existir, cria uma nova
            return this.createPermission(name, description, createdBy);
        }
        catch (error) {
            this.logger.error(`Erro ao criar permissão se não existir: ${error.message}`, {
                name,
                description,
                createdBy,
                stack: error.stack
            });
            return null;
        }
    }
    /**
     * Revoga uma permissão de um usuário.
     *
     * @param userId ID do usuário
     * @param permissionName Nome da permissão
     * @param scopeType Tipo de escopo
     * @param scopeId ID do escopo (opcional para escopo GLOBAL)
     * @param createdBy ID do usuário que está revogando a permissão
     * @returns true se a permissão foi revogada com sucesso, false caso contrário
     */
    async revokePermission(userId, permissionName, scopeType, scopeId, createdBy) {
        try {
            // Validação de parâmetros
            if (!userId || !permissionName || !createdBy) {
                this.logger.warn(`Tentativa de revogar permissão com parâmetros inválidos: userId=${userId}, permissionName=${permissionName}, createdBy=${createdBy}`);
                return false;
            }
            // Validação de escopo
            if (scopeType === user_permission_entity_1.TipoEscopo.UNIDADE && !scopeId) {
                this.logger.warn(`Tentativa de revogar permissão com escopo UNIT sem fornecer scopeId: userId=${userId}, permissionName=${permissionName}`);
                return false;
            }
            // Busca a permissão pelo nome
            const permission = await this.permissionRepository.findByName(permissionName);
            if (!permission) {
                this.logger.warn(`Tentativa de revogar permissão inexistente: permissionName=${permissionName}`);
                return false;
            }
            // Verifica se o usuário tem a permissão
            const existingPermission = await this.userPermissionRepository.findByUserAndPermission(userId, permission.id, scopeType, scopeId || undefined);
            if (!existingPermission) {
                this.logger.warn(`Tentativa de revogar permissão que o usuário não possui: userId=${userId}, permissionName=${permissionName}`);
                return false;
            }
            // Verifica se a permissão já está revogada
            if (existingPermission && !existingPermission.granted) {
                this.logger.log(`Permissão já está revogada: userId=${userId}, permissionName=${permissionName}`);
                return true; // Considera sucesso, pois o estado final é o desejado
            }
            // Atualiza a permissão existente para revogada
            await this.userPermissionRepository.updateUserPermission(existingPermission.id, {
                granted: false,
                updatedBy: createdBy,
            });
            // Limpa o cache de permissões do usuário
            await this.clearUserPermissionCache(userId);
            // Limpa o cache da permissão específica
            await this.clearPermissionCache(permissionName);
            // Registra a operação no log
            this.logger.log(`Permissão ${permissionName} revogada do usuário ${userId} com escopo ${scopeType} por ${createdBy}`);
            return true;
        }
        catch (error) {
            this.logger.error(`Erro ao revogar permissão: ${error.message}`, {
                userId,
                permissionName,
                scopeType,
                scopeId,
                createdBy,
                stack: error.stack
            });
            return false;
        }
    }
    /**
     * Concede uma permissão a um usuário.
     *
     * @param userId ID do usuário
     * @param permissionName Nome da permissão
     * @param scopeType Tipo de escopo
     * @param scopeId ID do escopo (opcional para escopo GLOBAL)
     * @param validUntil Data de validade da permissão (opcional)
     * @param createdBy ID do usuário que está concedendo a permissão
     * @returns true se a permissão foi concedida com sucesso, false caso contrário
     */
    async grantPermission(userId, permissionName, scopeType, scopeId, validUntil, createdBy) {
        try {
            // Validação de parâmetros
            if (!userId || !permissionName || !createdBy) {
                this.logger.warn(`Tentativa de conceder permissão com parâmetros inválidos: userId=${userId}, permissionName=${permissionName}, createdBy=${createdBy}`);
                return false;
            }
            // Validação de escopo
            if (scopeType === user_permission_entity_1.TipoEscopo.UNIDADE && !scopeId) {
                this.logger.warn(`Tentativa de conceder permissão com escopo UNIT sem fornecer scopeId: userId=${userId}, permissionName=${permissionName}`);
                return false;
            }
            // Busca a permissão pelo nome
            const permission = await this.permissionRepository.findByName(permissionName);
            if (!permission) {
                this.logger.warn(`Tentativa de conceder permissão inexistente: permissionName=${permissionName}`);
                return false;
            }
            // Verifica se o usuário já tem a permissão
            const existingPermission = await this.userPermissionRepository.findByUserAndPermission(userId, permission.id, scopeType, scopeId || undefined);
            // Se já existe e está ativa, apenas atualiza a data de validade se necessário
            if (existingPermission && existingPermission.granted) {
                // Verifica se precisa atualizar a data de validade
                if (validUntil && (!existingPermission.validUntil || validUntil > existingPermission.validUntil)) {
                    await this.userPermissionRepository.updateUserPermission(existingPermission.id, {
                        validUntil,
                        updatedBy: createdBy,
                    });
                    this.logger.log(`Data de validade da permissão ${permissionName} atualizada para o usuário ${userId}`);
                }
                else {
                    this.logger.log(`Usuário ${userId} já possui a permissão ${permissionName}`);
                }
                return true;
            }
            // Se existe mas está revogada, reativa
            if (existingPermission && !existingPermission.granted) {
                await this.userPermissionRepository.updateUserPermission(existingPermission.id, {
                    granted: true,
                    validUntil: validUntil || null,
                    updatedBy: createdBy,
                });
                this.logger.log(`Permissão ${permissionName} reativada para o usuário ${userId} com escopo ${scopeType} por ${createdBy}`);
            }
            else {
                // Cria uma nova permissão para o usuário
                await this.userPermissionRepository.createUserPermission({
                    userId,
                    permissionId: permission.id,
                    scopeType,
                    scopeId: scopeId || undefined,
                    granted: true,
                    validUntil: validUntil || null,
                    createdBy,
                });
                this.logger.log(`Permissão ${permissionName} concedida ao usuário ${userId} com escopo ${scopeType} por ${createdBy}`);
            }
            // Limpa o cache de permissões do usuário
            await this.clearUserPermissionCache(userId);
            // Limpa o cache da permissão específica
            await this.clearPermissionCache(permissionName);
            return true;
        }
        catch (error) {
            this.logger.error(`Erro ao conceder permissão: ${error.message}`, {
                error: error.message,
                stack: error.stack
            });
            return false;
        }
    }
    /**
     * Obtém as permissões associadas a uma role.
     *
     * @param roleId ID da role
     * @returns Lista de permissões associadas à role
     */
    async getPermissionsByRole(roleId) {
        try {
            // Busca as permissões associadas à role
            const rolePermissions = await this.rolePermissionRepository.findByRoleId(roleId);
            if (!rolePermissions || rolePermissions.length === 0) {
                return [];
            }
            // Extrai os IDs das permissões
            const permissionIds = rolePermissions.map(rp => rp.permissionId);
            // Busca os detalhes das permissões
            return this.permissionRepository.findByIds(permissionIds);
        }
        catch (error) {
            this.logger.error(`Erro ao obter permissões da role: ${error.message}`, {
                roleId,
                stack: error.stack
            });
            return [];
        }
    }
    /**
     * Obtém as permissões de role associadas a um usuário.
     *
     * @param userId ID do usuário
     * @returns Lista de permissões de role do usuário
     */
    async getRolePermissionsByUserId(userId) {
        try {
            // Busca permissões de role do usuário
            const permissions = await this.rolePermissionRepository.findPermissionsByUserRoles(userId);
            return permissions || [];
        }
        catch (error) {
            this.logger.error(`Erro ao obter permissões de role do usuário: ${error.message}`, {
                userId,
                stack: error.stack
            });
            return [];
        }
    }
};
exports.PermissionService = PermissionService;
exports.PermissionService = PermissionService = PermissionService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(permission_repository_1.PermissionRepository)),
    __param(1, (0, typeorm_1.InjectRepository)(role_permission_repository_1.RolePermissionRepository)),
    __param(2, (0, typeorm_1.InjectRepository)(user_permission_repository_1.UserPermissionRepository)),
    __param(3, (0, typeorm_1.InjectRepository)(permission_scope_repository_1.PermissionScopeRepository)),
    __param(4, (0, common_1.Inject)(cache_manager_1.CACHE_MANAGER)),
    __metadata("design:paramtypes", [typeof (_a = typeof permission_repository_1.PermissionRepository !== "undefined" && permission_repository_1.PermissionRepository) === "function" ? _a : Object, typeof (_b = typeof role_permission_repository_1.RolePermissionRepository !== "undefined" && role_permission_repository_1.RolePermissionRepository) === "function" ? _b : Object, typeof (_c = typeof user_permission_repository_1.UserPermissionRepository !== "undefined" && user_permission_repository_1.UserPermissionRepository) === "function" ? _c : Object, typeof (_d = typeof permission_scope_repository_1.PermissionScopeRepository !== "undefined" && permission_scope_repository_1.PermissionScopeRepository) === "function" ? _d : Object, typeof (_e = typeof cache_manager_2.Cache !== "undefined" && cache_manager_2.Cache) === "function" ? _e : Object])
], PermissionService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXGF1dGhcXHNlcnZpY2VzXFxwZXJtaXNzaW9uLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBNEQ7QUFDNUQsNkNBQW1EO0FBRW5ELGlGQUE2RTtBQUM3RSwyRkFBc0Y7QUFDdEYsMkZBQXNGO0FBQ3RGLDZGQUF3RjtBQUN4RixrRkFBbUU7QUFDbkUseURBQXNEO0FBQ3RELGlEQUFzQztBQTJCdEM7Ozs7OztHQU1HO0FBRUksSUFBTSxpQkFBaUIseUJBQXZCLE1BQU0saUJBQWlCO0lBTWxCO0lBRUE7SUFFQTtJQUVBO0lBRUE7SUFiTyxNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsbUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDNUMsU0FBUyxHQUFHLEdBQUcsQ0FBQyxDQUFDLHdCQUF3QjtJQUUxRCxZQUVVLG9CQUEwQyxFQUUxQyx3QkFBa0QsRUFFbEQsd0JBQWtELEVBRWxELHlCQUFvRCxFQUVwRCxZQUFtQjtRQVJuQix5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXNCO1FBRTFDLDZCQUF3QixHQUF4Qix3QkFBd0IsQ0FBMEI7UUFFbEQsNkJBQXdCLEdBQXhCLHdCQUF3QixDQUEwQjtRQUVsRCw4QkFBeUIsR0FBekIseUJBQXlCLENBQTJCO1FBRXBELGlCQUFZLEdBQVosWUFBWSxDQUFPO1FBRTNCLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7UUFFbEQsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLHlCQUF5QixFQUFFLElBQUksRUFBRSxFQUFFLENBQUM7YUFDdkQsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7YUFDN0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsOEJBQThCLEdBQUcsQ0FBQyxPQUFPLG9CQUFvQixDQUFDLENBQUMsQ0FBQztJQUNuRyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsYUFBYSxDQUFDLE9BQStCO1FBQ2pELElBQUksQ0FBQztZQUNILE1BQU0sRUFBRSxNQUFNLEVBQUUsY0FBYyxFQUFFLFNBQVMsR0FBRyxtQ0FBVSxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsR0FBRyxPQUFPLENBQUM7WUFFbkYsMEJBQTBCO1lBQzFCLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDL0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMscUVBQXFFLE1BQU0sb0JBQW9CLGNBQWMsRUFBRSxDQUFDLENBQUM7Z0JBQ2xJLE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQztZQUVELHNCQUFzQjtZQUN0QixJQUFJLFNBQVMsS0FBSyxtQ0FBVSxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNqRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxpRkFBaUYsTUFBTSxvQkFBb0IsY0FBYyxFQUFFLENBQUMsQ0FBQztnQkFDOUksT0FBTyxLQUFLLENBQUM7WUFDZixDQUFDO1lBRUQsa0JBQWtCO1lBQ2xCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNuRixJQUFJLFlBQVksQ0FBQztZQUVqQixJQUFJLENBQUM7Z0JBQ0gsWUFBWSxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQVUsUUFBUSxDQUFDLENBQUM7Z0JBQzlELElBQUksWUFBWSxLQUFLLFNBQVMsSUFBSSxZQUFZLEtBQUssSUFBSSxFQUFFLENBQUM7b0JBQ3hELE9BQU8sWUFBWSxDQUFDO2dCQUN0QixDQUFDO1lBQ0gsQ0FBQztZQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7Z0JBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsMEJBQTBCLEtBQUssQ0FBQyxPQUFPLDhCQUE4QixDQUFDLENBQUM7WUFDMUYsQ0FBQztZQUVELGlDQUFpQztZQUNqQyxJQUFJLGNBQWMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDakMsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDOUMsS0FBSyxNQUFNLElBQUksSUFBSSxXQUFXLEVBQUUsQ0FBQztvQkFDL0IsTUFBTSx1QkFBdUIsR0FBRyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUM7d0JBQ3ZELE1BQU07d0JBQ04sY0FBYyxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUU7d0JBQzNCLFNBQVM7d0JBQ1QsT0FBTztxQkFDUixDQUFDLENBQUM7b0JBRUgsSUFBSSx1QkFBdUIsRUFBRSxDQUFDO3dCQUM1QixJQUFJLENBQUM7NEJBQ0gsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO3dCQUNuRCxDQUFDO3dCQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7NEJBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsOEJBQThCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO3dCQUNsRSxDQUFDO3dCQUNELE9BQU8sSUFBSSxDQUFDO29CQUNkLENBQUM7Z0JBQ0gsQ0FBQztnQkFFRCxJQUFJLENBQUM7b0JBQ0gsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUNwRCxDQUFDO2dCQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7b0JBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsOEJBQThCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2dCQUNsRSxDQUFDO2dCQUNELE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQztZQUVELHlDQUF5QztZQUN6QyxNQUFNLG1CQUFtQixHQUFHLE1BQU0sSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ3pHLElBQUksbUJBQW1CLEVBQUUsQ0FBQztnQkFDeEIsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDNUQsT0FBTyxJQUFJLENBQUM7WUFDZCxDQUFDO1lBRUQseUNBQXlDO1lBQ3pDLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBQ2pGLElBQUksaUJBQWlCLEVBQUUsQ0FBQztnQkFDdEIsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDNUQsT0FBTyxJQUFJLENBQUM7WUFDZCxDQUFDO1lBRUQsNENBQTRDO1lBQzVDLE1BQU0sc0JBQXNCLEdBQUcsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsTUFBTSxFQUFFLGNBQWMsRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDL0csSUFBSSxzQkFBc0IsRUFBRSxDQUFDO2dCQUMzQixNQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUM1RCxPQUFPLElBQUksQ0FBQztZQUNkLENBQUM7WUFFRCxnREFBZ0Q7WUFDaEQsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUM3RCxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsZ0NBQWdDLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRTtnQkFDakUsT0FBTyxFQUFFLHFFQUFxRTtnQkFDOUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLO2FBQ25CLENBQUMsQ0FBQztZQUNILE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztJQUNILENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNLLEtBQUssQ0FBQyxxQkFBcUIsQ0FDakMsTUFBYyxFQUNkLGNBQXNCLEVBQ3RCLFNBQXFCLEVBQ3JCLE9BQW1DO1FBRW5DLElBQUksQ0FBQztZQUNILDhCQUE4QjtZQUM5QixNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDOUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNoQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyw2QkFBNkIsY0FBYyxFQUFFLENBQUMsQ0FBQztnQkFDaEUsT0FBTyxLQUFLLENBQUM7WUFDZixDQUFDO1lBRUQsK0NBQStDO1lBQy9DLE1BQU0sY0FBYyxHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLHVCQUF1QixDQUNoRixNQUFNLEVBQ04sVUFBVSxDQUFDLEVBQUUsRUFDYixTQUFTLEVBQ1QsT0FBTyxJQUFJLFNBQVMsQ0FDckIsQ0FBQztZQUVGLHdFQUF3RTtZQUN4RSxJQUFJLENBQUMsY0FBYyxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUMvQyxPQUFPLEtBQUssQ0FBQztZQUNmLENBQUM7WUFFRCx3Q0FBd0M7WUFDeEMsSUFBSSxjQUFjLENBQUMsVUFBVSxJQUFJLGNBQWMsQ0FBQyxVQUFVLEdBQUcsSUFBSSxJQUFJLEVBQUUsRUFBRSxDQUFDO2dCQUN4RSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsY0FBYyxpQkFBaUIsTUFBTSxFQUFFLENBQUMsQ0FBQztnQkFDbEYsT0FBTyxLQUFLLENBQUM7WUFDZixDQUFDO1lBRUQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHVDQUF1QyxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ3hFLE1BQU07Z0JBQ04sY0FBYztnQkFDZCxTQUFTO2dCQUNULE9BQU87Z0JBQ1AsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLO2FBQ25CLENBQUMsQ0FBQztZQUNILE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxLQUFLLENBQUMsbUJBQW1CLENBQUMsTUFBYyxFQUFFLGNBQXNCO1FBQzlELElBQUksQ0FBQztZQUNILDhCQUE4QjtZQUM5QixNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDOUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNoQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyw2QkFBNkIsY0FBYyxFQUFFLENBQUMsQ0FBQztnQkFDaEUsT0FBTyxLQUFLLENBQUM7WUFDZixDQUFDO1lBRUQseUZBQXlGO1lBQ3pGLE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTNGLHlFQUF5RTtZQUN6RSxPQUFPLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLFVBQVUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxjQUFjLENBQUMsQ0FBQztRQUNwRixDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ3pFLE1BQU07Z0JBQ04sY0FBYztnQkFDZCxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUs7YUFDbkIsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsS0FBSyxDQUFDLHdCQUF3QixDQUM1QixNQUFjLEVBQ2QsY0FBc0IsRUFDdEIsU0FBcUIsRUFDckIsT0FBbUM7UUFFbkMsSUFBSSxDQUFDO1lBQ0gsdUVBQXVFO1lBQ3ZFLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDeEMsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUNyQixPQUFPLEtBQUssQ0FBQyxDQUFDLG1CQUFtQjtZQUNuQyxDQUFDO1lBRUQsa0NBQWtDO1lBQ2xDLE1BQU0sU0FBUyxHQUFhLEVBQUUsQ0FBQztZQUUvQiw0REFBNEQ7WUFDNUQsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUV0Qix3Q0FBd0M7WUFDeEMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFaEMsaURBQWlEO1lBQ2pELElBQUksS0FBSyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDdEIsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzlDLENBQUM7WUFFRCw0Q0FBNEM7WUFDNUMsSUFBSSxLQUFLLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUN0QixTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2pELENBQUM7WUFFRCx5QkFBeUI7WUFDekIsS0FBSyxNQUFNLFFBQVEsSUFBSSxTQUFTLEVBQUUsQ0FBQztnQkFDakMsNEJBQTRCO2dCQUM1QixNQUFNLGlCQUFpQixHQUFHLE1BQU0sSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUNqRyxJQUFJLGlCQUFpQixFQUFFLENBQUM7b0JBQ3RCLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsTUFBTSxtQ0FBbUMsUUFBUSxFQUFFLENBQUMsQ0FBQztvQkFDbEYsT0FBTyxJQUFJLENBQUM7Z0JBQ2QsQ0FBQztnQkFFRCw2QkFBNkI7Z0JBQzdCLE1BQU0sZUFBZSxHQUFHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFDekUsSUFBSSxlQUFlLEVBQUUsQ0FBQztvQkFDcEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxNQUFNLHFDQUFxQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO29CQUNwRixPQUFPLElBQUksQ0FBQztnQkFDZCxDQUFDO1lBQ0gsQ0FBQztZQUVELE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyx5Q0FBeUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUMxRSxNQUFNO2dCQUNOLGNBQWM7Z0JBQ2QsU0FBUztnQkFDVCxPQUFPO2dCQUNQLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSzthQUNuQixDQUFDLENBQUM7WUFDSCxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxnQkFBZ0IsQ0FDZCxNQUFjLEVBQ2QsY0FBc0IsRUFDdEIsU0FBcUIsRUFDckIsT0FBbUM7UUFFbkMsT0FBTyxjQUFjLE1BQU0sSUFBSSxjQUFjLElBQUksU0FBUyxJQUFJLE9BQU8sSUFBSSxRQUFRLEVBQUUsQ0FBQztJQUN0RixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxNQUFjO1FBQzNDLElBQUksQ0FBQztZQUNILHdGQUF3RjtZQUN4RixzQ0FBc0M7WUFDdEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsa0NBQWtDLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFFOUQscUVBQXFFO1lBQ3JFLHFGQUFxRjtZQUNyRix5RUFBeUU7WUFDekUsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsTUFBTSxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztZQUVqRixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyw0Q0FBNEMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUMxRSxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGtEQUFrRCxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ25GLE1BQU07Z0JBQ04sS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLO2FBQ25CLENBQUMsQ0FBQztRQUNMLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxjQUFzQjtRQUMvQyxJQUFJLENBQUM7WUFDSCwwREFBMEQ7WUFDMUQsOEVBQThFO1lBQzlFLGlGQUFpRjtZQUVqRixpQkFBaUI7WUFDakIsdUZBQXVGO1lBQ3ZGLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLHNCQUFzQixjQUFjLG9CQUFvQixDQUFDLENBQUM7UUFDNUUsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxzQ0FBc0MsS0FBSyxDQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUN2RSxjQUFjO2dCQUNkLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSzthQUNuQixDQUFDLENBQUM7UUFDTCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxNQUFjLEVBQUUsa0JBQTJCLEtBQUs7UUFDdkUsSUFBSSxDQUFDO1lBQ0gsc0NBQXNDO1lBQ3RDLE1BQU0sZUFBZSxHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUVqRiwwQ0FBMEM7WUFDMUMsTUFBTSx1QkFBdUIsR0FBRyxlQUFlO2dCQUM3QyxDQUFDLENBQUMsZUFBZTtnQkFDakIsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQyxVQUFVLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFL0YsMkJBQTJCO1lBQzNCLE1BQU0sYUFBYSxHQUFHLHVCQUF1QixDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUV6RSxzQ0FBc0M7WUFDdEMsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsMEJBQTBCLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFL0YscUNBQXFDO1lBQ3JDLGVBQWUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7Z0JBQ25DLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO29CQUMzQyxhQUFhLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDcEMsQ0FBQztZQUNILENBQUMsQ0FBQyxDQUFDO1lBRUgsZ0NBQWdDO1lBQ2hDLElBQUksYUFBYSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDL0IsT0FBTyxFQUFFLENBQUM7WUFDWixDQUFDO1lBRUQsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzVELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsd0NBQXdDLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRTtnQkFDekUsTUFBTTtnQkFDTixlQUFlO2dCQUNmLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSzthQUNuQixDQUFDLENBQUM7WUFDSCxPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxpQkFBaUI7UUFDckIsSUFBSSxDQUFDO1lBQ0gsb0ZBQW9GO1lBQ3BGLCtDQUErQztZQUMvQyxNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0I7aUJBQ2hELGtCQUFrQixDQUFDLFlBQVksQ0FBQztpQkFDaEMsTUFBTSxDQUFDLENBQUMsZUFBZSxFQUFFLGlCQUFpQixFQUFFLHNCQUFzQixDQUFDLENBQUM7aUJBQ3BFLE9BQU8sRUFBRSxDQUFDO1lBQ2IsT0FBTyxXQUFXLENBQUM7UUFDckIsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyx1Q0FBdUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUN4RSxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUs7YUFDbkIsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxFQUFFLENBQUM7UUFDWixDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsZ0JBQWdCLENBQ3BCLElBQVksRUFDWixXQUFtQixFQUNuQixTQUFpQjtRQUVqQixJQUFJLENBQUM7WUFDSCwwQkFBMEI7WUFDMUIsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUN4QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQywrREFBK0QsSUFBSSxlQUFlLFNBQVMsRUFBRSxDQUFDLENBQUM7Z0JBQ2hILE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQztZQUVELG9DQUFvQztZQUNwQyxNQUFNLGtCQUFrQixHQUFHLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM1RSxJQUFJLGtCQUFrQixFQUFFLENBQUM7Z0JBQ3ZCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDhDQUE4QyxJQUFJLEVBQUUsQ0FBQyxDQUFDO2dCQUN2RSxPQUFPLGtCQUFrQixDQUFDO1lBQzVCLENBQUM7WUFFRCx3QkFBd0I7WUFDeEIsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQztnQkFDckQsSUFBSSxFQUFFLElBQUk7Z0JBQ1YsU0FBUyxFQUFFLFdBQVcsSUFBSSxhQUFhLElBQUksRUFBRTthQUM5QyxDQUFDLENBQUM7WUFFSCxzQ0FBc0M7WUFDdEMsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRTVFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLGFBQWEsSUFBSSwyQkFBMkIsU0FBUyxFQUFFLENBQUMsQ0FBQztZQUV6RSxPQUFPLGVBQWUsQ0FBQztRQUN6QixDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLDRCQUE0QixLQUFLLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQzdELElBQUk7Z0JBQ0osV0FBVztnQkFDWCxTQUFTO2dCQUNULEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSzthQUNuQixDQUFDLENBQUM7WUFDSCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILEtBQUssQ0FBQywyQkFBMkIsQ0FDL0IsSUFBWSxFQUNaLFdBQW1CLEVBQ25CLFNBQWlCO1FBRWpCLElBQUksQ0FBQztZQUNILDhCQUE4QjtZQUM5QixNQUFNLGtCQUFrQixHQUFHLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM1RSxJQUFJLGtCQUFrQixFQUFFLENBQUM7Z0JBQ3ZCLE9BQU8sa0JBQWtCLENBQUM7WUFDNUIsQ0FBQztZQUVELGdDQUFnQztZQUNoQyxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQzdELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsMkNBQTJDLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRTtnQkFDNUUsSUFBSTtnQkFDSixXQUFXO2dCQUNYLFNBQVM7Z0JBQ1QsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLO2FBQ25CLENBQUMsQ0FBQztZQUNILE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxLQUFLLENBQUMsZ0JBQWdCLENBQ3BCLE1BQWMsRUFDZCxjQUFzQixFQUN0QixTQUFxQixFQUNyQixPQUFrQyxFQUNsQyxTQUFpQjtRQUVqQixJQUFJLENBQUM7WUFDSCwwQkFBMEI7WUFDMUIsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLGNBQWMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUM3QyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxtRUFBbUUsTUFBTSxvQkFBb0IsY0FBYyxlQUFlLFNBQVMsRUFBRSxDQUFDLENBQUM7Z0JBQ3hKLE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQztZQUVELHNCQUFzQjtZQUN0QixJQUFJLFNBQVMsS0FBSyxtQ0FBVSxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNqRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQywrRUFBK0UsTUFBTSxvQkFBb0IsY0FBYyxFQUFFLENBQUMsQ0FBQztnQkFDNUksT0FBTyxLQUFLLENBQUM7WUFDZixDQUFDO1lBRUQsOEJBQThCO1lBQzlCLE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUM5RSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ2hCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDhEQUE4RCxjQUFjLEVBQUUsQ0FBQyxDQUFDO2dCQUNqRyxPQUFPLEtBQUssQ0FBQztZQUNmLENBQUM7WUFFRCx3Q0FBd0M7WUFDeEMsTUFBTSxrQkFBa0IsR0FBRyxNQUFNLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyx1QkFBdUIsQ0FDcEYsTUFBTSxFQUNOLFVBQVUsQ0FBQyxFQUFFLEVBQ2IsU0FBUyxFQUNULE9BQU8sSUFBSSxTQUFTLENBQ3JCLENBQUM7WUFFRixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztnQkFDeEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsbUVBQW1FLE1BQU0sb0JBQW9CLGNBQWMsRUFBRSxDQUFDLENBQUM7Z0JBQ2hJLE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQztZQUVELDJDQUEyQztZQUMzQyxJQUFJLGtCQUFrQixJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3RELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLHNDQUFzQyxNQUFNLG9CQUFvQixjQUFjLEVBQUUsQ0FBQyxDQUFDO2dCQUNsRyxPQUFPLElBQUksQ0FBQyxDQUFDLHNEQUFzRDtZQUNyRSxDQUFDO1lBRUQsK0NBQStDO1lBQy9DLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLG9CQUFvQixDQUFDLGtCQUFrQixDQUFDLEVBQUUsRUFBRTtnQkFDOUUsT0FBTyxFQUFFLEtBQUs7Z0JBQ2QsU0FBUyxFQUFFLFNBQVM7YUFDckIsQ0FBQyxDQUFDO1lBRUgseUNBQXlDO1lBQ3pDLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTVDLHdDQUF3QztZQUN4QyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUVoRCw2QkFBNkI7WUFDN0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsYUFBYSxjQUFjLHdCQUF3QixNQUFNLGVBQWUsU0FBUyxRQUFRLFNBQVMsRUFBRSxDQUFDLENBQUM7WUFDdEgsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLDhCQUE4QixLQUFLLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQy9ELE1BQU07Z0JBQ04sY0FBYztnQkFDZCxTQUFTO2dCQUNULE9BQU87Z0JBQ1AsU0FBUztnQkFDVCxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUs7YUFDbkIsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxLQUFLLENBQUMsZUFBZSxDQUNuQixNQUFjLEVBQ2QsY0FBc0IsRUFDdEIsU0FBcUIsRUFDckIsT0FBa0MsRUFDbEMsVUFBbUMsRUFDbkMsU0FBaUI7UUFFakIsSUFBSSxDQUFDO1lBQ0gsMEJBQTBCO1lBQzFCLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxjQUFjLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDN0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0VBQW9FLE1BQU0sb0JBQW9CLGNBQWMsZUFBZSxTQUFTLEVBQUUsQ0FBQyxDQUFDO2dCQUN6SixPQUFPLEtBQUssQ0FBQztZQUNmLENBQUM7WUFFRCxzQkFBc0I7WUFDdEIsSUFBSSxTQUFTLEtBQUssbUNBQVUsQ0FBQyxPQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDakQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0ZBQWdGLE1BQU0sb0JBQW9CLGNBQWMsRUFBRSxDQUFDLENBQUM7Z0JBQzdJLE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQztZQUVELDhCQUE4QjtZQUM5QixNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDOUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNoQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQywrREFBK0QsY0FBYyxFQUFFLENBQUMsQ0FBQztnQkFDbEcsT0FBTyxLQUFLLENBQUM7WUFDZixDQUFDO1lBRUQsMkNBQTJDO1lBQzNDLE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsdUJBQXVCLENBQ3BGLE1BQU0sRUFDTixVQUFVLENBQUMsRUFBRSxFQUNiLFNBQVMsRUFDVCxPQUFPLElBQUksU0FBUyxDQUNyQixDQUFDO1lBRUYsOEVBQThFO1lBQzlFLElBQUksa0JBQWtCLElBQUksa0JBQWtCLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3JELG1EQUFtRDtnQkFDbkQsSUFBSSxVQUFVLElBQUksQ0FBQyxDQUFDLGtCQUFrQixDQUFDLFVBQVUsSUFBSSxVQUFVLEdBQUcsa0JBQWtCLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQztvQkFDakcsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsb0JBQW9CLENBQUMsa0JBQWtCLENBQUMsRUFBRSxFQUFFO3dCQUM5RSxVQUFVO3dCQUNWLFNBQVMsRUFBRSxTQUFTO3FCQUNyQixDQUFDLENBQUM7b0JBRUgsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsaUNBQWlDLGNBQWMsOEJBQThCLE1BQU0sRUFBRSxDQUFDLENBQUM7Z0JBQ3pHLENBQUM7cUJBQU0sQ0FBQztvQkFDTixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxXQUFXLE1BQU0sMEJBQTBCLGNBQWMsRUFBRSxDQUFDLENBQUM7Z0JBQy9FLENBQUM7Z0JBRUQsT0FBTyxJQUFJLENBQUM7WUFDZCxDQUFDO1lBRUQsdUNBQXVDO1lBQ3ZDLElBQUksa0JBQWtCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDdEQsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsb0JBQW9CLENBQUMsa0JBQWtCLENBQUMsRUFBRSxFQUFFO29CQUM5RSxPQUFPLEVBQUUsSUFBSTtvQkFDYixVQUFVLEVBQUUsVUFBVSxJQUFJLElBQUk7b0JBQzlCLFNBQVMsRUFBRSxTQUFTO2lCQUNyQixDQUFDLENBQUM7Z0JBRUgsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsYUFBYSxjQUFjLDZCQUE2QixNQUFNLGVBQWUsU0FBUyxRQUFRLFNBQVMsRUFBRSxDQUFDLENBQUM7WUFDN0gsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLHlDQUF5QztnQkFDekMsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsb0JBQW9CLENBQUM7b0JBQ3ZELE1BQU07b0JBQ04sWUFBWSxFQUFFLFVBQVUsQ0FBQyxFQUFFO29CQUMzQixTQUFTO29CQUNULE9BQU8sRUFBRSxPQUFPLElBQUksU0FBUztvQkFDN0IsT0FBTyxFQUFFLElBQUk7b0JBQ2IsVUFBVSxFQUFFLFVBQVUsSUFBSSxJQUFJO29CQUM5QixTQUFTO2lCQUNWLENBQUMsQ0FBQztnQkFFSCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxhQUFhLGNBQWMseUJBQXlCLE1BQU0sZUFBZSxTQUFTLFFBQVEsU0FBUyxFQUFFLENBQUMsQ0FBQztZQUN6SCxDQUFDO1lBRUQseUNBQXlDO1lBQ3pDLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTVDLHdDQUF3QztZQUN4QyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUVoRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsK0JBQStCLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRTtnQkFDaEUsS0FBSyxFQUFFLEtBQUssQ0FBQyxPQUFPO2dCQUNwQixLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUs7YUFDbkIsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLG9CQUFvQixDQUFDLE1BQWM7UUFDdkMsSUFBSSxDQUFDO1lBQ0gsd0NBQXdDO1lBQ3hDLE1BQU0sZUFBZSxHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUVqRixJQUFJLENBQUMsZUFBZSxJQUFJLGVBQWUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQ3JELE9BQU8sRUFBRSxDQUFDO1lBQ1osQ0FBQztZQUVELCtCQUErQjtZQUMvQixNQUFNLGFBQWEsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBRWpFLG1DQUFtQztZQUNuQyxPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDNUQsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxxQ0FBcUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUN0RSxNQUFNO2dCQUNOLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSzthQUNuQixDQUFDLENBQUM7WUFDSCxPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsMEJBQTBCLENBQUMsTUFBYztRQUM3QyxJQUFJLENBQUM7WUFDSCxzQ0FBc0M7WUFDdEMsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsMEJBQTBCLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFM0YsT0FBTyxXQUFXLElBQUksRUFBRSxDQUFDO1FBQzNCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsZ0RBQWdELEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRTtnQkFDakYsTUFBTTtnQkFDTixLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUs7YUFDbkIsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxFQUFFLENBQUM7UUFDWixDQUFDO0lBQ0gsQ0FBQztDQUNGLENBQUE7QUEzdEJZLDhDQUFpQjs0QkFBakIsaUJBQWlCO0lBRDdCLElBQUEsbUJBQVUsR0FBRTtJQU1SLFdBQUEsSUFBQSwwQkFBZ0IsRUFBQyw0Q0FBb0IsQ0FBQyxDQUFBO0lBRXRDLFdBQUEsSUFBQSwwQkFBZ0IsRUFBQyxxREFBd0IsQ0FBQyxDQUFBO0lBRTFDLFdBQUEsSUFBQSwwQkFBZ0IsRUFBQyxxREFBd0IsQ0FBQyxDQUFBO0lBRTFDLFdBQUEsSUFBQSwwQkFBZ0IsRUFBQyx1REFBeUIsQ0FBQyxDQUFBO0lBRTNDLFdBQUEsSUFBQSxlQUFNLEVBQUMsNkJBQWEsQ0FBQyxDQUFBO3lEQVBRLDRDQUFvQixvQkFBcEIsNENBQW9CLG9EQUVoQixxREFBd0Isb0JBQXhCLHFEQUF3QixvREFFeEIscURBQXdCLG9CQUF4QixxREFBd0Isb0RBRXZCLHVEQUF5QixvQkFBekIsdURBQXlCLG9EQUV0QyxxQkFBSyxvQkFBTCxxQkFBSztHQWRsQixpQkFBaUIsQ0EydEI3QiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcYXV0aFxcc2VydmljZXNcXHBlcm1pc3Npb24uc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBMb2dnZXIsIEluamVjdCB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IEluamVjdFJlcG9zaXRvcnkgfSBmcm9tICdAbmVzdGpzL3R5cGVvcm0nO1xuaW1wb3J0IHsgUGVybWlzc2lvbiB9IGZyb20gJy4uLy4uL2VudGl0aWVzL3Blcm1pc3Npb24uZW50aXR5JztcbmltcG9ydCB7IFBlcm1pc3Npb25SZXBvc2l0b3J5IH0gZnJvbSAnLi4vcmVwb3NpdG9yaWVzL3Blcm1pc3Npb24ucmVwb3NpdG9yeSc7XG5pbXBvcnQgeyBSb2xlUGVybWlzc2lvblJlcG9zaXRvcnkgfSBmcm9tICcuLi9yZXBvc2l0b3JpZXMvcm9sZS1wZXJtaXNzaW9uLnJlcG9zaXRvcnknO1xuaW1wb3J0IHsgVXNlclBlcm1pc3Npb25SZXBvc2l0b3J5IH0gZnJvbSAnLi4vcmVwb3NpdG9yaWVzL3VzZXItcGVybWlzc2lvbi5yZXBvc2l0b3J5JztcbmltcG9ydCB7IFBlcm1pc3Npb25TY29wZVJlcG9zaXRvcnkgfSBmcm9tICcuLi9yZXBvc2l0b3JpZXMvcGVybWlzc2lvbi1zY29wZS5yZXBvc2l0b3J5JztcbmltcG9ydCB7IFRpcG9Fc2NvcG8gfSBmcm9tICcuLi8uLi9lbnRpdGllcy91c2VyLXBlcm1pc3Npb24uZW50aXR5JztcbmltcG9ydCB7IENBQ0hFX01BTkFHRVIgfSBmcm9tICdAbmVzdGpzL2NhY2hlLW1hbmFnZXInO1xuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICdjYWNoZS1tYW5hZ2VyJztcblxuLyoqXG4gKiBJbnRlcmZhY2UgcGFyYSB2ZXJpZmljYcOnw6NvIGRlIHBlcm1pc3PDo28gY29tIGVzY29wby5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQZXJtaXNzaW9uQ2hlY2tPcHRpb25zIHtcbiAgLyoqXG4gICAqIElEIGRvIHVzdcOhcmlvIHBhcmEgdmVyaWZpY2HDp8OjbyBkZSBwZXJtaXNzw6NvXG4gICAqL1xuICB1c2VySWQ6IHN0cmluZztcbiAgXG4gIC8qKlxuICAgKiBOb21lIGRhIHBlcm1pc3PDo28gbm8gZm9ybWF0byBgbW9kdWxvLnJlY3Vyc28ub3BlcmFjYW9gXG4gICAqL1xuICBwZXJtaXNzaW9uTmFtZTogc3RyaW5nO1xuICBcbiAgLyoqXG4gICAqIFRpcG8gZGUgZXNjb3BvIChvcGNpb25hbCwgcGFkcsOjbyDDqSBHTE9CQUwpXG4gICAqL1xuICBzY29wZVR5cGU/OiBUaXBvRXNjb3BvO1xuICBcbiAgLyoqXG4gICAqIElEIGRvIGVzY29wbyAob3BjaW9uYWwsIG5lY2Vzc8OhcmlvIGFwZW5hcyBwYXJhIHNjb3BlVHlwZSBVTklUKVxuICAgKi9cbiAgc2NvcGVJZD86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogU2VydmnDp28gcmVzcG9uc8OhdmVsIHBvciB2ZXJpZmljYXIgcGVybWlzc8O1ZXMgZGUgdXN1w6FyaW9zLlxuICogXG4gKiBFc3RlIHNlcnZpw6dvIGltcGxlbWVudGEgYSBsw7NnaWNhIGRlIHZlcmlmaWNhw6fDo28gZGUgcGVybWlzc8O1ZXMgZ3JhbnVsYXJlcyxcbiAqIGNvbnNpZGVyYW5kbyBwZXJtaXNzw7VlcyBkaXJldGFzLCBwZXJtaXNzw7VlcyBkZSByb2xlIGUgcGVybWlzc8O1ZXMgY29tcG9zdGFzLlxuICogVGFtYsOpbSBpbXBsZW1lbnRhIGNhY2hlIHBhcmEgb3RpbWl6YXIgbyBkZXNlbXBlbmhvIGRhcyB2ZXJpZmljYcOnw7Vlcy5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBlcm1pc3Npb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXIgPSBuZXcgTG9nZ2VyKFBlcm1pc3Npb25TZXJ2aWNlLm5hbWUpO1xuICBwcml2YXRlIHJlYWRvbmx5IENBQ0hFX1RUTCA9IDMwMDsgLy8gNSBtaW51dG9zIGVtIHNlZ3VuZG9zXG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdFJlcG9zaXRvcnkoUGVybWlzc2lvblJlcG9zaXRvcnkpXG4gICAgcHJpdmF0ZSBwZXJtaXNzaW9uUmVwb3NpdG9yeTogUGVybWlzc2lvblJlcG9zaXRvcnksXG4gICAgQEluamVjdFJlcG9zaXRvcnkoUm9sZVBlcm1pc3Npb25SZXBvc2l0b3J5KVxuICAgIHByaXZhdGUgcm9sZVBlcm1pc3Npb25SZXBvc2l0b3J5OiBSb2xlUGVybWlzc2lvblJlcG9zaXRvcnksXG4gICAgQEluamVjdFJlcG9zaXRvcnkoVXNlclBlcm1pc3Npb25SZXBvc2l0b3J5KVxuICAgIHByaXZhdGUgdXNlclBlcm1pc3Npb25SZXBvc2l0b3J5OiBVc2VyUGVybWlzc2lvblJlcG9zaXRvcnksXG4gICAgQEluamVjdFJlcG9zaXRvcnkoUGVybWlzc2lvblNjb3BlUmVwb3NpdG9yeSlcbiAgICBwcml2YXRlIHBlcm1pc3Npb25TY29wZVJlcG9zaXRvcnk6IFBlcm1pc3Npb25TY29wZVJlcG9zaXRvcnksXG4gICAgQEluamVjdChDQUNIRV9NQU5BR0VSKVxuICAgIHByaXZhdGUgY2FjaGVNYW5hZ2VyOiBDYWNoZVxuICApIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ1Blcm1pc3Npb25TZXJ2aWNlIGluaWNpYWxpemFkbycpO1xuICAgIFxuICAgIC8vIFZlcmlmaWNhciBzZSBvIGNhY2hlIGVzdMOhIGZ1bmNpb25hbmRvXG4gICAgdGhpcy5jYWNoZU1hbmFnZXIuc2V0KCdwZXJtaXNzaW9uX3NlcnZpY2VfdGVzdCcsICdvaycsIDEwKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5sb2dnZXIubG9nKCdDYWNoZSBpbmljaWFsaXphZG8gY29tIHN1Y2Vzc28nKSlcbiAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5sb2dnZXIud2FybihgRXJybyBhbyBpbmljaWFsaXphciBjYWNoZTogJHtlcnIubWVzc2FnZX0uIFVzYW5kbyBmYWxsYmFjay5gKSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgdW0gdXN1w6FyaW8gdGVtIHVtYSBwZXJtaXNzw6NvIGVzcGVjw61maWNhLlxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgT3DDp8O1ZXMgZGUgdmVyaWZpY2HDp8OjbyBkZSBwZXJtaXNzw6NvXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyB1c3XDoXJpbyB0ZW0gYSBwZXJtaXNzw6NvLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIGFzeW5jIGhhc1Blcm1pc3Npb24ob3B0aW9uczogUGVybWlzc2lvbkNoZWNrT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHVzZXJJZCwgcGVybWlzc2lvbk5hbWUsIHNjb3BlVHlwZSA9IFRpcG9Fc2NvcG8uR0xPQkFMLCBzY29wZUlkIH0gPSBvcHRpb25zO1xuICAgICAgXG4gICAgICAvLyBWYWxpZGHDp8OjbyBkZSBwYXLDom1ldHJvc1xuICAgICAgaWYgKCF1c2VySWQgfHwgIXBlcm1pc3Npb25OYW1lKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYFRlbnRhdGl2YSBkZSB2ZXJpZmljYXIgcGVybWlzc8OjbyBjb20gcGFyw6JtZXRyb3MgaW52w6FsaWRvczogdXNlcklkPSR7dXNlcklkfSwgcGVybWlzc2lvbk5hbWU9JHtwZXJtaXNzaW9uTmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWYWxpZGHDp8OjbyBkZSBlc2NvcG9cbiAgICAgIGlmIChzY29wZVR5cGUgPT09IFRpcG9Fc2NvcG8uVU5JREFERSAmJiAhc2NvcGVJZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBUZW50YXRpdmEgZGUgdmVyaWZpY2FyIHBlcm1pc3PDo28gY29tIGVzY29wbyBVTklUIHNlbSBmb3JuZWNlciBzY29wZUlkOiB1c2VySWQ9JHt1c2VySWR9LCBwZXJtaXNzaW9uTmFtZT0ke3Blcm1pc3Npb25OYW1lfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmaWNhciBjYWNoZVxuICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdlbmVyYXRlQ2FjaGVLZXkodXNlcklkLCBwZXJtaXNzaW9uTmFtZSwgc2NvcGVUeXBlLCBzY29wZUlkKTtcbiAgICAgIGxldCBjYWNoZWRSZXN1bHQ7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhY2hlZFJlc3VsdCA9IGF3YWl0IHRoaXMuY2FjaGVNYW5hZ2VyLmdldDxib29sZWFuPihjYWNoZUtleSk7XG4gICAgICAgIGlmIChjYWNoZWRSZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBjYWNoZWRSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBFcnJvIGFvIGFjZXNzYXIgY2FjaGU6ICR7ZXJyb3IubWVzc2FnZX0uIFVzYW5kbyB2ZXJpZmljYcOnw6NvIGRpcmV0YS5gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZpY2FyIHBlcm1pc3PDtWVzIGNvbXBvc3Rhc1xuICAgICAgaWYgKHBlcm1pc3Npb25OYW1lLmluY2x1ZGVzKCcsJykpIHtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBwZXJtaXNzaW9uTmFtZS5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlcm0gb2YgcGVybWlzc2lvbnMpIHtcbiAgICAgICAgICBjb25zdCBoYXNJbmRpdmlkdWFsUGVybWlzc2lvbiA9IGF3YWl0IHRoaXMuaGFzUGVybWlzc2lvbih7XG4gICAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgICBwZXJtaXNzaW9uTmFtZTogcGVybS50cmltKCksXG4gICAgICAgICAgICBzY29wZVR5cGUsXG4gICAgICAgICAgICBzY29wZUlkLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChoYXNJbmRpdmlkdWFsUGVybWlzc2lvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jYWNoZU1hbmFnZXIuc2V0KGNhY2hlS2V5LCB0cnVlLCAzMDApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgRXJybyBhbyBlc2NyZXZlciBubyBjYWNoZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuY2FjaGVNYW5hZ2VyLnNldChjYWNoZUtleSwgZmFsc2UsIDMwMCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgRXJybyBhbyBlc2NyZXZlciBubyBjYWNoZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZpY2EgcGVybWlzc8O1ZXMgZGlyZXRhcyBkbyB1c3XDoXJpb1xuICAgICAgY29uc3QgaGFzRGlyZWN0UGVybWlzc2lvbiA9IGF3YWl0IHRoaXMuY2hlY2tEaXJlY3RQZXJtaXNzaW9uKHVzZXJJZCwgcGVybWlzc2lvbk5hbWUsIHNjb3BlVHlwZSwgc2NvcGVJZCk7XG4gICAgICBpZiAoaGFzRGlyZWN0UGVybWlzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLmNhY2hlTWFuYWdlci5zZXQoY2FjaGVLZXksIHRydWUsIHRoaXMuQ0FDSEVfVFRMKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmaWNhIHBlcm1pc3PDtWVzIGRhIHJvbGUgZG8gdXN1w6FyaW9cbiAgICAgIGNvbnN0IGhhc1JvbGVQZXJtaXNzaW9uID0gYXdhaXQgdGhpcy5jaGVja1JvbGVQZXJtaXNzaW9uKHVzZXJJZCwgcGVybWlzc2lvbk5hbWUpO1xuICAgICAgaWYgKGhhc1JvbGVQZXJtaXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FjaGVNYW5hZ2VyLnNldChjYWNoZUtleSwgdHJ1ZSwgdGhpcy5DQUNIRV9UVEwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZpY2EgcGVybWlzc8O1ZXMgY29tcG9zdGFzICh3aWxkY2FyZHMpXG4gICAgICBjb25zdCBoYXNDb21wb3NpdGVQZXJtaXNzaW9uID0gYXdhaXQgdGhpcy5jaGVja0NvbXBvc2l0ZVBlcm1pc3Npb24odXNlcklkLCBwZXJtaXNzaW9uTmFtZSwgc2NvcGVUeXBlLCBzY29wZUlkKTtcbiAgICAgIGlmIChoYXNDb21wb3NpdGVQZXJtaXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FjaGVNYW5hZ2VyLnNldChjYWNoZUtleSwgdHJ1ZSwgdGhpcy5DQUNIRV9UVEwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2UgY2hlZ291IGFxdWksIG8gdXN1w6FyaW8gbsOjbyB0ZW0gYSBwZXJtaXNzw6NvXG4gICAgICBhd2FpdCB0aGlzLmNhY2hlTWFuYWdlci5zZXQoY2FjaGVLZXksIGZhbHNlLCB0aGlzLkNBQ0hFX1RUTCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIHZlcmlmaWNhciBwZXJtaXNzw6NvOiAke2Vycm9yLm1lc3NhZ2V9YCwge1xuICAgICAgICBvcHRpb25zLCAvLyBVc2FyIG8gb2JqZXRvIG9wdGlvbnMgY29tcGxldG8gZW0gdmV6IGRhcyBwcm9wcmllZGFkZXMgaW5kaXZpZHVhaXNcbiAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgdW0gdXN1w6FyaW8gdGVtIHVtYSBwZXJtaXNzw6NvIGRpcmV0YS5cbiAgICogXG4gICAqIEBwYXJhbSB1c2VySWQgSUQgZG8gdXN1w6FyaW9cbiAgICogQHBhcmFtIHBlcm1pc3Npb25OYW1lIE5vbWUgZGEgcGVybWlzc8Ojb1xuICAgKiBAcGFyYW0gc2NvcGVUeXBlIFRpcG8gZGUgZXNjb3BvXG4gICAqIEBwYXJhbSBzY29wZUlkIElEIGRvIGVzY29wbyAob3BjaW9uYWwgcGFyYSBlc2NvcG8gR0xPQkFMKVxuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gdXN1w6FyaW8gdGVtIGEgcGVybWlzc8OjbyBkaXJldGEsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjaGVja0RpcmVjdFBlcm1pc3Npb24oXG4gICAgdXNlcklkOiBzdHJpbmcsXG4gICAgcGVybWlzc2lvbk5hbWU6IHN0cmluZyxcbiAgICBzY29wZVR5cGU6IFRpcG9Fc2NvcG8sXG4gICAgc2NvcGVJZD86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBCdXNjYSBhIHBlcm1pc3PDo28gcGVsbyBub21lXG4gICAgICBjb25zdCBwZXJtaXNzaW9uID0gYXdhaXQgdGhpcy5wZXJtaXNzaW9uUmVwb3NpdG9yeS5maW5kQnlOYW1lKHBlcm1pc3Npb25OYW1lKTtcbiAgICAgIGlmICghcGVybWlzc2lvbikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBQZXJtaXNzw6NvIG7Do28gZW5jb250cmFkYTogJHtwZXJtaXNzaW9uTmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZmljYSBzZSBvIHVzdcOhcmlvIHRlbSBhIHBlcm1pc3PDo28gZGlyZXRhXG4gICAgICBjb25zdCB1c2VyUGVybWlzc2lvbiA9IGF3YWl0IHRoaXMudXNlclBlcm1pc3Npb25SZXBvc2l0b3J5LmZpbmRCeVVzZXJBbmRQZXJtaXNzaW9uKFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIHBlcm1pc3Npb24uaWQsXG4gICAgICAgIHNjb3BlVHlwZSxcbiAgICAgICAgc2NvcGVJZCB8fCB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFNlIG7Do28gZW5jb250cm91IGEgcGVybWlzc8OjbyBvdSBlbGEgbsOjbyBlc3TDoSBjb25jZWRpZGEsIHJldG9ybmEgZmFsc2VcbiAgICAgIGlmICghdXNlclBlcm1pc3Npb24gfHwgIXVzZXJQZXJtaXNzaW9uLmdyYW50ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZmljYSBzZSBhIHBlcm1pc3PDo28gZXN0w6EgZXhwaXJhZGFcbiAgICAgIGlmICh1c2VyUGVybWlzc2lvbi52YWxpZFVudGlsICYmIHVzZXJQZXJtaXNzaW9uLnZhbGlkVW50aWwgPCBuZXcgRGF0ZSgpKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBQZXJtaXNzw6NvIGV4cGlyYWRhOiAke3Blcm1pc3Npb25OYW1lfSBwYXJhIHVzdcOhcmlvICR7dXNlcklkfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRXJybyBhbyB2ZXJpZmljYXIgcGVybWlzc8OjbyBkaXJldGE6ICR7ZXJyb3IubWVzc2FnZX1gLCB7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgcGVybWlzc2lvbk5hbWUsXG4gICAgICAgIHNjb3BlVHlwZSxcbiAgICAgICAgc2NvcGVJZCxcbiAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgdW0gdXN1w6FyaW8gdGVtIHVtYSBwZXJtaXNzw6NvIGF0cmF2w6lzIGRhIHN1YSByb2xlLlxuICAgKiBcbiAgICogQHBhcmFtIHVzZXJJZCBJRCBkbyB1c3XDoXJpb1xuICAgKiBAcGFyYW0gcGVybWlzc2lvbk5hbWUgTm9tZSBkYSBwZXJtaXNzw6NvXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyB1c3XDoXJpbyB0ZW0gYSBwZXJtaXNzw6NvIGF0cmF2w6lzIGRhIHN1YSByb2xlLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIGFzeW5jIGNoZWNrUm9sZVBlcm1pc3Npb24odXNlcklkOiBzdHJpbmcsIHBlcm1pc3Npb25OYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQnVzY2EgYSBwZXJtaXNzw6NvIHBlbG8gbm9tZVxuICAgICAgY29uc3QgcGVybWlzc2lvbiA9IGF3YWl0IHRoaXMucGVybWlzc2lvblJlcG9zaXRvcnkuZmluZEJ5TmFtZShwZXJtaXNzaW9uTmFtZSk7XG4gICAgICBpZiAoIXBlcm1pc3Npb24pIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgUGVybWlzc8OjbyBuw6NvIGVuY29udHJhZGE6ICR7cGVybWlzc2lvbk5hbWV9YCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZpY2Egc2UgZXhpc3RlIHVtYSByb2xlIGNvbSBhIHBlcm1pc3PDo28gdXNhbmRvIG8gbcOpdG9kbyBmaW5kUGVybWlzc2lvbnNCeVVzZXJSb2xlc1xuICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBhd2FpdCB0aGlzLnJvbGVQZXJtaXNzaW9uUmVwb3NpdG9yeS5maW5kUGVybWlzc2lvbnNCeVVzZXJSb2xlcyh1c2VySWQpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZmljYSBzZSBhIHBlcm1pc3PDo28gZXNwZWPDrWZpY2EgZXN0w6EgbmEgbGlzdGEgZGUgcGVybWlzc8O1ZXMgZGEgcm9sZVxuICAgICAgcmV0dXJuIHBlcm1pc3Npb25zLnNvbWUocCA9PiBwLmlkID09PSBwZXJtaXNzaW9uLmlkIHx8IHAubmFtZSA9PT0gcGVybWlzc2lvbk5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRXJybyBhbyB2ZXJpZmljYXIgcGVybWlzc8OjbyBkZSByb2xlOiAke2Vycm9yLm1lc3NhZ2V9YCwge1xuICAgICAgICB1c2VySWQsXG4gICAgICAgIHBlcm1pc3Npb25OYW1lLFxuICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSB1bSB1c3XDoXJpbyB0ZW0gdW1hIHBlcm1pc3PDo28gY29tcG9zdGEgKGNvbSB3aWxkY2FyZCkuXG4gICAqIFxuICAgKiBAcGFyYW0gdXNlcklkIElEIGRvIHVzdcOhcmlvXG4gICAqIEBwYXJhbSBwZXJtaXNzaW9uTmFtZSBOb21lIGRhIHBlcm1pc3PDo28gZXNwZWPDrWZpY2EgcXVlIGVzdMOhIHNlbmRvIHZlcmlmaWNhZGFcbiAgICogQHBhcmFtIHNjb3BlVHlwZSBUaXBvIGRlIGVzY29wb1xuICAgKiBAcGFyYW0gc2NvcGVJZCBJRCBkbyBlc2NvcG8gKG9wY2lvbmFsIHBhcmEgZXNjb3BvIEdMT0JBTClcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIHVzdcOhcmlvIHRlbSBhIHBlcm1pc3PDo28gY29tcG9zdGEsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgYXN5bmMgY2hlY2tDb21wb3NpdGVQZXJtaXNzaW9uKFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICAgIHBlcm1pc3Npb25OYW1lOiBzdHJpbmcsXG4gICAgc2NvcGVUeXBlOiBUaXBvRXNjb3BvLFxuICAgIHNjb3BlSWQ/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRGl2aWRlIG8gbm9tZSBkYSBwZXJtaXNzw6NvIGVtIHBhcnRlcyAoZXg6ICdtb2R1bG8ucmVjdXJzby5vcGVyYWNhbycpXG4gICAgICBjb25zdCBwYXJ0cyA9IHBlcm1pc3Npb25OYW1lLnNwbGl0KCcuJyk7XG4gICAgICBpZiAocGFydHMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEZvcm1hdG8gaW52w6FsaWRvXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENvbnN0csOzaSBvcyB3aWxkY2FyZHMgcG9zc8OtdmVpc1xuICAgICAgY29uc3Qgd2lsZGNhcmRzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgXG4gICAgICAvLyBQZXJtaXNzw6NvIHN1cGVyIGFkbWluIC0gdmVyaWZpY2EgcHJpbWVpcm8gcGFyYSBvdGltaXphw6fDo29cbiAgICAgIHdpbGRjYXJkcy5wdXNoKCcqLionKTtcbiAgICAgIFxuICAgICAgLy8gV2lsZGNhcmQgcGFyYSBtw7NkdWxvIChleDogJ21vZHVsby4qJylcbiAgICAgIHdpbGRjYXJkcy5wdXNoKGAke3BhcnRzWzBdfS4qYCk7XG4gICAgICBcbiAgICAgIC8vIFdpbGRjYXJkIHBhcmEgcmVjdXJzbyAoZXg6ICdtb2R1bG8ucmVjdXJzby4qJylcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgICB3aWxkY2FyZHMucHVzaChgJHtwYXJ0c1swXX0uJHtwYXJ0c1sxXX0uKmApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBXaWxkY2FyZCBwYXJhIG9wZXJhw6fDo28gKGV4OiAnKi5vcGVyYWNhbycpXG4gICAgICBpZiAocGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgd2lsZGNhcmRzLnB1c2goYCouJHtwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZpY2EgY2FkYSB3aWxkY2FyZFxuICAgICAgZm9yIChjb25zdCB3aWxkY2FyZCBvZiB3aWxkY2FyZHMpIHtcbiAgICAgICAgLy8gVmVyaWZpY2EgcGVybWlzc8OjbyBkaXJldGFcbiAgICAgICAgY29uc3QgaGFzRGlyZWN0V2lsZGNhcmQgPSBhd2FpdCB0aGlzLmNoZWNrRGlyZWN0UGVybWlzc2lvbih1c2VySWQsIHdpbGRjYXJkLCBzY29wZVR5cGUsIHNjb3BlSWQpO1xuICAgICAgICBpZiAoaGFzRGlyZWN0V2lsZGNhcmQpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgVXN1w6FyaW8gJHt1c2VySWR9IHRlbSBwZXJtaXNzw6NvIHdpbGRjYXJkIGRpcmV0YTogJHt3aWxkY2FyZH1gKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVmVyaWZpY2EgcGVybWlzc8OjbyBkZSByb2xlXG4gICAgICAgIGNvbnN0IGhhc1JvbGVXaWxkY2FyZCA9IGF3YWl0IHRoaXMuY2hlY2tSb2xlUGVybWlzc2lvbih1c2VySWQsIHdpbGRjYXJkKTtcbiAgICAgICAgaWYgKGhhc1JvbGVXaWxkY2FyZCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBVc3XDoXJpbyAke3VzZXJJZH0gdGVtIHBlcm1pc3PDo28gd2lsZGNhcmQgdmlhIHJvbGU6ICR7d2lsZGNhcmR9YCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRXJybyBhbyB2ZXJpZmljYXIgcGVybWlzc8OjbyBjb21wb3N0YTogJHtlcnJvci5tZXNzYWdlfWAsIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBwZXJtaXNzaW9uTmFtZSxcbiAgICAgICAgc2NvcGVUeXBlLFxuICAgICAgICBzY29wZUlkLFxuICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXJhIHVtYSBjaGF2ZSBkZSBjYWNoZSBwYXJhIHVtYSB2ZXJpZmljYcOnw6NvIGRlIHBlcm1pc3PDo28uXG4gICAqIFxuICAgKiBAcGFyYW0gdXNlcklkIElEIGRvIHVzdcOhcmlvXG4gICAqIEBwYXJhbSBwZXJtaXNzaW9uTmFtZSBOb21lIGRhIHBlcm1pc3PDo29cbiAgICogQHBhcmFtIHNjb3BlVHlwZSBUaXBvIGRlIGVzY29wb1xuICAgKiBAcGFyYW0gc2NvcGVJZCBJRCBkbyBlc2NvcG8gKG9wY2lvbmFsIHBhcmEgZXNjb3BvIEdMT0JBTClcbiAgICogQHJldHVybnMgQ2hhdmUgZGUgY2FjaGVcbiAgICovXG4gIGdlbmVyYXRlQ2FjaGVLZXkoXG4gICAgdXNlcklkOiBzdHJpbmcsXG4gICAgcGVybWlzc2lvbk5hbWU6IHN0cmluZyxcbiAgICBzY29wZVR5cGU6IFRpcG9Fc2NvcG8sXG4gICAgc2NvcGVJZD86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBwZXJtaXNzaW9uOiR7dXNlcklkfToke3Blcm1pc3Npb25OYW1lfToke3Njb3BlVHlwZX06JHtzY29wZUlkIHx8ICdnbG9iYWwnfWA7XG4gIH1cblxuICAvKipcbiAgICogTGltcGEgbyBjYWNoZSBkZSBwZXJtaXNzw7VlcyBkZSB1bSB1c3XDoXJpby5cbiAgICogXG4gICAqIEBwYXJhbSB1c2VySWQgSUQgZG8gdXN1w6FyaW9cbiAgICovXG4gIGFzeW5jIGNsZWFyVXNlclBlcm1pc3Npb25DYWNoZSh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBJbXBsZW1lbnRhw6fDo28gc2ltcGxpZmljYWRhIHBhcmEgZXZpdGFyIHVzbyBkZSBtw6l0b2RvcyBxdWUgcG9kZW0gbsOjbyBlc3RhciBkaXNwb27DrXZlaXNcbiAgICAgIC8vIGVtIHRvZGFzIGFzIGltcGxlbWVudGHDp8O1ZXMgZGUgY2FjaGVcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBMaW1wYW5kbyBjYWNoZSBwYXJhIG8gdXN1w6FyaW86ICR7dXNlcklkfWApO1xuICAgICAgXG4gICAgICAvLyBDb21vIG7Do28gdGVtb3MgYWNlc3NvIGRpcmV0byBhIHVtIG3DqXRvZG8gcGFyYSBsaW1wYXIgdG9kbyBvIGNhY2hlLFxuICAgICAgLy8gdmFtb3MgdXNhciB1bWEgYWJvcmRhZ2VtIGFsdGVybmF0aXZhIHF1ZSBmdW5jaW9uYSBjb20gYSBtYWlvcmlhIGRhcyBpbXBsZW1lbnRhw6fDtWVzXG4gICAgICAvLyBEZWZpbmltb3MgdW1hIGNoYXZlIGNvbSBUVEwgbXVpdG8gY3VydG8gcGFyYSBmb3LDp2FyIGEgbGltcGV6YSBkbyBjYWNoZVxuICAgICAgYXdhaXQgdGhpcy5jYWNoZU1hbmFnZXIuc2V0KGB1c2VyLWNhY2hlLWNsZWFyOiR7dXNlcklkfToke0RhdGUubm93KCl9YCwgdHJ1ZSwgMSk7XG4gICAgICBcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBDYWNoZSBkZSBwZXJtaXNzw7VlcyBsaW1wbyBwYXJhIG8gdXN1w6FyaW8gJHt1c2VySWR9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIGxpbXBhciBjYWNoZSBkZSBwZXJtaXNzw7VlcyBkbyB1c3XDoXJpbzogJHtlcnJvci5tZXNzYWdlfWAsIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMaW1wYSBvIGNhY2hlIGRlIHBlcm1pc3PDtWVzIHBhcmEgdW1hIHBlcm1pc3PDo28gZXNwZWPDrWZpY2EuXG4gICAqIFxuICAgKiBAcGFyYW0gcGVybWlzc2lvbk5hbWUgTm9tZSBkYSBwZXJtaXNzw6NvXG4gICAqL1xuICBhc3luYyBjbGVhclBlcm1pc3Npb25DYWNoZShwZXJtaXNzaW9uTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE9idGVyIHRvZGFzIGFzIGNoYXZlcyBkZSBjYWNoZSByZWxhY2lvbmFkYXMgw6AgcGVybWlzc8Ojb1xuICAgICAgLy8gSXNzbyDDqSB1bWEgc2ltcGxpZmljYcOnw6NvLCBwb2lzIG8gY2FjaGUtbWFuYWdlciBuw6NvIHN1cG9ydGEgYnVzY2EgcG9yIHBhZHLDo29cbiAgICAgIC8vIEVtIHVtYSBpbXBsZW1lbnRhw6fDo28gcmVhbCwgc2VyaWEgbmVjZXNzw6FyaW8gdXNhciB1bSBhZGFwdGFkb3IgcXVlIHN1cG9ydGUgaXNzb1xuICAgICAgXG4gICAgICAvLyBMaW1wYXIgbyBjYWNoZVxuICAgICAgLy8gQ29tbyBuw6NvIHBvZGVtb3MgYnVzY2FyIGNoYXZlcywgdmFtb3MgYXBlbmFzIHJlZ2lzdHJhciBxdWUgbyBjYWNoZSBkZXZlcmlhIHNlciBsaW1wb1xuICAgICAgdGhpcy5sb2dnZXIubG9nKGBDYWNoZSBkYSBwZXJtaXNzw6NvICR7cGVybWlzc2lvbk5hbWV9IGRldmVyaWEgc2VyIGxpbXBvYCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIGxpbXBhciBjYWNoZSBkYSBwZXJtaXNzw6NvOiAke2Vycm9yLm1lc3NhZ2V9YCwge1xuICAgICAgICBwZXJtaXNzaW9uTmFtZSxcbiAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIHRvZGFzIGFzIHBlcm1pc3PDtWVzIGF0aXZhcyBkZSB1bSB1c3XDoXJpby5cbiAgICogXG4gICAqIEBwYXJhbSB1c2VySWQgSUQgZG8gdXN1w6FyaW9cbiAgICogQHBhcmFtIGluY2x1ZGVJbmFjdGl2ZSBTZSB0cnVlLCBpbmNsdWkgcGVybWlzc8O1ZXMgaW5hdGl2YXMgKHJldm9nYWRhcyBvdSBleHBpcmFkYXMpXG4gICAqIEByZXR1cm5zIExpc3RhIGRlIHBlcm1pc3PDtWVzIGRvIHVzdcOhcmlvXG4gICAqL1xuICBhc3luYyBnZXRVc2VyUGVybWlzc2lvbnModXNlcklkOiBzdHJpbmcsIGluY2x1ZGVJbmFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTxQZXJtaXNzaW9uW10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQnVzY2EgcGVybWlzc8O1ZXMgZGlyZXRhcyBkbyB1c3XDoXJpb1xuICAgICAgY29uc3QgdXNlclBlcm1pc3Npb25zID0gYXdhaXQgdGhpcy51c2VyUGVybWlzc2lvblJlcG9zaXRvcnkuZmluZEJ5VXNlcklkKHVzZXJJZCk7XG4gICAgICBcbiAgICAgIC8vIEZpbHRyYSBwZXJtaXNzw7VlcyBhdGl2YXMsIHNlIG5lY2Vzc8OhcmlvXG4gICAgICBjb25zdCBmaWx0ZXJlZFVzZXJQZXJtaXNzaW9ucyA9IGluY2x1ZGVJbmFjdGl2ZVxuICAgICAgICA/IHVzZXJQZXJtaXNzaW9uc1xuICAgICAgICA6IHVzZXJQZXJtaXNzaW9ucy5maWx0ZXIodXAgPT4gdXAuZ3JhbnRlZCAmJiAoIXVwLnZhbGlkVW50aWwgfHwgdXAudmFsaWRVbnRpbCA+IG5ldyBEYXRlKCkpKTtcbiAgICAgIFxuICAgICAgLy8gT2J0w6ltIElEcyBkYXMgcGVybWlzc8O1ZXNcbiAgICAgIGNvbnN0IHBlcm1pc3Npb25JZHMgPSBmaWx0ZXJlZFVzZXJQZXJtaXNzaW9ucy5tYXAodXAgPT4gdXAucGVybWlzc2lvbklkKTtcbiAgICAgIFxuICAgICAgLy8gQnVzY2EgcGVybWlzc8O1ZXMgZGUgcm9sZSBkbyB1c3XDoXJpb1xuICAgICAgY29uc3Qgcm9sZVBlcm1pc3Npb25zID0gYXdhaXQgdGhpcy5yb2xlUGVybWlzc2lvblJlcG9zaXRvcnkuZmluZFBlcm1pc3Npb25zQnlVc2VyUm9sZXModXNlcklkKTtcbiAgICAgIFxuICAgICAgLy8gQWRpY2lvbmEgSURzIGRlIHBlcm1pc3PDtWVzIGRlIHJvbGVcbiAgICAgIHJvbGVQZXJtaXNzaW9ucy5mb3JFYWNoKHBlcm1pc3Npb24gPT4ge1xuICAgICAgICBpZiAoIXBlcm1pc3Npb25JZHMuaW5jbHVkZXMocGVybWlzc2lvbi5pZCkpIHtcbiAgICAgICAgICBwZXJtaXNzaW9uSWRzLnB1c2gocGVybWlzc2lvbi5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBCdXNjYSBkZXRhbGhlcyBkYXMgcGVybWlzc8O1ZXNcbiAgICAgIGlmIChwZXJtaXNzaW9uSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25SZXBvc2l0b3J5LmZpbmRCeUlkcyhwZXJtaXNzaW9uSWRzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gb2J0ZXIgcGVybWlzc8O1ZXMgZG8gdXN1w6FyaW86ICR7ZXJyb3IubWVzc2FnZX1gLCB7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgaW5jbHVkZUluYWN0aXZlLFxuICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPYnTDqW0gdG9kYXMgYXMgcGVybWlzc8O1ZXMgZGlzcG9uw612ZWlzIG5vIHNpc3RlbWEuXG4gICAqIFxuICAgKiBAcmV0dXJucyBMaXN0YSBkZSB0b2RhcyBhcyBwZXJtaXNzw7Vlc1xuICAgKi9cbiAgYXN5bmMgZ2V0QWxsUGVybWlzc2lvbnMoKTogUHJvbWlzZTxQZXJtaXNzaW9uW10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQnVzY2EgdG9kYXMgYXMgcGVybWlzc8O1ZXMgbm8gYmFuY28sIHVzYW5kbyBhIHF1ZXJ5IGJ1aWxkZXIgcGFyYSB0ZXIgbWFpcyBjb250cm9sZVxuICAgICAgLy8gZSBldml0YXIgcHJvYmxlbWFzIGNvbSBub21lcyBkZSBwcm9wcmllZGFkZXNcbiAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gYXdhaXQgdGhpcy5wZXJtaXNzaW9uUmVwb3NpdG9yeVxuICAgICAgICAuY3JlYXRlUXVlcnlCdWlsZGVyKCdwZXJtaXNzaW9uJylcbiAgICAgICAgLnNlbGVjdChbJ3Blcm1pc3Npb24uaWQnLCAncGVybWlzc2lvbi5ub21lJywgJ3Blcm1pc3Npb24uZGVzY3JpY2FvJ10pXG4gICAgICAgIC5nZXRNYW55KCk7XG4gICAgICByZXR1cm4gcGVybWlzc2lvbnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIGJ1c2NhciB0b2RhcyBhcyBwZXJtaXNzw7VlczogJHtlcnJvci5tZXNzYWdlfWAsIHtcbiAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JpYSB1bWEgbm92YSBwZXJtaXNzw6NvIG5vIHNpc3RlbWEuXG4gICAqIFxuICAgKiBAcGFyYW0gbmFtZSBOb21lIGRhIHBlcm1pc3PDo28gKGRldmUgc2VndWlyIG8gZm9ybWF0byBtb2R1bG8ub3BlcmFjYW8pXG4gICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBEZXNjcmnDp8OjbyBkYSBwZXJtaXNzw6NvXG4gICAqIEBwYXJhbSBjcmVhdGVkQnkgSUQgZG8gdXN1w6FyaW8gcXVlIGVzdMOhIGNyaWFuZG8gYSBwZXJtaXNzw6NvXG4gICAqIEByZXR1cm5zIEEgcGVybWlzc8OjbyBjcmlhZGEgb3UgbnVsbCBzZSBvY29ycmVyIHVtIGVycm9cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVBlcm1pc3Npb24oXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gICAgY3JlYXRlZEJ5OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxQZXJtaXNzaW9uIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBWYWxpZGHDp8OjbyBkZSBwYXLDom1ldHJvc1xuICAgICAgaWYgKCFuYW1lIHx8ICFjcmVhdGVkQnkpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgVGVudGF0aXZhIGRlIGNyaWFyIHBlcm1pc3PDo28gY29tIHBhcsOibWV0cm9zIGludsOhbGlkb3M6IG5hbWU9JHtuYW1lfSwgY3JlYXRlZEJ5PSR7Y3JlYXRlZEJ5fWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZpY2Egc2UgYSBwZXJtaXNzw6NvIGrDoSBleGlzdGVcbiAgICAgIGNvbnN0IGV4aXN0aW5nUGVybWlzc2lvbiA9IGF3YWl0IHRoaXMucGVybWlzc2lvblJlcG9zaXRvcnkuZmluZEJ5TmFtZShuYW1lKTtcbiAgICAgIGlmIChleGlzdGluZ1Blcm1pc3Npb24pIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgVGVudGF0aXZhIGRlIGNyaWFyIHBlcm1pc3PDo28gasOhIGV4aXN0ZW50ZTogJHtuYW1lfWApO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdQZXJtaXNzaW9uO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmlhIGEgbm92YSBwZXJtaXNzw6NvXG4gICAgICBjb25zdCBuZXdQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uUmVwb3NpdG9yeS5jcmVhdGUoe1xuICAgICAgICBub21lOiBuYW1lLFxuICAgICAgICBkZXNjcmljYW86IGRlc2NyaXB0aW9uIHx8IGBQZXJtaXNzw6NvICR7bmFtZX1gXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2FsdmEgYSBwZXJtaXNzw6NvIG5vIGJhbmNvIGRlIGRhZG9zXG4gICAgICBjb25zdCBzYXZlZFBlcm1pc3Npb24gPSBhd2FpdCB0aGlzLnBlcm1pc3Npb25SZXBvc2l0b3J5LnNhdmUobmV3UGVybWlzc2lvbik7XG4gICAgICBcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgUGVybWlzc8OjbyAke25hbWV9IGNyaWFkYSBjb20gc3VjZXNzbyBwb3IgJHtjcmVhdGVkQnl9YCk7XG4gICAgICBcbiAgICAgIHJldHVybiBzYXZlZFBlcm1pc3Npb247XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIGNyaWFyIHBlcm1pc3PDo286ICR7ZXJyb3IubWVzc2FnZX1gLCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBjcmVhdGVkQnksXG4gICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JpYSB1bWEgcGVybWlzc8OjbyBzZSBlbGEgbsOjbyBleGlzdGlyLlxuICAgKiBcbiAgICogQHBhcmFtIG5hbWUgTm9tZSBkYSBwZXJtaXNzw6NvXG4gICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBEZXNjcmnDp8OjbyBkYSBwZXJtaXNzw6NvXG4gICAqIEBwYXJhbSBjcmVhdGVkQnkgSUQgZG8gdXN1w6FyaW8gcXVlIGVzdMOhIGNyaWFuZG8gYSBwZXJtaXNzw6NvXG4gICAqIEByZXR1cm5zIEEgcGVybWlzc8OjbyBjcmlhZGEgb3UgZXhpc3RlbnRlLCBvdSBudWxsIHNlIG9jb3JyZXIgdW0gZXJyb1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlUGVybWlzc2lvbklmTm90RXhpc3RzKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nLFxuICAgIGNyZWF0ZWRCeTogc3RyaW5nXG4gICk6IFByb21pc2U8UGVybWlzc2lvbiB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQnVzY2EgYSBwZXJtaXNzw6NvIHBlbG8gbm9tZVxuICAgICAgY29uc3QgZXhpc3RpbmdQZXJtaXNzaW9uID0gYXdhaXQgdGhpcy5wZXJtaXNzaW9uUmVwb3NpdG9yeS5maW5kQnlOYW1lKG5hbWUpO1xuICAgICAgaWYgKGV4aXN0aW5nUGVybWlzc2lvbikge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdQZXJtaXNzaW9uO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZSBuw6NvIGV4aXN0aXIsIGNyaWEgdW1hIG5vdmFcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBlcm1pc3Npb24obmFtZSwgZGVzY3JpcHRpb24sIGNyZWF0ZWRCeSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIGNyaWFyIHBlcm1pc3PDo28gc2UgbsOjbyBleGlzdGlyOiAke2Vycm9yLm1lc3NhZ2V9YCwge1xuICAgICAgICBuYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgY3JlYXRlZEJ5LFxuICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldm9nYSB1bWEgcGVybWlzc8OjbyBkZSB1bSB1c3XDoXJpby5cbiAgICogXG4gICAqIEBwYXJhbSB1c2VySWQgSUQgZG8gdXN1w6FyaW9cbiAgICogQHBhcmFtIHBlcm1pc3Npb25OYW1lIE5vbWUgZGEgcGVybWlzc8Ojb1xuICAgKiBAcGFyYW0gc2NvcGVUeXBlIFRpcG8gZGUgZXNjb3BvXG4gICAqIEBwYXJhbSBzY29wZUlkIElEIGRvIGVzY29wbyAob3BjaW9uYWwgcGFyYSBlc2NvcG8gR0xPQkFMKVxuICAgKiBAcGFyYW0gY3JlYXRlZEJ5IElEIGRvIHVzdcOhcmlvIHF1ZSBlc3TDoSByZXZvZ2FuZG8gYSBwZXJtaXNzw6NvXG4gICAqIEByZXR1cm5zIHRydWUgc2UgYSBwZXJtaXNzw6NvIGZvaSByZXZvZ2FkYSBjb20gc3VjZXNzbywgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBhc3luYyByZXZva2VQZXJtaXNzaW9uKFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICAgIHBlcm1pc3Npb25OYW1lOiBzdHJpbmcsXG4gICAgc2NvcGVUeXBlOiBUaXBvRXNjb3BvLFxuICAgIHNjb3BlSWQ6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgY3JlYXRlZEJ5OiBzdHJpbmcsXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBWYWxpZGHDp8OjbyBkZSBwYXLDom1ldHJvc1xuICAgICAgaWYgKCF1c2VySWQgfHwgIXBlcm1pc3Npb25OYW1lIHx8ICFjcmVhdGVkQnkpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgVGVudGF0aXZhIGRlIHJldm9nYXIgcGVybWlzc8OjbyBjb20gcGFyw6JtZXRyb3MgaW52w6FsaWRvczogdXNlcklkPSR7dXNlcklkfSwgcGVybWlzc2lvbk5hbWU9JHtwZXJtaXNzaW9uTmFtZX0sIGNyZWF0ZWRCeT0ke2NyZWF0ZWRCeX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWYWxpZGHDp8OjbyBkZSBlc2NvcG9cbiAgICAgIGlmIChzY29wZVR5cGUgPT09IFRpcG9Fc2NvcG8uVU5JREFERSAmJiAhc2NvcGVJZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBUZW50YXRpdmEgZGUgcmV2b2dhciBwZXJtaXNzw6NvIGNvbSBlc2NvcG8gVU5JVCBzZW0gZm9ybmVjZXIgc2NvcGVJZDogdXNlcklkPSR7dXNlcklkfSwgcGVybWlzc2lvbk5hbWU9JHtwZXJtaXNzaW9uTmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBCdXNjYSBhIHBlcm1pc3PDo28gcGVsbyBub21lXG4gICAgICBjb25zdCBwZXJtaXNzaW9uID0gYXdhaXQgdGhpcy5wZXJtaXNzaW9uUmVwb3NpdG9yeS5maW5kQnlOYW1lKHBlcm1pc3Npb25OYW1lKTtcbiAgICAgIGlmICghcGVybWlzc2lvbikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBUZW50YXRpdmEgZGUgcmV2b2dhciBwZXJtaXNzw6NvIGluZXhpc3RlbnRlOiBwZXJtaXNzaW9uTmFtZT0ke3Blcm1pc3Npb25OYW1lfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmaWNhIHNlIG8gdXN1w6FyaW8gdGVtIGEgcGVybWlzc8Ojb1xuICAgICAgY29uc3QgZXhpc3RpbmdQZXJtaXNzaW9uID0gYXdhaXQgdGhpcy51c2VyUGVybWlzc2lvblJlcG9zaXRvcnkuZmluZEJ5VXNlckFuZFBlcm1pc3Npb24oXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgcGVybWlzc2lvbi5pZCxcbiAgICAgICAgc2NvcGVUeXBlLFxuICAgICAgICBzY29wZUlkIHx8IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKCFleGlzdGluZ1Blcm1pc3Npb24pIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgVGVudGF0aXZhIGRlIHJldm9nYXIgcGVybWlzc8OjbyBxdWUgbyB1c3XDoXJpbyBuw6NvIHBvc3N1aTogdXNlcklkPSR7dXNlcklkfSwgcGVybWlzc2lvbk5hbWU9JHtwZXJtaXNzaW9uTmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZmljYSBzZSBhIHBlcm1pc3PDo28gasOhIGVzdMOhIHJldm9nYWRhXG4gICAgICBpZiAoZXhpc3RpbmdQZXJtaXNzaW9uICYmICFleGlzdGluZ1Blcm1pc3Npb24uZ3JhbnRlZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coYFBlcm1pc3PDo28gasOhIGVzdMOhIHJldm9nYWRhOiB1c2VySWQ9JHt1c2VySWR9LCBwZXJtaXNzaW9uTmFtZT0ke3Blcm1pc3Npb25OYW1lfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQ29uc2lkZXJhIHN1Y2Vzc28sIHBvaXMgbyBlc3RhZG8gZmluYWwgw6kgbyBkZXNlamFkb1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBdHVhbGl6YSBhIHBlcm1pc3PDo28gZXhpc3RlbnRlIHBhcmEgcmV2b2dhZGFcbiAgICAgIGF3YWl0IHRoaXMudXNlclBlcm1pc3Npb25SZXBvc2l0b3J5LnVwZGF0ZVVzZXJQZXJtaXNzaW9uKGV4aXN0aW5nUGVybWlzc2lvbi5pZCwge1xuICAgICAgICBncmFudGVkOiBmYWxzZSxcbiAgICAgICAgdXBkYXRlZEJ5OiBjcmVhdGVkQnksXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTGltcGEgbyBjYWNoZSBkZSBwZXJtaXNzw7VlcyBkbyB1c3XDoXJpb1xuICAgICAgYXdhaXQgdGhpcy5jbGVhclVzZXJQZXJtaXNzaW9uQ2FjaGUodXNlcklkKTtcbiAgICAgIFxuICAgICAgLy8gTGltcGEgbyBjYWNoZSBkYSBwZXJtaXNzw6NvIGVzcGVjw61maWNhXG4gICAgICBhd2FpdCB0aGlzLmNsZWFyUGVybWlzc2lvbkNhY2hlKHBlcm1pc3Npb25OYW1lKTtcbiAgICAgIFxuICAgICAgLy8gUmVnaXN0cmEgYSBvcGVyYcOnw6NvIG5vIGxvZ1xuICAgICAgdGhpcy5sb2dnZXIubG9nKGBQZXJtaXNzw6NvICR7cGVybWlzc2lvbk5hbWV9IHJldm9nYWRhIGRvIHVzdcOhcmlvICR7dXNlcklkfSBjb20gZXNjb3BvICR7c2NvcGVUeXBlfSBwb3IgJHtjcmVhdGVkQnl9YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gcmV2b2dhciBwZXJtaXNzw6NvOiAke2Vycm9yLm1lc3NhZ2V9YCwge1xuICAgICAgICB1c2VySWQsXG4gICAgICAgIHBlcm1pc3Npb25OYW1lLFxuICAgICAgICBzY29wZVR5cGUsXG4gICAgICAgIHNjb3BlSWQsXG4gICAgICAgIGNyZWF0ZWRCeSxcbiAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uY2VkZSB1bWEgcGVybWlzc8OjbyBhIHVtIHVzdcOhcmlvLlxuICAgKiBcbiAgICogQHBhcmFtIHVzZXJJZCBJRCBkbyB1c3XDoXJpb1xuICAgKiBAcGFyYW0gcGVybWlzc2lvbk5hbWUgTm9tZSBkYSBwZXJtaXNzw6NvXG4gICAqIEBwYXJhbSBzY29wZVR5cGUgVGlwbyBkZSBlc2NvcG9cbiAgICogQHBhcmFtIHNjb3BlSWQgSUQgZG8gZXNjb3BvIChvcGNpb25hbCBwYXJhIGVzY29wbyBHTE9CQUwpXG4gICAqIEBwYXJhbSB2YWxpZFVudGlsIERhdGEgZGUgdmFsaWRhZGUgZGEgcGVybWlzc8OjbyAob3BjaW9uYWwpXG4gICAqIEBwYXJhbSBjcmVhdGVkQnkgSUQgZG8gdXN1w6FyaW8gcXVlIGVzdMOhIGNvbmNlZGVuZG8gYSBwZXJtaXNzw6NvXG4gICAqIEByZXR1cm5zIHRydWUgc2UgYSBwZXJtaXNzw6NvIGZvaSBjb25jZWRpZGEgY29tIHN1Y2Vzc28sIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgYXN5bmMgZ3JhbnRQZXJtaXNzaW9uKFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICAgIHBlcm1pc3Npb25OYW1lOiBzdHJpbmcsXG4gICAgc2NvcGVUeXBlOiBUaXBvRXNjb3BvLFxuICAgIHNjb3BlSWQ6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgdmFsaWRVbnRpbDogRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgY3JlYXRlZEJ5OiBzdHJpbmcsXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBWYWxpZGHDp8OjbyBkZSBwYXLDom1ldHJvc1xuICAgICAgaWYgKCF1c2VySWQgfHwgIXBlcm1pc3Npb25OYW1lIHx8ICFjcmVhdGVkQnkpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgVGVudGF0aXZhIGRlIGNvbmNlZGVyIHBlcm1pc3PDo28gY29tIHBhcsOibWV0cm9zIGludsOhbGlkb3M6IHVzZXJJZD0ke3VzZXJJZH0sIHBlcm1pc3Npb25OYW1lPSR7cGVybWlzc2lvbk5hbWV9LCBjcmVhdGVkQnk9JHtjcmVhdGVkQnl9YCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmFsaWRhw6fDo28gZGUgZXNjb3BvXG4gICAgICBpZiAoc2NvcGVUeXBlID09PSBUaXBvRXNjb3BvLlVOSURBREUgJiYgIXNjb3BlSWQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgVGVudGF0aXZhIGRlIGNvbmNlZGVyIHBlcm1pc3PDo28gY29tIGVzY29wbyBVTklUIHNlbSBmb3JuZWNlciBzY29wZUlkOiB1c2VySWQ9JHt1c2VySWR9LCBwZXJtaXNzaW9uTmFtZT0ke3Blcm1pc3Npb25OYW1lfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEJ1c2NhIGEgcGVybWlzc8OjbyBwZWxvIG5vbWVcbiAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSBhd2FpdCB0aGlzLnBlcm1pc3Npb25SZXBvc2l0b3J5LmZpbmRCeU5hbWUocGVybWlzc2lvbk5hbWUpO1xuICAgICAgaWYgKCFwZXJtaXNzaW9uKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYFRlbnRhdGl2YSBkZSBjb25jZWRlciBwZXJtaXNzw6NvIGluZXhpc3RlbnRlOiBwZXJtaXNzaW9uTmFtZT0ke3Blcm1pc3Npb25OYW1lfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmaWNhIHNlIG8gdXN1w6FyaW8gasOhIHRlbSBhIHBlcm1pc3PDo29cbiAgICAgIGNvbnN0IGV4aXN0aW5nUGVybWlzc2lvbiA9IGF3YWl0IHRoaXMudXNlclBlcm1pc3Npb25SZXBvc2l0b3J5LmZpbmRCeVVzZXJBbmRQZXJtaXNzaW9uKFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIHBlcm1pc3Npb24uaWQsXG4gICAgICAgIHNjb3BlVHlwZSxcbiAgICAgICAgc2NvcGVJZCB8fCB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFNlIGrDoSBleGlzdGUgZSBlc3TDoSBhdGl2YSwgYXBlbmFzIGF0dWFsaXphIGEgZGF0YSBkZSB2YWxpZGFkZSBzZSBuZWNlc3PDoXJpb1xuICAgICAgaWYgKGV4aXN0aW5nUGVybWlzc2lvbiAmJiBleGlzdGluZ1Blcm1pc3Npb24uZ3JhbnRlZCkge1xuICAgICAgICAvLyBWZXJpZmljYSBzZSBwcmVjaXNhIGF0dWFsaXphciBhIGRhdGEgZGUgdmFsaWRhZGVcbiAgICAgICAgaWYgKHZhbGlkVW50aWwgJiYgKCFleGlzdGluZ1Blcm1pc3Npb24udmFsaWRVbnRpbCB8fCB2YWxpZFVudGlsID4gZXhpc3RpbmdQZXJtaXNzaW9uLnZhbGlkVW50aWwpKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy51c2VyUGVybWlzc2lvblJlcG9zaXRvcnkudXBkYXRlVXNlclBlcm1pc3Npb24oZXhpc3RpbmdQZXJtaXNzaW9uLmlkLCB7XG4gICAgICAgICAgICB2YWxpZFVudGlsLFxuICAgICAgICAgICAgdXBkYXRlZEJ5OiBjcmVhdGVkQnksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBEYXRhIGRlIHZhbGlkYWRlIGRhIHBlcm1pc3PDo28gJHtwZXJtaXNzaW9uTmFtZX0gYXR1YWxpemFkYSBwYXJhIG8gdXN1w6FyaW8gJHt1c2VySWR9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBVc3XDoXJpbyAke3VzZXJJZH0gasOhIHBvc3N1aSBhIHBlcm1pc3PDo28gJHtwZXJtaXNzaW9uTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNlIGV4aXN0ZSBtYXMgZXN0w6EgcmV2b2dhZGEsIHJlYXRpdmFcbiAgICAgIGlmIChleGlzdGluZ1Blcm1pc3Npb24gJiYgIWV4aXN0aW5nUGVybWlzc2lvbi5ncmFudGVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudXNlclBlcm1pc3Npb25SZXBvc2l0b3J5LnVwZGF0ZVVzZXJQZXJtaXNzaW9uKGV4aXN0aW5nUGVybWlzc2lvbi5pZCwge1xuICAgICAgICAgIGdyYW50ZWQ6IHRydWUsXG4gICAgICAgICAgdmFsaWRVbnRpbDogdmFsaWRVbnRpbCB8fCBudWxsLFxuICAgICAgICAgIHVwZGF0ZWRCeTogY3JlYXRlZEJ5LFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhgUGVybWlzc8OjbyAke3Blcm1pc3Npb25OYW1lfSByZWF0aXZhZGEgcGFyYSBvIHVzdcOhcmlvICR7dXNlcklkfSBjb20gZXNjb3BvICR7c2NvcGVUeXBlfSBwb3IgJHtjcmVhdGVkQnl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmlhIHVtYSBub3ZhIHBlcm1pc3PDo28gcGFyYSBvIHVzdcOhcmlvXG4gICAgICAgIGF3YWl0IHRoaXMudXNlclBlcm1pc3Npb25SZXBvc2l0b3J5LmNyZWF0ZVVzZXJQZXJtaXNzaW9uKHtcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgcGVybWlzc2lvbklkOiBwZXJtaXNzaW9uLmlkLFxuICAgICAgICAgIHNjb3BlVHlwZSxcbiAgICAgICAgICBzY29wZUlkOiBzY29wZUlkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBncmFudGVkOiB0cnVlLFxuICAgICAgICAgIHZhbGlkVW50aWw6IHZhbGlkVW50aWwgfHwgbnVsbCxcbiAgICAgICAgICBjcmVhdGVkQnksXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKGBQZXJtaXNzw6NvICR7cGVybWlzc2lvbk5hbWV9IGNvbmNlZGlkYSBhbyB1c3XDoXJpbyAke3VzZXJJZH0gY29tIGVzY29wbyAke3Njb3BlVHlwZX0gcG9yICR7Y3JlYXRlZEJ5fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBMaW1wYSBvIGNhY2hlIGRlIHBlcm1pc3PDtWVzIGRvIHVzdcOhcmlvXG4gICAgICBhd2FpdCB0aGlzLmNsZWFyVXNlclBlcm1pc3Npb25DYWNoZSh1c2VySWQpO1xuICAgICAgXG4gICAgICAvLyBMaW1wYSBvIGNhY2hlIGRhIHBlcm1pc3PDo28gZXNwZWPDrWZpY2FcbiAgICAgIGF3YWl0IHRoaXMuY2xlYXJQZXJtaXNzaW9uQ2FjaGUocGVybWlzc2lvbk5hbWUpO1xuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gY29uY2VkZXIgcGVybWlzc8OjbzogJHtlcnJvci5tZXNzYWdlfWAsIHtcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9idMOpbSBhcyBwZXJtaXNzw7VlcyBhc3NvY2lhZGFzIGEgdW1hIHJvbGUuXG4gICAqIFxuICAgKiBAcGFyYW0gcm9sZUlkIElEIGRhIHJvbGVcbiAgICogQHJldHVybnMgTGlzdGEgZGUgcGVybWlzc8O1ZXMgYXNzb2NpYWRhcyDDoCByb2xlXG4gICAqL1xuICBhc3luYyBnZXRQZXJtaXNzaW9uc0J5Um9sZShyb2xlSWQ6IHN0cmluZyk6IFByb21pc2U8UGVybWlzc2lvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEJ1c2NhIGFzIHBlcm1pc3PDtWVzIGFzc29jaWFkYXMgw6Agcm9sZVxuICAgICAgY29uc3Qgcm9sZVBlcm1pc3Npb25zID0gYXdhaXQgdGhpcy5yb2xlUGVybWlzc2lvblJlcG9zaXRvcnkuZmluZEJ5Um9sZUlkKHJvbGVJZCk7XG4gICAgICBcbiAgICAgIGlmICghcm9sZVBlcm1pc3Npb25zIHx8IHJvbGVQZXJtaXNzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFeHRyYWkgb3MgSURzIGRhcyBwZXJtaXNzw7Vlc1xuICAgICAgY29uc3QgcGVybWlzc2lvbklkcyA9IHJvbGVQZXJtaXNzaW9ucy5tYXAocnAgPT4gcnAucGVybWlzc2lvbklkKTtcbiAgICAgIFxuICAgICAgLy8gQnVzY2Egb3MgZGV0YWxoZXMgZGFzIHBlcm1pc3PDtWVzXG4gICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uUmVwb3NpdG9yeS5maW5kQnlJZHMocGVybWlzc2lvbklkcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIG9idGVyIHBlcm1pc3PDtWVzIGRhIHJvbGU6ICR7ZXJyb3IubWVzc2FnZX1gLCB7XG4gICAgICAgIHJvbGVJZCxcbiAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIGFzIHBlcm1pc3PDtWVzIGRlIHJvbGUgYXNzb2NpYWRhcyBhIHVtIHVzdcOhcmlvLlxuICAgKiBcbiAgICogQHBhcmFtIHVzZXJJZCBJRCBkbyB1c3XDoXJpb1xuICAgKiBAcmV0dXJucyBMaXN0YSBkZSBwZXJtaXNzw7VlcyBkZSByb2xlIGRvIHVzdcOhcmlvXG4gICAqL1xuICBhc3luYyBnZXRSb2xlUGVybWlzc2lvbnNCeVVzZXJJZCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8UGVybWlzc2lvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEJ1c2NhIHBlcm1pc3PDtWVzIGRlIHJvbGUgZG8gdXN1w6FyaW9cbiAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gYXdhaXQgdGhpcy5yb2xlUGVybWlzc2lvblJlcG9zaXRvcnkuZmluZFBlcm1pc3Npb25zQnlVc2VyUm9sZXModXNlcklkKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHBlcm1pc3Npb25zIHx8IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRXJybyBhbyBvYnRlciBwZXJtaXNzw7VlcyBkZSByb2xlIGRvIHVzdcOhcmlvOiAke2Vycm9yLm1lc3NhZ2V9YCwge1xuICAgICAgICB1c2VySWQsXG4gICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59XG4iXSwidmVyc2lvbiI6M30=