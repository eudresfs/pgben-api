95fdb3a96e3f7eb5352b07de0ed47429
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const testing_1 = require("@nestjs/testing");
const common_1 = require("@nestjs/common");
const core_1 = require("@nestjs/core");
const requires_permission_decorator_1 = require("@/auth/decorators/requires-permission.decorator");
const user_permission_entity_1 = require("@/auth/entities/user-permission.entity");
/**
 * Testes unitários para o decorator RequiresPermission
 *
 * Estes testes verificam se o decorator armazena corretamente as
 * informações de permissão necessárias para o PermissionGuard.
 */
describe('RequiresPermission', () => {
    let reflector;
    beforeEach(async () => {
        const moduleRef = await testing_1.Test.createTestingModule({
            providers: [core_1.Reflector],
        }).compile();
        reflector = moduleRef.get(core_1.Reflector);
    });
    it('deve armazenar requisito de permissão com escopo GLOBAL', () => {
        // Definir um controlador de teste com o decorator
        let TestController = class TestController {
            testMethod() {
                return 'test';
            }
        };
        __decorate([
            (0, requires_permission_decorator_1.RequiresPermission)({
                permissionName: 'beneficio.listar',
                scopeType: user_permission_entity_1.ScopeType.GLOBAL,
            }),
            (0, common_1.Get)(),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TestController.prototype, "testMethod", null);
        TestController = __decorate([
            (0, common_1.Controller)('test')
        ], TestController);
        // Instanciar o controlador
        const controller = new TestController();
        // Obter os metadados
        const permissionReqs = reflector.get(requires_permission_decorator_1.REQUIRES_PERMISSION_KEY, controller.testMethod);
        // Verificar se os metadados foram armazenados corretamente
        expect(permissionReqs).toBeDefined();
        expect(permissionReqs).toBeInstanceOf(Array);
        expect(permissionReqs.length).toBe(1);
        expect(permissionReqs[0]).toEqual({
            permissionName: 'beneficio.listar',
            scopeType: user_permission_entity_1.ScopeType.GLOBAL,
        });
    });
    it('deve armazenar requisito de permissão com escopo UNIT e expressão de escopo', () => {
        // Definir um controlador de teste com o decorator
        let TestController = class TestController {
            testMethod() {
                return 'test';
            }
        };
        __decorate([
            (0, requires_permission_decorator_1.RequiresPermission)({
                permissionName: 'solicitacao.listar',
                scopeType: user_permission_entity_1.ScopeType.UNIT,
                scopeIdExpression: 'query.unidade_id',
            }),
            (0, common_1.Get)(),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TestController.prototype, "testMethod", null);
        TestController = __decorate([
            (0, common_1.Controller)('test')
        ], TestController);
        // Instanciar o controlador
        const controller = new TestController();
        // Obter os metadados
        const permissionReqs = reflector.get(requires_permission_decorator_1.REQUIRES_PERMISSION_KEY, controller.testMethod);
        // Verificar se os metadados foram armazenados corretamente
        expect(permissionReqs).toBeDefined();
        expect(permissionReqs).toBeInstanceOf(Array);
        expect(permissionReqs.length).toBe(1);
        expect(permissionReqs[0]).toEqual({
            permissionName: 'solicitacao.listar',
            scopeType: user_permission_entity_1.ScopeType.UNIT,
            scopeIdExpression: 'query.unidade_id',
        });
    });
    it('deve armazenar requisito de permissão com escopo SELF', () => {
        // Definir um controlador de teste com o decorator
        let TestController = class TestController {
            testMethod() {
                return 'test';
            }
        };
        __decorate([
            (0, requires_permission_decorator_1.RequiresPermission)({
                permissionName: 'usuario.perfil.editar',
                scopeType: user_permission_entity_1.ScopeType.SELF,
            }),
            (0, common_1.Get)(),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TestController.prototype, "testMethod", null);
        TestController = __decorate([
            (0, common_1.Controller)('test')
        ], TestController);
        // Instanciar o controlador
        const controller = new TestController();
        // Obter os metadados
        const permissionReqs = reflector.get(requires_permission_decorator_1.REQUIRES_PERMISSION_KEY, controller.testMethod);
        // Verificar se os metadados foram armazenados corretamente
        expect(permissionReqs).toBeDefined();
        expect(permissionReqs).toBeInstanceOf(Array);
        expect(permissionReqs.length).toBe(1);
        expect(permissionReqs[0]).toEqual({
            permissionName: 'usuario.perfil.editar',
            scopeType: user_permission_entity_1.ScopeType.SELF,
        });
    });
    it('deve acumular múltiplos requisitos de permissão', () => {
        // Definir um controlador de teste com múltiplos decorators
        let TestController = class TestController {
            testMethod() {
                return 'test';
            }
        };
        __decorate([
            (0, requires_permission_decorator_1.RequiresPermission)({
                permissionName: 'solicitacao.visualizar',
                scopeType: user_permission_entity_1.ScopeType.UNIT,
                scopeIdExpression: 'solicitacao.unidadeId',
            }),
            (0, requires_permission_decorator_1.RequiresPermission)({
                permissionName: 'solicitacao.historico.visualizar',
                scopeType: user_permission_entity_1.ScopeType.UNIT,
                scopeIdExpression: 'solicitacao.unidadeId',
            }),
            (0, common_1.Get)(),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], TestController.prototype, "testMethod", null);
        TestController = __decorate([
            (0, common_1.Controller)('test')
        ], TestController);
        // Instanciar o controlador
        const controller = new TestController();
        // Obter os metadados
        const permissionReqs = reflector.get(requires_permission_decorator_1.REQUIRES_PERMISSION_KEY, controller.testMethod);
        // Verificar se os metadados foram armazenados corretamente
        expect(permissionReqs).toBeDefined();
        expect(permissionReqs).toBeInstanceOf(Array);
        expect(permissionReqs.length).toBe(2);
        expect(permissionReqs[0]).toEqual({
            permissionName: 'solicitacao.visualizar',
            scopeType: user_permission_entity_1.ScopeType.UNIT,
            scopeIdExpression: 'solicitacao.unidadeId',
        });
        expect(permissionReqs[1]).toEqual({
            permissionName: 'solicitacao.historico.visualizar',
            scopeType: user_permission_entity_1.ScopeType.UNIT,
            scopeIdExpression: 'solicitacao.unidadeId',
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFx0ZXN0XFxtb2R1bGVzXFxhdXRoXFxkZWNvcmF0b3JzXFxyZXF1aXJlcy1wZXJtaXNzaW9uLmRlY29yYXRvci51bml0LnNwZWMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSw2Q0FBdUM7QUFDdkMsMkNBQWlEO0FBQ2pELHVDQUF5QztBQUN6QyxtR0FBOEc7QUFDOUcsbUZBQW1FO0FBRW5FOzs7OztHQUtHO0FBQ0gsUUFBUSxDQUFDLG9CQUFvQixFQUFFLEdBQUcsRUFBRTtJQUNsQyxJQUFJLFNBQW9CLENBQUM7SUFFekIsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3BCLE1BQU0sU0FBUyxHQUFHLE1BQU0sY0FBSSxDQUFDLG1CQUFtQixDQUFDO1lBQy9DLFNBQVMsRUFBRSxDQUFDLGdCQUFTLENBQUM7U0FDdkIsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRWIsU0FBUyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQVksZ0JBQVMsQ0FBQyxDQUFDO0lBQ2xELENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLHlEQUF5RCxFQUFFLEdBQUcsRUFBRTtRQUNqRSxrREFBa0Q7UUFFbEQsSUFBTSxjQUFjLEdBQXBCLE1BQU0sY0FBYztZQU1sQixVQUFVO2dCQUNSLE9BQU8sTUFBTSxDQUFDO1lBQ2hCLENBQUM7U0FDRixDQUFBO1FBSEM7WUFMQyxJQUFBLGtEQUFrQixFQUFDO2dCQUNsQixjQUFjLEVBQUUsa0JBQWtCO2dCQUNsQyxTQUFTLEVBQUUsa0NBQVMsQ0FBQyxNQUFNO2FBQzVCLENBQUM7WUFDRCxJQUFBLFlBQUcsR0FBRTs7Ozt3REFHTDtRQVJHLGNBQWM7WUFEbkIsSUFBQSxtQkFBVSxFQUFDLE1BQU0sQ0FBQztXQUNiLGNBQWMsQ0FTbkI7UUFFRCwyQkFBMkI7UUFDM0IsTUFBTSxVQUFVLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztR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QUFFLENBQUM7UUFDckMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM3QyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO1lBQ2hDLGNBQWMsRUFBRSx3QkFBd0I7WUFDeEMsU0FBUyxFQUFFLGtDQUFTLENBQUMsSUFBSTtZQUN6QixpQkFBaUIsRUFBRSx1QkFBdUI7U0FDM0MsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztZQUNoQyxjQUFjLEVBQUUsa0NBQWtDO1lBQ2xELFNBQVMsRUFBRSxrQ0FBUyxDQUFDLElBQUk7WUFDekIsaUJBQWlCLEVBQUUsdUJBQXVCO1NBQzNDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFx0ZXN0XFxtb2R1bGVzXFxhdXRoXFxkZWNvcmF0b3JzXFxyZXF1aXJlcy1wZXJtaXNzaW9uLmRlY29yYXRvci51bml0LnNwZWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGVzdCB9IGZyb20gJ0BuZXN0anMvdGVzdGluZyc7XG5pbXBvcnQgeyBDb250cm9sbGVyLCBHZXQgfSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBSZWZsZWN0b3IgfSBmcm9tICdAbmVzdGpzL2NvcmUnO1xuaW1wb3J0IHsgUmVxdWlyZXNQZXJtaXNzaW9uLCBSRVFVSVJFU19QRVJNSVNTSU9OX0tFWSB9IGZyb20gJ0AvYXV0aC9kZWNvcmF0b3JzL3JlcXVpcmVzLXBlcm1pc3Npb24uZGVjb3JhdG9yJztcbmltcG9ydCB7IFNjb3BlVHlwZSB9IGZyb20gJ0AvYXV0aC9lbnRpdGllcy91c2VyLXBlcm1pc3Npb24uZW50aXR5JztcblxuLyoqXG4gKiBUZXN0ZXMgdW5pdMOhcmlvcyBwYXJhIG8gZGVjb3JhdG9yIFJlcXVpcmVzUGVybWlzc2lvblxuICogXG4gKiBFc3RlcyB0ZXN0ZXMgdmVyaWZpY2FtIHNlIG8gZGVjb3JhdG9yIGFybWF6ZW5hIGNvcnJldGFtZW50ZSBhc1xuICogaW5mb3JtYcOnw7VlcyBkZSBwZXJtaXNzw6NvIG5lY2Vzc8OhcmlhcyBwYXJhIG8gUGVybWlzc2lvbkd1YXJkLlxuICovXG5kZXNjcmliZSgnUmVxdWlyZXNQZXJtaXNzaW9uJywgKCkgPT4ge1xuICBsZXQgcmVmbGVjdG9yOiBSZWZsZWN0b3I7XG5cbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9kdWxlUmVmID0gYXdhaXQgVGVzdC5jcmVhdGVUZXN0aW5nTW9kdWxlKHtcbiAgICAgIHByb3ZpZGVyczogW1JlZmxlY3Rvcl0sXG4gICAgfSkuY29tcGlsZSgpO1xuXG4gICAgcmVmbGVjdG9yID0gbW9kdWxlUmVmLmdldDxSZWZsZWN0b3I+KFJlZmxlY3Rvcik7XG4gIH0pO1xuXG4gIGl0KCdkZXZlIGFybWF6ZW5hciByZXF1aXNpdG8gZGUgcGVybWlzc8OjbyBjb20gZXNjb3BvIEdMT0JBTCcsICgpID0+IHtcbiAgICAvLyBEZWZpbmlyIHVtIGNvbnRyb2xhZG9yIGRlIHRlc3RlIGNvbSBvIGRlY29yYXRvclxuICAgIEBDb250cm9sbGVyKCd0ZXN0JylcbiAgICBjbGFzcyBUZXN0Q29udHJvbGxlciB7XG4gICAgICBAUmVxdWlyZXNQZXJtaXNzaW9uKHtcbiAgICAgICAgcGVybWlzc2lvbk5hbWU6ICdiZW5lZmljaW8ubGlzdGFyJyxcbiAgICAgICAgc2NvcGVUeXBlOiBTY29wZVR5cGUuR0xPQkFMLFxuICAgICAgfSlcbiAgICAgIEBHZXQoKVxuICAgICAgdGVzdE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuICd0ZXN0JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbnN0YW5jaWFyIG8gY29udHJvbGFkb3JcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IFRlc3RDb250cm9sbGVyKCk7XG4gICAgXG4gICAgLy8gT2J0ZXIgb3MgbWV0YWRhZG9zXG4gICAgY29uc3QgcGVybWlzc2lvblJlcXMgPSByZWZsZWN0b3IuZ2V0KFJFUVVJUkVTX1BFUk1JU1NJT05fS0VZLCBjb250cm9sbGVyLnRlc3RNZXRob2QpO1xuICAgIFxuICAgIC8vIFZlcmlmaWNhciBzZSBvcyBtZXRhZGFkb3MgZm9yYW0gYXJtYXplbmFkb3MgY29ycmV0YW1lbnRlXG4gICAgZXhwZWN0KHBlcm1pc3Npb25SZXFzKS50b0JlRGVmaW5lZCgpO1xuICAgIGV4cGVjdChwZXJtaXNzaW9uUmVxcykudG9CZUluc3RhbmNlT2YoQXJyYXkpO1xuICAgIGV4cGVjdChwZXJtaXNzaW9uUmVxcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgZXhwZWN0KHBlcm1pc3Npb25SZXFzWzBdKS50b0VxdWFsKHtcbiAgICAgIHBlcm1pc3Npb25OYW1lOiAnYmVuZWZpY2lvLmxpc3RhcicsXG4gICAgICBzY29wZVR5cGU6IFNjb3BlVHlwZS5HTE9CQUwsXG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KCdkZXZlIGFybWF6ZW5hciByZXF1aXNpdG8gZGUgcGVybWlzc8OjbyBjb20gZXNjb3BvIFVOSVQgZSBleHByZXNzw6NvIGRlIGVzY29wbycsICgpID0+IHtcbiAgICAvLyBEZWZpbmlyIHVtIGNvbnRyb2xhZG9yIGRlIHRlc3RlIGNvbSBvIGRlY29yYXRvclxuICAgIEBDb250cm9sbGVyKCd0ZXN0JylcbiAgICBjbGFzcyBUZXN0Q29udHJvbGxlciB7XG4gICAgICBAUmVxdWlyZXNQZXJtaXNzaW9uKHtcbiAgICAgICAgcGVybWlzc2lvbk5hbWU6ICdzb2xpY2l0YWNhby5saXN0YXInLFxuICAgICAgICBzY29wZVR5cGU6IFNjb3BlVHlwZS5VTklULFxuICAgICAgICBzY29wZUlkRXhwcmVzc2lvbjogJ3F1ZXJ5LnVuaWRhZGVfaWQnLFxuICAgICAgfSlcbiAgICAgIEBHZXQoKVxuICAgICAgdGVzdE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuICd0ZXN0JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbnN0YW5jaWFyIG8gY29udHJvbGFkb3JcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IFRlc3RDb250cm9sbGVyKCk7XG4gICAgXG4gICAgLy8gT2J0ZXIgb3MgbWV0YWRhZG9zXG4gICAgY29uc3QgcGVybWlzc2lvblJlcXMgPSByZWZsZWN0b3IuZ2V0KFJFUVVJUkVTX1BFUk1JU1NJT05fS0VZLCBjb250cm9sbGVyLnRlc3RNZXRob2QpO1xuICAgIFxuICAgIC8vIFZlcmlmaWNhciBzZSBvcyBtZXRhZGFkb3MgZm9yYW0gYXJtYXplbmFkb3MgY29ycmV0YW1lbnRlXG4gICAgZXhwZWN0KHBlcm1pc3Npb25SZXFzKS50b0JlRGVmaW5lZCgpO1xuICAgIGV4cGVjdChwZXJtaXNzaW9uUmVxcykudG9CZUluc3RhbmNlT2YoQXJyYXkpO1xuICAgIGV4cGVjdChwZXJtaXNzaW9uUmVxcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgZXhwZWN0KHBlcm1pc3Npb25SZXFzWzBdKS50b0VxdWFsKHtcbiAgICAgIHBlcm1pc3Npb25OYW1lOiAnc29saWNpdGFjYW8ubGlzdGFyJyxcbiAgICAgIHNjb3BlVHlwZTogU2NvcGVUeXBlLlVOSVQsXG4gICAgICBzY29wZUlkRXhwcmVzc2lvbjogJ3F1ZXJ5LnVuaWRhZGVfaWQnLFxuICAgIH0pO1xuICB9KTtcblxuICBpdCgnZGV2ZSBhcm1hemVuYXIgcmVxdWlzaXRvIGRlIHBlcm1pc3PDo28gY29tIGVzY29wbyBTRUxGJywgKCkgPT4ge1xuICAgIC8vIERlZmluaXIgdW0gY29udHJvbGFkb3IgZGUgdGVzdGUgY29tIG8gZGVjb3JhdG9yXG4gICAgQENvbnRyb2xsZXIoJ3Rlc3QnKVxuICAgIGNsYXNzIFRlc3RDb250cm9sbGVyIHtcbiAgICAgIEBSZXF1aXJlc1Blcm1pc3Npb24oe1xuICAgICAgICBwZXJtaXNzaW9uTmFtZTogJ3VzdWFyaW8ucGVyZmlsLmVkaXRhcicsXG4gICAgICAgIHNjb3BlVHlwZTogU2NvcGVUeXBlLlNFTEYsXG4gICAgICB9KVxuICAgICAgQEdldCgpXG4gICAgICB0ZXN0TWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gJ3Rlc3QnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluc3RhbmNpYXIgbyBjb250cm9sYWRvclxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgVGVzdENvbnRyb2xsZXIoKTtcbiAgICBcbiAgICAvLyBPYnRlciBvcyBtZXRhZGFkb3NcbiAgICBjb25zdCBwZXJtaXNzaW9uUmVxcyA9IHJlZmxlY3Rvci5nZXQoUkVRVUlSRVNfUEVSTUlTU0lPTl9LRVksIGNvbnRyb2xsZXIudGVzdE1ldGhvZCk7XG4gICAgXG4gICAgLy8gVmVyaWZpY2FyIHNlIG9zIG1ldGFkYWRvcyBmb3JhbSBhcm1hemVuYWRvcyBjb3JyZXRhbWVudGVcbiAgICBleHBlY3QocGVybWlzc2lvblJlcXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgZXhwZWN0KHBlcm1pc3Npb25SZXFzKS50b0JlSW5zdGFuY2VPZihBcnJheSk7XG4gICAgZXhwZWN0KHBlcm1pc3Npb25SZXFzLmxlbmd0aCkudG9CZSgxKTtcbiAgICBleHBlY3QocGVybWlzc2lvblJlcXNbMF0pLnRvRXF1YWwoe1xuICAgICAgcGVybWlzc2lvbk5hbWU6ICd1c3VhcmlvLnBlcmZpbC5lZGl0YXInLFxuICAgICAgc2NvcGVUeXBlOiBTY29wZVR5cGUuU0VMRixcbiAgICB9KTtcbiAgfSk7XG5cbiAgaXQoJ2RldmUgYWN1bXVsYXIgbcO6bHRpcGxvcyByZXF1aXNpdG9zIGRlIHBlcm1pc3PDo28nLCAoKSA9PiB7XG4gICAgLy8gRGVmaW5pciB1bSBjb250cm9sYWRvciBkZSB0ZXN0ZSBjb20gbcO6bHRpcGxvcyBkZWNvcmF0b3JzXG4gICAgQENvbnRyb2xsZXIoJ3Rlc3QnKVxuICAgIGNsYXNzIFRlc3RDb250cm9sbGVyIHtcbiAgICAgIEBSZXF1aXJlc1Blcm1pc3Npb24oe1xuICAgICAgICBwZXJtaXNzaW9uTmFtZTogJ3NvbGljaXRhY2FvLnZpc3VhbGl6YXInLFxuICAgICAgICBzY29wZVR5cGU6IFNjb3BlVHlwZS5VTklULFxuICAgICAgICBzY29wZUlkRXhwcmVzc2lvbjogJ3NvbGljaXRhY2FvLnVuaWRhZGVJZCcsXG4gICAgICB9KVxuICAgICAgQFJlcXVpcmVzUGVybWlzc2lvbih7XG4gICAgICAgIHBlcm1pc3Npb25OYW1lOiAnc29saWNpdGFjYW8uaGlzdG9yaWNvLnZpc3VhbGl6YXInLFxuICAgICAgICBzY29wZVR5cGU6IFNjb3BlVHlwZS5VTklULFxuICAgICAgICBzY29wZUlkRXhwcmVzc2lvbjogJ3NvbGljaXRhY2FvLnVuaWRhZGVJZCcsXG4gICAgICB9KVxuICAgICAgQEdldCgpXG4gICAgICB0ZXN0TWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gJ3Rlc3QnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluc3RhbmNpYXIgbyBjb250cm9sYWRvclxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgVGVzdENvbnRyb2xsZXIoKTtcbiAgICBcbiAgICAvLyBPYnRlciBvcyBtZXRhZGFkb3NcbiAgICBjb25zdCBwZXJtaXNzaW9uUmVxcyA9IHJlZmxlY3Rvci5nZXQoUkVRVUlSRVNfUEVSTUlTU0lPTl9LRVksIGNvbnRyb2xsZXIudGVzdE1ldGhvZCk7XG4gICAgXG4gICAgLy8gVmVyaWZpY2FyIHNlIG9zIG1ldGFkYWRvcyBmb3JhbSBhcm1hemVuYWRvcyBjb3JyZXRhbWVudGVcbiAgICBleHBlY3QocGVybWlzc2lvblJlcXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgZXhwZWN0KHBlcm1pc3Npb25SZXFzKS50b0JlSW5zdGFuY2VPZihBcnJheSk7XG4gICAgZXhwZWN0KHBlcm1pc3Npb25SZXFzLmxlbmd0aCkudG9CZSgyKTtcbiAgICBleHBlY3QocGVybWlzc2lvblJlcXNbMF0pLnRvRXF1YWwoe1xuICAgICAgcGVybWlzc2lvbk5hbWU6ICdzb2xpY2l0YWNhby52aXN1YWxpemFyJyxcbiAgICAgIHNjb3BlVHlwZTogU2NvcGVUeXBlLlVOSVQsXG4gICAgICBzY29wZUlkRXhwcmVzc2lvbjogJ3NvbGljaXRhY2FvLnVuaWRhZGVJZCcsXG4gICAgfSk7XG4gICAgZXhwZWN0KHBlcm1pc3Npb25SZXFzWzFdKS50b0VxdWFsKHtcbiAgICAgIHBlcm1pc3Npb25OYW1lOiAnc29saWNpdGFjYW8uaGlzdG9yaWNvLnZpc3VhbGl6YXInLFxuICAgICAgc2NvcGVUeXBlOiBTY29wZVR5cGUuVU5JVCxcbiAgICAgIHNjb3BlSWRFeHByZXNzaW9uOiAnc29saWNpdGFjYW8udW5pZGFkZUlkJyxcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==