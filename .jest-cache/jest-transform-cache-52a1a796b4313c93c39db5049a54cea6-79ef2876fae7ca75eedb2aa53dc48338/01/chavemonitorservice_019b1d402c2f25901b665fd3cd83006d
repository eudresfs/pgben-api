ee3be21d1da7627f8713ad76010b4ed7
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ChaveMonitorService_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChaveMonitorService = void 0;
const common_1 = require("@nestjs/common");
const config_1 = require("@nestjs/config");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const crypto = __importStar(require("crypto"));
/**
 * Serviço de Monitoramento de Chaves
 *
 * Responsável por monitorar a integridade das chaves de criptografia,
 * verificar permissões de arquivo e registrar alterações não autorizadas.
 */
let ChaveMonitorService = ChaveMonitorService_1 = class ChaveMonitorService {
    configService;
    logger = new common_1.Logger(ChaveMonitorService_1.name);
    keyPath;
    keyChecksum;
    lastModified;
    lastPermissions;
    constructor(configService) {
        this.configService = configService;
        this.keyPath =
            this.configService.get('ENCRYPTION_KEY_PATH') ||
                path.join(process.cwd(), 'config', 'encryption.key');
        // Inicializar o monitoramento se a chave existir
        if (fs.existsSync(this.keyPath)) {
            this.inicializarMonitoramento();
        }
        else {
            this.logger.warn('Arquivo de chave não encontrado para monitoramento');
        }
    }
    /**
     * Inicializa o monitoramento da chave
     */
    inicializarMonitoramento() {
        try {
            const stats = fs.statSync(this.keyPath);
            this.lastModified = stats.mtime;
            this.lastPermissions = stats.mode;
            this.keyChecksum = this.calcularChecksum();
            this.logger.log('Monitoramento de chave inicializado com sucesso');
            // Verificar permissões
            this.verificarPermissoes();
        }
        catch (error) {
            this.logger.error(`Erro ao inicializar monitoramento: ${error.message}`);
        }
    }
    /**
     * Calcula o checksum do arquivo de chave
     */
    calcularChecksum() {
        try {
            const fileBuffer = fs.readFileSync(this.keyPath);
            const hashSum = crypto.createHash('sha256');
            hashSum.update(fileBuffer);
            return hashSum.digest('hex');
        }
        catch (error) {
            this.logger.error(`Erro ao calcular checksum: ${error.message}`);
            return '';
        }
    }
    /**
     * Verifica se as permissões do arquivo estão corretas
     */
    verificarPermissoes() {
        try {
            const stats = fs.statSync(this.keyPath);
            const permissoes = stats.mode & 0o777; // Extrair apenas as permissões
            // Em sistemas Unix, verificar se as permissões são 600 (leitura/escrita apenas para o proprietário)
            if (process.platform !== 'win32' && permissoes !== 0o600) {
                this.logger.warn(`Permissões inseguras detectadas no arquivo de chave: ${permissoes.toString(8)}. ` +
                    'Recomendado: 600 (leitura/escrita apenas para o proprietário)');
                // Tentar corrigir as permissões
                try {
                    fs.chmodSync(this.keyPath, 0o600);
                    this.logger.log('Permissões do arquivo de chave corrigidas para 600');
                }
                catch (chmodError) {
                    this.logger.error(`Não foi possível corrigir as permissões: ${chmodError.message}`);
                }
            }
        }
        catch (error) {
            this.logger.error(`Erro ao verificar permissões: ${error.message}`);
        }
    }
    /**
     * Verifica a integridade da chave
     * @returns true se a chave está íntegra, false caso contrário
     */
    verificarIntegridade() {
        if (!fs.existsSync(this.keyPath)) {
            this.logger.error('Arquivo de chave não encontrado durante verificação de integridade');
            return false;
        }
        try {
            // Verificar se o arquivo foi modificado
            const stats = fs.statSync(this.keyPath);
            if (stats.mtime.getTime() !== this.lastModified.getTime()) {
                this.logger.warn('Detectada modificação no arquivo de chave!');
                // Verificar se o conteúdo realmente mudou (checksum)
                const novoChecksum = this.calcularChecksum();
                if (novoChecksum !== this.keyChecksum) {
                    this.logger.error('ALERTA DE SEGURANÇA: Conteúdo do arquivo de chave foi alterado!');
                    return false;
                }
                // Atualizar timestamp se apenas o timestamp mudou mas o conteúdo não
                this.lastModified = stats.mtime;
                this.logger.log('Timestamp do arquivo atualizado, mas conteúdo permanece íntegro');
            }
            // Verificar permissões
            if (stats.mode !== this.lastPermissions) {
                this.logger.warn('Permissões do arquivo de chave foram alteradas!');
                this.verificarPermissoes();
                this.lastPermissions = stats.mode;
            }
            return true;
        }
        catch (error) {
            this.logger.error(`Erro ao verificar integridade: ${error.message}`);
            return false;
        }
    }
    /**
     * Cria um backup da chave
     * @returns true se o backup foi criado com sucesso, false caso contrário
     */
    criarBackup() {
        if (!fs.existsSync(this.keyPath)) {
            this.logger.error('Arquivo de chave não encontrado para backup');
            return false;
        }
        try {
            const backupDir = path.join(path.dirname(this.keyPath), 'backups');
            // Criar diretório de backup se não existir
            if (!fs.existsSync(backupDir)) {
                fs.mkdirSync(backupDir, { recursive: true, mode: 0o700 }); // Permissões restritas
            }
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backupPath = path.join(backupDir, `encryption.key.${timestamp}`);
            // Copiar arquivo
            fs.copyFileSync(this.keyPath, backupPath);
            // Definir permissões restritas
            if (process.platform !== 'win32') {
                fs.chmodSync(backupPath, 0o600);
            }
            this.logger.log(`Backup da chave criado com sucesso: ${backupPath}`);
            return true;
        }
        catch (error) {
            this.logger.error(`Erro ao criar backup: ${error.message}`);
            return false;
        }
    }
};
exports.ChaveMonitorService = ChaveMonitorService;
exports.ChaveMonitorService = ChaveMonitorService = ChaveMonitorService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], ChaveMonitorService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXHNoYXJlZFxcc2VydmljZXNcXGNoYXZlLW1vbml0b3Iuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUFvRDtBQUNwRCwyQ0FBK0M7QUFDL0MsdUNBQXlCO0FBQ3pCLDJDQUE2QjtBQUM3QiwrQ0FBaUM7QUFFakM7Ozs7O0dBS0c7QUFFSSxJQUFNLG1CQUFtQiwyQkFBekIsTUFBTSxtQkFBbUI7SUFPVjtJQU5ILE1BQU0sR0FBRyxJQUFJLGVBQU0sQ0FBQyxxQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QyxPQUFPLENBQVM7SUFDekIsV0FBVyxDQUFTO0lBQ3BCLFlBQVksQ0FBTztJQUNuQixlQUFlLENBQVM7SUFFaEMsWUFBb0IsYUFBNEI7UUFBNUIsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDOUMsSUFBSSxDQUFDLE9BQU87WUFDVixJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBUyxxQkFBcUIsQ0FBQztnQkFDckQsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsUUFBUSxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFFdkQsaURBQWlEO1FBQ2pELElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNoQyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztRQUNsQyxDQUFDO2FBQU0sQ0FBQztZQUNOLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLG9EQUFvRCxDQUFDLENBQUM7UUFDekUsQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNLLHdCQUF3QjtRQUM5QixJQUFJLENBQUM7WUFDSCxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElB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QUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMseUJBQXlCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQzVELE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztJQUNILENBQUM7Q0FDRixDQUFBO0FBaEtZLGtEQUFtQjs4QkFBbkIsbUJBQW1CO0lBRC9CLElBQUEsbUJBQVUsR0FBRTt5REFRd0Isc0JBQWEsb0JBQWIsc0JBQWE7R0FQckMsbUJBQW1CLENBZ0svQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGV1ZHJlXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamV0b3NcXHBnYmVuXFxwZ2Jlbi1zZXJ2ZXJcXHNyY1xcc2hhcmVkXFxzZXJ2aWNlc1xcY2hhdmUtbW9uaXRvci5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIExvZ2dlciB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IENvbmZpZ1NlcnZpY2UgfSBmcm9tICdAbmVzdGpzL2NvbmZpZyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8qKlxuICogU2VydmnDp28gZGUgTW9uaXRvcmFtZW50byBkZSBDaGF2ZXNcbiAqIFxuICogUmVzcG9uc8OhdmVsIHBvciBtb25pdG9yYXIgYSBpbnRlZ3JpZGFkZSBkYXMgY2hhdmVzIGRlIGNyaXB0b2dyYWZpYSxcbiAqIHZlcmlmaWNhciBwZXJtaXNzw7VlcyBkZSBhcnF1aXZvIGUgcmVnaXN0cmFyIGFsdGVyYcOnw7VlcyBuw6NvIGF1dG9yaXphZGFzLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ2hhdmVNb25pdG9yU2VydmljZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyID0gbmV3IExvZ2dlcihDaGF2ZU1vbml0b3JTZXJ2aWNlLm5hbWUpO1xuICBwcml2YXRlIHJlYWRvbmx5IGtleVBhdGg6IHN0cmluZztcbiAgcHJpdmF0ZSBrZXlDaGVja3N1bTogc3RyaW5nO1xuICBwcml2YXRlIGxhc3RNb2RpZmllZDogRGF0ZTtcbiAgcHJpdmF0ZSBsYXN0UGVybWlzc2lvbnM6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbmZpZ1NlcnZpY2U6IENvbmZpZ1NlcnZpY2UpIHtcbiAgICB0aGlzLmtleVBhdGggPSBcbiAgICAgIHRoaXMuY29uZmlnU2VydmljZS5nZXQ8c3RyaW5nPignRU5DUllQVElPTl9LRVlfUEFUSCcpIHx8XG4gICAgICBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2NvbmZpZycsICdlbmNyeXB0aW9uLmtleScpO1xuICAgIFxuICAgIC8vIEluaWNpYWxpemFyIG8gbW9uaXRvcmFtZW50byBzZSBhIGNoYXZlIGV4aXN0aXJcbiAgICBpZiAoZnMuZXhpc3RzU3luYyh0aGlzLmtleVBhdGgpKSB7XG4gICAgICB0aGlzLmluaWNpYWxpemFyTW9uaXRvcmFtZW50bygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdBcnF1aXZvIGRlIGNoYXZlIG7Do28gZW5jb250cmFkbyBwYXJhIG1vbml0b3JhbWVudG8nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pY2lhbGl6YSBvIG1vbml0b3JhbWVudG8gZGEgY2hhdmVcbiAgICovXG4gIHByaXZhdGUgaW5pY2lhbGl6YXJNb25pdG9yYW1lbnRvKCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKHRoaXMua2V5UGF0aCk7XG4gICAgICB0aGlzLmxhc3RNb2RpZmllZCA9IHN0YXRzLm10aW1lO1xuICAgICAgdGhpcy5sYXN0UGVybWlzc2lvbnMgPSBzdGF0cy5tb2RlO1xuICAgICAgdGhpcy5rZXlDaGVja3N1bSA9IHRoaXMuY2FsY3VsYXJDaGVja3N1bSgpO1xuICAgICAgXG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ01vbml0b3JhbWVudG8gZGUgY2hhdmUgaW5pY2lhbGl6YWRvIGNvbSBzdWNlc3NvJyk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmaWNhciBwZXJtaXNzw7Vlc1xuICAgICAgdGhpcy52ZXJpZmljYXJQZXJtaXNzb2VzKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIGluaWNpYWxpemFyIG1vbml0b3JhbWVudG86ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYSBvIGNoZWNrc3VtIGRvIGFycXVpdm8gZGUgY2hhdmVcbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXJDaGVja3N1bSgpOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmaWxlQnVmZmVyID0gZnMucmVhZEZpbGVTeW5jKHRoaXMua2V5UGF0aCk7XG4gICAgICBjb25zdCBoYXNoU3VtID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpO1xuICAgICAgaGFzaFN1bS51cGRhdGUoZmlsZUJ1ZmZlcik7XG4gICAgICByZXR1cm4gaGFzaFN1bS5kaWdlc3QoJ2hleCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRXJybyBhbyBjYWxjdWxhciBjaGVja3N1bTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBhcyBwZXJtaXNzw7VlcyBkbyBhcnF1aXZvIGVzdMOjbyBjb3JyZXRhc1xuICAgKi9cbiAgcHJpdmF0ZSB2ZXJpZmljYXJQZXJtaXNzb2VzKCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKHRoaXMua2V5UGF0aCk7XG4gICAgICBjb25zdCBwZXJtaXNzb2VzID0gc3RhdHMubW9kZSAmIDBvNzc3OyAvLyBFeHRyYWlyIGFwZW5hcyBhcyBwZXJtaXNzw7Vlc1xuICAgICAgXG4gICAgICAvLyBFbSBzaXN0ZW1hcyBVbml4LCB2ZXJpZmljYXIgc2UgYXMgcGVybWlzc8O1ZXMgc8OjbyA2MDAgKGxlaXR1cmEvZXNjcml0YSBhcGVuYXMgcGFyYSBvIHByb3ByaWV0w6FyaW8pXG4gICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ3dpbjMyJyAmJiBwZXJtaXNzb2VzICE9PSAwbzYwMCkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgIGBQZXJtaXNzw7VlcyBpbnNlZ3VyYXMgZGV0ZWN0YWRhcyBubyBhcnF1aXZvIGRlIGNoYXZlOiAke3Blcm1pc3NvZXMudG9TdHJpbmcoOCl9LiBgICtcbiAgICAgICAgICAnUmVjb21lbmRhZG86IDYwMCAobGVpdHVyYS9lc2NyaXRhIGFwZW5hcyBwYXJhIG8gcHJvcHJpZXTDoXJpbyknXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBUZW50YXIgY29ycmlnaXIgYXMgcGVybWlzc8O1ZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmcy5jaG1vZFN5bmModGhpcy5rZXlQYXRoLCAwbzYwMCk7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdQZXJtaXNzw7VlcyBkbyBhcnF1aXZvIGRlIGNoYXZlIGNvcnJpZ2lkYXMgcGFyYSA2MDAnKTtcbiAgICAgICAgfSBjYXRjaCAoY2htb2RFcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBOw6NvIGZvaSBwb3Nzw612ZWwgY29ycmlnaXIgYXMgcGVybWlzc8O1ZXM6ICR7Y2htb2RFcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIGFvIHZlcmlmaWNhciBwZXJtaXNzw7VlczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBhIGludGVncmlkYWRlIGRhIGNoYXZlXG4gICAqIEByZXR1cm5zIHRydWUgc2UgYSBjaGF2ZSBlc3TDoSDDrW50ZWdyYSwgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBwdWJsaWMgdmVyaWZpY2FySW50ZWdyaWRhZGUoKTogYm9vbGVhbiB7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHRoaXMua2V5UGF0aCkpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdBcnF1aXZvIGRlIGNoYXZlIG7Do28gZW5jb250cmFkbyBkdXJhbnRlIHZlcmlmaWNhw6fDo28gZGUgaW50ZWdyaWRhZGUnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gVmVyaWZpY2FyIHNlIG8gYXJxdWl2byBmb2kgbW9kaWZpY2Fkb1xuICAgICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyh0aGlzLmtleVBhdGgpO1xuICAgICAgaWYgKHN0YXRzLm10aW1lLmdldFRpbWUoKSAhPT0gdGhpcy5sYXN0TW9kaWZpZWQuZ2V0VGltZSgpKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0RldGVjdGFkYSBtb2RpZmljYcOnw6NvIG5vIGFycXVpdm8gZGUgY2hhdmUhJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZmljYXIgc2UgbyBjb250ZcO6ZG8gcmVhbG1lbnRlIG11ZG91IChjaGVja3N1bSlcbiAgICAgICAgY29uc3Qgbm92b0NoZWNrc3VtID0gdGhpcy5jYWxjdWxhckNoZWNrc3VtKCk7XG4gICAgICAgIGlmIChub3ZvQ2hlY2tzdW0gIT09IHRoaXMua2V5Q2hlY2tzdW0pIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignQUxFUlRBIERFIFNFR1VSQU7Dh0E6IENvbnRlw7pkbyBkbyBhcnF1aXZvIGRlIGNoYXZlIGZvaSBhbHRlcmFkbyEnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEF0dWFsaXphciB0aW1lc3RhbXAgc2UgYXBlbmFzIG8gdGltZXN0YW1wIG11ZG91IG1hcyBvIGNvbnRlw7pkbyBuw6NvXG4gICAgICAgIHRoaXMubGFzdE1vZGlmaWVkID0gc3RhdHMubXRpbWU7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnVGltZXN0YW1wIGRvIGFycXVpdm8gYXR1YWxpemFkbywgbWFzIGNvbnRlw7pkbyBwZXJtYW5lY2Ugw61udGVncm8nKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZpY2FyIHBlcm1pc3PDtWVzXG4gICAgICBpZiAoc3RhdHMubW9kZSAhPT0gdGhpcy5sYXN0UGVybWlzc2lvbnMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybignUGVybWlzc8O1ZXMgZG8gYXJxdWl2byBkZSBjaGF2ZSBmb3JhbSBhbHRlcmFkYXMhJyk7XG4gICAgICAgIHRoaXMudmVyaWZpY2FyUGVybWlzc29lcygpO1xuICAgICAgICB0aGlzLmxhc3RQZXJtaXNzaW9ucyA9IHN0YXRzLm1vZGU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRXJybyBhbyB2ZXJpZmljYXIgaW50ZWdyaWRhZGU6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JpYSB1bSBiYWNrdXAgZGEgY2hhdmVcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIGJhY2t1cCBmb2kgY3JpYWRvIGNvbSBzdWNlc3NvLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIHB1YmxpYyBjcmlhckJhY2t1cCgpOiBib29sZWFuIHtcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmModGhpcy5rZXlQYXRoKSkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0FycXVpdm8gZGUgY2hhdmUgbsOjbyBlbmNvbnRyYWRvIHBhcmEgYmFja3VwJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJhY2t1cERpciA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUodGhpcy5rZXlQYXRoKSwgJ2JhY2t1cHMnKTtcbiAgICAgIFxuICAgICAgLy8gQ3JpYXIgZGlyZXTDs3JpbyBkZSBiYWNrdXAgc2UgbsOjbyBleGlzdGlyXG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoYmFja3VwRGlyKSkge1xuICAgICAgICBmcy5ta2RpclN5bmMoYmFja3VwRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgbW9kZTogMG83MDAgfSk7IC8vIFBlcm1pc3PDtWVzIHJlc3RyaXRhc1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvWzouXS9nLCAnLScpO1xuICAgICAgY29uc3QgYmFja3VwUGF0aCA9IHBhdGguam9pbihiYWNrdXBEaXIsIGBlbmNyeXB0aW9uLmtleS4ke3RpbWVzdGFtcH1gKTtcbiAgICAgIFxuICAgICAgLy8gQ29waWFyIGFycXVpdm9cbiAgICAgIGZzLmNvcHlGaWxlU3luYyh0aGlzLmtleVBhdGgsIGJhY2t1cFBhdGgpO1xuICAgICAgXG4gICAgICAvLyBEZWZpbmlyIHBlcm1pc3PDtWVzIHJlc3RyaXRhc1xuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICAgICAgZnMuY2htb2RTeW5jKGJhY2t1cFBhdGgsIDBvNjAwKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5sb2dnZXIubG9nKGBCYWNrdXAgZGEgY2hhdmUgY3JpYWRvIGNvbSBzdWNlc3NvOiAke2JhY2t1cFBhdGh9YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gY3JpYXIgYmFja3VwOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG4iXSwidmVyc2lvbiI6M30=