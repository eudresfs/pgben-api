c9938a55b06302c2e5f5f7755bb23241
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatchValidator = void 0;
exports.Match = Match;
const class_validator_1 = require("class-validator");
/**
 * Validador para verificar se dois campos possuem o mesmo valor
 *
 * Útil para confirmação de senhas, emails, etc.
 */
let MatchValidator = class MatchValidator {
    validate(value, args) {
        const [relatedPropertyName] = args.constraints;
        const relatedValue = args.object[relatedPropertyName];
        return value === relatedValue;
    }
    defaultMessage(args) {
        const [relatedPropertyName] = args.constraints;
        return `${args.property} deve ser igual a ${relatedPropertyName}`;
    }
};
exports.MatchValidator = MatchValidator;
exports.MatchValidator = MatchValidator = __decorate([
    (0, class_validator_1.ValidatorConstraint)({ name: 'match', async: false })
], MatchValidator);
/**
 * Decorator para validar se dois campos possuem o mesmo valor
 *
 * @param property - Nome da propriedade que deve ter o mesmo valor
 * @param validationOptions - Opções de validação
 *
 * @example
 * ```typescript
 * export class AlterarSenhaDto {
 *   @IsString()
 *   novaSenha: string;
 *
 *   @IsString()
 *   @Match('novaSenha', { message: 'As senhas não coincidem' })
 *   confirmarSenha: string;
 * }
 * ```
 */
function Match(property, validationOptions) {
    return function (object, propertyName) {
        (0, class_validator_1.registerDecorator)({
            target: object.constructor,
            propertyName: propertyName,
            options: validationOptions,
            constraints: [property],
            validator: MatchValidator,
        });
    };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXHNoYXJlZFxcdmFsaWRhdG9yc1xcbWF0Y2gudmFsaWRhdG9yLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQTZDQSxzQkFVQztBQXZERCxxREFNeUI7QUFFekI7Ozs7R0FJRztBQUVJLElBQU0sY0FBYyxHQUFwQixNQUFNLGNBQWM7SUFDekIsUUFBUSxDQUFDLEtBQVUsRUFBRSxJQUF5QjtRQUM1QyxNQUFNLENBQUMsbUJBQW1CLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQy9DLE1BQU0sWUFBWSxHQUFJLElBQUksQ0FBQyxNQUFjLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUMvRCxPQUFPLEtBQUssS0FBSyxZQUFZLENBQUM7SUFDaEMsQ0FBQztJQUVELGNBQWMsQ0FBQyxJQUF5QjtRQUN0QyxNQUFNLENBQUMsbUJBQW1CLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQy9DLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxxQkFBcUIsbUJBQW1CLEVBQUUsQ0FBQztJQUNwRSxDQUFDO0NBQ0YsQ0FBQTtBQVhZLHdDQUFjO3lCQUFkLGNBQWM7SUFEMUIsSUFBQSxxQ0FBbUIsRUFBQyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDO0dBQ3hDLGNBQWMsQ0FXMUI7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFDSCxTQUFnQixLQUFLLENBQUMsUUFBZ0IsRUFBRSxpQkFBcUM7SUFDM0UsT0FBTyxVQUFVLE1BQWMsRUFBRSxZQUFvQjtRQUNuRCxJQUFBLG1DQUFpQixFQUFDO1lBQ2hCLE1BQU0sRUFBRSxNQUFNLENBQUMsV0FBVztZQUMxQixZQUFZLEVBQUUsWUFBWTtZQUMxQixPQUFPLEVBQUUsaUJBQWlCO1lBQzFCLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQztZQUN2QixTQUFTLEVBQUUsY0FBYztTQUMxQixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7QUFDSixDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZXVkcmVcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxzaGFyZWRcXHZhbGlkYXRvcnNcXG1hdGNoLnZhbGlkYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBWYWxpZGF0b3JDb25zdHJhaW50LFxuICBWYWxpZGF0b3JDb25zdHJhaW50SW50ZXJmYWNlLFxuICBWYWxpZGF0aW9uQXJndW1lbnRzLFxuICBWYWxpZGF0aW9uT3B0aW9ucyxcbiAgcmVnaXN0ZXJEZWNvcmF0b3IsXG59IGZyb20gJ2NsYXNzLXZhbGlkYXRvcic7XG5cbi8qKlxuICogVmFsaWRhZG9yIHBhcmEgdmVyaWZpY2FyIHNlIGRvaXMgY2FtcG9zIHBvc3N1ZW0gbyBtZXNtbyB2YWxvclxuICpcbiAqIMOadGlsIHBhcmEgY29uZmlybWHDp8OjbyBkZSBzZW5oYXMsIGVtYWlscywgZXRjLlxuICovXG5AVmFsaWRhdG9yQ29uc3RyYWludCh7IG5hbWU6ICdtYXRjaCcsIGFzeW5jOiBmYWxzZSB9KVxuZXhwb3J0IGNsYXNzIE1hdGNoVmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yQ29uc3RyYWludEludGVyZmFjZSB7XG4gIHZhbGlkYXRlKHZhbHVlOiBhbnksIGFyZ3M6IFZhbGlkYXRpb25Bcmd1bWVudHMpIHtcbiAgICBjb25zdCBbcmVsYXRlZFByb3BlcnR5TmFtZV0gPSBhcmdzLmNvbnN0cmFpbnRzO1xuICAgIGNvbnN0IHJlbGF0ZWRWYWx1ZSA9IChhcmdzLm9iamVjdCBhcyBhbnkpW3JlbGF0ZWRQcm9wZXJ0eU5hbWVdO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gcmVsYXRlZFZhbHVlO1xuICB9XG5cbiAgZGVmYXVsdE1lc3NhZ2UoYXJnczogVmFsaWRhdGlvbkFyZ3VtZW50cykge1xuICAgIGNvbnN0IFtyZWxhdGVkUHJvcGVydHlOYW1lXSA9IGFyZ3MuY29uc3RyYWludHM7XG4gICAgcmV0dXJuIGAke2FyZ3MucHJvcGVydHl9IGRldmUgc2VyIGlndWFsIGEgJHtyZWxhdGVkUHJvcGVydHlOYW1lfWA7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNvcmF0b3IgcGFyYSB2YWxpZGFyIHNlIGRvaXMgY2FtcG9zIHBvc3N1ZW0gbyBtZXNtbyB2YWxvclxuICpcbiAqIEBwYXJhbSBwcm9wZXJ0eSAtIE5vbWUgZGEgcHJvcHJpZWRhZGUgcXVlIGRldmUgdGVyIG8gbWVzbW8gdmFsb3JcbiAqIEBwYXJhbSB2YWxpZGF0aW9uT3B0aW9ucyAtIE9ww6fDtWVzIGRlIHZhbGlkYcOnw6NvXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGV4cG9ydCBjbGFzcyBBbHRlcmFyU2VuaGFEdG8ge1xuICogICBASXNTdHJpbmcoKVxuICogICBub3ZhU2VuaGE6IHN0cmluZztcbiAqXG4gKiAgIEBJc1N0cmluZygpXG4gKiAgIEBNYXRjaCgnbm92YVNlbmhhJywgeyBtZXNzYWdlOiAnQXMgc2VuaGFzIG7Do28gY29pbmNpZGVtJyB9KVxuICogICBjb25maXJtYXJTZW5oYTogc3RyaW5nO1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNYXRjaChwcm9wZXJ0eTogc3RyaW5nLCB2YWxpZGF0aW9uT3B0aW9ucz86IFZhbGlkYXRpb25PcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqZWN0OiBPYmplY3QsIHByb3BlcnR5TmFtZTogc3RyaW5nKSB7XG4gICAgcmVnaXN0ZXJEZWNvcmF0b3Ioe1xuICAgICAgdGFyZ2V0OiBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgIG9wdGlvbnM6IHZhbGlkYXRpb25PcHRpb25zLFxuICAgICAgY29uc3RyYWludHM6IFtwcm9wZXJ0eV0sXG4gICAgICB2YWxpZGF0b3I6IE1hdGNoVmFsaWRhdG9yLFxuICAgIH0pO1xuICB9O1xufVxuIl0sInZlcnNpb24iOjN9