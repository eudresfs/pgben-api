{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\pagamento\\services\\integracao-documento.service.ts","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,2CAAiE;AACjE,2CAA6B;AAC7B,+CAAiC;AAEjC;;;;;;;GAOG;AAEI,IAAM,0BAA0B,GAAhC,MAAM,0BAA0B;IACrC,8FAA8F;IAC9F,sEAAsE;IAEtE;;;;;;;;;;OAUG;IACH,KAAK,CAAC,oBAAoB,CACxB,MAAc,EACd,WAAmB,EACnB,QAAgB,EAChB,WAAmB,EACnB,aAAqB,EACrB,SAAiB;QAOjB,oBAAoB;QACpB,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;QAEtC,qCAAqC;QACrC,MAAM,SAAS,GAAG,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;QAEvE,2DAA2D;QAC3D,MAAM,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAEtE,6DAA6D;QAC7D,qEAAqE;QACrE,sBAAsB;QACtB,4BAA4B;QAC5B,cAAc;QACd,wCAAwC;QACxC,6BAA6B;QAC7B,+BAA+B;QAC/B,iBAAiB;QACjB,qBAAqB;QACrB,YAAY;QACZ,6BAA6B;QAC7B,MAAM;QACN,MAAM;QAEN,6CAA6C;QAC7C,OAAO,CAAC,GAAG,CAAC,yDAAyD,WAAW,EAAE,CAAC,CAAC;QAEpF,mCAAmC;QACnC,MAAM,cAAc,GAAG,cAAc,WAAW,iBAAiB,SAAS,EAAE,CAAC;QAE7E,OAAO;YACL,EAAE,EAAE,MAAM,CAAC,UAAU,EAAE;YACvB,cAAc;YACd,OAAO,EAAE,MAAM,CAAC,MAAM;YACtB,IAAI;SACL,CAAC;IACJ,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,oBAAoB,CACxB,cAAsB,EACtB,SAAiB;QAOjB,6DAA6D;QAC7D,+FAA+F;QAE/F,gCAAgC;QAChC,gDAAgD;QAChD,oBAAoB;QACpB,eAAe;QACf,4BAA4B;QAC5B,0BAA0B;QAC1B,MAAM;QAEN,WAAW;QACX,gCAAgC;QAChC,yCAAyC;QACzC,kCAAkC;QAClC,+BAA+B;QAC/B,KAAK;QAEL,6CAA6C;QAC7C,OAAO,CAAC,GAAG,CAAC,yCAAyC,cAAc,EAAE,CAAC,CAAC;QAEvE,qCAAqC;QACrC,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;QAElD,uCAAuC;QACvC,MAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,6CAA6C,CAAC,CAAC;QAE1E,6CAA6C;QAC7C,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,WAAW,EAAE,CAAC;QACzD,IAAI,QAAQ,GAAG,0BAA0B,CAAC;QAE1C,IAAI,QAAQ,KAAK,MAAM,EAAE,CAAC;YAAA,QAAQ,GAAG,iBAAiB,CAAC;QAAA,CAAC;aACnD,IAAI,QAAQ,KAAK,MAAM,IAAI,QAAQ,KAAK,OAAO,EAAE,CAAC;YAAA,QAAQ,GAAG,YAAY,CAAC;QAAA,CAAC;aAC3E,IAAI,QAAQ,KAAK,MAAM,EAAE,CAAC;YAAA,QAAQ,GAAG,WAAW,CAAC;QAAA,CAAC;QAEvD,OAAO;YACL,MAAM;YACN,WAAW;YACX,QAAQ;YACR,OAAO,EAAE,MAAM,CAAC,MAAM;SACvB,CAAC;IACJ,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,kBAAkB,CACtB,cAAsB,EACtB,SAAiB;QAEjB,6DAA6D;QAC7D,2EAA2E;QAE3E,iCAAiC;QACjC,kDAAkD;QAClD,oBAAoB;QACpB,eAAe;QACf,6BAA6B;QAC7B,0BAA0B;QAC1B,MAAM;QAEN,eAAe;QAEf,6CAA6C;QAC7C,OAAO,CAAC,GAAG,CAAC,uCAAuC,cAAc,EAAE,CAAC,CAAC;QAErE,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;OAMG;IACK,cAAc,CAAC,MAAc,EAAE,QAAgB;QACrD,iCAAiC;QACjC,MAAM,aAAa,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC;QACtC,IAAI,MAAM,CAAC,MAAM,GAAG,aAAa,EAAE,CAAC;YAClC,MAAM,IAAI,4BAAmB,CAC3B,gDAAgD,aAAa,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAClF,CAAC;QACJ,CAAC;QAED,kCAAkC;QAClC,MAAM,eAAe,GAAG;YACtB,iBAAiB;YACjB,YAAY;YACZ,WAAW;YACX,WAAW;SACZ,CAAC;QAEF,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;YACxC,MAAM,IAAI,4BAAmB,CAC3B,oDAAoD,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CACjF,CAAC;QACJ,CAAC;QAED,4DAA4D;QAC5D,sEAAsE;QACtE,IAAI,QAAQ,KAAK,iBAAiB,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC,EAAE,CAAC;YACzD,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACrD,IAAI,SAAS,KAAK,UAAU,EAAE,CAAC,CAAC,cAAc;gBAC5C,MAAM,IAAI,4BAAmB,CAAC,sBAAsB,CAAC,CAAC;YACxD,CAAC;QACH,CAAC;QAED,IAAI,QAAQ,KAAK,YAAY,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC,EAAE,CAAC;YACpD,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACrD,IAAI,SAAS,KAAK,QAAQ,EAAE,CAAC,CAAC,kBAAkB;gBAC9C,MAAM,IAAI,4BAAmB,CAAC,uBAAuB,CAAC,CAAC;YACzD,CAAC;QACH,CAAC;QAED,IAAI,QAAQ,KAAK,WAAW,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC,EAAE,CAAC;YACnD,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACrD,IAAI,SAAS,KAAK,kBAAkB,EAAE,CAAC,CAAC,gBAAgB;gBACtD,MAAM,IAAI,4BAAmB,CAAC,sBAAsB,CAAC,CAAC;YACxD,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;;;;OAMG;IACK,qBAAqB,CAAC,YAAoB,EAAE,WAAmB;QACrE,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC7B,MAAM,YAAY,GAAG,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC3D,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QAE5C,OAAO,GAAG,SAAS,IAAI,YAAY,GAAG,QAAQ,EAAE,CAAC;IACnD,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,sBAAsB,CAAC,cAAsB;QACjD,6DAA6D;QAC7D,oEAAoE;QAEpE,6CAA6C;QAC7C,OAAO,CAAC,GAAG,CAAC,mDAAmD,cAAc,EAAE,CAAC,CAAC;QAEjF,+BAA+B;QAC/B,OAAO,IAAI,CAAC;IACd,CAAC;CACF,CAAA;AAhPY,gEAA0B;qCAA1B,0BAA0B;IADtC,IAAA,mBAAU,GAAE;GACA,0BAA0B,CAgPtC","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\pagamento\\services\\integracao-documento.service.ts"],"sourcesContent":["import { Injectable, BadRequestException } from '@nestjs/common';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\n\n/**\n * Serviço de integração com o módulo de Documento\n * \n * Implementa a comunicação entre o módulo de Pagamento e o módulo de Documento,\n * permitindo o armazenamento e recuperação de comprovantes de pagamento.\n * \n * @author Equipe PGBen\n */\n@Injectable()\nexport class IntegracaoDocumentoService {\n  // Em uma implementação real, este serviço injetaria o DocumentoService do módulo de documento\n  // constructor(private readonly documentoService: DocumentoService) {}\n\n  /**\n   * Armazena um comprovante de pagamento\n   * \n   * @param buffer Buffer com o conteúdo do arquivo\n   * @param nomeArquivo Nome original do arquivo\n   * @param mimeType Tipo MIME do arquivo\n   * @param pagamentoId ID do pagamento relacionado\n   * @param tipoDocumento Tipo do documento (comprovante, recibo, etc.)\n   * @param usuarioId ID do usuário que está realizando o upload\n   * @returns Informações do documento armazenado\n   */\n  async armazenarComprovante(\n    buffer: Buffer,\n    nomeArquivo: string,\n    mimeType: string,\n    pagamentoId: string,\n    tipoDocumento: string,\n    usuarioId: string\n  ): Promise<{\n    id: string;\n    caminhoArquivo: string;\n    tamanho: number;\n    hash: string;\n  }> {\n    // Validar o arquivo\n    this.validarArquivo(buffer, mimeType);\n\n    // Gerar um nome único para o arquivo\n    const nomeUnico = this.gerarNomeUnicoArquivo(nomeArquivo, pagamentoId);\n    \n    // Calcular hash do arquivo para verificação de integridade\n    const hash = crypto.createHash('sha256').update(buffer).digest('hex');\n\n    // Em uma implementação real, chamaria o serviço de documento\n    // const resultado = await this.documentoService.armazenarDocumento({\n    //   conteudo: buffer,\n    //   nomeArquivo: nomeUnico,\n    //   mimeType,\n    //   categoria: 'COMPROVANTE_PAGAMENTO',\n    //   entidadeId: pagamentoId,\n    //   tipoEntidade: 'PAGAMENTO',\n    //   metadados: {\n    //     tipoDocumento,\n    //     hash,\n    //     uploadedPor: usuarioId\n    //   }\n    // });\n    \n    // Implementação de mock para desenvolvimento\n    console.log(`[INTEGRAÇÃO] Armazenando comprovante para o pagamento ${pagamentoId}`);\n    \n    // Simular caminho de armazenamento\n    const caminhoArquivo = `pagamentos/${pagamentoId}/comprovantes/${nomeUnico}`;\n    \n    return {\n      id: crypto.randomUUID(),\n      caminhoArquivo,\n      tamanho: buffer.length,\n      hash\n    };\n  }\n\n  /**\n   * Recupera o conteúdo de um comprovante de pagamento\n   * \n   * @param caminhoArquivo Caminho do arquivo no sistema de armazenamento\n   * @param usuarioId ID do usuário que está solicitando o arquivo\n   * @returns Buffer com o conteúdo do arquivo e metadados\n   */\n  async recuperarComprovante(\n    caminhoArquivo: string,\n    usuarioId: string\n  ): Promise<{\n    buffer: Buffer;\n    nomeArquivo: string;\n    mimeType: string;\n    tamanho: number;\n  }> {\n    // Em uma implementação real, chamaria o serviço de documento\n    // const documento = await this.documentoService.recuperarDocumento(caminhoArquivo, usuarioId);\n    \n    // Registrar acesso ao documento\n    // await this.documentoService.registrarAcesso({\n    //   caminhoArquivo,\n    //   usuarioId,\n    //   tipoAcesso: 'DOWNLOAD',\n    //   timestamp: new Date()\n    // });\n    \n    // return {\n    //   buffer: documento.conteudo,\n    //   nomeArquivo: documento.nomeOriginal,\n    //   mimeType: documento.mimeType,\n    //   tamanho: documento.tamanho\n    // };\n\n    // Implementação de mock para desenvolvimento\n    console.log(`[INTEGRAÇÃO] Recuperando comprovante: ${caminhoArquivo}`);\n    \n    // Extrair nome do arquivo do caminho\n    const nomeArquivo = path.basename(caminhoArquivo);\n    \n    // Criar um buffer vazio para simulação\n    const buffer = Buffer.from('Conteúdo simulado do arquivo de comprovante');\n    \n    // Determinar o MIME type baseado na extensão\n    const extensao = path.extname(nomeArquivo).toLowerCase();\n    let mimeType = 'application/octet-stream';\n    \n    if (extensao === '.pdf') {mimeType = 'application/pdf';}\n    else if (extensao === '.jpg' || extensao === '.jpeg') {mimeType = 'image/jpeg';}\n    else if (extensao === '.png') {mimeType = 'image/png';}\n    \n    return {\n      buffer,\n      nomeArquivo,\n      mimeType,\n      tamanho: buffer.length\n    };\n  }\n\n  /**\n   * Remove um comprovante de pagamento\n   * \n   * @param caminhoArquivo Caminho do arquivo no sistema de armazenamento\n   * @param usuarioId ID do usuário que está solicitando a remoção\n   * @returns true se removido com sucesso\n   */\n  async removerComprovante(\n    caminhoArquivo: string,\n    usuarioId: string\n  ): Promise<boolean> {\n    // Em uma implementação real, chamaria o serviço de documento\n    // await this.documentoService.removerDocumento(caminhoArquivo, usuarioId);\n    \n    // Registrar remoção do documento\n    // await this.documentoService.registrarOperacao({\n    //   caminhoArquivo,\n    //   usuarioId,\n    //   tipoOperacao: 'REMOCAO',\n    //   timestamp: new Date()\n    // });\n    \n    // return true;\n\n    // Implementação de mock para desenvolvimento\n    console.log(`[INTEGRAÇÃO] Removendo comprovante: ${caminhoArquivo}`);\n    \n    return true;\n  }\n\n  /**\n   * Valida um arquivo antes do armazenamento\n   * \n   * @param buffer Conteúdo do arquivo\n   * @param mimeType Tipo MIME declarado\n   * @throws BadRequestException se o arquivo for inválido\n   */\n  private validarArquivo(buffer: Buffer, mimeType: string): void {\n    // Verificar tamanho máximo (5MB)\n    const tamanhoMaximo = 5 * 1024 * 1024;\n    if (buffer.length > tamanhoMaximo) {\n      throw new BadRequestException(\n        `Tamanho do arquivo excede o limite máximo de ${tamanhoMaximo / (1024 * 1024)}MB`\n      );\n    }\n\n    // Verificar tipos MIME permitidos\n    const tiposPermitidos = [\n      'application/pdf',\n      'image/jpeg',\n      'image/jpg',\n      'image/png'\n    ];\n    \n    if (!tiposPermitidos.includes(mimeType)) {\n      throw new BadRequestException(\n        `Tipo de arquivo não permitido. Tipos permitidos: ${tiposPermitidos.join(', ')}`\n      );\n    }\n\n    // Verificação básica de assinatura de arquivo (magic bytes)\n    // Esta é uma verificação simplificada, em produção seria mais robusta\n    if (mimeType === 'application/pdf' && buffer.length >= 4) {\n      const signature = buffer.slice(0, 4).toString('hex');\n      if (signature !== '25504446') { // %PDF em hex\n        throw new BadRequestException('Arquivo PDF inválido');\n      }\n    }\n    \n    if (mimeType === 'image/jpeg' && buffer.length >= 3) {\n      const signature = buffer.slice(0, 3).toString('hex');\n      if (signature !== 'ffd8ff') { // JPEG SOI marker\n        throw new BadRequestException('Arquivo JPEG inválido');\n      }\n    }\n    \n    if (mimeType === 'image/png' && buffer.length >= 8) {\n      const signature = buffer.slice(0, 8).toString('hex');\n      if (signature !== '89504e470d0a1a0a') { // PNG signature\n        throw new BadRequestException('Arquivo PNG inválido');\n      }\n    }\n  }\n\n  /**\n   * Gera um nome único para o arquivo\n   * \n   * @param nomeOriginal Nome original do arquivo\n   * @param pagamentoId ID do pagamento relacionado\n   * @returns Nome único para armazenamento\n   */\n  private gerarNomeUnicoArquivo(nomeOriginal: string, pagamentoId: string): string {\n    const timestamp = Date.now();\n    const randomString = crypto.randomBytes(8).toString('hex');\n    const extensao = path.extname(nomeOriginal);\n    \n    return `${timestamp}-${randomString}${extensao}`;\n  }\n\n  /**\n   * Verifica se um arquivo existe no sistema de armazenamento\n   * \n   * @param caminhoArquivo Caminho do arquivo\n   * @returns true se o arquivo existir\n   */\n  async verificarArquivoExiste(caminhoArquivo: string): Promise<boolean> {\n    // Em uma implementação real, chamaria o serviço de documento\n    // return this.documentoService.verificarExistencia(caminhoArquivo);\n\n    // Implementação de mock para desenvolvimento\n    console.log(`[INTEGRAÇÃO] Verificando existência do arquivo: ${caminhoArquivo}`);\n    \n    // Simular que o arquivo existe\n    return true;\n  }\n}\n"],"version":3}