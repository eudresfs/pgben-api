21137a9f41a67b26dfdd29baf37aad26
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntegradorService = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const integrador_entity_1 = require("../../../entities/integrador.entity");
const integrador_response_dto_1 = require("../dto/integrador-response.dto");
/**
 * Serviço responsável pelo gerenciamento de integradores.
 * Implementa operações CRUD e regras de negócio específicas para integradores.
 */
let IntegradorService = class IntegradorService {
    integradorRepository;
    constructor(integradorRepository) {
        this.integradorRepository = integradorRepository;
    }
    /**
     * Cria um novo integrador na plataforma.
     * @param createIntegradorDto Dados do integrador a ser criado
     * @returns Dados do integrador criado
     */
    async create(createIntegradorDto) {
        // Verifica se já existe um integrador com o mesmo nome
        const existingIntegrador = await this.integradorRepository.findOne({
            where: { nome: createIntegradorDto.nome },
        });
        if (existingIntegrador) {
            throw new common_1.ConflictException(`Já existe um integrador com o nome '${createIntegradorDto.nome}'`);
        }
        const integrador = this.integradorRepository.create(createIntegradorDto);
        const savedIntegrador = await this.integradorRepository.save(integrador);
        return new integrador_response_dto_1.IntegradorResponseDto(savedIntegrador);
    }
    /**
     * Retorna todos os integradores cadastrados.
     * @returns Lista de integradores
     */
    async findAll() {
        const integradores = await this.integradorRepository.find();
        return integradores.map((integrador) => new integrador_response_dto_1.IntegradorResponseDto(integrador));
    }
    /**
     * Busca um integrador pelo seu ID.
     * @param id ID do integrador
     * @returns Dados do integrador encontrado
     * @throws NotFoundException se o integrador não for encontrado
     */
    async findById(id) {
        const integrador = await this.integradorRepository.findOne({
            where: { id },
        });
        if (!integrador) {
            throw new common_1.NotFoundException(`Integrador com ID ${id} não encontrado`);
        }
        return integrador;
    }
    /**
     * Obtém um integrador pelo ID e retorna com o formato de resposta padronizado.
     * @param id ID do integrador
     * @returns Dados do integrador no formato de resposta
     */
    async findOne(id) {
        const integrador = await this.findById(id);
        return new integrador_response_dto_1.IntegradorResponseDto(integrador);
    }
    /**
     * Atualiza os dados de um integrador.
     * @param id ID do integrador a ser atualizado
     * @param updateIntegradorDto Dados a serem atualizados
     * @returns Dados do integrador atualizado
     */
    async update(id, updateIntegradorDto) {
        // Verifica se o integrador existe
        const integrador = await this.findById(id);
        // Se o nome estiver sendo alterado, verifica se já existe outro com o mesmo nome
        if (updateIntegradorDto.nome &&
            updateIntegradorDto.nome !== integrador.nome) {
            const existingIntegrador = await this.integradorRepository.findOne({
                where: { nome: updateIntegradorDto.nome },
            });
            if (existingIntegrador) {
                throw new common_1.ConflictException(`Já existe um integrador com o nome '${updateIntegradorDto.nome}'`);
            }
        }
        // Atualiza os dados
        Object.assign(integrador, updateIntegradorDto);
        const updatedIntegrador = await this.integradorRepository.save(integrador);
        return new integrador_response_dto_1.IntegradorResponseDto(updatedIntegrador);
    }
    /**
     * Remove um integrador do sistema.
     * @param id ID do integrador a ser removido
     */
    async remove(id) {
        const integrador = await this.findById(id);
        await this.integradorRepository.remove(integrador);
    }
    /**
     * Ativa ou desativa um integrador.
     * @param id ID do integrador
     * @param ativo Novo status de ativação
     * @returns Dados do integrador atualizado
     */
    async toggleAtivo(id, ativo) {
        const integrador = await this.findById(id);
        integrador.ativo = ativo;
        const updatedIntegrador = await this.integradorRepository.save(integrador);
        return new integrador_response_dto_1.IntegradorResponseDto(updatedIntegrador);
    }
    /**
     * Registra um acesso do integrador à API.
     * @param id ID do integrador
     */
    async registrarAcesso(id) {
        await this.integradorRepository.update({ id }, { ultimoAcesso: new Date() });
    }
};
exports.IntegradorService = IntegradorService;
exports.IntegradorService = IntegradorService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(integrador_entity_1.Integrador)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], IntegradorService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXGludGVncmFkb3JcXHNlcnZpY2VzXFxpbnRlZ3JhZG9yLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUl3QjtBQUN4Qiw2Q0FBbUQ7QUFDbkQscUNBQXFDO0FBQ3JDLDJFQUFpRTtBQUdqRSw0RUFBdUU7QUFFdkU7OztHQUdHO0FBRUksSUFBTSxpQkFBaUIsR0FBdkIsTUFBTSxpQkFBaUI7SUFHbEI7SUFGVixZQUVVLG9CQUE0QztRQUE1Qyx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXdCO0lBQ25ELENBQUM7SUFFSjs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLE1BQU0sQ0FDVixtQkFBd0M7UUFFeEMsdURBQXVEO1FBQ3ZELE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDO1lBQ2pFLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxtQkFBbUIsQ0FBQyxJQUFJLEVBQUU7U0FDMUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxrQkFBa0IsRUFBRSxDQUFDO1lBQ3ZCLE1BQU0sSUFBSSwwQkFBaUIsQ0FDekIsdUNBQXVDLG1CQUFtQixDQUFDLElBQUksR0FBRyxDQUNuRSxDQUFDO1FBQ0osQ0FBQztRQUVELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUN6RSxNQUFNLGVBQWUsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFekUsT0FBTyxJQUFJLCtDQUFxQixDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsT0FBTztRQUNYLE1BQU0sWUFBWSxHQUFHLE1BQU0sSUFBSSxDQUFDLG9C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LEVBQUUsSUFBSSxJQUFJLEVBQUUsRUFBRSxDQUM3QixDQUFDO0lBQ0osQ0FBQztDQUNGLENBQUE7QUE5SVksOENBQWlCOzRCQUFqQixpQkFBaUI7SUFEN0IsSUFBQSxtQkFBVSxHQUFFO0lBR1IsV0FBQSxJQUFBLDBCQUFnQixFQUFDLDhCQUFVLENBQUMsQ0FBQTt5REFDQyxvQkFBVSxvQkFBVixvQkFBVTtHQUgvQixpQkFBaUIsQ0E4STdCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZXVkcmVcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxtb2R1bGVzXFxpbnRlZ3JhZG9yXFxzZXJ2aWNlc1xcaW50ZWdyYWRvci5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEluamVjdGFibGUsXG4gIE5vdEZvdW5kRXhjZXB0aW9uLFxuICBDb25mbGljdEV4Y2VwdGlvbixcbn0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xuaW1wb3J0IHsgSW5qZWN0UmVwb3NpdG9yeSB9IGZyb20gJ0BuZXN0anMvdHlwZW9ybSc7XG5pbXBvcnQgeyBSZXBvc2l0b3J5IH0gZnJvbSAndHlwZW9ybSc7XG5pbXBvcnQgeyBJbnRlZ3JhZG9yIH0gZnJvbSAnLi4vLi4vLi4vZW50aXRpZXMvaW50ZWdyYWRvci5lbnRpdHknO1xuaW1wb3J0IHsgQ3JlYXRlSW50ZWdyYWRvckR0byB9IGZyb20gJy4uL2R0by9jcmVhdGUtaW50ZWdyYWRvci5kdG8nO1xuaW1wb3J0IHsgVXBkYXRlSW50ZWdyYWRvckR0byB9IGZyb20gJy4uL2R0by91cGRhdGUtaW50ZWdyYWRvci5kdG8nO1xuaW1wb3J0IHsgSW50ZWdyYWRvclJlc3BvbnNlRHRvIH0gZnJvbSAnLi4vZHRvL2ludGVncmFkb3ItcmVzcG9uc2UuZHRvJztcblxuLyoqXG4gKiBTZXJ2acOnbyByZXNwb25zw6F2ZWwgcGVsbyBnZXJlbmNpYW1lbnRvIGRlIGludGVncmFkb3Jlcy5cbiAqIEltcGxlbWVudGEgb3BlcmHDp8O1ZXMgQ1JVRCBlIHJlZ3JhcyBkZSBuZWfDs2NpbyBlc3BlY8OtZmljYXMgcGFyYSBpbnRlZ3JhZG9yZXMuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBJbnRlZ3JhZG9yU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3RSZXBvc2l0b3J5KEludGVncmFkb3IpXG4gICAgcHJpdmF0ZSBpbnRlZ3JhZG9yUmVwb3NpdG9yeTogUmVwb3NpdG9yeTxJbnRlZ3JhZG9yPixcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDcmlhIHVtIG5vdm8gaW50ZWdyYWRvciBuYSBwbGF0YWZvcm1hLlxuICAgKiBAcGFyYW0gY3JlYXRlSW50ZWdyYWRvckR0byBEYWRvcyBkbyBpbnRlZ3JhZG9yIGEgc2VyIGNyaWFkb1xuICAgKiBAcmV0dXJucyBEYWRvcyBkbyBpbnRlZ3JhZG9yIGNyaWFkb1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlKFxuICAgIGNyZWF0ZUludGVncmFkb3JEdG86IENyZWF0ZUludGVncmFkb3JEdG8sXG4gICk6IFByb21pc2U8SW50ZWdyYWRvclJlc3BvbnNlRHRvPiB7XG4gICAgLy8gVmVyaWZpY2Egc2UgasOhIGV4aXN0ZSB1bSBpbnRlZ3JhZG9yIGNvbSBvIG1lc21vIG5vbWVcbiAgICBjb25zdCBleGlzdGluZ0ludGVncmFkb3IgPSBhd2FpdCB0aGlzLmludGVncmFkb3JSZXBvc2l0b3J5LmZpbmRPbmUoe1xuICAgICAgd2hlcmU6IHsgbm9tZTogY3JlYXRlSW50ZWdyYWRvckR0by5ub21lIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoZXhpc3RpbmdJbnRlZ3JhZG9yKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RFeGNlcHRpb24oXG4gICAgICAgIGBKw6EgZXhpc3RlIHVtIGludGVncmFkb3IgY29tIG8gbm9tZSAnJHtjcmVhdGVJbnRlZ3JhZG9yRHRvLm5vbWV9J2AsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGludGVncmFkb3IgPSB0aGlzLmludGVncmFkb3JSZXBvc2l0b3J5LmNyZWF0ZShjcmVhdGVJbnRlZ3JhZG9yRHRvKTtcbiAgICBjb25zdCBzYXZlZEludGVncmFkb3IgPSBhd2FpdCB0aGlzLmludGVncmFkb3JSZXBvc2l0b3J5LnNhdmUoaW50ZWdyYWRvcik7XG5cbiAgICByZXR1cm4gbmV3IEludGVncmFkb3JSZXNwb25zZUR0byhzYXZlZEludGVncmFkb3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldG9ybmEgdG9kb3Mgb3MgaW50ZWdyYWRvcmVzIGNhZGFzdHJhZG9zLlxuICAgKiBAcmV0dXJucyBMaXN0YSBkZSBpbnRlZ3JhZG9yZXNcbiAgICovXG4gIGFzeW5jIGZpbmRBbGwoKTogUHJvbWlzZTxJbnRlZ3JhZG9yUmVzcG9uc2VEdG9bXT4ge1xuICAgIGNvbnN0IGludGVncmFkb3JlcyA9IGF3YWl0IHRoaXMuaW50ZWdyYWRvclJlcG9zaXRvcnkuZmluZCgpO1xuICAgIHJldHVybiBpbnRlZ3JhZG9yZXMubWFwKFxuICAgICAgKGludGVncmFkb3IpID0+IG5ldyBJbnRlZ3JhZG9yUmVzcG9uc2VEdG8oaW50ZWdyYWRvciksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdXNjYSB1bSBpbnRlZ3JhZG9yIHBlbG8gc2V1IElELlxuICAgKiBAcGFyYW0gaWQgSUQgZG8gaW50ZWdyYWRvclxuICAgKiBAcmV0dXJucyBEYWRvcyBkbyBpbnRlZ3JhZG9yIGVuY29udHJhZG9cbiAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBzZSBvIGludGVncmFkb3IgbsOjbyBmb3IgZW5jb250cmFkb1xuICAgKi9cbiAgYXN5bmMgZmluZEJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8SW50ZWdyYWRvcj4ge1xuICAgIGNvbnN0IGludGVncmFkb3IgPSBhd2FpdCB0aGlzLmludGVncmFkb3JSZXBvc2l0b3J5LmZpbmRPbmUoe1xuICAgICAgd2hlcmU6IHsgaWQgfSxcbiAgICB9KTtcblxuICAgIGlmICghaW50ZWdyYWRvcikge1xuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKGBJbnRlZ3JhZG9yIGNvbSBJRCAke2lkfSBuw6NvIGVuY29udHJhZG9gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZWdyYWRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnTDqW0gdW0gaW50ZWdyYWRvciBwZWxvIElEIGUgcmV0b3JuYSBjb20gbyBmb3JtYXRvIGRlIHJlc3Bvc3RhIHBhZHJvbml6YWRvLlxuICAgKiBAcGFyYW0gaWQgSUQgZG8gaW50ZWdyYWRvclxuICAgKiBAcmV0dXJucyBEYWRvcyBkbyBpbnRlZ3JhZG9yIG5vIGZvcm1hdG8gZGUgcmVzcG9zdGFcbiAgICovXG4gIGFzeW5jIGZpbmRPbmUoaWQ6IHN0cmluZyk6IFByb21pc2U8SW50ZWdyYWRvclJlc3BvbnNlRHRvPiB7XG4gICAgY29uc3QgaW50ZWdyYWRvciA9IGF3YWl0IHRoaXMuZmluZEJ5SWQoaWQpO1xuICAgIHJldHVybiBuZXcgSW50ZWdyYWRvclJlc3BvbnNlRHRvKGludGVncmFkb3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dWFsaXphIG9zIGRhZG9zIGRlIHVtIGludGVncmFkb3IuXG4gICAqIEBwYXJhbSBpZCBJRCBkbyBpbnRlZ3JhZG9yIGEgc2VyIGF0dWFsaXphZG9cbiAgICogQHBhcmFtIHVwZGF0ZUludGVncmFkb3JEdG8gRGFkb3MgYSBzZXJlbSBhdHVhbGl6YWRvc1xuICAgKiBAcmV0dXJucyBEYWRvcyBkbyBpbnRlZ3JhZG9yIGF0dWFsaXphZG9cbiAgICovXG4gIGFzeW5jIHVwZGF0ZShcbiAgICBpZDogc3RyaW5nLFxuICAgIHVwZGF0ZUludGVncmFkb3JEdG86IFVwZGF0ZUludGVncmFkb3JEdG8sXG4gICk6IFByb21pc2U8SW50ZWdyYWRvclJlc3BvbnNlRHRvPiB7XG4gICAgLy8gVmVyaWZpY2Egc2UgbyBpbnRlZ3JhZG9yIGV4aXN0ZVxuICAgIGNvbnN0IGludGVncmFkb3IgPSBhd2FpdCB0aGlzLmZpbmRCeUlkKGlkKTtcblxuICAgIC8vIFNlIG8gbm9tZSBlc3RpdmVyIHNlbmRvIGFsdGVyYWRvLCB2ZXJpZmljYSBzZSBqw6EgZXhpc3RlIG91dHJvIGNvbSBvIG1lc21vIG5vbWVcbiAgICBpZiAoXG4gICAgICB1cGRhdGVJbnRlZ3JhZG9yRHRvLm5vbWUgJiZcbiAgICAgIHVwZGF0ZUludGVncmFkb3JEdG8ubm9tZSAhPT0gaW50ZWdyYWRvci5ub21lXG4gICAgKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0ludGVncmFkb3IgPSBhd2FpdCB0aGlzLmludGVncmFkb3JSZXBvc2l0b3J5LmZpbmRPbmUoe1xuICAgICAgICB3aGVyZTogeyBub21lOiB1cGRhdGVJbnRlZ3JhZG9yRHRvLm5vbWUgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZXhpc3RpbmdJbnRlZ3JhZG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25mbGljdEV4Y2VwdGlvbihcbiAgICAgICAgICBgSsOhIGV4aXN0ZSB1bSBpbnRlZ3JhZG9yIGNvbSBvIG5vbWUgJyR7dXBkYXRlSW50ZWdyYWRvckR0by5ub21lfSdgLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEF0dWFsaXphIG9zIGRhZG9zXG4gICAgT2JqZWN0LmFzc2lnbihpbnRlZ3JhZG9yLCB1cGRhdGVJbnRlZ3JhZG9yRHRvKTtcbiAgICBjb25zdCB1cGRhdGVkSW50ZWdyYWRvciA9IGF3YWl0IHRoaXMuaW50ZWdyYWRvclJlcG9zaXRvcnkuc2F2ZShpbnRlZ3JhZG9yKTtcblxuICAgIHJldHVybiBuZXcgSW50ZWdyYWRvclJlc3BvbnNlRHRvKHVwZGF0ZWRJbnRlZ3JhZG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdW0gaW50ZWdyYWRvciBkbyBzaXN0ZW1hLlxuICAgKiBAcGFyYW0gaWQgSUQgZG8gaW50ZWdyYWRvciBhIHNlciByZW1vdmlkb1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBpbnRlZ3JhZG9yID0gYXdhaXQgdGhpcy5maW5kQnlJZChpZCk7XG4gICAgYXdhaXQgdGhpcy5pbnRlZ3JhZG9yUmVwb3NpdG9yeS5yZW1vdmUoaW50ZWdyYWRvcik7XG4gIH1cblxuICAvKipcbiAgICogQXRpdmEgb3UgZGVzYXRpdmEgdW0gaW50ZWdyYWRvci5cbiAgICogQHBhcmFtIGlkIElEIGRvIGludGVncmFkb3JcbiAgICogQHBhcmFtIGF0aXZvIE5vdm8gc3RhdHVzIGRlIGF0aXZhw6fDo29cbiAgICogQHJldHVybnMgRGFkb3MgZG8gaW50ZWdyYWRvciBhdHVhbGl6YWRvXG4gICAqL1xuICBhc3luYyB0b2dnbGVBdGl2byhcbiAgICBpZDogc3RyaW5nLFxuICAgIGF0aXZvOiBib29sZWFuLFxuICApOiBQcm9taXNlPEludGVncmFkb3JSZXNwb25zZUR0bz4ge1xuICAgIGNvbnN0IGludGVncmFkb3IgPSBhd2FpdCB0aGlzLmZpbmRCeUlkKGlkKTtcbiAgICBpbnRlZ3JhZG9yLmF0aXZvID0gYXRpdm87XG4gICAgY29uc3QgdXBkYXRlZEludGVncmFkb3IgPSBhd2FpdCB0aGlzLmludGVncmFkb3JSZXBvc2l0b3J5LnNhdmUoaW50ZWdyYWRvcik7XG5cbiAgICByZXR1cm4gbmV3IEludGVncmFkb3JSZXNwb25zZUR0byh1cGRhdGVkSW50ZWdyYWRvcik7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0cmEgdW0gYWNlc3NvIGRvIGludGVncmFkb3Igw6AgQVBJLlxuICAgKiBAcGFyYW0gaWQgSUQgZG8gaW50ZWdyYWRvclxuICAgKi9cbiAgYXN5bmMgcmVnaXN0cmFyQWNlc3NvKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmludGVncmFkb3JSZXBvc2l0b3J5LnVwZGF0ZShcbiAgICAgIHsgaWQgfSxcbiAgICAgIHsgdWx0aW1vQWNlc3NvOiBuZXcgRGF0ZSgpIH0sXG4gICAgKTtcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9