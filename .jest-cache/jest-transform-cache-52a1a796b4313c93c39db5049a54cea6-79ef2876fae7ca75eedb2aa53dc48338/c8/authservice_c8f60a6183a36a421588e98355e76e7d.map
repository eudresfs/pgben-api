{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\auth\\services\\auth.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\auth\\services\\auth.service.ts"],"sourcesContent":["import { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { JwtService } from '@nestjs/jwt';\nimport { plainToClass } from 'class-transformer';\nimport { Request } from 'express';\nimport { RoleType } from '../../shared/constants/roles.constants';\n\nimport { AppLogger } from '../../shared/logger/logger.service';\nimport { RequestContext } from '../../shared/request-context/request-context.dto';\nimport { UsuarioService } from '../../modules/usuario/services/usuario.service';\nimport { RegisterInput } from '../dtos/auth-register-input.dto';\nimport { RegisterOutput } from '../dtos/auth-register-output.dto';\nimport {\n  AuthTokenOutput,\n  UserAccessTokenClaims,\n} from '../dtos/auth-token-output.dto';\nimport { UserOutput, UsuarioAdapter } from '../adapters/usuario-adapter';\nimport { RefreshTokenService } from './refresh-token.service';\nimport { RefreshTokenInput } from '../dtos/auth-refresh-token-input.dto';\nimport { Usuario } from '../../entities/usuario.entity';\nimport { PermissionService } from './permission.service';\n\n@Injectable()\nexport class AuthService {\n  // Valores padrão no formato semântico\n  private readonly DEFAULT_ACCESS_TOKEN_EXPIRES_IN = '1h';\n  private readonly DEFAULT_REFRESH_TOKEN_EXPIRES_IN = '7d';\n\n  /**\n   * Gera um JTI (JWT ID) único\n   * @returns string - JTI único\n   */\n  private generateJti(): string {\n    // Combinar timestamp, número aleatório e hash para garantir unicidade\n    const timestamp = Date.now().toString(36);\n    const randomPart = Math.random().toString(36).substring(2, 15);\n    return `${timestamp}-${randomPart}`;\n  }\n\n  constructor(\n    private usuarioService: UsuarioService,\n    private refreshTokenService: RefreshTokenService,\n    private jwtService: JwtService,\n    private configService: ConfigService,\n    private readonly logger: AppLogger,\n    private readonly permissionService: PermissionService,\n  ) {\n    this.logger.setContext(AuthService.name);\n\n    // Log das configurações de token\n    const accessTokenExpiresIn = this.getAccessTokenExpiresIn();\n    const refreshTokenExpiresIn = this.getRefreshTokenExpiresIn();\n\n    this.logger.log(\n      {} as RequestContext,\n      `Configuração de tokens - Access Token: ${accessTokenExpiresIn}, ` +\n        `Refresh Token: ${refreshTokenExpiresIn} ` +\n        `(em segundos: ${this.timeToSeconds(refreshTokenExpiresIn)})`,\n    );\n\n    // Debug das variáveis de ambiente\n    console.log(\n      'JWT_REFRESH_TOKEN_EXPIRES_IN:',\n      this.configService.get('JWT_REFRESH_TOKEN_EXPIRES_IN', 'não definido'),\n    );\n    console.log(\n      'JWT_ACCESS_TOKEN_EXPIRES_IN:',\n      this.configService.get('JWT_ACCESS_TOKEN_EXPIRES_IN', 'não definido'),\n    );\n  }\n\n  /**\n   * Obtém o tempo de expiração do access token no formato semântico (1h, 7d, etc)\n   */\n  private getAccessTokenExpiresIn(): string {\n    return this.configService.get<string>(\n      'JWT_ACCESS_TOKEN_EXPIRES_IN',\n      this.DEFAULT_ACCESS_TOKEN_EXPIRES_IN,\n    );\n  }\n\n  /**\n   * Obtém o tempo de expiração do refresh token no formato semântico (1h, 7d, etc)\n   */\n  private getRefreshTokenExpiresIn(): string {\n    return this.configService.get<string>(\n      'JWT_REFRESH_TOKEN_EXPIRES_IN',\n      this.DEFAULT_REFRESH_TOKEN_EXPIRES_IN,\n    );\n  }\n\n  /**\n   * Converte uma string de tempo no formato semântico (1h, 7d, etc) para segundos\n   */\n  private timeToSeconds(timeString: string): number {\n    // Se for apenas um número, considera como segundos\n    if (/^\\d+$/.test(timeString)) {\n      return parseInt(timeString, 10);\n    }\n\n    // Se for no formato número+unidade (ex: 7d, 24h, etc)\n    const match = timeString.match(/^(\\d+)([smhdw])$/);\n    if (match) {\n      const value = parseInt(match[1], 10);\n      const unit = match[2];\n\n      switch (unit) {\n        case 's':\n          return value; // segundos\n        case 'm':\n          return value * 60; // minutos\n        case 'h':\n          return value * 60 * 60; // horas\n        case 'd':\n          return value * 24 * 60 * 60; // dias\n        case 'w':\n          return value * 7 * 24 * 60 * 60; // semanas\n        default:\n          return 86400; // padrão: 1 dia\n      }\n    }\n\n    // Fallback para valores que não conseguimos interpretar\n    this.logger.warn(\n      {} as RequestContext,\n      `Não foi possível interpretar o formato de tempo: ${timeString}, usando 1 dia como padrão`,\n    );\n    return 86400; // 1 dia em segundos\n  }\n\n  async validateUser(\n    ctx: RequestContext,\n    username: string,\n    pass: string,\n  ): Promise<UserAccessTokenClaims> {\n    this.logger.log(ctx, `${this.validateUser.name} foi chamado`);\n\n    // Buscar usuário pelo email (username)\n    const usuario = await this.usuarioService.findByEmail(username);\n    if (!usuario) {\n      throw new UnauthorizedException('Nome de usuário ou senha inválidos');\n    }\n\n    // Verificar se a senha está correta\n    const senhaCorreta = await require('bcrypt').compare(\n      pass,\n      usuario.senhaHash,\n    );\n    if (!senhaCorreta) {\n      throw new UnauthorizedException('Nome de usuário ou senha inválidos');\n    }\n\n    // Verificar se o usuário está ativo\n    if (usuario.status === 'inativo') {\n      throw new UnauthorizedException('Esta conta de usuário foi desativada');\n    }\n\n    // Obter as permissões do usuário\n    const permissions = await this.permissionService.getUserPermissions(\n      usuario.id,\n    );\n\n    // Obter os escopos das permissões\n    const permissionScopes: Record<string, string> = {};\n\n    // Converter para o formato esperado incluindo permissões\n    return UsuarioAdapter.toUserAccessTokenClaims(\n      usuario,\n      permissions,\n      permissionScopes,\n    );\n  }\n\n  async login(ctx: RequestContext): Promise<AuthTokenOutput> {\n    this.logger.log(ctx, `${this.login.name} foi chamado`);\n\n    // Obter o token de autenticação\n    const tokens = this.getAuthToken(ctx, ctx.user!);\n\n    // Criar e salvar o refresh token\n    const usuario = await this.usuarioService.findById(ctx.user!.id as string);\n    if (!usuario) {\n      throw new UnauthorizedException('Usuário não encontrado');\n    }\n\n    // Obter o tempo de expiração\n    const refreshTokenExpiresIn = this.getRefreshTokenExpiresIn();\n    const refreshTokenSeconds = this.timeToSeconds(refreshTokenExpiresIn);\n\n    this.logger.log(\n      ctx,\n      `Criando refresh token com duração de ${refreshTokenExpiresIn} (${refreshTokenSeconds} segundos)`,\n    );\n\n    const refreshToken = await this.refreshTokenService.createToken(\n      usuario as Usuario,\n      refreshTokenSeconds, // Converte para segundos para o RefreshTokenService\n    );\n\n    return {\n      ...tokens,\n      refreshToken: refreshToken.token,\n    };\n  }\n\n  async refreshToken(\n    ctx: RequestContext,\n    refreshTokenInput: RefreshTokenInput,\n  ): Promise<AuthTokenOutput> {\n    this.logger.log(ctx, `${this.refreshToken.name} foi chamado`);\n\n    // Encontrar o token de refresh\n    const refreshToken = await this.refreshTokenService.findToken(\n      refreshTokenInput.refreshToken,\n    );\n\n    // Verificar se o token existe e não foi revogado\n    if (!refreshToken || refreshToken.revoked) {\n      throw new UnauthorizedException('Token de refresh inválido');\n    }\n\n    // Verificar se o token expirou\n    if (new Date() > refreshToken.expires_at) {\n      throw new UnauthorizedException('Token de refresh expirado');\n    }\n\n    // Revogar apenas o token de refresh atual\n    // Não adicionamos o access token à blacklist, pois isso causaria problemas\n    // com requisições subsequentes\n    const ipAddress = (ctx as any).req?.ip || '0.0.0.0';\n    await this.refreshTokenService.revokeToken(refreshToken.token, ipAddress);\n\n    // Não revogar tokens descendentes para evitar problemas com a blacklist\n    // await this.refreshTokenService.revokeDescendantTokens(\n    //   refreshToken,\n    //   ipAddress,\n    // );\n\n    // Obter o usuário\n    const usuario = await this.usuarioService.findById(refreshToken.usuario.id);\n    if (!usuario) {\n      throw new UnauthorizedException('Usuário não encontrado');\n    }\n\n    // Gerar novos tokens\n    const userOutput = UsuarioAdapter.toUserOutput(usuario as any);\n    const tokens = this.getAuthToken(ctx, userOutput);\n\n    // Obter o tempo de expiração\n    const refreshTokenExpiresIn = this.getRefreshTokenExpiresIn();\n    const refreshTokenSeconds = this.timeToSeconds(refreshTokenExpiresIn);\n\n    this.logger.log(\n      ctx,\n      `Criando novo refresh token com duração de ${refreshTokenExpiresIn} (${refreshTokenSeconds} segundos)`,\n    );\n\n    const newRefreshToken = await this.refreshTokenService.createToken(\n      usuario as Usuario,\n      refreshTokenSeconds, // Converte para segundos para o RefreshTokenService\n    );\n\n    return {\n      ...tokens,\n      refreshToken: newRefreshToken.token,\n    };\n  }\n\n  getAuthToken(\n    ctx: RequestContext,\n    user: UserAccessTokenClaims | UserOutput,\n  ): AuthTokenOutput {\n    this.logger.log(ctx, `${this.getAuthToken.name} was called`);\n\n    // Gerar um JTI (JWT ID) único para cada token\n    const jti = this.generateJti();\n\n    const subject = { sub: user.id };\n    const payload = {\n      username: user.username,\n      sub: user.id,\n      roles: user.roles,\n    };\n\n    // Adicionar permissões ao payload se disponíveis\n    if ('permissions' in user && user.permissions) {\n      payload['permissions'] = user.permissions;\n    }\n\n    // Adicionar escopos de permissões ao payload se disponíveis\n    if ('permissionScopes' in user && user.permissionScopes) {\n      payload['permissionScopes'] = user.permissionScopes;\n    }\n\n    // Garantir que estamos usando o algoritmo RS256 e a chave privada para assinar o token\n    const privateKey = Buffer.from(\n      this.configService.get<string>('JWT_PRIVATE_KEY_BASE64', ''),\n      'base64',\n    ).toString('utf8');\n\n    // Obter valores de expiração no formato semântico\n    const accessTokenExpiresIn = this.getAccessTokenExpiresIn();\n    const refreshTokenExpiresIn = this.getRefreshTokenExpiresIn();\n\n    this.logger.log(\n      ctx,\n      `Gerando tokens - Access token expira em: ${accessTokenExpiresIn}, Refresh token expira em: ${refreshTokenExpiresIn}`,\n    );\n\n    const accessToken = this.jwtService.sign(\n      {\n        ...payload,\n        ...subject,\n      },\n      {\n        secret: privateKey,\n        algorithm: 'RS256',\n        expiresIn: accessTokenExpiresIn,\n        jwtid: jti,\n      },\n    );\n\n    // Para o refreshToken, usamos o mesmo JwtService, mas com opções diferentes de expiração\n    // Gerar um JTI diferente para o refresh token\n    const refreshJti = this.generateJti();\n\n    const refreshTokenJwt = this.jwtService.sign(\n      {\n        ...subject,\n      },\n      {\n        secret: privateKey,\n        algorithm: 'RS256',\n        expiresIn: refreshTokenExpiresIn,\n        jwtid: refreshJti,\n      },\n    );\n\n    const authToken = {\n      accessToken,\n      refreshToken: refreshTokenJwt,\n    };\n\n    return plainToClass(AuthTokenOutput, authToken, {\n      excludeExtraneousValues: true,\n    });\n  }\n}\n"],"version":3}