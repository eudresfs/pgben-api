ed1e388063c518aeddcc8e59d882719c
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AuthService_1;
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthService = void 0;
const common_1 = require("@nestjs/common");
const config_1 = require("@nestjs/config");
const jwt_1 = require("@nestjs/jwt");
const class_transformer_1 = require("class-transformer");
const logger_service_1 = require("../../shared/logger/logger.service");
const usuario_service_1 = require("../../modules/usuario/services/usuario.service");
const auth_token_output_dto_1 = require("../dtos/auth-token-output.dto");
const usuario_adapter_1 = require("../adapters/usuario-adapter");
const refresh_token_service_1 = require("./refresh-token.service");
const permission_service_1 = require("./permission.service");
let AuthService = AuthService_1 = class AuthService {
    usuarioService;
    refreshTokenService;
    jwtService;
    configService;
    logger;
    permissionService;
    // Valores padrão no formato semântico
    DEFAULT_ACCESS_TOKEN_EXPIRES_IN = '1h';
    DEFAULT_REFRESH_TOKEN_EXPIRES_IN = '7d';
    /**
     * Gera um JTI (JWT ID) único
     * @returns string - JTI único
     */
    generateJti() {
        // Combinar timestamp, número aleatório e hash para garantir unicidade
        const timestamp = Date.now().toString(36);
        const randomPart = Math.random().toString(36).substring(2, 15);
        return `${timestamp}-${randomPart}`;
    }
    constructor(usuarioService, refreshTokenService, jwtService, configService, logger, permissionService) {
        this.usuarioService = usuarioService;
        this.refreshTokenService = refreshTokenService;
        this.jwtService = jwtService;
        this.configService = configService;
        this.logger = logger;
        this.permissionService = permissionService;
        this.logger.setContext(AuthService_1.name);
        // Log das configurações de token
        const accessTokenExpiresIn = this.getAccessTokenExpiresIn();
        const refreshTokenExpiresIn = this.getRefreshTokenExpiresIn();
        this.logger.log({}, `Configuração de tokens - Access Token: ${accessTokenExpiresIn}, ` +
            `Refresh Token: ${refreshTokenExpiresIn} ` +
            `(em segundos: ${this.timeToSeconds(refreshTokenExpiresIn)})`);
        // Debug das variáveis de ambiente
        console.log('JWT_REFRESH_TOKEN_EXPIRES_IN:', this.configService.get('JWT_REFRESH_TOKEN_EXPIRES_IN', 'não definido'));
        console.log('JWT_ACCESS_TOKEN_EXPIRES_IN:', this.configService.get('JWT_ACCESS_TOKEN_EXPIRES_IN', 'não definido'));
    }
    /**
     * Obtém o tempo de expiração do access token no formato semântico (1h, 7d, etc)
     */
    getAccessTokenExpiresIn() {
        return this.configService.get('JWT_ACCESS_TOKEN_EXPIRES_IN', this.DEFAULT_ACCESS_TOKEN_EXPIRES_IN);
    }
    /**
     * Obtém o tempo de expiração do refresh token no formato semântico (1h, 7d, etc)
     */
    getRefreshTokenExpiresIn() {
        return this.configService.get('JWT_REFRESH_TOKEN_EXPIRES_IN', this.DEFAULT_REFRESH_TOKEN_EXPIRES_IN);
    }
    /**
     * Converte uma string de tempo no formato semântico (1h, 7d, etc) para segundos
     */
    timeToSeconds(timeString) {
        // Se for apenas um número, considera como segundos
        if (/^\d+$/.test(timeString)) {
            return parseInt(timeString, 10);
        }
        // Se for no formato número+unidade (ex: 7d, 24h, etc)
        const match = timeString.match(/^(\d+)([smhdw])$/);
        if (match) {
            const value = parseInt(match[1], 10);
            const unit = match[2];
            switch (unit) {
                case 's':
                    return value; // segundos
                case 'm':
                    return value * 60; // minutos
                case 'h':
                    return value * 60 * 60; // horas
                case 'd':
                    return value * 24 * 60 * 60; // dias
                case 'w':
                    return value * 7 * 24 * 60 * 60; // semanas
                default:
                    return 86400; // padrão: 1 dia
            }
        }
        // Fallback para valores que não conseguimos interpretar
        this.logger.warn({}, `Não foi possível interpretar o formato de tempo: ${timeString}, usando 1 dia como padrão`);
        return 86400; // 1 dia em segundos
    }
    async validateUser(ctx, username, pass) {
        this.logger.log(ctx, `${this.validateUser.name} foi chamado`);
        // Buscar usuário pelo email (username)
        const usuario = await this.usuarioService.findByEmail(username);
        if (!usuario) {
            throw new common_1.UnauthorizedException('Nome de usuário ou senha inválidos');
        }
        // Verificar se a senha está correta
        const senhaCorreta = await require('bcrypt').compare(pass, usuario.senhaHash);
        if (!senhaCorreta) {
            throw new common_1.UnauthorizedException('Nome de usuário ou senha inválidos');
        }
        // Verificar se o usuário está ativo
        if (usuario.status === 'inativo') {
            throw new common_1.UnauthorizedException('Esta conta de usuário foi desativada');
        }
        // Obter as permissões do usuário
        const permissions = await this.permissionService.getUserPermissions(usuario.id);
        // Obter os escopos das permissões
        const permissionScopes = {};
        // Converter para o formato esperado incluindo permissões
        return usuario_adapter_1.UsuarioAdapter.toUserAccessTokenClaims(usuario, permissions, permissionScopes);
    }
    async login(ctx) {
        this.logger.log(ctx, `${this.login.name} foi chamado`);
        // Obter o token de autenticação
        const tokens = this.getAuthToken(ctx, ctx.user);
        // Criar e salvar o refresh token
        const usuario = await this.usuarioService.findById(ctx.user.id);
        if (!usuario) {
            throw new common_1.UnauthorizedException('Usuário não encontrado');
        }
        // Obter o tempo de expiração
        const refreshTokenExpiresIn = this.getRefreshTokenExpiresIn();
        const refreshTokenSeconds = this.timeToSeconds(refreshTokenExpiresIn);
        this.logger.log(ctx, `Criando refresh token com duração de ${refreshTokenExpiresIn} (${refreshTokenSeconds} segundos)`);
        const refreshToken = await this.refreshTokenService.createToken(usuario, refreshTokenSeconds);
        return {
            ...tokens,
            refreshToken: refreshToken.token,
        };
    }
    async refreshToken(ctx, refreshTokenInput) {
        this.logger.log(ctx, `${this.refreshToken.name} foi chamado`);
        // Encontrar o token de refresh
        const refreshToken = await this.refreshTokenService.findToken(refreshTokenInput.refreshToken);
        // Verificar se o token existe e não foi revogado
        if (!refreshToken || refreshToken.revoked) {
            throw new common_1.UnauthorizedException('Token de refresh inválido');
        }
        // Verificar se o token expirou
        if (new Date() > refreshToken.expires_at) {
            throw new common_1.UnauthorizedException('Token de refresh expirado');
        }
        // Revogar apenas o token de refresh atual
        // Não adicionamos o access token à blacklist, pois isso causaria problemas
        // com requisições subsequentes
        const ipAddress = ctx.req?.ip || '0.0.0.0';
        await this.refreshTokenService.revokeToken(refreshToken.token, ipAddress);
        // Não revogar tokens descendentes para evitar problemas com a blacklist
        // await this.refreshTokenService.revokeDescendantTokens(
        //   refreshToken,
        //   ipAddress,
        // );
        // Obter o usuário
        const usuario = await this.usuarioService.findById(refreshToken.usuario.id);
        if (!usuario) {
            throw new common_1.UnauthorizedException('Usuário não encontrado');
        }
        // Gerar novos tokens
        const userOutput = usuario_adapter_1.UsuarioAdapter.toUserOutput(usuario);
        const tokens = this.getAuthToken(ctx, userOutput);
        // Obter o tempo de expiração
        const refreshTokenExpiresIn = this.getRefreshTokenExpiresIn();
        const refreshTokenSeconds = this.timeToSeconds(refreshTokenExpiresIn);
        this.logger.log(ctx, `Criando novo refresh token com duração de ${refreshTokenExpiresIn} (${refreshTokenSeconds} segundos)`);
        const newRefreshToken = await this.refreshTokenService.createToken(usuario, refreshTokenSeconds);
        return {
            ...tokens,
            refreshToken: newRefreshToken.token,
        };
    }
    getAuthToken(ctx, user) {
        this.logger.log(ctx, `${this.getAuthToken.name} was called`);
        // Gerar um JTI (JWT ID) único para cada token
        const jti = this.generateJti();
        const subject = { sub: user.id };
        const payload = {
            username: user.username,
            sub: user.id,
            roles: user.roles,
        };
        // Adicionar permissões ao payload se disponíveis
        if ('permissions' in user && user.permissions) {
            payload['permissions'] = user.permissions;
        }
        // Adicionar escopos de permissões ao payload se disponíveis
        if ('permissionScopes' in user && user.permissionScopes) {
            payload['permissionScopes'] = user.permissionScopes;
        }
        // Garantir que estamos usando o algoritmo RS256 e a chave privada para assinar o token
        const privateKey = Buffer.from(this.configService.get('JWT_PRIVATE_KEY_BASE64', ''), 'base64').toString('utf8');
        // Obter valores de expiração no formato semântico
        const accessTokenExpiresIn = this.getAccessTokenExpiresIn();
        const refreshTokenExpiresIn = this.getRefreshTokenExpiresIn();
        this.logger.log(ctx, `Gerando tokens - Access token expira em: ${accessTokenExpiresIn}, Refresh token expira em: ${refreshTokenExpiresIn}`);
        const accessToken = this.jwtService.sign({
            ...payload,
            ...subject,
        }, {
            secret: privateKey,
            algorithm: 'RS256',
            expiresIn: accessTokenExpiresIn,
            jwtid: jti,
        });
        // Para o refreshToken, usamos o mesmo JwtService, mas com opções diferentes de expiração
        // Gerar um JTI diferente para o refresh token
        const refreshJti = this.generateJti();
        const refreshTokenJwt = this.jwtService.sign({
            ...subject,
        }, {
            secret: privateKey,
            algorithm: 'RS256',
            expiresIn: refreshTokenExpiresIn,
            jwtid: refreshJti,
        });
        const authToken = {
            accessToken,
            refreshToken: refreshTokenJwt,
        };
        return (0, class_transformer_1.plainToClass)(auth_token_output_dto_1.AuthTokenOutput, authToken, {
            excludeExtraneousValues: true,
        });
    }
};
exports.AuthService = AuthService;
exports.AuthService = AuthService = AuthService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof usuario_service_1.UsuarioService !== "undefined" && usuario_service_1.UsuarioService) === "function" ? _a : Object, typeof (_b = typeof refresh_token_service_1.RefreshTokenService !== "undefined" && refresh_token_service_1.RefreshTokenService) === "function" ? _b : Object, typeof (_c = typeof jwt_1.JwtService !== "undefined" && jwt_1.JwtService) === "function" ? _c : Object, typeof (_d = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _d : Object, typeof (_e = typeof logger_service_1.AppLogger !== "undefined" && logger_service_1.AppLogger) === "function" ? _e : Object, typeof (_f = typeof permission_service_1.PermissionService !== "undefined" && permission_service_1.PermissionService) === "function" ? _f : Object])
], AuthService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXGF1dGhcXHNlcnZpY2VzXFxhdXRoLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBbUU7QUFDbkUsMkNBQStDO0FBQy9DLHFDQUF5QztBQUN6Qyx5REFBaUQ7QUFJakQsdUVBQStEO0FBRS9ELG9GQUFnRjtBQUdoRix5RUFHdUM7QUFDdkMsaUVBQXlFO0FBQ3pFLG1FQUE4RDtBQUc5RCw2REFBeUQ7QUFHbEQsSUFBTSxXQUFXLG1CQUFqQixNQUFNLFdBQVc7SUFpQlo7SUFDQTtJQUNBO0lBQ0E7SUFDUztJQUNBO0lBckJuQixzQ0FBc0M7SUFDckIsK0JBQStCLEdBQUcsSUFBSSxDQUFDO0lBQ3ZDLGdDQUFnQyxHQUFHLElBQUksQ0FBQztJQUV6RDs7O09BR0c7SUFDSyxXQUFXO1FBQ2pCLHNFQUFzRTtRQUN0RSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzFDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUMvRCxPQUFPLEdBQUcsU0FBUyxJQUFJLFVBQVUsRUFBRSxDQUFDO0lBQ3RDLENBQUM7SUFFRCxZQUNVLGNBQThCLEVBQzlCLG1CQUF3QyxFQUN4QyxVQUFzQixFQUN0QixhQUE0QixFQUNuQixNQUFpQixFQUNqQixpQkFBb0M7UUFMN0MsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFDeEMsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQUNuQixXQUFNLEdBQU4sTUFBTSxDQUFXO1FBQ2pCLHNCQUFpQixH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Q0FBZSxFQUFFLFNBQVMsRUFBRTtZQUM5Qyx1QkFBdUIsRUFBRSxJQUFJO1NBQzlCLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRixDQUFBO0FBcFVZLGtDQUFXO3NCQUFYLFdBQVc7SUFEdkIsSUFBQSxtQkFBVSxHQUFFO3lEQWtCZSxnQ0FBYyxvQkFBZCxnQ0FBYyxvREFDVCwyQ0FBbUIsb0JBQW5CLDJDQUFtQixvREFDNUIsZ0JBQVUsb0JBQVYsZ0JBQVUsb0RBQ1Asc0JBQWEsb0JBQWIsc0JBQWEsb0RBQ1gsMEJBQVMsb0JBQVQsMEJBQVMsb0RBQ0Usc0NBQWlCLG9CQUFqQixzQ0FBaUI7R0F0QjVDLFdBQVcsQ0FvVXZCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZXVkcmVcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxhdXRoXFxzZXJ2aWNlc1xcYXV0aC5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIFVuYXV0aG9yaXplZEV4Y2VwdGlvbiB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IENvbmZpZ1NlcnZpY2UgfSBmcm9tICdAbmVzdGpzL2NvbmZpZyc7XG5pbXBvcnQgeyBKd3RTZXJ2aWNlIH0gZnJvbSAnQG5lc3Rqcy9qd3QnO1xuaW1wb3J0IHsgcGxhaW5Ub0NsYXNzIH0gZnJvbSAnY2xhc3MtdHJhbnNmb3JtZXInO1xuaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gJ2V4cHJlc3MnO1xuaW1wb3J0IHsgUm9sZVR5cGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3JvbGVzLmNvbnN0YW50cyc7XG5cbmltcG9ydCB7IEFwcExvZ2dlciB9IGZyb20gJy4uLy4uL3NoYXJlZC9sb2dnZXIvbG9nZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgUmVxdWVzdENvbnRleHQgfSBmcm9tICcuLi8uLi9zaGFyZWQvcmVxdWVzdC1jb250ZXh0L3JlcXVlc3QtY29udGV4dC5kdG8nO1xuaW1wb3J0IHsgVXN1YXJpb1NlcnZpY2UgfSBmcm9tICcuLi8uLi9tb2R1bGVzL3VzdWFyaW8vc2VydmljZXMvdXN1YXJpby5zZXJ2aWNlJztcbmltcG9ydCB7IFJlZ2lzdGVySW5wdXQgfSBmcm9tICcuLi9kdG9zL2F1dGgtcmVnaXN0ZXItaW5wdXQuZHRvJztcbmltcG9ydCB7IFJlZ2lzdGVyT3V0cHV0IH0gZnJvbSAnLi4vZHRvcy9hdXRoLXJlZ2lzdGVyLW91dHB1dC5kdG8nO1xuaW1wb3J0IHtcbiAgQXV0aFRva2VuT3V0cHV0LFxuICBVc2VyQWNjZXNzVG9rZW5DbGFpbXMsXG59IGZyb20gJy4uL2R0b3MvYXV0aC10b2tlbi1vdXRwdXQuZHRvJztcbmltcG9ydCB7IFVzZXJPdXRwdXQsIFVzdWFyaW9BZGFwdGVyIH0gZnJvbSAnLi4vYWRhcHRlcnMvdXN1YXJpby1hZGFwdGVyJztcbmltcG9ydCB7IFJlZnJlc2hUb2tlblNlcnZpY2UgfSBmcm9tICcuL3JlZnJlc2gtdG9rZW4uc2VydmljZSc7XG5pbXBvcnQgeyBSZWZyZXNoVG9rZW5JbnB1dCB9IGZyb20gJy4uL2R0b3MvYXV0aC1yZWZyZXNoLXRva2VuLWlucHV0LmR0byc7XG5pbXBvcnQgeyBVc3VhcmlvIH0gZnJvbSAnLi4vLi4vZW50aXRpZXMvdXN1YXJpby5lbnRpdHknO1xuaW1wb3J0IHsgUGVybWlzc2lvblNlcnZpY2UgfSBmcm9tICcuL3Blcm1pc3Npb24uc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBdXRoU2VydmljZSB7XG4gIC8vIFZhbG9yZXMgcGFkcsOjbyBubyBmb3JtYXRvIHNlbcOibnRpY29cbiAgcHJpdmF0ZSByZWFkb25seSBERUZBVUxUX0FDQ0VTU19UT0tFTl9FWFBJUkVTX0lOID0gJzFoJztcbiAgcHJpdmF0ZSByZWFkb25seSBERUZBVUxUX1JFRlJFU0hfVE9LRU5fRVhQSVJFU19JTiA9ICc3ZCc7XG5cbiAgLyoqXG4gICAqIEdlcmEgdW0gSlRJIChKV1QgSUQpIMO6bmljb1xuICAgKiBAcmV0dXJucyBzdHJpbmcgLSBKVEkgw7puaWNvXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlSnRpKCk6IHN0cmluZyB7XG4gICAgLy8gQ29tYmluYXIgdGltZXN0YW1wLCBuw7ptZXJvIGFsZWF0w7NyaW8gZSBoYXNoIHBhcmEgZ2FyYW50aXIgdW5pY2lkYWRlXG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKS50b1N0cmluZygzNik7XG4gICAgY29uc3QgcmFuZG9tUGFydCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gICAgcmV0dXJuIGAke3RpbWVzdGFtcH0tJHtyYW5kb21QYXJ0fWA7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHVzdWFyaW9TZXJ2aWNlOiBVc3VhcmlvU2VydmljZSxcbiAgICBwcml2YXRlIHJlZnJlc2hUb2tlblNlcnZpY2U6IFJlZnJlc2hUb2tlblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBqd3RTZXJ2aWNlOiBKd3RTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29uZmlnU2VydmljZTogQ29uZmlnU2VydmljZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlcjogQXBwTG9nZ2VyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGVybWlzc2lvblNlcnZpY2U6IFBlcm1pc3Npb25TZXJ2aWNlLFxuICApIHtcbiAgICB0aGlzLmxvZ2dlci5zZXRDb250ZXh0KEF1dGhTZXJ2aWNlLm5hbWUpO1xuXG4gICAgLy8gTG9nIGRhcyBjb25maWd1cmHDp8O1ZXMgZGUgdG9rZW5cbiAgICBjb25zdCBhY2Nlc3NUb2tlbkV4cGlyZXNJbiA9IHRoaXMuZ2V0QWNjZXNzVG9rZW5FeHBpcmVzSW4oKTtcbiAgICBjb25zdCByZWZyZXNoVG9rZW5FeHBpcmVzSW4gPSB0aGlzLmdldFJlZnJlc2hUb2tlbkV4cGlyZXNJbigpO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAge30gYXMgUmVxdWVzdENvbnRleHQsXG4gICAgICBgQ29uZmlndXJhw6fDo28gZGUgdG9rZW5zIC0gQWNjZXNzIFRva2VuOiAke2FjY2Vzc1Rva2VuRXhwaXJlc0lufSwgYCArXG4gICAgICAgIGBSZWZyZXNoIFRva2VuOiAke3JlZnJlc2hUb2tlbkV4cGlyZXNJbn0gYCArXG4gICAgICAgIGAoZW0gc2VndW5kb3M6ICR7dGhpcy50aW1lVG9TZWNvbmRzKHJlZnJlc2hUb2tlbkV4cGlyZXNJbil9KWAsXG4gICAgKTtcblxuICAgIC8vIERlYnVnIGRhcyB2YXJpw6F2ZWlzIGRlIGFtYmllbnRlXG4gICAgY29uc29sZS5sb2coXG4gICAgICAnSldUX1JFRlJFU0hfVE9LRU5fRVhQSVJFU19JTjonLFxuICAgICAgdGhpcy5jb25maWdTZXJ2aWNlLmdldCgnSldUX1JFRlJFU0hfVE9LRU5fRVhQSVJFU19JTicsICduw6NvIGRlZmluaWRvJyksXG4gICAgKTtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgICdKV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU46JyxcbiAgICAgIHRoaXMuY29uZmlnU2VydmljZS5nZXQoJ0pXVF9BQ0NFU1NfVE9LRU5fRVhQSVJFU19JTicsICduw6NvIGRlZmluaWRvJyksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnTDqW0gbyB0ZW1wbyBkZSBleHBpcmHDp8OjbyBkbyBhY2Nlc3MgdG9rZW4gbm8gZm9ybWF0byBzZW3Dom50aWNvICgxaCwgN2QsIGV0YylcbiAgICovXG4gIHByaXZhdGUgZ2V0QWNjZXNzVG9rZW5FeHBpcmVzSW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWdTZXJ2aWNlLmdldDxzdHJpbmc+KFxuICAgICAgJ0pXVF9BQ0NFU1NfVE9LRU5fRVhQSVJFU19JTicsXG4gICAgICB0aGlzLkRFRkFVTFRfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnTDqW0gbyB0ZW1wbyBkZSBleHBpcmHDp8OjbyBkbyByZWZyZXNoIHRva2VuIG5vIGZvcm1hdG8gc2Vtw6JudGljbyAoMWgsIDdkLCBldGMpXG4gICAqL1xuICBwcml2YXRlIGdldFJlZnJlc2hUb2tlbkV4cGlyZXNJbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZ1NlcnZpY2UuZ2V0PHN0cmluZz4oXG4gICAgICAnSldUX1JFRlJFU0hfVE9LRU5fRVhQSVJFU19JTicsXG4gICAgICB0aGlzLkRFRkFVTFRfUkVGUkVTSF9UT0tFTl9FWFBJUkVTX0lOLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydGUgdW1hIHN0cmluZyBkZSB0ZW1wbyBubyBmb3JtYXRvIHNlbcOibnRpY28gKDFoLCA3ZCwgZXRjKSBwYXJhIHNlZ3VuZG9zXG4gICAqL1xuICBwcml2YXRlIHRpbWVUb1NlY29uZHModGltZVN0cmluZzogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAvLyBTZSBmb3IgYXBlbmFzIHVtIG7Dum1lcm8sIGNvbnNpZGVyYSBjb21vIHNlZ3VuZG9zXG4gICAgaWYgKC9eXFxkKyQvLnRlc3QodGltZVN0cmluZykpIHtcbiAgICAgIHJldHVybiBwYXJzZUludCh0aW1lU3RyaW5nLCAxMCk7XG4gICAgfVxuXG4gICAgLy8gU2UgZm9yIG5vIGZvcm1hdG8gbsO6bWVybyt1bmlkYWRlIChleDogN2QsIDI0aCwgZXRjKVxuICAgIGNvbnN0IG1hdGNoID0gdGltZVN0cmluZy5tYXRjaCgvXihcXGQrKShbc21oZHddKSQvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgIGNvbnN0IHVuaXQgPSBtYXRjaFsyXTtcblxuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgIHJldHVybiB2YWx1ZTsgLy8gc2VndW5kb3NcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICogNjA7IC8vIG1pbnV0b3NcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICogNjAgKiA2MDsgLy8gaG9yYXNcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICogMjQgKiA2MCAqIDYwOyAvLyBkaWFzXG4gICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgIHJldHVybiB2YWx1ZSAqIDcgKiAyNCAqIDYwICogNjA7IC8vIHNlbWFuYXNcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gODY0MDA7IC8vIHBhZHLDo286IDEgZGlhXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgcGFyYSB2YWxvcmVzIHF1ZSBuw6NvIGNvbnNlZ3VpbW9zIGludGVycHJldGFyXG4gICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgIHt9IGFzIFJlcXVlc3RDb250ZXh0LFxuICAgICAgYE7Do28gZm9pIHBvc3PDrXZlbCBpbnRlcnByZXRhciBvIGZvcm1hdG8gZGUgdGVtcG86ICR7dGltZVN0cmluZ30sIHVzYW5kbyAxIGRpYSBjb21vIHBhZHLDo29gLFxuICAgICk7XG4gICAgcmV0dXJuIDg2NDAwOyAvLyAxIGRpYSBlbSBzZWd1bmRvc1xuICB9XG5cbiAgYXN5bmMgdmFsaWRhdGVVc2VyKFxuICAgIGN0eDogUmVxdWVzdENvbnRleHQsXG4gICAgdXNlcm5hbWU6IHN0cmluZyxcbiAgICBwYXNzOiBzdHJpbmcsXG4gICk6IFByb21pc2U8VXNlckFjY2Vzc1Rva2VuQ2xhaW1zPiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGN0eCwgYCR7dGhpcy52YWxpZGF0ZVVzZXIubmFtZX0gZm9pIGNoYW1hZG9gKTtcblxuICAgIC8vIEJ1c2NhciB1c3XDoXJpbyBwZWxvIGVtYWlsICh1c2VybmFtZSlcbiAgICBjb25zdCB1c3VhcmlvID0gYXdhaXQgdGhpcy51c3VhcmlvU2VydmljZS5maW5kQnlFbWFpbCh1c2VybmFtZSk7XG4gICAgaWYgKCF1c3VhcmlvKSB7XG4gICAgICB0aHJvdyBuZXcgVW5hdXRob3JpemVkRXhjZXB0aW9uKCdOb21lIGRlIHVzdcOhcmlvIG91IHNlbmhhIGludsOhbGlkb3MnKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZmljYXIgc2UgYSBzZW5oYSBlc3TDoSBjb3JyZXRhXG4gICAgY29uc3Qgc2VuaGFDb3JyZXRhID0gYXdhaXQgcmVxdWlyZSgnYmNyeXB0JykuY29tcGFyZShcbiAgICAgIHBhc3MsXG4gICAgICB1c3VhcmlvLnNlbmhhSGFzaCxcbiAgICApO1xuICAgIGlmICghc2VuaGFDb3JyZXRhKSB7XG4gICAgICB0aHJvdyBuZXcgVW5hdXRob3JpemVkRXhjZXB0aW9uKCdOb21lIGRlIHVzdcOhcmlvIG91IHNlbmhhIGludsOhbGlkb3MnKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZmljYXIgc2UgbyB1c3XDoXJpbyBlc3TDoSBhdGl2b1xuICAgIGlmICh1c3VhcmlvLnN0YXR1cyA9PT0gJ2luYXRpdm8nKSB7XG4gICAgICB0aHJvdyBuZXcgVW5hdXRob3JpemVkRXhjZXB0aW9uKCdFc3RhIGNvbnRhIGRlIHVzdcOhcmlvIGZvaSBkZXNhdGl2YWRhJyk7XG4gICAgfVxuXG4gICAgLy8gT2J0ZXIgYXMgcGVybWlzc8O1ZXMgZG8gdXN1w6FyaW9cbiAgICBjb25zdCBwZXJtaXNzaW9ucyA9IGF3YWl0IHRoaXMucGVybWlzc2lvblNlcnZpY2UuZ2V0VXNlclBlcm1pc3Npb25zKFxuICAgICAgdXN1YXJpby5pZCxcbiAgICApO1xuXG4gICAgLy8gT2J0ZXIgb3MgZXNjb3BvcyBkYXMgcGVybWlzc8O1ZXNcbiAgICBjb25zdCBwZXJtaXNzaW9uU2NvcGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgICAvLyBDb252ZXJ0ZXIgcGFyYSBvIGZvcm1hdG8gZXNwZXJhZG8gaW5jbHVpbmRvIHBlcm1pc3PDtWVzXG4gICAgcmV0dXJuIFVzdWFyaW9BZGFwdGVyLnRvVXNlckFjY2Vzc1Rva2VuQ2xhaW1zKFxuICAgICAgdXN1YXJpbyxcbiAgICAgIHBlcm1pc3Npb25zLFxuICAgICAgcGVybWlzc2lvblNjb3BlcyxcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgbG9naW4oY3R4OiBSZXF1ZXN0Q29udGV4dCk6IFByb21pc2U8QXV0aFRva2VuT3V0cHV0PiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGN0eCwgYCR7dGhpcy5sb2dpbi5uYW1lfSBmb2kgY2hhbWFkb2ApO1xuXG4gICAgLy8gT2J0ZXIgbyB0b2tlbiBkZSBhdXRlbnRpY2HDp8Ojb1xuICAgIGNvbnN0IHRva2VucyA9IHRoaXMuZ2V0QXV0aFRva2VuKGN0eCwgY3R4LnVzZXIhKTtcblxuICAgIC8vIENyaWFyIGUgc2FsdmFyIG8gcmVmcmVzaCB0b2tlblxuICAgIGNvbnN0IHVzdWFyaW8gPSBhd2FpdCB0aGlzLnVzdWFyaW9TZXJ2aWNlLmZpbmRCeUlkKGN0eC51c2VyIS5pZCBhcyBzdHJpbmcpO1xuICAgIGlmICghdXN1YXJpbykge1xuICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEV4Y2VwdGlvbignVXN1w6FyaW8gbsOjbyBlbmNvbnRyYWRvJyk7XG4gICAgfVxuXG4gICAgLy8gT2J0ZXIgbyB0ZW1wbyBkZSBleHBpcmHDp8Ojb1xuICAgIGNvbnN0IHJlZnJlc2hUb2tlbkV4cGlyZXNJbiA9IHRoaXMuZ2V0UmVmcmVzaFRva2VuRXhwaXJlc0luKCk7XG4gICAgY29uc3QgcmVmcmVzaFRva2VuU2Vjb25kcyA9IHRoaXMudGltZVRvU2Vjb25kcyhyZWZyZXNoVG9rZW5FeHBpcmVzSW4pO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgY3R4LFxuICAgICAgYENyaWFuZG8gcmVmcmVzaCB0b2tlbiBjb20gZHVyYcOnw6NvIGRlICR7cmVmcmVzaFRva2VuRXhwaXJlc0lufSAoJHtyZWZyZXNoVG9rZW5TZWNvbmRzfSBzZWd1bmRvcylgLFxuICAgICk7XG5cbiAgICBjb25zdCByZWZyZXNoVG9rZW4gPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlblNlcnZpY2UuY3JlYXRlVG9rZW4oXG4gICAgICB1c3VhcmlvIGFzIFVzdWFyaW8sXG4gICAgICByZWZyZXNoVG9rZW5TZWNvbmRzLCAvLyBDb252ZXJ0ZSBwYXJhIHNlZ3VuZG9zIHBhcmEgbyBSZWZyZXNoVG9rZW5TZXJ2aWNlXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi50b2tlbnMsXG4gICAgICByZWZyZXNoVG9rZW46IHJlZnJlc2hUb2tlbi50b2tlbixcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgcmVmcmVzaFRva2VuKFxuICAgIGN0eDogUmVxdWVzdENvbnRleHQsXG4gICAgcmVmcmVzaFRva2VuSW5wdXQ6IFJlZnJlc2hUb2tlbklucHV0LFxuICApOiBQcm9taXNlPEF1dGhUb2tlbk91dHB1dD4ge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhjdHgsIGAke3RoaXMucmVmcmVzaFRva2VuLm5hbWV9IGZvaSBjaGFtYWRvYCk7XG5cbiAgICAvLyBFbmNvbnRyYXIgbyB0b2tlbiBkZSByZWZyZXNoXG4gICAgY29uc3QgcmVmcmVzaFRva2VuID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW5TZXJ2aWNlLmZpbmRUb2tlbihcbiAgICAgIHJlZnJlc2hUb2tlbklucHV0LnJlZnJlc2hUb2tlbixcbiAgICApO1xuXG4gICAgLy8gVmVyaWZpY2FyIHNlIG8gdG9rZW4gZXhpc3RlIGUgbsOjbyBmb2kgcmV2b2dhZG9cbiAgICBpZiAoIXJlZnJlc2hUb2tlbiB8fCByZWZyZXNoVG9rZW4ucmV2b2tlZCkge1xuICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEV4Y2VwdGlvbignVG9rZW4gZGUgcmVmcmVzaCBpbnbDoWxpZG8nKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZmljYXIgc2UgbyB0b2tlbiBleHBpcm91XG4gICAgaWYgKG5ldyBEYXRlKCkgPiByZWZyZXNoVG9rZW4uZXhwaXJlc19hdCkge1xuICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEV4Y2VwdGlvbignVG9rZW4gZGUgcmVmcmVzaCBleHBpcmFkbycpO1xuICAgIH1cblxuICAgIC8vIFJldm9nYXIgYXBlbmFzIG8gdG9rZW4gZGUgcmVmcmVzaCBhdHVhbFxuICAgIC8vIE7Do28gYWRpY2lvbmFtb3MgbyBhY2Nlc3MgdG9rZW4gw6AgYmxhY2tsaXN0LCBwb2lzIGlzc28gY2F1c2FyaWEgcHJvYmxlbWFzXG4gICAgLy8gY29tIHJlcXVpc2nDp8O1ZXMgc3Vic2VxdWVudGVzXG4gICAgY29uc3QgaXBBZGRyZXNzID0gKGN0eCBhcyBhbnkpLnJlcT8uaXAgfHwgJzAuMC4wLjAnO1xuICAgIGF3YWl0IHRoaXMucmVmcmVzaFRva2VuU2VydmljZS5yZXZva2VUb2tlbihyZWZyZXNoVG9rZW4udG9rZW4sIGlwQWRkcmVzcyk7XG5cbiAgICAvLyBOw6NvIHJldm9nYXIgdG9rZW5zIGRlc2NlbmRlbnRlcyBwYXJhIGV2aXRhciBwcm9ibGVtYXMgY29tIGEgYmxhY2tsaXN0XG4gICAgLy8gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW5TZXJ2aWNlLnJldm9rZURlc2NlbmRhbnRUb2tlbnMoXG4gICAgLy8gICByZWZyZXNoVG9rZW4sXG4gICAgLy8gICBpcEFkZHJlc3MsXG4gICAgLy8gKTtcblxuICAgIC8vIE9idGVyIG8gdXN1w6FyaW9cbiAgICBjb25zdCB1c3VhcmlvID0gYXdhaXQgdGhpcy51c3VhcmlvU2VydmljZS5maW5kQnlJZChyZWZyZXNoVG9rZW4udXN1YXJpby5pZCk7XG4gICAgaWYgKCF1c3VhcmlvKSB7XG4gICAgICB0aHJvdyBuZXcgVW5hdXRob3JpemVkRXhjZXB0aW9uKCdVc3XDoXJpbyBuw6NvIGVuY29udHJhZG8nKTtcbiAgICB9XG5cbiAgICAvLyBHZXJhciBub3ZvcyB0b2tlbnNcbiAgICBjb25zdCB1c2VyT3V0cHV0ID0gVXN1YXJpb0FkYXB0ZXIudG9Vc2VyT3V0cHV0KHVzdWFyaW8gYXMgYW55KTtcbiAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmdldEF1dGhUb2tlbihjdHgsIHVzZXJPdXRwdXQpO1xuXG4gICAgLy8gT2J0ZXIgbyB0ZW1wbyBkZSBleHBpcmHDp8Ojb1xuICAgIGNvbnN0IHJlZnJlc2hUb2tlbkV4cGlyZXNJbiA9IHRoaXMuZ2V0UmVmcmVzaFRva2VuRXhwaXJlc0luKCk7XG4gICAgY29uc3QgcmVmcmVzaFRva2VuU2Vjb25kcyA9IHRoaXMudGltZVRvU2Vjb25kcyhyZWZyZXNoVG9rZW5FeHBpcmVzSW4pO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgY3R4LFxuICAgICAgYENyaWFuZG8gbm92byByZWZyZXNoIHRva2VuIGNvbSBkdXJhw6fDo28gZGUgJHtyZWZyZXNoVG9rZW5FeHBpcmVzSW59ICgke3JlZnJlc2hUb2tlblNlY29uZHN9IHNlZ3VuZG9zKWAsXG4gICAgKTtcblxuICAgIGNvbnN0IG5ld1JlZnJlc2hUb2tlbiA9IGF3YWl0IHRoaXMucmVmcmVzaFRva2VuU2VydmljZS5jcmVhdGVUb2tlbihcbiAgICAgIHVzdWFyaW8gYXMgVXN1YXJpbyxcbiAgICAgIHJlZnJlc2hUb2tlblNlY29uZHMsIC8vIENvbnZlcnRlIHBhcmEgc2VndW5kb3MgcGFyYSBvIFJlZnJlc2hUb2tlblNlcnZpY2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRva2VucyxcbiAgICAgIHJlZnJlc2hUb2tlbjogbmV3UmVmcmVzaFRva2VuLnRva2VuLFxuICAgIH07XG4gIH1cblxuICBnZXRBdXRoVG9rZW4oXG4gICAgY3R4OiBSZXF1ZXN0Q29udGV4dCxcbiAgICB1c2VyOiBVc2VyQWNjZXNzVG9rZW5DbGFpbXMgfCBVc2VyT3V0cHV0LFxuICApOiBBdXRoVG9rZW5PdXRwdXQge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhjdHgsIGAke3RoaXMuZ2V0QXV0aFRva2VuLm5hbWV9IHdhcyBjYWxsZWRgKTtcblxuICAgIC8vIEdlcmFyIHVtIEpUSSAoSldUIElEKSDDum5pY28gcGFyYSBjYWRhIHRva2VuXG4gICAgY29uc3QganRpID0gdGhpcy5nZW5lcmF0ZUp0aSgpO1xuXG4gICAgY29uc3Qgc3ViamVjdCA9IHsgc3ViOiB1c2VyLmlkIH07XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHVzZXJuYW1lOiB1c2VyLnVzZXJuYW1lLFxuICAgICAgc3ViOiB1c2VyLmlkLFxuICAgICAgcm9sZXM6IHVzZXIucm9sZXMsXG4gICAgfTtcblxuICAgIC8vIEFkaWNpb25hciBwZXJtaXNzw7VlcyBhbyBwYXlsb2FkIHNlIGRpc3BvbsOtdmVpc1xuICAgIGlmICgncGVybWlzc2lvbnMnIGluIHVzZXIgJiYgdXNlci5wZXJtaXNzaW9ucykge1xuICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHVzZXIucGVybWlzc2lvbnM7XG4gICAgfVxuXG4gICAgLy8gQWRpY2lvbmFyIGVzY29wb3MgZGUgcGVybWlzc8O1ZXMgYW8gcGF5bG9hZCBzZSBkaXNwb27DrXZlaXNcbiAgICBpZiAoJ3Blcm1pc3Npb25TY29wZXMnIGluIHVzZXIgJiYgdXNlci5wZXJtaXNzaW9uU2NvcGVzKSB7XG4gICAgICBwYXlsb2FkWydwZXJtaXNzaW9uU2NvcGVzJ10gPSB1c2VyLnBlcm1pc3Npb25TY29wZXM7XG4gICAgfVxuXG4gICAgLy8gR2FyYW50aXIgcXVlIGVzdGFtb3MgdXNhbmRvIG8gYWxnb3JpdG1vIFJTMjU2IGUgYSBjaGF2ZSBwcml2YWRhIHBhcmEgYXNzaW5hciBvIHRva2VuXG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IEJ1ZmZlci5mcm9tKFxuICAgICAgdGhpcy5jb25maWdTZXJ2aWNlLmdldDxzdHJpbmc+KCdKV1RfUFJJVkFURV9LRVlfQkFTRTY0JywgJycpLFxuICAgICAgJ2Jhc2U2NCcsXG4gICAgKS50b1N0cmluZygndXRmOCcpO1xuXG4gICAgLy8gT2J0ZXIgdmFsb3JlcyBkZSBleHBpcmHDp8OjbyBubyBmb3JtYXRvIHNlbcOibnRpY29cbiAgICBjb25zdCBhY2Nlc3NUb2tlbkV4cGlyZXNJbiA9IHRoaXMuZ2V0QWNjZXNzVG9rZW5FeHBpcmVzSW4oKTtcbiAgICBjb25zdCByZWZyZXNoVG9rZW5FeHBpcmVzSW4gPSB0aGlzLmdldFJlZnJlc2hUb2tlbkV4cGlyZXNJbigpO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgY3R4LFxuICAgICAgYEdlcmFuZG8gdG9rZW5zIC0gQWNjZXNzIHRva2VuIGV4cGlyYSBlbTogJHthY2Nlc3NUb2tlbkV4cGlyZXNJbn0sIFJlZnJlc2ggdG9rZW4gZXhwaXJhIGVtOiAke3JlZnJlc2hUb2tlbkV4cGlyZXNJbn1gLFxuICAgICk7XG5cbiAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRoaXMuand0U2VydmljZS5zaWduKFxuICAgICAge1xuICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAuLi5zdWJqZWN0LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2VjcmV0OiBwcml2YXRlS2V5LFxuICAgICAgICBhbGdvcml0aG06ICdSUzI1NicsXG4gICAgICAgIGV4cGlyZXNJbjogYWNjZXNzVG9rZW5FeHBpcmVzSW4sXG4gICAgICAgIGp3dGlkOiBqdGksXG4gICAgICB9LFxuICAgICk7XG5cbiAgICAvLyBQYXJhIG8gcmVmcmVzaFRva2VuLCB1c2Ftb3MgbyBtZXNtbyBKd3RTZXJ2aWNlLCBtYXMgY29tIG9ww6fDtWVzIGRpZmVyZW50ZXMgZGUgZXhwaXJhw6fDo29cbiAgICAvLyBHZXJhciB1bSBKVEkgZGlmZXJlbnRlIHBhcmEgbyByZWZyZXNoIHRva2VuXG4gICAgY29uc3QgcmVmcmVzaEp0aSA9IHRoaXMuZ2VuZXJhdGVKdGkoKTtcblxuICAgIGNvbnN0IHJlZnJlc2hUb2tlbkp3dCA9IHRoaXMuand0U2VydmljZS5zaWduKFxuICAgICAge1xuICAgICAgICAuLi5zdWJqZWN0LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2VjcmV0OiBwcml2YXRlS2V5LFxuICAgICAgICBhbGdvcml0aG06ICdSUzI1NicsXG4gICAgICAgIGV4cGlyZXNJbjogcmVmcmVzaFRva2VuRXhwaXJlc0luLFxuICAgICAgICBqd3RpZDogcmVmcmVzaEp0aSxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IGF1dGhUb2tlbiA9IHtcbiAgICAgIGFjY2Vzc1Rva2VuLFxuICAgICAgcmVmcmVzaFRva2VuOiByZWZyZXNoVG9rZW5Kd3QsXG4gICAgfTtcblxuICAgIHJldHVybiBwbGFpblRvQ2xhc3MoQXV0aFRva2VuT3V0cHV0LCBhdXRoVG9rZW4sIHtcbiAgICAgIGV4Y2x1ZGVFeHRyYW5lb3VzVmFsdWVzOiB0cnVlLFxuICAgIH0pO1xuICB9XG59XG4iXSwidmVyc2lvbiI6M30=