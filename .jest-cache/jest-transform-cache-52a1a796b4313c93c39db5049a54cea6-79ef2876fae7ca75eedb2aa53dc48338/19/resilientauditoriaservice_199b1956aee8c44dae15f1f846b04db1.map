{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\shared\\services\\resilient-auditoria.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\shared\\services\\resilient-auditoria.service.ts"],"sourcesContent":["import { Injectable, Logger, OnModuleInit } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Cron } from '@nestjs/schedule';\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { CreateLogAuditoriaDto } from '../../modules/auditoria/dto/create-log-auditoria.dto';\nimport { HealthCheckService } from './health-check.service';\nimport { ModuleRef } from '@nestjs/core';\n\ninterface BackupLogEntry {\n  id: string;\n  timestamp: string;\n  data: CreateLogAuditoriaDto;\n  status: 'pending_recovery' | 'processed' | 'failed';\n  attempts: number;\n}\n\n/**\n * Serviço de Auditoria Resiliente\n *\n * Implementa múltiplas camadas de fallback para garantir que nenhum log de auditoria seja perdido:\n * 1. Processamento assíncrono via fila (preferencial)\n * 2. Fallback síncrono direto no banco de dados\n * 3. Backup em arquivo para recuperação posterior\n * 4. Job de recuperação automática\n */\n@Injectable()\nexport class ResilientAuditoriaService implements OnModuleInit {\n  private readonly logger = new Logger(ResilientAuditoriaService.name);\n  private readonly maxRetries = 3;\n  private readonly retryDelay = 1000; // 1 segundo\n  private readonly backupPath: string;\n  private readonly enableSyncFallback: boolean;\n  private readonly enableFileBackup: boolean;\n\n  // Métricas internas\n  private metrics = {\n    queueSuccesses: 0,\n    queueFailures: 0,\n    syncFallbacks: 0,\n    fileBackups: 0,\n    recoveredLogs: 0,\n  };\n\n  // Serviços obtidos via lazy loading para evitar dependência circular\n  private auditoriaService: any;\n  private auditoriaQueueService: any;\n\n  constructor(\n    private readonly moduleRef: ModuleRef,\n    private readonly healthCheckService: HealthCheckService,\n    private readonly configService: ConfigService,\n  ) {\n    this.backupPath = this.configService.get(\n      'AUDITORIA_BACKUP_PATH',\n      './logs/audit-backup',\n    );\n    this.enableSyncFallback =\n      this.configService.get('AUDITORIA_ENABLE_SYNC_FALLBACK', 'true') ===\n      'true';\n    this.enableFileBackup =\n      this.configService.get('AUDITORIA_ENABLE_FILE_BACKUP', 'true') === 'true';\n\n    // Criar diretório de backup se não existir\n    this.ensureBackupDirectory();\n  }\n\n  /**\n   * Inicialização do módulo - obtém serviços de forma lazy para evitar dependência circular\n   */\n  async onModuleInit() {\n    try {\n      // Aguarda um pouco para garantir que os módulos estejam inicializados\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      this.auditoriaService = this.moduleRef.get('AuditoriaService', {\n        strict: false,\n      });\n      this.auditoriaQueueService = this.moduleRef.get('AuditoriaQueueService', {\n        strict: false,\n      });\n\n      this.logger.log('Serviços de auditoria inicializados via lazy loading');\n    } catch (error) {\n      this.logger.warn(\n        `Falha ao inicializar serviços de auditoria: ${error.message}`,\n      );\n      this.logger.warn(\n        'ResilientAuditoriaService funcionará apenas com backup em arquivo',\n      );\n    }\n  }\n\n  /**\n   * Registra log de auditoria com estratégia de fallback resiliente\n   *\n   * Estratégia de fallback:\n   * 1. Tenta enfileirar (assíncrono) - melhor performance\n   * 2. Se falhar, registra diretamente no banco (síncrono) - garantia de persistência\n   * 3. Se falhar, armazena em arquivo (backup) - última linha de defesa\n   *\n   * @param logData Dados do log de auditoria\n   * @returns Promise<void>\n   */\n  async registrarLogResilient(logData: CreateLogAuditoriaDto): Promise<void> {\n    const startTime = Date.now();\n\n    try {\n      // Estratégia 1: Processamento assíncrono via fila (preferencial)\n      await this.tryQueueProcessing(logData);\n\n      this.metrics.queueSuccesses++;\n      this.logger.debug(\n        `Log de auditoria enfileirado com sucesso em ${Date.now() - startTime}ms`,\n      );\n    } catch (queueError) {\n      this.metrics.queueFailures++;\n      this.logger.warn(`Falha na fila de auditoria: ${queueError.message}`);\n\n      if (this.enableSyncFallback) {\n        try {\n          // Estratégia 2: Fallback síncrono direto no banco\n          await this.trySyncProcessing(logData);\n\n          this.metrics.syncFallbacks++;\n          this.logger.debug(\n            `Log de auditoria registrado via fallback síncrono em ${Date.now() - startTime}ms`,\n          );\n        } catch (syncError) {\n          this.logger.error(`Falha no fallback síncrono: ${syncError.message}`);\n\n          if (this.enableFileBackup) {\n            // Estratégia 3: Backup em arquivo para recuperação posterior\n            await this.tryFileBackup(logData, { queueError, syncError });\n\n            this.metrics.fileBackups++;\n            this.logger.warn(\n              `Log de auditoria armazenado em backup para recuperação posterior`,\n            );\n          } else {\n            throw new Error(\n              `Falha crítica na auditoria: Queue=${queueError.message}, Sync=${syncError.message}`,\n            );\n          }\n        }\n      } else {\n        throw queueError;\n      }\n    }\n  }\n\n  /**\n   * Tenta processar via fila com timeout\n   */\n  private async tryQueueProcessing(\n    logData: CreateLogAuditoriaDto,\n  ): Promise<void> {\n    if (!this.auditoriaQueueService) {\n      throw new Error('AuditoriaQueueService não disponível');\n    }\n\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error('Timeout na fila de auditoria')), 2000);\n    });\n\n    const queuePromise =\n      this.auditoriaQueueService.enfileirarLogAuditoria(logData);\n\n    await Promise.race([queuePromise, timeoutPromise]);\n  }\n\n  /**\n   * Tenta processar diretamente no banco com timeout\n   */\n  private async trySyncProcessing(\n    logData: CreateLogAuditoriaDto,\n  ): Promise<void> {\n    if (!this.auditoriaService) {\n      throw new Error('AuditoriaService não disponível');\n    }\n\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error('Timeout no registro síncrono')), 5000);\n    });\n\n    const syncPromise = this.auditoriaService.create(logData);\n\n    await Promise.race([syncPromise, timeoutPromise]);\n  }\n\n  /**\n   * Armazena log de auditoria em arquivo para recuperação posterior\n   */\n  private async tryFileBackup(\n    logData: CreateLogAuditoriaDto,\n    errors: { queueError: Error; syncError: Error },\n  ): Promise<void> {\n    try {\n      const backupEntry: BackupLogEntry = {\n        id: this.generateBackupId(),\n        timestamp: new Date().toISOString(),\n        data: logData,\n        status: 'pending_recovery',\n        attempts: 0,\n      };\n\n      const backupFile = join(\n        this.backupPath,\n        `audit-backup-${new Date().toISOString().split('T')[0]}.jsonl`,\n      );\n      const logLine =\n        JSON.stringify({\n          ...backupEntry,\n          errors: {\n            queue: errors.queueError.message,\n            sync: errors.syncError.message,\n          },\n        }) + '\\n';\n\n      await fs.appendFile(backupFile, logLine, 'utf8');\n\n      this.logger.debug(`Log de auditoria salvo em backup: ${backupFile}`);\n    } catch (fileError) {\n      this.logger.error(\n        `Falha crítica: não foi possível armazenar log de auditoria em arquivo: ${fileError.message}`,\n      );\n      throw new Error(`Falha total na auditoria: ${fileError.message}`);\n    }\n  }\n\n  /**\n   * Job de recuperação que roda periodicamente\n   * Processa logs de auditoria que falharam anteriormente\n   */\n  @Cron('0 */5 * * * *') // A cada 5 minutos\n  async processBackupAuditLogs(): Promise<void> {\n    if (!this.enableFileBackup || !this.auditoriaService) {\n      return;\n    }\n\n    try {\n      this.logger.debug(\n        'Iniciando processo de recuperação de logs de auditoria',\n      );\n\n      const backupLogs = await this.readBackupLogs();\n\n      if (backupLogs.length === 0) {\n        return;\n      }\n\n      this.logger.log(`Encontrados ${backupLogs.length} logs para recuperação`);\n\n      let processedCount = 0;\n      let failedCount = 0;\n\n      for (const log of backupLogs) {\n        try {\n          // Tentar processar o log\n          await this.auditoriaService.create(log.data);\n\n          // Marcar como processado\n          await this.markLogAsProcessed(log.id);\n\n          processedCount++;\n          this.metrics.recoveredLogs++;\n        } catch (error) {\n          failedCount++;\n\n          // Incrementar tentativas\n          log.attempts++;\n\n          if (log.attempts >= this.maxRetries) {\n            this.logger.error(\n              `Log ${log.id} falhou após ${this.maxRetries} tentativas: ${error.message}`,\n            );\n            await this.markLogAsFailed(log.id);\n          } else {\n            this.logger.warn(\n              `Falha ao recuperar log ${log.id} (tentativa ${log.attempts}/${this.maxRetries}): ${error.message}`,\n            );\n            await this.updateLogAttempts(log.id, log.attempts);\n          }\n        }\n      }\n\n      if (processedCount > 0 || failedCount > 0) {\n        this.logger.log(\n          `Recuperação concluída: ${processedCount} processados, ${failedCount} falharam`,\n        );\n      }\n    } catch (error) {\n      this.logger.error(`Erro no processo de recuperação: ${error.message}`);\n    }\n  }\n\n  /**\n   * Lê logs de backup pendentes de recuperação\n   */\n  private async readBackupLogs(): Promise<BackupLogEntry[]> {\n    try {\n      const files = await fs.readdir(this.backupPath);\n      const backupFiles = files.filter(\n        (file) => file.startsWith('audit-backup-') && file.endsWith('.jsonl'),\n      );\n\n      const allLogs: BackupLogEntry[] = [];\n\n      for (const file of backupFiles) {\n        try {\n          const filePath = join(this.backupPath, file);\n          const content = await fs.readFile(filePath, 'utf8');\n\n          const lines = content\n            .trim()\n            .split('\\n')\n            .filter((line) => line.trim());\n\n          for (const line of lines) {\n            try {\n              const log = JSON.parse(line) as BackupLogEntry;\n\n              // Apenas logs pendentes de recuperação\n              if (\n                log.status === 'pending_recovery' &&\n                log.attempts < this.maxRetries\n              ) {\n                allLogs.push(log);\n              }\n            } catch (parseError) {\n              this.logger.warn(\n                `Erro ao parsear linha de backup: ${parseError.message}`,\n              );\n            }\n          }\n        } catch (fileError) {\n          this.logger.warn(\n            `Erro ao ler arquivo de backup ${file}: ${fileError.message}`,\n          );\n        }\n      }\n\n      return allLogs;\n    } catch (error) {\n      this.logger.error(`Erro ao ler logs de backup: ${error.message}`);\n      return [];\n    }\n  }\n\n  /**\n   * Marca log como processado com sucesso\n   */\n  private async markLogAsProcessed(logId: string): Promise<void> {\n    // Implementar marcação do log como processado\n    // Por simplicidade, podemos mover para um arquivo de logs processados\n    this.logger.debug(`Log ${logId} marcado como processado`);\n  }\n\n  /**\n   * Marca log como falha definitiva\n   */\n  private async markLogAsFailed(logId: string): Promise<void> {\n    // Implementar marcação do log como falha definitiva\n    this.logger.error(`Log ${logId} marcado como falha definitiva`);\n  }\n\n  /**\n   * Atualiza número de tentativas do log\n   */\n  private async updateLogAttempts(\n    logId: string,\n    attempts: number,\n  ): Promise<void> {\n    // Implementar atualização do número de tentativas\n    this.logger.debug(`Log ${logId} atualizado para ${attempts} tentativas`);\n  }\n\n  /**\n   * Gera ID único para entrada de backup\n   */\n  private generateBackupId(): string {\n    return `backup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Garante que o diretório de backup existe\n   */\n  private async ensureBackupDirectory(): Promise<void> {\n    try {\n      await fs.mkdir(this.backupPath, { recursive: true });\n    } catch (error) {\n      this.logger.error(`Erro ao criar diretório de backup: ${error.message}`);\n    }\n  }\n\n  /**\n   * Retorna métricas do serviço de auditoria resiliente\n   */\n  getMetrics() {\n    const total = this.metrics.queueSuccesses + this.metrics.queueFailures;\n\n    return {\n      ...this.metrics,\n      queueSuccessRate:\n        total > 0 ? (this.metrics.queueSuccesses / total) * 100 : 0,\n      fallbackUsageRate:\n        total > 0 ? (this.metrics.syncFallbacks / total) * 100 : 0,\n      backupUsageRate: total > 0 ? (this.metrics.fileBackups / total) * 100 : 0,\n    };\n  }\n\n  /**\n   * Reseta métricas (útil para testes)\n   */\n  resetMetrics(): void {\n    this.metrics = {\n      queueSuccesses: 0,\n      queueFailures: 0,\n      syncFallbacks: 0,\n      fileBackups: 0,\n      recoveredLogs: 0,\n    };\n  }\n}\n"],"version":3}