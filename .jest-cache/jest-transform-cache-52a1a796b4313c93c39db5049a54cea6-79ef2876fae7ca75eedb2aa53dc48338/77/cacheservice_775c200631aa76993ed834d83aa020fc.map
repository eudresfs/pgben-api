{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\shared\\cache\\cache.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\shared\\cache\\cache.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { InjectQueue } from '@nestjs/bull';\nimport { Queue } from 'bull';\nimport { ConfigService } from '@nestjs/config';\nimport { CacheMetricsProvider } from './cache-metrics.provider';\n\n// Estados do Circuit Breaker\nenum CircuitState {\n  CLOSED, // Funcionamento normal\n  OPEN, // Em falha, não tenta operações\n  HALF_OPEN, // Tentando recuperar\n}\n\n/**\n * Serviço de cache\n *\n * Implementa um sistema de cache utilizando o Redis através do Bull\n * para melhorar a performance de operações frequentes\n */\n@Injectable()\nexport class CacheService {\n  private readonly logger = new Logger(CacheService.name);\n  private readonly defaultTTL = 3600; // 1 hora em segundos\n\n  // Circuit Breaker configurações\n  private circuitState: CircuitState = CircuitState.CLOSED;\n  private failureCount: number = 0;\n  private readonly failureThreshold: number = 3; // Reduzido para 3 falhas para abrir o circuito mais rapidamente\n  private readonly resetTimeout: number = 10000; // 10 segundos para tentar recuperar (reduzido para resposta mais rápida)\n  private lastFailureTime: number = 0;\n  private inMemoryCache: Map<string, { value: any; expiry: number }> =\n    new Map();\n  private readonly localCacheTTL: number;\n\n  constructor(\n    @InjectQueue('cache') private readonly cacheQueue: Queue,\n    private readonly metricsProvider: CacheMetricsProvider,\n    private readonly configService: ConfigService,\n  ) {\n    // Verificar se o Redis está desabilitado via configuração\n    const disableRedis = this.configService.get('DISABLE_REDIS') === 'true';\n\n    // Carregar configurações do circuit breaker\n    this.failureThreshold = this.configService.get<number>(\n      'CACHE_CIRCUIT_BREAKER_THRESHOLD',\n      3,\n    );\n    this.resetTimeout = this.configService.get<number>(\n      'CACHE_CIRCUIT_BREAKER_RESET',\n      10000,\n    );\n    this.localCacheTTL = this.configService.get<number>('CACHE_LOCAL_TTL', 600);\n\n    if (disableRedis) {\n      this.logger.warn('Redis está desabilitado. Usando apenas cache local.');\n      this.circuitState = CircuitState.OPEN; // Forçar uso do cache local\n    }\n\n    // Verificar conexão com Redis na inicialização\n    this.checkRedisConnection();\n  }\n\n  /**\n   * Verifica a conexão com o Redis na inicialização\n   * @private\n   */\n  private async checkRedisConnection(): Promise<void> {\n    try {\n      // Definir um timeout para evitar bloqueio\n      const timeoutPromise = new Promise<void>((_, reject) => {\n        setTimeout(\n          () => reject(new Error('Timeout ao verificar conexão com Redis')),\n          2000,\n        );\n      });\n\n      const pingPromise = this.cacheQueue.client.ping();\n\n      await Promise.race([pingPromise, timeoutPromise]);\n      this.logger.log('Conexão com Redis estabelecida com sucesso');\n    } catch (error) {\n      this.logger.error(\n        `Erro ao conectar com Redis: ${error.message}. Usando cache local.`,\n        error.stack,\n      );\n      // Abrir o circuit breaker para usar cache local\n      this.circuitState = CircuitState.OPEN;\n    }\n  }\n\n  /**\n   * Verifica o estado do circuit breaker e atualiza conforme necessário\n   * @private\n   */\n  private checkCircuitState(): void {\n    const now = Date.now();\n\n    // Se estiver aberto, verificar se já passou o tempo para tentar recuperar\n    if (this.circuitState === CircuitState.OPEN) {\n      if (now - this.lastFailureTime > this.resetTimeout) {\n        this.logger.log(\n          'Circuit Breaker mudando para estado HALF_OPEN, tentando recuperar',\n        );\n        this.circuitState = CircuitState.HALF_OPEN;\n        // Resetar contador de falhas ao tentar recuperar\n        this.failureCount = 0;\n\n        // Registrar métrica de recuperação\n        this.metricsProvider.registerCacheRecoveryAttempt();\n      }\n    }\n  }\n\n  /**\n   * Registra uma falha no circuit breaker\n   * @private\n   */\n  private registerFailure(): void {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n\n    // Registrar métrica de falha\n    this.metricsProvider.registerCacheFailure();\n\n    if (\n      this.failureCount >= this.failureThreshold &&\n      this.circuitState === CircuitState.CLOSED\n    ) {\n      this.logger.warn(\n        `Circuit Breaker mudando para estado OPEN após ${this.failureCount} falhas`,\n      );\n      this.circuitState = CircuitState.OPEN;\n\n      // Limpar fila de cache quando o circuito abrir para evitar acumular operações pendentes\n      this.clearCacheQueue().catch((err) => {\n        this.logger.error(\n          `Erro ao limpar fila de cache: ${err.message}`,\n          err.stack,\n        );\n      });\n    }\n  }\n\n  /**\n   * Limpa a fila de cache para evitar acumular operações pendentes\n   * @private\n   */\n  private async clearCacheQueue(): Promise<void> {\n    try {\n      // Definir um timeout para evitar bloqueio\n      const timeoutPromise = new Promise<void>((_, reject) => {\n        setTimeout(\n          () => reject(new Error('Timeout ao limpar fila de cache')),\n          1000,\n        );\n      });\n\n      const cleanPromise = Promise.all([\n        this.cacheQueue.clean(0, 'delayed'),\n        this.cacheQueue.clean(0, 'wait'),\n      ]);\n\n      await Promise.race([cleanPromise, timeoutPromise]);\n      this.logger.log('Fila de cache limpa com sucesso');\n    } catch (error) {\n      this.logger.error(\n        `Erro ao limpar fila de cache: ${error.message}`,\n        error.stack,\n      );\n      // Forçar o fechamento do circuito em caso de erro ao limpar a fila\n      // Isso é importante para evitar que o sistema continue tentando usar o Redis\n      this.circuitState = CircuitState.OPEN;\n    }\n  }\n\n  /**\n   * Registra um sucesso no circuit breaker\n   * @private\n   */\n  private registerSuccess(): void {\n    if (this.circuitState === CircuitState.HALF_OPEN) {\n      this.logger.log(\n        'Circuit Breaker recuperado, voltando para estado CLOSED',\n      );\n      this.circuitState = CircuitState.CLOSED;\n      this.failureCount = 0;\n    } else if (this.circuitState === CircuitState.CLOSED) {\n      // Resetar contador de falhas gradualmente em caso de sucesso\n      this.failureCount = Math.max(0, this.failureCount - 1);\n    }\n  }\n\n  /**\n   * Salva um valor no cache local em memória\n   * @private\n   */\n  private setLocalCache<T>(\n    key: string,\n    value: T,\n    ttl: number = this.localCacheTTL,\n  ): void {\n    const expiry = Date.now() + ttl * 1000;\n    this.inMemoryCache.set(key, { value, expiry });\n  }\n\n  /**\n   * Obtém um valor do cache local em memória\n   * @private\n   */\n  private getLocalCache<T>(key: string): T | null {\n    const cached = this.inMemoryCache.get(key);\n    if (!cached) {\n      return null;\n    }\n\n    if (Date.now() > cached.expiry) {\n      this.inMemoryCache.delete(key);\n      return null;\n    }\n\n    return cached.value as T;\n  }\n\n  async get<T>(key: string): Promise<T | null> {\n    // Primeiro verificar cache local (mais rápido e sem dependência do Redis)\n    const localValue = this.getLocalCache<T>(key);\n    if (localValue !== null) {\n      this.metricsProvider.registerCacheHit();\n      return localValue;\n    }\n\n    // Verificar o estado do circuit breaker\n    this.checkCircuitState();\n\n    // Se o circuit breaker estiver aberto, não tentar Redis e retornar null\n    if (this.circuitState === CircuitState.OPEN) {\n      this.logger.debug(\n        `Circuit breaker aberto, não tentando Redis para chave: ${key}`,\n      );\n      this.metricsProvider.registerCacheMiss();\n      return null;\n    }\n\n    try {\n      const job = await this.cacheQueue.getJob(key);\n\n      if (!job) {\n        // Cache miss\n        this.metricsProvider.registerCacheMiss();\n        this.registerSuccess(); // Operação concluída com sucesso (mesmo que seja um miss)\n        return null;\n      }\n\n      const jobData = await job.data;\n\n      // Verificar se o job expirou\n      if (job.finishedOn && Date.now() > job.finishedOn) {\n        await job.remove();\n        this.metricsProvider.registerCacheMiss();\n        this.registerSuccess(); // Operação concluída com sucesso\n        return null;\n      }\n\n      // Cache hit - armazenar também no cache local\n      const value = jobData.value as T;\n      this.setLocalCache(key, value);\n      this.metricsProvider.registerCacheHit();\n      this.registerSuccess(); // Operação concluída com sucesso\n      return value;\n    } catch (error) {\n      this.logger.error(\n        `Erro ao obter valor do cache: ${error.message}`,\n        error.stack,\n      );\n      this.registerFailure(); // Registrar falha para o circuit breaker\n      this.metricsProvider.registerCacheMiss();\n\n      // Se for um erro de timeout, tentar obter o valor do cache local novamente\n      // Isso pode acontecer se o valor for adicionado ao cache local por outra thread\n      if (error.message && error.message.includes('Timeout')) {\n        const retryLocalValue = this.getLocalCache<T>(key);\n        if (retryLocalValue !== null) {\n          this.logger.debug(\n            `Valor encontrado no cache local após timeout: ${key}`,\n          );\n          return retryLocalValue;\n        }\n      }\n\n      return null;\n    }\n  }\n\n  /**\n   * Armazena um valor no cache\n   * @param key Chave para armazenar o valor\n   * @param value Valor a ser armazenado\n   * @param ttl Tempo de vida em segundos (padrão: 1 hora)\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttl: number = this.defaultTTL,\n  ): Promise<void> {\n    // Armazenar no cache local primeiro (mais rápido e sem dependência do Redis)\n    this.setLocalCache(key, value, ttl);\n\n    // Verificar o estado do circuit breaker\n    this.checkCircuitState();\n\n    // Se o circuit breaker estiver aberto, não tentar Redis\n    if (this.circuitState === CircuitState.OPEN) {\n      this.logger.debug(\n        `Circuit breaker aberto, não tentando Redis para chave: ${key}`,\n      );\n      return;\n    }\n\n    try {\n      // Timeout para evitar bloqueio da thread principal\n      const timeoutPromise = new Promise<void>((_, reject) => {\n        setTimeout(\n          () => reject(new Error('Timeout ao armazenar no cache')),\n          500,\n        );\n      });\n\n      const cachePromise = (async () => {\n        // Remover job existente com a mesma chave\n        const existingJob = await this.cacheQueue.getJob(key);\n        if (existingJob) {\n          await existingJob.remove();\n        }\n\n        // Criar novo job com os dados\n        await this.cacheQueue.add(\n          { value },\n          {\n            jobId: key,\n            removeOnComplete: ttl,\n            removeOnFail: true,\n          },\n        );\n      })();\n\n      // Usar race para evitar bloqueio por tempo indefinido\n      await Promise.race([cachePromise, timeoutPromise]);\n\n      // Registrar operação de set no cache\n      this.metricsProvider.registerCacheSet();\n      this.registerSuccess(); // Operação concluída com sucesso\n    } catch (error) {\n      this.logger.error(\n        `Erro ao armazenar valor no cache: ${error.message}`,\n        error.stack,\n      );\n      this.registerFailure(); // Registrar falha para o circuit breaker\n    }\n  }\n\n  /**\n   * Remove um valor do cache\n   * @param key Chave do valor a ser removido\n   */\n  async del(key: string): Promise<void> {\n    // Remover do cache local\n    this.inMemoryCache.delete(key);\n\n    // Verificar o estado do circuit breaker\n    this.checkCircuitState();\n\n    // Se o circuit breaker estiver aberto, não tentar Redis\n    if (this.circuitState === CircuitState.OPEN) {\n      return;\n    }\n\n    try {\n      // Timeout para evitar bloqueio da thread principal\n      const timeoutPromise = new Promise<void>((_, reject) => {\n        setTimeout(() => reject(new Error('Timeout ao remover do cache')), 500);\n      });\n\n      const cachePromise = (async () => {\n        const job = await this.cacheQueue.getJob(key);\n        if (job) {\n          await job.remove();\n        }\n      })();\n\n      // Usar race para evitar bloqueio por tempo indefinido\n      await Promise.race([cachePromise, timeoutPromise]);\n\n      // Registrar operação de delete no cache\n      this.metricsProvider.registerCacheDelete();\n      this.registerSuccess(); // Operação concluída com sucesso\n    } catch (error) {\n      this.logger.error(\n        `Erro ao remover valor do cache: ${error.message}`,\n        error.stack,\n      );\n      this.registerFailure(); // Registrar falha para o circuit breaker\n    }\n  }\n\n  /**\n   * Verifica se uma chave existe no cache\n   * @param key Chave a ser verificada\n   * @returns true se a chave existir, false caso contrário\n   */\n  async has(key: string): Promise<boolean> {\n    // Verificar primeiro no cache local\n    if (this.getLocalCache(key) !== null) {\n      return true;\n    }\n\n    // Verificar o estado do circuit breaker\n    this.checkCircuitState();\n\n    // Se o circuit breaker estiver aberto, retornar apenas resultado do cache local\n    if (this.circuitState === CircuitState.OPEN) {\n      return false;\n    }\n\n    try {\n      const job = await this.cacheQueue.getJob(key);\n      const exists = !!job;\n      this.registerSuccess(); // Operação concluída com sucesso\n      return exists;\n    } catch (error) {\n      this.logger.error(\n        `Erro ao verificar existência no cache: ${error.message}`,\n        error.stack,\n      );\n      this.registerFailure(); // Registrar falha para o circuit breaker\n      return false;\n    }\n  }\n\n  /**\n   * Limpa todo o cache\n   */\n  async clear(): Promise<void> {\n    // Limpar cache local\n    this.inMemoryCache.clear();\n\n    // Verificar o estado do circuit breaker\n    this.checkCircuitState();\n\n    // Se o circuit breaker estiver aberto, não tentar Redis\n    if (this.circuitState === CircuitState.OPEN) {\n      return;\n    }\n\n    try {\n      // Timeout para evitar bloqueio da thread principal\n      const timeoutPromise = new Promise<void>((_, reject) => {\n        setTimeout(() => reject(new Error('Timeout ao limpar cache')), 1000);\n      });\n\n      const cachePromise = this.cacheQueue.empty();\n\n      // Usar race para evitar bloqueio por tempo indefinido\n      await Promise.race([cachePromise, timeoutPromise]);\n\n      // Registrar operação de clear no cache\n      this.metricsProvider.registerCacheClear();\n      this.registerSuccess(); // Operação concluída com sucesso\n    } catch (error) {\n      this.logger.error(`Erro ao limpar cache: ${error.message}`, error.stack);\n      this.registerFailure(); // Registrar falha para o circuit breaker\n    }\n  }\n\n  /**\n   * Obtém o estado atual do circuit breaker\n   * @returns Estado atual do circuit breaker\n   */\n  getCircuitState(): string {\n    switch (this.circuitState) {\n      case CircuitState.CLOSED:\n        return 'CLOSED';\n      case CircuitState.OPEN:\n        return 'OPEN';\n      case CircuitState.HALF_OPEN:\n        return 'HALF_OPEN';\n      default:\n        return 'UNKNOWN';\n    }\n  }\n\n  /**\n   * Força o fechamento do circuit breaker, útil para recuperação manual\n   */\n  forceCloseCircuit(): void {\n    this.circuitState = CircuitState.CLOSED;\n    this.failureCount = 0;\n    this.logger.log('Circuit Breaker forçado para estado CLOSED manualmente');\n  }\n\n  /**\n   * Obtém estatísticas do circuit breaker\n   * @returns Estatísticas do circuit breaker\n   */\n  getCircuitStats(): any {\n    return {\n      state: this.getCircuitState(),\n      failureCount: this.failureCount,\n      lastFailureTime: this.lastFailureTime,\n      localCacheSize: this.inMemoryCache.size,\n      thresholdConfig: {\n        failureThreshold: this.failureThreshold,\n        resetTimeoutMs: this.resetTimeout,\n      },\n    };\n  }\n}\n"],"version":3}