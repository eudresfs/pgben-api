3c95ceace8f81e96f1a140a87628209a
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CacheService_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheService = void 0;
const common_1 = require("@nestjs/common");
const bull_1 = require("@nestjs/bull");
const bull_2 = require("bull");
const config_1 = require("@nestjs/config");
const cache_metrics_provider_1 = require("./cache-metrics.provider");
// Estados do Circuit Breaker
var CircuitState;
(function (CircuitState) {
    CircuitState[CircuitState["CLOSED"] = 0] = "CLOSED";
    CircuitState[CircuitState["OPEN"] = 1] = "OPEN";
    CircuitState[CircuitState["HALF_OPEN"] = 2] = "HALF_OPEN";
})(CircuitState || (CircuitState = {}));
/**
 * Serviço de cache
 *
 * Implementa um sistema de cache utilizando o Redis através do Bull
 * para melhorar a performance de operações frequentes
 */
let CacheService = CacheService_1 = class CacheService {
    cacheQueue;
    metricsProvider;
    configService;
    logger = new common_1.Logger(CacheService_1.name);
    defaultTTL = 3600; // 1 hora em segundos
    // Circuit Breaker configurações
    circuitState = CircuitState.CLOSED;
    failureCount = 0;
    failureThreshold = 3; // Reduzido para 3 falhas para abrir o circuito mais rapidamente
    resetTimeout = 10000; // 10 segundos para tentar recuperar (reduzido para resposta mais rápida)
    lastFailureTime = 0;
    inMemoryCache = new Map();
    localCacheTTL;
    constructor(cacheQueue, metricsProvider, configService) {
        this.cacheQueue = cacheQueue;
        this.metricsProvider = metricsProvider;
        this.configService = configService;
        // Verificar se o Redis está desabilitado via configuração
        const disableRedis = this.configService.get('DISABLE_REDIS') === 'true';
        // Carregar configurações do circuit breaker
        this.failureThreshold = this.configService.get('CACHE_CIRCUIT_BREAKER_THRESHOLD', 3);
        this.resetTimeout = this.configService.get('CACHE_CIRCUIT_BREAKER_RESET', 10000);
        this.localCacheTTL = this.configService.get('CACHE_LOCAL_TTL', 600);
        if (disableRedis) {
            this.logger.warn('Redis está desabilitado. Usando apenas cache local.');
            this.circuitState = CircuitState.OPEN; // Forçar uso do cache local
        }
        // Verificar conexão com Redis na inicialização
        this.checkRedisConnection();
    }
    /**
     * Verifica a conexão com o Redis na inicialização
     * @private
     */
    async checkRedisConnection() {
        try {
            // Definir um timeout para evitar bloqueio
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Timeout ao verificar conexão com Redis')), 2000);
            });
            const pingPromise = this.cacheQueue.client.ping();
            await Promise.race([pingPromise, timeoutPromise]);
            this.logger.log('Conexão com Redis estabelecida com sucesso');
        }
        catch (error) {
            this.logger.error(`Erro ao conectar com Redis: ${error.message}. Usando cache local.`, error.stack);
            // Abrir o circuit breaker para usar cache local
            this.circuitState = CircuitState.OPEN;
        }
    }
    /**
     * Verifica o estado do circuit breaker e atualiza conforme necessário
     * @private
     */
    checkCircuitState() {
        const now = Date.now();
        // Se estiver aberto, verificar se já passou o tempo para tentar recuperar
        if (this.circuitState === CircuitState.OPEN) {
            if (now - this.lastFailureTime > this.resetTimeout) {
                this.logger.log('Circuit Breaker mudando para estado HALF_OPEN, tentando recuperar');
                this.circuitState = CircuitState.HALF_OPEN;
                // Resetar contador de falhas ao tentar recuperar
                this.failureCount = 0;
                // Registrar métrica de recuperação
                this.metricsProvider.registerCacheRecoveryAttempt();
            }
        }
    }
    /**
     * Registra uma falha no circuit breaker
     * @private
     */
    registerFailure() {
        this.failureCount++;
        this.lastFailureTime = Date.now();
        // Registrar métrica de falha
        this.metricsProvider.registerCacheFailure();
        if (this.failureCount >= this.failureThreshold &&
            this.circuitState === CircuitState.CLOSED) {
            this.logger.warn(`Circuit Breaker mudando para estado OPEN após ${this.failureCount} falhas`);
            this.circuitState = CircuitState.OPEN;
            // Limpar fila de cache quando o circuito abrir para evitar acumular operações pendentes
            this.clearCacheQueue().catch((err) => {
                this.logger.error(`Erro ao limpar fila de cache: ${err.message}`, err.stack);
            });
        }
    }
    /**
     * Limpa a fila de cache para evitar acumular operações pendentes
     * @private
     */
    async clearCacheQueue() {
        try {
            // Definir um timeout para evitar bloqueio
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Timeout ao limpar fila de cache')), 1000);
            });
            const cleanPromise = Promise.all([
                this.cacheQueue.clean(0, 'delayed'),
                this.cacheQueue.clean(0, 'wait'),
            ]);
            await Promise.race([cleanPromise, timeoutPromise]);
            this.logger.log('Fila de cache limpa com sucesso');
        }
        catch (error) {
            this.logger.error(`Erro ao limpar fila de cache: ${error.message}`, error.stack);
            // Forçar o fechamento do circuito em caso de erro ao limpar a fila
            // Isso é importante para evitar que o sistema continue tentando usar o Redis
            this.circuitState = CircuitState.OPEN;
        }
    }
    /**
     * Registra um sucesso no circuit breaker
     * @private
     */
    registerSuccess() {
        if (this.circuitState === CircuitState.HALF_OPEN) {
            this.logger.log('Circuit Breaker recuperado, voltando para estado CLOSED');
            this.circuitState = CircuitState.CLOSED;
            this.failureCount = 0;
        }
        else if (this.circuitState === CircuitState.CLOSED) {
            // Resetar contador de falhas gradualmente em caso de sucesso
            this.failureCount = Math.max(0, this.failureCount - 1);
        }
    }
    /**
     * Salva um valor no cache local em memória
     * @private
     */
    setLocalCache(key, value, ttl = this.localCacheTTL) {
        const expiry = Date.now() + ttl * 1000;
        this.inMemoryCache.set(key, { value, expiry });
    }
    /**
     * Obtém um valor do cache local em memória
     * @private
     */
    getLocalCache(key) {
        const cached = this.inMemoryCache.get(key);
        if (!cached) {
            return null;
        }
        if (Date.now() > cached.expiry) {
            this.inMemoryCache.delete(key);
            return null;
        }
        return cached.value;
    }
    async get(key) {
        // Primeiro verificar cache local (mais rápido e sem dependência do Redis)
        const localValue = this.getLocalCache(key);
        if (localValue !== null) {
            this.metricsProvider.registerCacheHit();
            return localValue;
        }
        // Verificar o estado do circuit breaker
        this.checkCircuitState();
        // Se o circuit breaker estiver aberto, não tentar Redis e retornar null
        if (this.circuitState === CircuitState.OPEN) {
            this.logger.debug(`Circuit breaker aberto, não tentando Redis para chave: ${key}`);
            this.metricsProvider.registerCacheMiss();
            return null;
        }
        try {
            const job = await this.cacheQueue.getJob(key);
            if (!job) {
                // Cache miss
                this.metricsProvider.registerCacheMiss();
                this.registerSuccess(); // Operação concluída com sucesso (mesmo que seja um miss)
                return null;
            }
            const jobData = await job.data;
            // Verificar se o job expirou
            if (job.finishedOn && Date.now() > job.finishedOn) {
                await job.remove();
                this.metricsProvider.registerCacheMiss();
                this.registerSuccess(); // Operação concluída com sucesso
                return null;
            }
            // Cache hit - armazenar também no cache local
            const value = jobData.value;
            this.setLocalCache(key, value);
            this.metricsProvider.registerCacheHit();
            this.registerSuccess(); // Operação concluída com sucesso
            return value;
        }
        catch (error) {
            this.logger.error(`Erro ao obter valor do cache: ${error.message}`, error.stack);
            this.registerFailure(); // Registrar falha para o circuit breaker
            this.metricsProvider.registerCacheMiss();
            // Se for um erro de timeout, tentar obter o valor do cache local novamente
            // Isso pode acontecer se o valor for adicionado ao cache local por outra thread
            if (error.message && error.message.includes('Timeout')) {
                const retryLocalValue = this.getLocalCache(key);
                if (retryLocalValue !== null) {
                    this.logger.debug(`Valor encontrado no cache local após timeout: ${key}`);
                    return retryLocalValue;
                }
            }
            return null;
        }
    }
    /**
     * Armazena um valor no cache
     * @param key Chave para armazenar o valor
     * @param value Valor a ser armazenado
     * @param ttl Tempo de vida em segundos (padrão: 1 hora)
     */
    async set(key, value, ttl = this.defaultTTL) {
        // Armazenar no cache local primeiro (mais rápido e sem dependência do Redis)
        this.setLocalCache(key, value, ttl);
        // Verificar o estado do circuit breaker
        this.checkCircuitState();
        // Se o circuit breaker estiver aberto, não tentar Redis
        if (this.circuitState === CircuitState.OPEN) {
            this.logger.debug(`Circuit breaker aberto, não tentando Redis para chave: ${key}`);
            return;
        }
        try {
            // Timeout para evitar bloqueio da thread principal
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Timeout ao armazenar no cache')), 500);
            });
            const cachePromise = (async () => {
                // Remover job existente com a mesma chave
                const existingJob = await this.cacheQueue.getJob(key);
                if (existingJob) {
                    await existingJob.remove();
                }
                // Criar novo job com os dados
                await this.cacheQueue.add({ value }, {
                    jobId: key,
                    removeOnComplete: ttl,
                    removeOnFail: true,
                });
            })();
            // Usar race para evitar bloqueio por tempo indefinido
            await Promise.race([cachePromise, timeoutPromise]);
            // Registrar operação de set no cache
            this.metricsProvider.registerCacheSet();
            this.registerSuccess(); // Operação concluída com sucesso
        }
        catch (error) {
            this.logger.error(`Erro ao armazenar valor no cache: ${error.message}`, error.stack);
            this.registerFailure(); // Registrar falha para o circuit breaker
        }
    }
    /**
     * Remove um valor do cache
     * @param key Chave do valor a ser removido
     */
    async del(key) {
        // Remover do cache local
        this.inMemoryCache.delete(key);
        // Verificar o estado do circuit breaker
        this.checkCircuitState();
        // Se o circuit breaker estiver aberto, não tentar Redis
        if (this.circuitState === CircuitState.OPEN) {
            return;
        }
        try {
            // Timeout para evitar bloqueio da thread principal
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Timeout ao remover do cache')), 500);
            });
            const cachePromise = (async () => {
                const job = await this.cacheQueue.getJob(key);
                if (job) {
                    await job.remove();
                }
            })();
            // Usar race para evitar bloqueio por tempo indefinido
            await Promise.race([cachePromise, timeoutPromise]);
            // Registrar operação de delete no cache
            this.metricsProvider.registerCacheDelete();
            this.registerSuccess(); // Operação concluída com sucesso
        }
        catch (error) {
            this.logger.error(`Erro ao remover valor do cache: ${error.message}`, error.stack);
            this.registerFailure(); // Registrar falha para o circuit breaker
        }
    }
    /**
     * Verifica se uma chave existe no cache
     * @param key Chave a ser verificada
     * @returns true se a chave existir, false caso contrário
     */
    async has(key) {
        // Verificar primeiro no cache local
        if (this.getLocalCache(key) !== null) {
            return true;
        }
        // Verificar o estado do circuit breaker
        this.checkCircuitState();
        // Se o circuit breaker estiver aberto, retornar apenas resultado do cache local
        if (this.circuitState === CircuitState.OPEN) {
            return false;
        }
        try {
            const job = await this.cacheQueue.getJob(key);
            const exists = !!job;
            this.registerSuccess(); // Operação concluída com sucesso
            return exists;
        }
        catch (error) {
            this.logger.error(`Erro ao verificar existência no cache: ${error.message}`, error.stack);
            this.registerFailure(); // Registrar falha para o circuit breaker
            return false;
        }
    }
    /**
     * Limpa todo o cache
     */
    async clear() {
        // Limpar cache local
        this.inMemoryCache.clear();
        // Verificar o estado do circuit breaker
        this.checkCircuitState();
        // Se o circuit breaker estiver aberto, não tentar Redis
        if (this.circuitState === CircuitState.OPEN) {
            return;
        }
        try {
            // Timeout para evitar bloqueio da thread principal
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Timeout ao limpar cache')), 1000);
            });
            const cachePromise = this.cacheQueue.empty();
            // Usar race para evitar bloqueio por tempo indefinido
            await Promise.race([cachePromise, timeoutPromise]);
            // Registrar operação de clear no cache
            this.metricsProvider.registerCacheClear();
            this.registerSuccess(); // Operação concluída com sucesso
        }
        catch (error) {
            this.logger.error(`Erro ao limpar cache: ${error.message}`, error.stack);
            this.registerFailure(); // Registrar falha para o circuit breaker
        }
    }
    /**
     * Obtém o estado atual do circuit breaker
     * @returns Estado atual do circuit breaker
     */
    getCircuitState() {
        switch (this.circuitState) {
            case CircuitState.CLOSED:
                return 'CLOSED';
            case CircuitState.OPEN:
                return 'OPEN';
            case CircuitState.HALF_OPEN:
                return 'HALF_OPEN';
            default:
                return 'UNKNOWN';
        }
    }
    /**
     * Força o fechamento do circuit breaker, útil para recuperação manual
     */
    forceCloseCircuit() {
        this.circuitState = CircuitState.CLOSED;
        this.failureCount = 0;
        this.logger.log('Circuit Breaker forçado para estado CLOSED manualmente');
    }
    /**
     * Obtém estatísticas do circuit breaker
     * @returns Estatísticas do circuit breaker
     */
    getCircuitStats() {
        return {
            state: this.getCircuitState(),
            failureCount: this.failureCount,
            lastFailureTime: this.lastFailureTime,
            localCacheSize: this.inMemoryCache.size,
            thresholdConfig: {
                failureThreshold: this.failureThreshold,
                resetTimeoutMs: this.resetTimeout,
            },
        };
    }
};
exports.CacheService = CacheService;
exports.CacheService = CacheService = CacheService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, bull_1.InjectQueue)('cache')),
    __metadata("design:paramtypes", [typeof (_a = typeof bull_2.Queue !== "undefined" && bull_2.Queue) === "function" ? _a : Object, typeof (_b = typeof cache_metrics_provider_1.CacheMetricsProvider !== "undefined" && cache_metrics_provider_1.CacheMetricsProvider) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object])
], CacheService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXHNoYXJlZFxcY2FjaGVcXGNhY2hlLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBb0Q7QUFDcEQsdUNBQTJDO0FBQzNDLCtCQUE2QjtBQUM3QiwyQ0FBK0M7QUFDL0MscUVBQWdFO0FBRWhFLDZCQUE2QjtBQUM3QixJQUFLLFlBSUo7QUFKRCxXQUFLLFlBQVk7SUFDZixtREFBTSxDQUFBO0lBQ04sK0NBQUksQ0FBQTtJQUNKLHlEQUFTLENBQUE7QUFDWCxDQUFDLEVBSkksWUFBWSxLQUFaLFlBQVksUUFJaEI7QUFFRDs7Ozs7R0FLRztBQUVJLElBQU0sWUFBWSxvQkFBbEIsTUFBTSxZQUFZO0lBZWtCO0lBQ3RCO0lBQ0E7SUFoQkYsTUFBTSxHQUFHLElBQUksZUFBTSxDQUFDLGNBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2QyxVQUFVLEdBQUcsSUFBSSxDQUFDLENBQUMscUJBQXFCO0lBRXpELGdDQUFnQztJQUN4QixZQUFZLEdBQWlCLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDakQsWUFBWSxHQUFXLENBQUMsQ0FBQztJQUNoQixnQkFBZ0IsR0FBVyxDQUFDLENBQUMsQ0FBQyxnRUFBZ0U7SUFDOUYsWUFBWSxHQUFXLEtBQUssQ0FBQyxDQUFDLHlFQUF5RTtJQUNoSCxlQUFlLEdBQVcsQ0FBQyxDQUFDO0lBQzVCLGFBQWEsR0FDbkIsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNLLGFBQWEsQ0FBUztJQUV2QyxZQUN5QyxVQUFpQixFQUN2QyxlQUFxQyxFQUNyQyxhQUE0QjtRQUZOLGVBQVUsR0FBVixVQUFVLENBQU87UUFDdkMsb0JBQWUsR0FBZixlQUFlLENBQXNCO1FBQ3JDLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBRTdDLDBEQUEwRDtRQUMxRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFD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LFlBQVksR0FBRyxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsd0RBQXdELENBQUMsQ0FBQztJQUM1RSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsZUFBZTtRQUNiLE9BQU87WUFDTCxLQUFLLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUM3QixZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7WUFDL0IsZUFBZSxFQUFFLElBQUksQ0FBQyxlQUFlO1lBQ3JDLGNBQWMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUk7WUFDdkMsZUFBZSxFQUFFO2dCQUNmLGdCQUFnQixFQUFFLElBQUksQ0FBQyxnQkFBZ0I7Z0JBQ3ZDLGNBQWMsRUFBRSxJQUFJLENBQUMsWUFBWTthQUNsQztTQUNGLENBQUM7SUFDSixDQUFDO0NBQ0YsQ0FBQTtBQS9lWSxvQ0FBWTt1QkFBWixZQUFZO0lBRHhCLElBQUEsbUJBQVUsR0FBRTtJQWdCUixXQUFBLElBQUEsa0JBQVcsRUFBQyxPQUFPLENBQUMsQ0FBQTt5REFBOEIsWUFBSyxvQkFBTCxZQUFLLG9EQUN0Qiw2Q0FBb0Isb0JBQXBCLDZDQUFvQixvREFDdEIsc0JBQWEsb0JBQWIsc0JBQWE7R0FqQnBDLFlBQVksQ0ErZXhCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZXVkcmVcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxzaGFyZWRcXGNhY2hlXFxjYWNoZS5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIExvZ2dlciB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IEluamVjdFF1ZXVlIH0gZnJvbSAnQG5lc3Rqcy9idWxsJztcbmltcG9ydCB7IFF1ZXVlIH0gZnJvbSAnYnVsbCc7XG5pbXBvcnQgeyBDb25maWdTZXJ2aWNlIH0gZnJvbSAnQG5lc3Rqcy9jb25maWcnO1xuaW1wb3J0IHsgQ2FjaGVNZXRyaWNzUHJvdmlkZXIgfSBmcm9tICcuL2NhY2hlLW1ldHJpY3MucHJvdmlkZXInO1xuXG4vLyBFc3RhZG9zIGRvIENpcmN1aXQgQnJlYWtlclxuZW51bSBDaXJjdWl0U3RhdGUge1xuICBDTE9TRUQsIC8vIEZ1bmNpb25hbWVudG8gbm9ybWFsXG4gIE9QRU4sIC8vIEVtIGZhbGhhLCBuw6NvIHRlbnRhIG9wZXJhw6fDtWVzXG4gIEhBTEZfT1BFTiwgLy8gVGVudGFuZG8gcmVjdXBlcmFyXG59XG5cbi8qKlxuICogU2VydmnDp28gZGUgY2FjaGVcbiAqXG4gKiBJbXBsZW1lbnRhIHVtIHNpc3RlbWEgZGUgY2FjaGUgdXRpbGl6YW5kbyBvIFJlZGlzIGF0cmF2w6lzIGRvIEJ1bGxcbiAqIHBhcmEgbWVsaG9yYXIgYSBwZXJmb3JtYW5jZSBkZSBvcGVyYcOnw7VlcyBmcmVxdWVudGVzXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDYWNoZVNlcnZpY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlciA9IG5ldyBMb2dnZXIoQ2FjaGVTZXJ2aWNlLm5hbWUpO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRUVEwgPSAzNjAwOyAvLyAxIGhvcmEgZW0gc2VndW5kb3NcblxuICAvLyBDaXJjdWl0IEJyZWFrZXIgY29uZmlndXJhw6fDtWVzXG4gIHByaXZhdGUgY2lyY3VpdFN0YXRlOiBDaXJjdWl0U3RhdGUgPSBDaXJjdWl0U3RhdGUuQ0xPU0VEO1xuICBwcml2YXRlIGZhaWx1cmVDb3VudDogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSByZWFkb25seSBmYWlsdXJlVGhyZXNob2xkOiBudW1iZXIgPSAzOyAvLyBSZWR1emlkbyBwYXJhIDMgZmFsaGFzIHBhcmEgYWJyaXIgbyBjaXJjdWl0byBtYWlzIHJhcGlkYW1lbnRlXG4gIHByaXZhdGUgcmVhZG9ubHkgcmVzZXRUaW1lb3V0OiBudW1iZXIgPSAxMDAwMDsgLy8gMTAgc2VndW5kb3MgcGFyYSB0ZW50YXIgcmVjdXBlcmFyIChyZWR1emlkbyBwYXJhIHJlc3Bvc3RhIG1haXMgcsOhcGlkYSlcbiAgcHJpdmF0ZSBsYXN0RmFpbHVyZVRpbWU6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgaW5NZW1vcnlDYWNoZTogTWFwPHN0cmluZywgeyB2YWx1ZTogYW55OyBleHBpcnk6IG51bWJlciB9PiA9XG4gICAgbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlYWRvbmx5IGxvY2FsQ2FjaGVUVEw6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0UXVldWUoJ2NhY2hlJykgcHJpdmF0ZSByZWFkb25seSBjYWNoZVF1ZXVlOiBRdWV1ZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1ldHJpY3NQcm92aWRlcjogQ2FjaGVNZXRyaWNzUHJvdmlkZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb25maWdTZXJ2aWNlOiBDb25maWdTZXJ2aWNlLFxuICApIHtcbiAgICAvLyBWZXJpZmljYXIgc2UgbyBSZWRpcyBlc3TDoSBkZXNhYmlsaXRhZG8gdmlhIGNvbmZpZ3VyYcOnw6NvXG4gICAgY29uc3QgZGlzYWJsZVJlZGlzID0gdGhpcy5jb25maWdTZXJ2aWNlLmdldCgnRElTQUJMRV9SRURJUycpID09PSAndHJ1ZSc7XG5cbiAgICAvLyBDYXJyZWdhciBjb25maWd1cmHDp8O1ZXMgZG8gY2lyY3VpdCBicmVha2VyXG4gICAgdGhpcy5mYWlsdXJlVGhyZXNob2xkID0gdGhpcy5jb25maWdTZXJ2aWNlLmdldDxudW1iZXI+KFxuICAgICAgJ0NBQ0hFX0NJUkNVSVRfQlJFQUtFUl9USFJFU0hPTEQnLFxuICAgICAgMyxcbiAgICApO1xuICAgIHRoaXMucmVzZXRUaW1lb3V0ID0gdGhpcy5jb25maWdTZXJ2aWNlLmdldDxudW1iZXI+KFxuICAgICAgJ0NBQ0hFX0NJUkNVSVRfQlJFQUtFUl9SRVNFVCcsXG4gICAgICAxMDAwMCxcbiAgICApO1xuICAgIHRoaXMubG9jYWxDYWNoZVRUTCA9IHRoaXMuY29uZmlnU2VydmljZS5nZXQ8bnVtYmVyPignQ0FDSEVfTE9DQUxfVFRMJywgNjAwKTtcblxuICAgIGlmIChkaXNhYmxlUmVkaXMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1JlZGlzIGVzdMOhIGRlc2FiaWxpdGFkby4gVXNhbmRvIGFwZW5hcyBjYWNoZSBsb2NhbC4nKTtcbiAgICAgIHRoaXMuY2lyY3VpdFN0YXRlID0gQ2lyY3VpdFN0YXRlLk9QRU47IC8vIEZvcsOnYXIgdXNvIGRvIGNhY2hlIGxvY2FsXG4gICAgfVxuXG4gICAgLy8gVmVyaWZpY2FyIGNvbmV4w6NvIGNvbSBSZWRpcyBuYSBpbmljaWFsaXphw6fDo29cbiAgICB0aGlzLmNoZWNrUmVkaXNDb25uZWN0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2EgYSBjb25leMOjbyBjb20gbyBSZWRpcyBuYSBpbmljaWFsaXphw6fDo29cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY2hlY2tSZWRpc0Nvbm5lY3Rpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIERlZmluaXIgdW0gdGltZW91dCBwYXJhIGV2aXRhciBibG9xdWVpb1xuICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCBhbyB2ZXJpZmljYXIgY29uZXjDo28gY29tIFJlZGlzJykpLFxuICAgICAgICAgIDIwMDAsXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcGluZ1Byb21pc2UgPSB0aGlzLmNhY2hlUXVldWUuY2xpZW50LnBpbmcoKTtcblxuICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtwaW5nUHJvbWlzZSwgdGltZW91dFByb21pc2VdKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnQ29uZXjDo28gY29tIFJlZGlzIGVzdGFiZWxlY2lkYSBjb20gc3VjZXNzbycpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gY29uZWN0YXIgY29tIFJlZGlzOiAke2Vycm9yLm1lc3NhZ2V9LiBVc2FuZG8gY2FjaGUgbG9jYWwuYCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgLy8gQWJyaXIgbyBjaXJjdWl0IGJyZWFrZXIgcGFyYSB1c2FyIGNhY2hlIGxvY2FsXG4gICAgICB0aGlzLmNpcmN1aXRTdGF0ZSA9IENpcmN1aXRTdGF0ZS5PUEVOO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBvIGVzdGFkbyBkbyBjaXJjdWl0IGJyZWFrZXIgZSBhdHVhbGl6YSBjb25mb3JtZSBuZWNlc3PDoXJpb1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjaGVja0NpcmN1aXRTdGF0ZSgpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gU2UgZXN0aXZlciBhYmVydG8sIHZlcmlmaWNhciBzZSBqw6EgcGFzc291IG8gdGVtcG8gcGFyYSB0ZW50YXIgcmVjdXBlcmFyXG4gICAgaWYgKHRoaXMuY2lyY3VpdFN0YXRlID09PSBDaXJjdWl0U3RhdGUuT1BFTikge1xuICAgICAgaWYgKG5vdyAtIHRoaXMubGFzdEZhaWx1cmVUaW1lID4gdGhpcy5yZXNldFRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgICAgICdDaXJjdWl0IEJyZWFrZXIgbXVkYW5kbyBwYXJhIGVzdGFkbyBIQUxGX09QRU4sIHRlbnRhbmRvIHJlY3VwZXJhcicsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2lyY3VpdFN0YXRlID0gQ2lyY3VpdFN0YXRlLkhBTEZfT1BFTjtcbiAgICAgICAgLy8gUmVzZXRhciBjb250YWRvciBkZSBmYWxoYXMgYW8gdGVudGFyIHJlY3VwZXJhclxuICAgICAgICB0aGlzLmZhaWx1cmVDb3VudCA9IDA7XG5cbiAgICAgICAgLy8gUmVnaXN0cmFyIG3DqXRyaWNhIGRlIHJlY3VwZXJhw6fDo29cbiAgICAgICAgdGhpcy5tZXRyaWNzUHJvdmlkZXIucmVnaXN0ZXJDYWNoZVJlY292ZXJ5QXR0ZW1wdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RyYSB1bWEgZmFsaGEgbm8gY2lyY3VpdCBicmVha2VyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHJlZ2lzdGVyRmFpbHVyZSgpOiB2b2lkIHtcbiAgICB0aGlzLmZhaWx1cmVDb3VudCsrO1xuICAgIHRoaXMubGFzdEZhaWx1cmVUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIFJlZ2lzdHJhciBtw6l0cmljYSBkZSBmYWxoYVxuICAgIHRoaXMubWV0cmljc1Byb3ZpZGVyLnJlZ2lzdGVyQ2FjaGVGYWlsdXJlKCk7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLmZhaWx1cmVDb3VudCA+PSB0aGlzLmZhaWx1cmVUaHJlc2hvbGQgJiZcbiAgICAgIHRoaXMuY2lyY3VpdFN0YXRlID09PSBDaXJjdWl0U3RhdGUuQ0xPU0VEXG4gICAgKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICBgQ2lyY3VpdCBCcmVha2VyIG11ZGFuZG8gcGFyYSBlc3RhZG8gT1BFTiBhcMOzcyAke3RoaXMuZmFpbHVyZUNvdW50fSBmYWxoYXNgLFxuICAgICAgKTtcbiAgICAgIHRoaXMuY2lyY3VpdFN0YXRlID0gQ2lyY3VpdFN0YXRlLk9QRU47XG5cbiAgICAgIC8vIExpbXBhciBmaWxhIGRlIGNhY2hlIHF1YW5kbyBvIGNpcmN1aXRvIGFicmlyIHBhcmEgZXZpdGFyIGFjdW11bGFyIG9wZXJhw6fDtWVzIHBlbmRlbnRlc1xuICAgICAgdGhpcy5jbGVhckNhY2hlUXVldWUoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgIGBFcnJvIGFvIGxpbXBhciBmaWxhIGRlIGNhY2hlOiAke2Vyci5tZXNzYWdlfWAsXG4gICAgICAgICAgZXJyLnN0YWNrLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpbXBhIGEgZmlsYSBkZSBjYWNoZSBwYXJhIGV2aXRhciBhY3VtdWxhciBvcGVyYcOnw7VlcyBwZW5kZW50ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY2xlYXJDYWNoZVF1ZXVlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBEZWZpbmlyIHVtIHRpbWVvdXQgcGFyYSBldml0YXIgYmxvcXVlaW9cbiAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQgYW8gbGltcGFyIGZpbGEgZGUgY2FjaGUnKSksXG4gICAgICAgICAgMTAwMCxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjbGVhblByb21pc2UgPSBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMuY2FjaGVRdWV1ZS5jbGVhbigwLCAnZGVsYXllZCcpLFxuICAgICAgICB0aGlzLmNhY2hlUXVldWUuY2xlYW4oMCwgJ3dhaXQnKSxcbiAgICAgIF0pO1xuXG4gICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW2NsZWFuUHJvbWlzZSwgdGltZW91dFByb21pc2VdKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnRmlsYSBkZSBjYWNoZSBsaW1wYSBjb20gc3VjZXNzbycpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gbGltcGFyIGZpbGEgZGUgY2FjaGU6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICBlcnJvci5zdGFjayxcbiAgICAgICk7XG4gICAgICAvLyBGb3LDp2FyIG8gZmVjaGFtZW50byBkbyBjaXJjdWl0byBlbSBjYXNvIGRlIGVycm8gYW8gbGltcGFyIGEgZmlsYVxuICAgICAgLy8gSXNzbyDDqSBpbXBvcnRhbnRlIHBhcmEgZXZpdGFyIHF1ZSBvIHNpc3RlbWEgY29udGludWUgdGVudGFuZG8gdXNhciBvIFJlZGlzXG4gICAgICB0aGlzLmNpcmN1aXRTdGF0ZSA9IENpcmN1aXRTdGF0ZS5PUEVOO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RyYSB1bSBzdWNlc3NvIG5vIGNpcmN1aXQgYnJlYWtlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSByZWdpc3RlclN1Y2Nlc3MoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2lyY3VpdFN0YXRlID09PSBDaXJjdWl0U3RhdGUuSEFMRl9PUEVOKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXG4gICAgICAgICdDaXJjdWl0IEJyZWFrZXIgcmVjdXBlcmFkbywgdm9sdGFuZG8gcGFyYSBlc3RhZG8gQ0xPU0VEJyxcbiAgICAgICk7XG4gICAgICB0aGlzLmNpcmN1aXRTdGF0ZSA9IENpcmN1aXRTdGF0ZS5DTE9TRUQ7XG4gICAgICB0aGlzLmZhaWx1cmVDb3VudCA9IDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNpcmN1aXRTdGF0ZSA9PT0gQ2lyY3VpdFN0YXRlLkNMT1NFRCkge1xuICAgICAgLy8gUmVzZXRhciBjb250YWRvciBkZSBmYWxoYXMgZ3JhZHVhbG1lbnRlIGVtIGNhc28gZGUgc3VjZXNzb1xuICAgICAgdGhpcy5mYWlsdXJlQ291bnQgPSBNYXRoLm1heCgwLCB0aGlzLmZhaWx1cmVDb3VudCAtIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTYWx2YSB1bSB2YWxvciBubyBjYWNoZSBsb2NhbCBlbSBtZW3Ds3JpYVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXRMb2NhbENhY2hlPFQ+KFxuICAgIGtleTogc3RyaW5nLFxuICAgIHZhbHVlOiBULFxuICAgIHR0bDogbnVtYmVyID0gdGhpcy5sb2NhbENhY2hlVFRMLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBleHBpcnkgPSBEYXRlLm5vdygpICsgdHRsICogMTAwMDtcbiAgICB0aGlzLmluTWVtb3J5Q2FjaGUuc2V0KGtleSwgeyB2YWx1ZSwgZXhwaXJ5IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idMOpbSB1bSB2YWxvciBkbyBjYWNoZSBsb2NhbCBlbSBtZW3Ds3JpYVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRMb2NhbENhY2hlPFQ+KGtleTogc3RyaW5nKTogVCB8IG51bGwge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuaW5NZW1vcnlDYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKERhdGUubm93KCkgPiBjYWNoZWQuZXhwaXJ5KSB7XG4gICAgICB0aGlzLmluTWVtb3J5Q2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVkLnZhbHVlIGFzIFQ7XG4gIH1cblxuICBhc3luYyBnZXQ8VD4oa2V5OiBzdHJpbmcpOiBQcm9taXNlPFQgfCBudWxsPiB7XG4gICAgLy8gUHJpbWVpcm8gdmVyaWZpY2FyIGNhY2hlIGxvY2FsIChtYWlzIHLDoXBpZG8gZSBzZW0gZGVwZW5kw6puY2lhIGRvIFJlZGlzKVxuICAgIGNvbnN0IGxvY2FsVmFsdWUgPSB0aGlzLmdldExvY2FsQ2FjaGU8VD4oa2V5KTtcbiAgICBpZiAobG9jYWxWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5tZXRyaWNzUHJvdmlkZXIucmVnaXN0ZXJDYWNoZUhpdCgpO1xuICAgICAgcmV0dXJuIGxvY2FsVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZpY2FyIG8gZXN0YWRvIGRvIGNpcmN1aXQgYnJlYWtlclxuICAgIHRoaXMuY2hlY2tDaXJjdWl0U3RhdGUoKTtcblxuICAgIC8vIFNlIG8gY2lyY3VpdCBicmVha2VyIGVzdGl2ZXIgYWJlcnRvLCBuw6NvIHRlbnRhciBSZWRpcyBlIHJldG9ybmFyIG51bGxcbiAgICBpZiAodGhpcy5jaXJjdWl0U3RhdGUgPT09IENpcmN1aXRTdGF0ZS5PUEVOKSB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYENpcmN1aXQgYnJlYWtlciBhYmVydG8sIG7Do28gdGVudGFuZG8gUmVkaXMgcGFyYSBjaGF2ZTogJHtrZXl9YCxcbiAgICAgICk7XG4gICAgICB0aGlzLm1ldHJpY3NQcm92aWRlci5yZWdpc3RlckNhY2hlTWlzcygpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGpvYiA9IGF3YWl0IHRoaXMuY2FjaGVRdWV1ZS5nZXRKb2Ioa2V5KTtcblxuICAgICAgaWYgKCFqb2IpIHtcbiAgICAgICAgLy8gQ2FjaGUgbWlzc1xuICAgICAgICB0aGlzLm1ldHJpY3NQcm92aWRlci5yZWdpc3RlckNhY2hlTWlzcygpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyU3VjY2VzcygpOyAvLyBPcGVyYcOnw6NvIGNvbmNsdcOtZGEgY29tIHN1Y2Vzc28gKG1lc21vIHF1ZSBzZWphIHVtIG1pc3MpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBqb2JEYXRhID0gYXdhaXQgam9iLmRhdGE7XG5cbiAgICAgIC8vIFZlcmlmaWNhciBzZSBvIGpvYiBleHBpcm91XG4gICAgICBpZiAoam9iLmZpbmlzaGVkT24gJiYgRGF0ZS5ub3coKSA+IGpvYi5maW5pc2hlZE9uKSB7XG4gICAgICAgIGF3YWl0IGpvYi5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5tZXRyaWNzUHJvdmlkZXIucmVnaXN0ZXJDYWNoZU1pc3MoKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclN1Y2Nlc3MoKTsgLy8gT3BlcmHDp8OjbyBjb25jbHXDrWRhIGNvbSBzdWNlc3NvXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWNoZSBoaXQgLSBhcm1hemVuYXIgdGFtYsOpbSBubyBjYWNoZSBsb2NhbFxuICAgICAgY29uc3QgdmFsdWUgPSBqb2JEYXRhLnZhbHVlIGFzIFQ7XG4gICAgICB0aGlzLnNldExvY2FsQ2FjaGUoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLm1ldHJpY3NQcm92aWRlci5yZWdpc3RlckNhY2hlSGl0KCk7XG4gICAgICB0aGlzLnJlZ2lzdGVyU3VjY2VzcygpOyAvLyBPcGVyYcOnw6NvIGNvbmNsdcOtZGEgY29tIHN1Y2Vzc29cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBFcnJvIGFvIG9idGVyIHZhbG9yIGRvIGNhY2hlOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhpcy5yZWdpc3RlckZhaWx1cmUoKTsgLy8gUmVnaXN0cmFyIGZhbGhhIHBhcmEgbyBjaXJjdWl0IGJyZWFrZXJcbiAgICAgIHRoaXMubWV0cmljc1Byb3ZpZGVyLnJlZ2lzdGVyQ2FjaGVNaXNzKCk7XG5cbiAgICAgIC8vIFNlIGZvciB1bSBlcnJvIGRlIHRpbWVvdXQsIHRlbnRhciBvYnRlciBvIHZhbG9yIGRvIGNhY2hlIGxvY2FsIG5vdmFtZW50ZVxuICAgICAgLy8gSXNzbyBwb2RlIGFjb250ZWNlciBzZSBvIHZhbG9yIGZvciBhZGljaW9uYWRvIGFvIGNhY2hlIGxvY2FsIHBvciBvdXRyYSB0aHJlYWRcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1RpbWVvdXQnKSkge1xuICAgICAgICBjb25zdCByZXRyeUxvY2FsVmFsdWUgPSB0aGlzLmdldExvY2FsQ2FjaGU8VD4oa2V5KTtcbiAgICAgICAgaWYgKHJldHJ5TG9jYWxWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgYFZhbG9yIGVuY29udHJhZG8gbm8gY2FjaGUgbG9jYWwgYXDDs3MgdGltZW91dDogJHtrZXl9YCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiByZXRyeUxvY2FsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFybWF6ZW5hIHVtIHZhbG9yIG5vIGNhY2hlXG4gICAqIEBwYXJhbSBrZXkgQ2hhdmUgcGFyYSBhcm1hemVuYXIgbyB2YWxvclxuICAgKiBAcGFyYW0gdmFsdWUgVmFsb3IgYSBzZXIgYXJtYXplbmFkb1xuICAgKiBAcGFyYW0gdHRsIFRlbXBvIGRlIHZpZGEgZW0gc2VndW5kb3MgKHBhZHLDo286IDEgaG9yYSlcbiAgICovXG4gIGFzeW5jIHNldDxUPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogVCxcbiAgICB0dGw6IG51bWJlciA9IHRoaXMuZGVmYXVsdFRUTCxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gQXJtYXplbmFyIG5vIGNhY2hlIGxvY2FsIHByaW1laXJvIChtYWlzIHLDoXBpZG8gZSBzZW0gZGVwZW5kw6puY2lhIGRvIFJlZGlzKVxuICAgIHRoaXMuc2V0TG9jYWxDYWNoZShrZXksIHZhbHVlLCB0dGwpO1xuXG4gICAgLy8gVmVyaWZpY2FyIG8gZXN0YWRvIGRvIGNpcmN1aXQgYnJlYWtlclxuICAgIHRoaXMuY2hlY2tDaXJjdWl0U3RhdGUoKTtcblxuICAgIC8vIFNlIG8gY2lyY3VpdCBicmVha2VyIGVzdGl2ZXIgYWJlcnRvLCBuw6NvIHRlbnRhciBSZWRpc1xuICAgIGlmICh0aGlzLmNpcmN1aXRTdGF0ZSA9PT0gQ2lyY3VpdFN0YXRlLk9QRU4pIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgQ2lyY3VpdCBicmVha2VyIGFiZXJ0bywgbsOjbyB0ZW50YW5kbyBSZWRpcyBwYXJhIGNoYXZlOiAke2tleX1gLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gVGltZW91dCBwYXJhIGV2aXRhciBibG9xdWVpbyBkYSB0aHJlYWQgcHJpbmNpcGFsXG4gICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChfLCByZWplY3QpID0+IHtcbiAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAoKSA9PiByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0IGFvIGFybWF6ZW5hciBubyBjYWNoZScpKSxcbiAgICAgICAgICA1MDAsXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY2FjaGVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gUmVtb3ZlciBqb2IgZXhpc3RlbnRlIGNvbSBhIG1lc21hIGNoYXZlXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSm9iID0gYXdhaXQgdGhpcy5jYWNoZVF1ZXVlLmdldEpvYihrZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdKb2IpIHtcbiAgICAgICAgICBhd2FpdCBleGlzdGluZ0pvYi5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyaWFyIG5vdm8gam9iIGNvbSBvcyBkYWRvc1xuICAgICAgICBhd2FpdCB0aGlzLmNhY2hlUXVldWUuYWRkKFxuICAgICAgICAgIHsgdmFsdWUgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBqb2JJZDoga2V5LFxuICAgICAgICAgICAgcmVtb3ZlT25Db21wbGV0ZTogdHRsLFxuICAgICAgICAgICAgcmVtb3ZlT25GYWlsOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9KSgpO1xuXG4gICAgICAvLyBVc2FyIHJhY2UgcGFyYSBldml0YXIgYmxvcXVlaW8gcG9yIHRlbXBvIGluZGVmaW5pZG9cbiAgICAgIGF3YWl0IFByb21pc2UucmFjZShbY2FjaGVQcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pO1xuXG4gICAgICAvLyBSZWdpc3RyYXIgb3BlcmHDp8OjbyBkZSBzZXQgbm8gY2FjaGVcbiAgICAgIHRoaXMubWV0cmljc1Byb3ZpZGVyLnJlZ2lzdGVyQ2FjaGVTZXQoKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJTdWNjZXNzKCk7IC8vIE9wZXJhw6fDo28gY29uY2x1w61kYSBjb20gc3VjZXNzb1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gYXJtYXplbmFyIHZhbG9yIG5vIGNhY2hlOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhpcy5yZWdpc3RlckZhaWx1cmUoKTsgLy8gUmVnaXN0cmFyIGZhbGhhIHBhcmEgbyBjaXJjdWl0IGJyZWFrZXJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVtIHZhbG9yIGRvIGNhY2hlXG4gICAqIEBwYXJhbSBrZXkgQ2hhdmUgZG8gdmFsb3IgYSBzZXIgcmVtb3ZpZG9cbiAgICovXG4gIGFzeW5jIGRlbChrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFJlbW92ZXIgZG8gY2FjaGUgbG9jYWxcbiAgICB0aGlzLmluTWVtb3J5Q2FjaGUuZGVsZXRlKGtleSk7XG5cbiAgICAvLyBWZXJpZmljYXIgbyBlc3RhZG8gZG8gY2lyY3VpdCBicmVha2VyXG4gICAgdGhpcy5jaGVja0NpcmN1aXRTdGF0ZSgpO1xuXG4gICAgLy8gU2UgbyBjaXJjdWl0IGJyZWFrZXIgZXN0aXZlciBhYmVydG8sIG7Do28gdGVudGFyIFJlZGlzXG4gICAgaWYgKHRoaXMuY2lyY3VpdFN0YXRlID09PSBDaXJjdWl0U3RhdGUuT1BFTikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBUaW1lb3V0IHBhcmEgZXZpdGFyIGJsb3F1ZWlvIGRhIHRocmVhZCBwcmluY2lwYWxcbiAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQgYW8gcmVtb3ZlciBkbyBjYWNoZScpKSwgNTAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjYWNoZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBqb2IgPSBhd2FpdCB0aGlzLmNhY2hlUXVldWUuZ2V0Sm9iKGtleSk7XG4gICAgICAgIGlmIChqb2IpIHtcbiAgICAgICAgICBhd2FpdCBqb2IucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG5cbiAgICAgIC8vIFVzYXIgcmFjZSBwYXJhIGV2aXRhciBibG9xdWVpbyBwb3IgdGVtcG8gaW5kZWZpbmlkb1xuICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtjYWNoZVByb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG5cbiAgICAgIC8vIFJlZ2lzdHJhciBvcGVyYcOnw6NvIGRlIGRlbGV0ZSBubyBjYWNoZVxuICAgICAgdGhpcy5tZXRyaWNzUHJvdmlkZXIucmVnaXN0ZXJDYWNoZURlbGV0ZSgpO1xuICAgICAgdGhpcy5yZWdpc3RlclN1Y2Nlc3MoKTsgLy8gT3BlcmHDp8OjbyBjb25jbHXDrWRhIGNvbSBzdWNlc3NvXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBgRXJybyBhbyByZW1vdmVyIHZhbG9yIGRvIGNhY2hlOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhpcy5yZWdpc3RlckZhaWx1cmUoKTsgLy8gUmVnaXN0cmFyIGZhbGhhIHBhcmEgbyBjaXJjdWl0IGJyZWFrZXJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgdW1hIGNoYXZlIGV4aXN0ZSBubyBjYWNoZVxuICAgKiBAcGFyYW0ga2V5IENoYXZlIGEgc2VyIHZlcmlmaWNhZGFcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBhIGNoYXZlIGV4aXN0aXIsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgYXN5bmMgaGFzKGtleTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gVmVyaWZpY2FyIHByaW1laXJvIG5vIGNhY2hlIGxvY2FsXG4gICAgaWYgKHRoaXMuZ2V0TG9jYWxDYWNoZShrZXkpICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZmljYXIgbyBlc3RhZG8gZG8gY2lyY3VpdCBicmVha2VyXG4gICAgdGhpcy5jaGVja0NpcmN1aXRTdGF0ZSgpO1xuXG4gICAgLy8gU2UgbyBjaXJjdWl0IGJyZWFrZXIgZXN0aXZlciBhYmVydG8sIHJldG9ybmFyIGFwZW5hcyByZXN1bHRhZG8gZG8gY2FjaGUgbG9jYWxcbiAgICBpZiAodGhpcy5jaXJjdWl0U3RhdGUgPT09IENpcmN1aXRTdGF0ZS5PUEVOKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGpvYiA9IGF3YWl0IHRoaXMuY2FjaGVRdWV1ZS5nZXRKb2Ioa2V5KTtcbiAgICAgIGNvbnN0IGV4aXN0cyA9ICEham9iO1xuICAgICAgdGhpcy5yZWdpc3RlclN1Y2Nlc3MoKTsgLy8gT3BlcmHDp8OjbyBjb25jbHXDrWRhIGNvbSBzdWNlc3NvXG4gICAgICByZXR1cm4gZXhpc3RzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gdmVyaWZpY2FyIGV4aXN0w6puY2lhIG5vIGNhY2hlOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhpcy5yZWdpc3RlckZhaWx1cmUoKTsgLy8gUmVnaXN0cmFyIGZhbGhhIHBhcmEgbyBjaXJjdWl0IGJyZWFrZXJcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGltcGEgdG9kbyBvIGNhY2hlXG4gICAqL1xuICBhc3luYyBjbGVhcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBMaW1wYXIgY2FjaGUgbG9jYWxcbiAgICB0aGlzLmluTWVtb3J5Q2FjaGUuY2xlYXIoKTtcblxuICAgIC8vIFZlcmlmaWNhciBvIGVzdGFkbyBkbyBjaXJjdWl0IGJyZWFrZXJcbiAgICB0aGlzLmNoZWNrQ2lyY3VpdFN0YXRlKCk7XG5cbiAgICAvLyBTZSBvIGNpcmN1aXQgYnJlYWtlciBlc3RpdmVyIGFiZXJ0bywgbsOjbyB0ZW50YXIgUmVkaXNcbiAgICBpZiAodGhpcy5jaXJjdWl0U3RhdGUgPT09IENpcmN1aXRTdGF0ZS5PUEVOKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRpbWVvdXQgcGFyYSBldml0YXIgYmxvcXVlaW8gZGEgdGhyZWFkIHByaW5jaXBhbFxuICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCBhbyBsaW1wYXIgY2FjaGUnKSksIDEwMDApO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNhY2hlUHJvbWlzZSA9IHRoaXMuY2FjaGVRdWV1ZS5lbXB0eSgpO1xuXG4gICAgICAvLyBVc2FyIHJhY2UgcGFyYSBldml0YXIgYmxvcXVlaW8gcG9yIHRlbXBvIGluZGVmaW5pZG9cbiAgICAgIGF3YWl0IFByb21pc2UucmFjZShbY2FjaGVQcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pO1xuXG4gICAgICAvLyBSZWdpc3RyYXIgb3BlcmHDp8OjbyBkZSBjbGVhciBubyBjYWNoZVxuICAgICAgdGhpcy5tZXRyaWNzUHJvdmlkZXIucmVnaXN0ZXJDYWNoZUNsZWFyKCk7XG4gICAgICB0aGlzLnJlZ2lzdGVyU3VjY2VzcygpOyAvLyBPcGVyYcOnw6NvIGNvbmNsdcOtZGEgY29tIHN1Y2Vzc29cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gbGltcGFyIGNhY2hlOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3Iuc3RhY2spO1xuICAgICAgdGhpcy5yZWdpc3RlckZhaWx1cmUoKTsgLy8gUmVnaXN0cmFyIGZhbGhhIHBhcmEgbyBjaXJjdWl0IGJyZWFrZXJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIG8gZXN0YWRvIGF0dWFsIGRvIGNpcmN1aXQgYnJlYWtlclxuICAgKiBAcmV0dXJucyBFc3RhZG8gYXR1YWwgZG8gY2lyY3VpdCBicmVha2VyXG4gICAqL1xuICBnZXRDaXJjdWl0U3RhdGUoKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKHRoaXMuY2lyY3VpdFN0YXRlKSB7XG4gICAgICBjYXNlIENpcmN1aXRTdGF0ZS5DTE9TRUQ6XG4gICAgICAgIHJldHVybiAnQ0xPU0VEJztcbiAgICAgIGNhc2UgQ2lyY3VpdFN0YXRlLk9QRU46XG4gICAgICAgIHJldHVybiAnT1BFTic7XG4gICAgICBjYXNlIENpcmN1aXRTdGF0ZS5IQUxGX09QRU46XG4gICAgICAgIHJldHVybiAnSEFMRl9PUEVOJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnVU5LTk9XTic7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcsOnYSBvIGZlY2hhbWVudG8gZG8gY2lyY3VpdCBicmVha2VyLCDDunRpbCBwYXJhIHJlY3VwZXJhw6fDo28gbWFudWFsXG4gICAqL1xuICBmb3JjZUNsb3NlQ2lyY3VpdCgpOiB2b2lkIHtcbiAgICB0aGlzLmNpcmN1aXRTdGF0ZSA9IENpcmN1aXRTdGF0ZS5DTE9TRUQ7XG4gICAgdGhpcy5mYWlsdXJlQ291bnQgPSAwO1xuICAgIHRoaXMubG9nZ2VyLmxvZygnQ2lyY3VpdCBCcmVha2VyIGZvcsOnYWRvIHBhcmEgZXN0YWRvIENMT1NFRCBtYW51YWxtZW50ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idMOpbSBlc3RhdMOtc3RpY2FzIGRvIGNpcmN1aXQgYnJlYWtlclxuICAgKiBAcmV0dXJucyBFc3RhdMOtc3RpY2FzIGRvIGNpcmN1aXQgYnJlYWtlclxuICAgKi9cbiAgZ2V0Q2lyY3VpdFN0YXRzKCk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiB0aGlzLmdldENpcmN1aXRTdGF0ZSgpLFxuICAgICAgZmFpbHVyZUNvdW50OiB0aGlzLmZhaWx1cmVDb3VudCxcbiAgICAgIGxhc3RGYWlsdXJlVGltZTogdGhpcy5sYXN0RmFpbHVyZVRpbWUsXG4gICAgICBsb2NhbENhY2hlU2l6ZTogdGhpcy5pbk1lbW9yeUNhY2hlLnNpemUsXG4gICAgICB0aHJlc2hvbGRDb25maWc6IHtcbiAgICAgICAgZmFpbHVyZVRocmVzaG9sZDogdGhpcy5mYWlsdXJlVGhyZXNob2xkLFxuICAgICAgICByZXNldFRpbWVvdXRNczogdGhpcy5yZXNldFRpbWVvdXQsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==