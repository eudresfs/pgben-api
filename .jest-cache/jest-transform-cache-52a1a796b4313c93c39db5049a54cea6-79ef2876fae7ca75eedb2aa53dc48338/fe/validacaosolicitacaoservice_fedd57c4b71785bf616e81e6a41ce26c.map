{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\solicitacao\\services\\validacao-solicitacao.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\solicitacao\\services\\validacao-solicitacao.service.ts"],"sourcesContent":["import { Injectable, BadRequestException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Pendencia, StatusPendencia } from '../../../entities';\nimport { Solicitacao, StatusSolicitacao } from '../../../entities';\nimport { TransicaoEstadoService } from './transicao-estado.service';\n\n/**\n * Serviço de Validação de Solicitação\n *\n * Responsável por validar as regras de negócio específicas para operações\n * relacionadas a solicitações, como aprovação, liberação, etc.\n */\n@Injectable()\nexport class ValidacaoSolicitacaoService {\n  constructor(\n    @InjectRepository(Solicitacao)\n    private readonly solicitacaoRepository: Repository<Solicitacao>,\n    @InjectRepository(Pendencia)\n    private readonly pendenciaRepository: Repository<Pendencia>,\n    private readonly transicaoEstadoService: TransicaoEstadoService,\n  ) {}\n\n  /**\n   * Valida se uma solicitação pode ser aprovada\n   * @param solicitacaoId ID da solicitação\n   * @returns void se validação passar, exception caso contrário\n   */\n  async validarAprovacao(solicitacaoId: string): Promise<void> {\n    const solicitacao = await this.solicitacaoRepository.findOne({\n      where: { id: solicitacaoId },\n    });\n\n    if (!solicitacao) {\n      throw new BadRequestException('Solicitação não encontrada');\n    }\n\n    // Verificar se a transição para APROVADA é válida\n    if (\n      !this.transicaoEstadoService.isTransicaoValida(\n        solicitacao.status,\n        StatusSolicitacao.APROVADA,\n      )\n    ) {\n      throw new BadRequestException(\n        `Não é possível aprovar uma solicitação no estado ${solicitacao.status}`,\n      );\n    }\n\n    // Verificar se existem pendências não resolvidas\n    const pendenciasAbertas = await this.pendenciaRepository.find({\n      where: {\n        solicitacao_id: solicitacaoId,\n        status: StatusPendencia.ABERTA,\n      },\n    });\n\n    if (pendenciasAbertas.length > 0) {\n      throw new BadRequestException(\n        'Não é possível aprovar a solicitação com pendências não resolvidas. Resolva todas as pendências antes de aprovar.',\n      );\n    }\n\n    // Verificar se a solicitação tem os campos obrigatórios preenchidos\n    if (!solicitacao.parecer_semtas) {\n      throw new BadRequestException(\n        'O parecer da SEMTAS é obrigatório para aprovar a solicitação',\n      );\n    }\n  }\n\n  /**\n   * Valida se uma solicitação pode ser liberada\n   * @param solicitacaoId ID da solicitação\n   * @returns void se validação passar, exception caso contrário\n   */\n  async validarLiberacao(solicitacaoId: string): Promise<void> {\n    const solicitacao = await this.solicitacaoRepository.findOne({\n      where: { id: solicitacaoId },\n    });\n\n    if (!solicitacao) {\n      throw new BadRequestException('Solicitação não encontrada');\n    }\n\n    // Verificar se a transição para LIBERADA é válida\n    if (\n      !this.transicaoEstadoService.isTransicaoValida(\n        solicitacao.status,\n        StatusSolicitacao.LIBERADA,\n      )\n    ) {\n      throw new BadRequestException(\n        `Não é possível liberar uma solicitação no estado ${solicitacao.status}`,\n      );\n    }\n\n    // Verificar se a solicitação foi aprovada\n    if (solicitacao.status !== StatusSolicitacao.APROVADA) {\n      throw new BadRequestException(\n        'Apenas solicitações aprovadas podem ser liberadas',\n      );\n    }\n\n    // Verificar se a solicitação tem os campos obrigatórios preenchidos\n    if (!solicitacao.aprovador_id) {\n      throw new BadRequestException(\n        'A solicitação precisa ter um aprovador registrado para ser liberada',\n      );\n    }\n  }\n\n  /**\n   * Valida se uma solicitação pode ser cancelada\n   * @param solicitacaoId ID da solicitação\n   * @returns void se validação passar, exception caso contrário\n   */\n  async validarCancelamento(solicitacaoId: string): Promise<void> {\n    const solicitacao = await this.solicitacaoRepository.findOne({\n      where: { id: solicitacaoId },\n    });\n\n    if (!solicitacao) {\n      throw new BadRequestException('Solicitação não encontrada');\n    }\n\n    // Verificar se a transição para CANCELADA é válida\n    if (\n      !this.transicaoEstadoService.isTransicaoValida(\n        solicitacao.status,\n        StatusSolicitacao.CANCELADA,\n      )\n    ) {\n      throw new BadRequestException(\n        `Não é possível cancelar uma solicitação no estado ${solicitacao.status}`,\n      );\n    }\n\n    // Verificar se a solicitação já está em um estado final\n    if (\n      solicitacao.status === StatusSolicitacao.CONCLUIDA ||\n      solicitacao.status === StatusSolicitacao.ARQUIVADA\n    ) {\n      throw new BadRequestException(\n        'Não é possível cancelar uma solicitação que já foi concluída ou arquivada',\n      );\n    }\n  }\n\n  /**\n   * Valida se uma solicitação pode ser concluída\n   * @param solicitacaoId ID da solicitação\n   * @returns void se validação passar, exception caso contrário\n   */\n  async validarConclusao(solicitacaoId: string): Promise<void> {\n    const solicitacao = await this.solicitacaoRepository.findOne({\n      where: { id: solicitacaoId },\n    });\n\n    if (!solicitacao) {\n      throw new BadRequestException('Solicitação não encontrada');\n    }\n\n    // Verificar se a transição para CONCLUIDA é válida\n    if (\n      !this.transicaoEstadoService.isTransicaoValida(\n        solicitacao.status,\n        StatusSolicitacao.CONCLUIDA,\n      )\n    ) {\n      throw new BadRequestException(\n        `Não é possível concluir uma solicitação no estado ${solicitacao.status}`,\n      );\n    }\n\n    // Verificar se a solicitação está em processamento\n    if (solicitacao.status !== StatusSolicitacao.EM_PROCESSAMENTO) {\n      throw new BadRequestException(\n        'Apenas solicitações em processamento podem ser concluídas',\n      );\n    }\n  }\n\n  /**\n   * Valida se uma solicitação pode ser arquivada\n   * @param solicitacaoId ID da solicitação\n   * @returns void se validação passar, exception caso contrário\n   */\n  async validarArquivamento(solicitacaoId: string): Promise<void> {\n    const solicitacao = await this.solicitacaoRepository.findOne({\n      where: { id: solicitacaoId },\n    });\n\n    if (!solicitacao) {\n      throw new BadRequestException('Solicitação não encontrada');\n    }\n\n    // Verificar se a transição para ARQUIVADA é válida\n    if (\n      !this.transicaoEstadoService.isTransicaoValida(\n        solicitacao.status,\n        StatusSolicitacao.ARQUIVADA,\n      )\n    ) {\n      throw new BadRequestException(\n        `Não é possível arquivar uma solicitação no estado ${solicitacao.status}`,\n      );\n    }\n\n    // Verificar se a solicitação está em um estado que permite arquivamento\n    const estadosPermitidos = [\n      StatusSolicitacao.CONCLUIDA,\n      StatusSolicitacao.INDEFERIDA,\n      StatusSolicitacao.CANCELADA,\n    ];\n\n    if (!estadosPermitidos.includes(solicitacao.status)) {\n      throw new BadRequestException(\n        'Apenas solicitações concluídas, reprovadas ou canceladas podem ser arquivadas',\n      );\n    }\n  }\n}\n"],"version":3}