{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\cidadao\\services\\papel-cidadao.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\cidadao\\services\\papel-cidadao.service.ts"],"sourcesContent":["import {\n  Injectable,\n  Logger,\n  NotFoundException,\n  BadRequestException,\n  ConflictException,\n  InternalServerErrorException,\n  Inject,\n  forwardRef,\n} from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, DataSource } from 'typeorm';\nimport { PapelCidadao } from '../../../entities/papel-cidadao.entity';\nimport { Cidadao } from '../../../entities/cidadao.entity';\nimport { CreatePapelCidadaoDto } from '../dto/create-papel-cidadao.dto';\nimport { TipoPapel, PaperType } from '../../../enums/tipo-papel.enum';\nimport { CidadaoService } from './cidadao.service';\nimport { VerificacaoPapelService } from './verificacao-papel.service';\nimport { normalizeEnumFields } from '../../../shared/utils/enum-normalizer.util';\n\n/**\n * Serviço de Papéis de Cidadão\n *\n * Responsável pela lógica de negócio relacionada aos papéis que os cidadãos\n * podem assumir no sistema (beneficiário, requerente, representante legal).\n */\n@Injectable()\nexport class PapelCidadaoService {\n  private readonly logger = new Logger(PapelCidadaoService.name);\n\n  constructor(\n    @InjectRepository(PapelCidadao)\n    private readonly papelCidadaoRepository: Repository<PapelCidadao>,\n    @Inject(forwardRef(() => CidadaoService))\n    private readonly cidadaoService: CidadaoService,\n    private readonly verificacaoPapelService: VerificacaoPapelService,\n    private readonly dataSource: DataSource,\n  ) {}\n\n  /**\n   * Cria um novo papel para um cidadão\n   * @param createPapelCidadaoDto Dados para criação do papel\n   * @returns Papel criado\n   */\n  async create(\n    createPapelCidadaoDto: CreatePapelCidadaoDto,\n  ): Promise<PapelCidadao> {\n    // Verificar se o cidadão existe\n    const cidadaoExistente = await this.cidadaoService.findById(\n      createPapelCidadaoDto.cidadao_id,\n      false,\n    );\n    if (!cidadaoExistente) {\n      throw new NotFoundException('Cidadão não encontrado');\n    }\n\n    // Verificar se já existe um papel ativo para este cidadão\n    const papelExistente = await this.papelCidadaoRepository.findOne({\n      where: {\n        cidadao_id: createPapelCidadaoDto.cidadao_id,\n        tipo_papel: createPapelCidadaoDto.tipo_papel,\n        ativo: true,\n      },\n    });\n\n    if (papelExistente) {\n      throw new ConflictException('Cidadão já possui este papel ativo');\n    }\n\n    return this.dataSource.transaction(async (manager) => {\n      // Buscar o cidadão novamente dentro da transação\n      const cidadaoNaTransacao = await manager.findOne(Cidadao, {\n        where: { id: createPapelCidadaoDto.cidadao_id },\n      });\n\n      if (!cidadaoNaTransacao) {\n        throw new NotFoundException('Cidadão não encontrado');\n      }\n\n      // Validar metadados específicos do tipo de papel\n      this.validarMetadados(\n        createPapelCidadaoDto.tipo_papel,\n        createPapelCidadaoDto.metadados,\n      );\n\n      // Normalizar campos de enum antes de criar\n      const dadosNormalizados = normalizeEnumFields({\n        cidadao_id: createPapelCidadaoDto.cidadao_id,\n        tipo_papel: createPapelCidadaoDto.tipo_papel,\n        metadados: createPapelCidadaoDto.metadados,\n        ativo: true,\n      });\n\n      const papel = manager.create(PapelCidadao, dadosNormalizados);\n\n      const savedPapel = await manager.save(papel);\n\n      return savedPapel;\n    });\n  }\n\n  /**\n   * Cria múltiplos papéis para um cidadão\n   * @param cidadaoId ID do cidadão\n   * @param papeis Lista de papéis a serem criados\n   * @returns Lista de papéis criados\n   * @throws NotFoundException se o cidadão não for encontrado\n   * @throws ConflictException se houver conflito de papéis\n   * @throws BadRequestException se os dados forem inválidos\n   */\n  async createMany(\n    cidadaoId: string,\n    papeis: Omit<CreatePapelCidadaoDto, 'cidadao_id'>[],\n  ): Promise<PapelCidadao[]> {\n    this.logger.log(\n      `Criando ${papeis.length} papéis para cidadão ${cidadaoId}`,\n    );\n\n    if (!papeis || papeis.length === 0) {\n      throw new BadRequestException('Lista de papéis não pode estar vazia');\n    }\n\n    return this.dataSource.transaction(async (manager) => {\n      // Verificar se o cidadão existe\n      const cidadao = await this.cidadaoService.findById(cidadaoId, false);\n      if (!cidadao) {\n        throw new NotFoundException('Cidadão não encontrado');\n      }\n\n      const papeisParaCriar = papeis.map((papel) => ({\n        ...papel,\n        cidadao_id: cidadaoId,\n      }));\n\n      // Verificar papéis duplicados na lista\n      const tiposPapeis = papeisParaCriar.map((p) => p.tipo_papel);\n      const tiposUnicos = new Set(tiposPapeis);\n      if (tiposUnicos.size !== tiposPapeis.length) {\n        throw new BadRequestException('Lista contém papéis duplicados');\n      }\n\n      // Buscar CPF do cidadão uma única vez para verificar conflitos\n      const cidadaoParaConflito = await manager.findOne(Cidadao, {\n        where: { id: cidadaoId },\n      });\n\n      if (!cidadaoParaConflito) {\n        throw new NotFoundException('Cidadão não encontrado');\n      }\n\n      // Verificar conflitos para cada papel\n      for (const papel of papeisParaCriar) {\n        // Verificar se já possui o papel\n        const papelExistente = await manager.findOne(PapelCidadao, {\n          where: {\n            cidadao_id: cidadaoId,\n            tipo_papel: papel.tipo_papel,\n            ativo: true,\n          },\n        });\n\n        if (papelExistente) {\n          throw new ConflictException(\n            `Cidadão já possui o papel ${papel.tipo_papel} ativo`,\n          );\n        }\n\n        const conflitos =\n          await this.verificacaoPapelService.verificarConflitoPapeis(\n            cidadaoParaConflito.cpf,\n          );\n\n        if (conflitos.temConflito) {\n          throw new ConflictException(\n            `Conflito de papel detectado para ${papel.tipo_papel}: ${conflitos.detalhes}`,\n          );\n        }\n\n        // Validar metadados\n        this.validarMetadados(papel.tipo_papel, papel.metadados);\n      }\n\n      // Normalizar campos de enum antes de criar as entidades\n      const papeisNormalizados = papeisParaCriar.map((papel) =>\n        normalizeEnumFields({\n          ...papel,\n          ativo: true,\n        }),\n      );\n\n      const papeisEntities = manager.create(PapelCidadao, papeisNormalizados);\n      return manager.save(papeisEntities);\n    });\n  }\n\n  /**\n   * Busca todos os papéis de um cidadão\n   * @param cidadaoId ID do cidadão\n   * @returns Lista de papéis do cidadão\n   */\n  async findByCidadaoId(cidadaoId: string): Promise<PapelCidadao[]> {\n    try {\n      return this.papelCidadaoRepository.find({\n        where: { cidadao_id: cidadaoId, ativo: true },\n      });\n    } catch (error) {\n      this.logger.error(\n        `Erro ao buscar papéis do cidadão: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException(\n        'Erro ao buscar papéis do cidadão',\n      );\n    }\n  }\n\n  /**\n   * Verifica se um cidadão possui um determinado papel\n   * @param cidadaoId ID do cidadão\n   * @param tipoPapel Tipo de papel a verificar\n   * @returns true se o cidadão possui o papel, false caso contrário\n   */\n  async verificarPapel(\n    cidadaoId: string,\n    tipoPapel: PaperType,\n  ): Promise<boolean> {\n    const papel = await this.papelCidadaoRepository.findOne({\n      where: {\n        cidadao_id: cidadaoId,\n        tipo_papel: tipoPapel,\n        ativo: true,\n      },\n    });\n\n    return !!papel;\n  }\n\n  /**\n   * Desativa um papel de um cidadão\n   * @param id ID do papel a ser desativado\n   * @returns Papel desativado\n   */\n  async desativar(id: string): Promise<PapelCidadao> {\n    try {\n      const papel = await this.papelCidadaoRepository.findOne({\n        where: { id },\n      });\n\n      if (!papel) {\n        throw new NotFoundException(`Papel com ID ${id} não encontrado`);\n      }\n\n      papel.ativo = false;\n      return this.papelCidadaoRepository.save(papel);\n    } catch (error) {\n      if (error instanceof NotFoundException) {\n        throw error;\n      }\n\n      this.logger.error(\n        `Erro ao desativar papel: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException('Erro ao desativar papel');\n    }\n  }\n\n  /**\n   * Busca cidadãos por tipo de papel\n   * @param tipoPapel Tipo de papel a buscar\n   * @param options Opções de filtro e paginação\n   * @returns Lista de cidadãos com o papel especificado\n   */\n  async findCidadaosByTipoPapel(\n    tipoPapel: PaperType,\n    options: {\n      page?: number;\n      limit?: number;\n      includeInactive?: boolean;\n    } = {},\n  ): Promise<{\n    data: Array<{\n      cidadao: Cidadao;\n      papel: PapelCidadao;\n    }>;\n    total: number;\n    page: number;\n    limit: number;\n  }> {\n    const { page = 1, limit = 10, includeInactive = false } = options;\n    const skip = (page - 1) * limit;\n\n    const whereCondition: any = {\n      tipo_papel: tipoPapel,\n    };\n\n    if (!includeInactive) {\n      whereCondition.ativo = true;\n    }\n\n    const [papeis, total] = await this.papelCidadaoRepository.findAndCount({\n      where: whereCondition,\n      relations: ['cidadao'],\n      skip,\n      take: limit,\n      order: {\n        created_at: 'DESC',\n      },\n    });\n\n    const data = papeis.map((papel) => ({\n      cidadao: papel.cidadao,\n      papel,\n    }));\n\n    return {\n      data,\n      total,\n      page,\n      limit,\n    };\n  }\n\n  /**\n   * Cria um novo papel para um cidadão (alias para o método create)\n   * @param createPapelCidadaoDto Dados do papel a ser criado\n   * @returns Papel criado\n   */\n  async criarPapel(\n    createPapelCidadaoDto: CreatePapelCidadaoDto,\n    usuarioId: string,\n    manager: unknown,\n  ): Promise<PapelCidadao> {\n    return this.create(createPapelCidadaoDto);\n  }\n\n  /**\n   * Inativa um papel de cidadão (alias para o método desativar)\n   * @param papelId ID do papel a ser inativado\n   * @returns Papel inativado\n   */\n  async inativarPapel(papelId: string): Promise<PapelCidadao> {\n    return this.desativar(papelId);\n  }\n\n  /**\n   * Atualiza os papéis de um cidadão\n   * @param cidadaoId ID do cidadão\n   * @param updatePapeisDto Dados para atualização dos papéis\n   * @returns Papéis atualizados\n   */\n  async updatePapeis(\n    cidadaoId: string,\n    updatePapeisDto: { papeis: CreatePapelCidadaoDto[] },\n  ): Promise<PapelCidadao[]> {\n    return await this.dataSource.transaction(async (manager) => {\n      // Verificar se o cidadão existe\n      const cidadaoExistente = await manager.findOne(Cidadao, {\n        where: { id: cidadaoId },\n      });\n\n      if (!cidadaoExistente) {\n        throw new NotFoundException('Cidadão não encontrado');\n      }\n\n      // Buscar papéis ativos atuais\n      const papeisAtuais = await manager.find(PapelCidadao, {\n        where: {\n          cidadao_id: cidadaoId,\n          ativo: true,\n        },\n      });\n\n      // Desativar todos os papéis atuais\n      for (const papel of papeisAtuais) {\n        papel.ativo = false;\n        papel.updated_at = new Date();\n        await manager.save(papel);\n      }\n\n      // Criar novos papéis\n      const papeisParaCriar = updatePapeisDto.papeis.map((papelDto: any) => {\n        // Validar metadados específicos do tipo de papel\n        this.validarMetadados(papelDto.tipo_papel, papelDto.metadados);\n\n        return {\n          cidadao_id: cidadaoId,\n          tipo_papel: papelDto.tipo_papel,\n          metadados: papelDto.metadados,\n          ativo: true,\n        };\n      });\n\n      const papeisEntities = manager.create(PapelCidadao, papeisParaCriar);\n      const novosPapeis = await manager.save(papeisEntities);\n\n      return novosPapeis;\n    });\n  }\n\n  /**\n   * Valida os metadados específicos de cada tipo de papel\n   * @param tipoPapel - Tipo do papel a ser validado\n   * @param metadados - Metadados a serem validados\n   * @throws BadRequestException se os metadados forem inválidos\n   */\n  private validarMetadados(tipoPapel: PaperType, metadados?: any): void {\n    if (!metadados) {\n      metadados = {};\n    }\n\n    switch (tipoPapel) {\n      case 'representante_legal':\n        if (!metadados.documento_representacao) {\n          throw new BadRequestException(\n            'Documento de representação é obrigatório para representantes legais',\n          );\n        }\n        if (!metadados.data_validade_representacao) {\n          throw new BadRequestException(\n            'Data de validade da representação é obrigatória para representantes legais',\n          );\n        }\n        break;\n\n      case 'requerente':\n        if (!metadados.grau_parentesco) {\n          throw new BadRequestException(\n            'Grau de parentesco é obrigatório para requerentes',\n          );\n        }\n        break;\n\n      case 'beneficiario':\n        // Não há metadados obrigatórios para beneficiários\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n"],"version":3}