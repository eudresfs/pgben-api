d2af383d0d0fc6830aff8f2432b4109f
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var LogAuditoriaRepository_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogAuditoriaRepository = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const log_auditoria_entity_1 = require("../../../entities/log-auditoria.entity");
const zlib = __importStar(require("zlib"));
const util_1 = require("util");
// Promisificar funções de compressão
const gzipAsync = (0, util_1.promisify)(zlib.gzip);
const gunzipAsync = (0, util_1.promisify)(zlib.gunzip);
/**
 * Repositório para logs de auditoria
 *
 * Implementa o padrão Repository para operações com logs de auditoria,
 * incluindo suporte a compressão de dados e particionamento de tabelas.
 */
let LogAuditoriaRepository = LogAuditoriaRepository_1 = class LogAuditoriaRepository {
    repository;
    logger = new common_1.Logger(LogAuditoriaRepository_1.name);
    compressionEnabled = true;
    compressionThreshold = 1024; // 1KB
    constructor(repository) {
        this.repository = repository;
    }
    /**
     * Cria um novo log de auditoria
     *
     * @param createLogAuditoriaDto DTO com dados do log
     * @returns Log de auditoria criado
     */
    async create(createLogAuditoriaDto) {
        try {
            // Criar entidade a partir do DTO
            const logAuditoria = this.repository.create(createLogAuditoriaDto);
            // Comprimir dados grandes se necessário
            await this.compressLogDataIfNeeded(logAuditoria);
            // Salvar o log sem assinatura para evitar dependência circular
            const savedLog = await this.repository.save(logAuditoria);
            this.logger.debug(`Log ${savedLog.id} criado com sucesso`);
            return savedLog;
        }
        catch (error) {
            this.logger.error(`Erro ao criar log de auditoria: ${error.message}`, error.stack);
            throw error;
        }
    }
    /**
     * Busca logs de auditoria com filtros e paginação
     *
     * @param queryDto DTO com filtros de busca
     * @returns Logs de auditoria paginados
     */
    async findAll(queryDto) {
        try {
            const { tipo_operacao, entidade_afetada, entidade_id, usuario_id, ip_usuario: ip_origem, endpoint, metodo_http, data_inicial: data_inicio, data_final: data_fim, termo_busca, pagina: page = 1, itens_por_pagina: limit = 10, } = queryDto;
            // Construir where clause
            const where = {};
            // Filtrar por tipo de operação
            if (tipo_operacao) {
                where.tipo_operacao = tipo_operacao;
            }
            // Filtrar por entidade afetada
            if (entidade_afetada) {
                where.entidade_afetada = entidade_afetada;
            }
            // Filtrar por usuário
            if (usuario_id) {
                where.usuario_id = usuario_id;
            }
            // Filtrar por IP de origem
            if (ip_origem) {
                where.ip_origem = ip_origem;
            }
            // Filtrar por endpoint
            if (endpoint) {
                where.endpoint = (0, typeorm_2.Raw)((alias) => `(${alias} ILIKE '%${endpoint.replace(/'/g, "''")}%')`);
            }
            // Filtrar por método HTTP
            if (metodo_http) {
                where.metodo_http = metodo_http;
            }
            // Filtrar por período
            if (data_inicio && data_fim) {
                where.created_at = (0, typeorm_2.Between)(new Date(data_inicio), new Date(data_fim));
            }
            else if (data_inicio) {
                where.created_at = (0, typeorm_2.Raw)((alias) => `(${alias} >= :dataInicio)`, {
                    dataInicio: new Date(data_inicio),
                });
            }
            else if (data_fim) {
                where.created_at = (0, typeorm_2.Raw)((alias) => `(${alias} <= :dataFim)`, {
                    dataFim: new Date(data_fim),
                });
            }
            // Filtrar por presença de dados sensíveis
            if (termo_busca) {
                where.dados_sensiveis_acessados = (0, typeorm_2.Raw)((alias) => `(${alias}::text ILIKE :termo)`, { termo: `%${termo_busca}%` });
            }
            // Calcular skip para paginação
            const skip = (page - 1) * limit;
            // Executar consulta
            const [items, total] = await this.repository.findAndCount({
                where,
                skip,
                take: limit,
                order: {
                    created_at: 'DESC',
                },
            });
            // Descomprimir dados se necessário
            for (const item of items) {
                await this.decompressLogDataIfNeeded(item);
            }
            return { items, total };
        }
        catch (error) {
            this.logger.error(`Erro ao buscar logs de auditoria: ${error.message}`, error.stack);
            throw error;
        }
    }
    /**
     * Busca um log de auditoria pelo ID
     *
     * @param id ID do log
     * @returns Log de auditoria
     */
    async findOne(id) {
        try {
            const log = await this.repository.findOne({ where: { id } });
            if (!log) {
                return null;
            }
            // Descomprimir dados se necessário
            await this.decompressLogDataIfNeeded(log);
            return log;
        }
        catch (error) {
            this.logger.error(`Erro ao buscar log de auditoria: ${error.message}`, error.stack);
            throw error;
        }
    }
    /**
     * Busca logs de auditoria por entidade e ID
     *
     * @param entidade Nome da entidade
     * @param entidadeId ID da entidade
     * @returns Logs de auditoria
     */
    async findByEntity(entidade, entidadeId) {
        try {
            const logs = await this.repository.find({
                where: {
                    entidade_afetada: entidade,
                    entidade_id: entidadeId,
                },
                order: {
                    created_at: 'DESC',
                },
            });
            // Descomprimir dados se necessário
            for (const log of logs) {
                await this.decompressLogDataIfNeeded(log);
            }
            return logs;
        }
        catch (error) {
            this.logger.error(`Erro ao buscar logs por entidade: ${error.message}`, error.stack);
            throw error;
        }
    }
    /**
     * Busca logs de auditoria por usuário
     *
     * @param usuarioId ID do usuário
     * @param limit Limite de registros
     * @returns Logs de auditoria
     */
    async findByUser(usuarioId, limit = 100) {
        try {
            const logs = await this.repository.find({
                where: {
                    usuario_id: usuarioId,
                },
                order: {
                    created_at: 'DESC',
                },
                take: limit,
            });
            // Descomprimir dados se necessário
            for (const log of logs) {
                await this.decompressLogDataIfNeeded(log);
            }
            return logs;
        }
        catch (error) {
            this.logger.error(`Erro ao buscar logs por usuário: ${error.message}`, error.stack);
            throw error;
        }
    }
    /**
     * Busca logs de auditoria de acesso a dados sensíveis
     *
     * @param limit Limite de registros
     * @returns Logs de auditoria
     */
    async findSensitiveDataAccess(limit = 100) {
        try {
            const logs = await this.repository.find({
                where: {
                    dados_sensiveis_acessados: (0, typeorm_2.Raw)((alias) => `(${alias} IS NOT NULL AND ${alias}::text != '[]')`),
                },
                order: {
                    created_at: 'DESC',
                },
                take: limit,
            });
            // Descomprimir dados se necessário
            for (const log of logs) {
                await this.decompressLogDataIfNeeded(log);
            }
            return logs;
        }
        catch (error) {
            this.logger.error(`Erro ao buscar logs de acesso a dados sensíveis: ${error.message}`, error.stack);
            throw error;
        }
    }
    /**
     * Comprime dados grandes no log de auditoria
     *
     * @param log Log de auditoria
     */
    async compressLogDataIfNeeded(log) {
        if (!this.compressionEnabled) {
            return;
        }
        try {
            // Comprimir dados_anteriores se for grande
            if (log.dados_anteriores) {
                const dadosAnterioresStr = JSON.stringify(log.dados_anteriores);
                if (dadosAnterioresStr.length > this.compressionThreshold) {
                    const compressed = await gzipAsync(Buffer.from(dadosAnterioresStr));
                    log.dados_anteriores = {
                        __compressed: true,
                        data: compressed.toString('base64'),
                    };
                }
            }
            // Comprimir dados_novos se for grande
            if (log.dados_novos) {
                const dadosNovosStr = JSON.stringify(log.dados_novos);
                if (dadosNovosStr.length > this.compressionThreshold) {
                    const compressed = await gzipAsync(Buffer.from(dadosNovosStr));
                    log.dados_novos = {
                        __compressed: true,
                        data: compressed.toString('base64'),
                    };
                }
            }
        }
        catch (error) {
            this.logger.warn(`Erro ao comprimir dados do log: ${error.message}`);
            // Continuar sem compressão em caso de erro
        }
    }
    /**
     * Descomprime dados no log de auditoria
     *
     * @param log Log de auditoria
     */
    async decompressLogDataIfNeeded(log) {
        if (!this.compressionEnabled) {
            return;
        }
        try {
            // Descomprimir dados_anteriores se estiver comprimido
            if (log.dados_anteriores && log.dados_anteriores['__compressed']) {
                const compressedData = Buffer.from(log.dados_anteriores['data'], 'base64');
                const decompressed = await gunzipAsync(compressedData);
                log.dados_anteriores = JSON.parse(decompressed.toString());
            }
            // Descomprimir dados_novos se estiver comprimido
            if (log.dados_novos && log.dados_novos['__compressed']) {
                const compressedData = Buffer.from(log.dados_novos['data'], 'base64');
                const decompressed = await gunzipAsync(compressedData);
                log.dados_novos = JSON.parse(decompressed.toString());
            }
        }
        catch (error) {
            this.logger.warn(`Erro ao descomprimir dados do log: ${error.message}`);
            // Manter dados comprimidos em caso de erro
        }
    }
    /**
     * Cria uma nova partição na tabela de logs
     *
     * @param dataInicio Data de início da partição
     * @param dataFim Data de fim da partição
     */
    async createPartition(dataInicio, dataFim) {
        try {
            const partitionName = `logs_auditoria_${dataInicio.getFullYear()}_${(dataInicio.getMonth() + 1).toString().padStart(2, '0')}`;
            const startDate = dataInicio.toISOString().split('T')[0];
            const endDate = dataFim.toISOString().split('T')[0];
            // Criar partição usando SQL nativo
            await this.repository.query(`
        CREATE TABLE IF NOT EXISTS ${partitionName} PARTITION OF logs_auditoria
        FOR VALUES FROM ('${startDate}') TO ('${endDate}');
      `);
            this.logger.log(`Partição ${partitionName} criada com sucesso para o período ${startDate} a ${endDate}`);
        }
        catch (error) {
            this.logger.error(`Erro ao criar partição: ${error.message}`, error.stack);
            throw error;
        }
    }
    /**
     * Cria partições para os próximos meses
     *
     * @param meses Número de meses para criar partições
     */
    async createPartitionsForNextMonths(meses = 12) {
        try {
            const hoje = new Date();
            for (let i = 0; i < meses; i++) {
                const dataInicio = new Date(hoje.getFullYear(), hoje.getMonth() + i, 1);
                const dataFim = new Date(hoje.getFullYear(), hoje.getMonth() + i + 1, 1);
                await this.createPartition(dataInicio, dataFim);
            }
            this.logger.log(`Partições criadas com sucesso para os próximos ${meses} meses`);
        }
        catch (error) {
            this.logger.error(`Erro ao criar partições: ${error.message}`, error.stack);
            throw error;
        }
    }
    /**
     * Arquiva logs antigos para tabelas de histórico
     *
     * @param mesesRetencao Número de meses para manter logs na tabela principal
     */
    async archiveOldLogs(mesesRetencao = 12) {
        try {
            const dataLimite = new Date();
            dataLimite.setMonth(dataLimite.getMonth() - mesesRetencao);
            // Mover logs antigos para tabela de histórico
            await this.repository.query(`
        INSERT INTO logs_auditoria_historico
        SELECT * FROM logs_auditoria
        WHERE created_at < '${dataLimite.toISOString()}'
      `);
            // Remover logs antigos da tabela principal
            await this.repository.query(`
        DELETE FROM logs_auditoria
        WHERE created_at < '${dataLimite.toISOString()}'
      `);
            this.logger.log(`Logs anteriores a ${dataLimite.toISOString()} arquivados com sucesso`);
        }
        catch (error) {
            this.logger.error(`Erro ao arquivar logs antigos: ${error.message}`, error.stack);
            throw error;
        }
    }
};
exports.LogAuditoriaRepository = LogAuditoriaRepository;
exports.LogAuditoriaRepository = LogAuditoriaRepository = LogAuditoriaRepository_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(log_auditoria_entity_1.LogAuditoria)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object])
], LogAuditoriaRepository);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXGF1ZGl0b3JpYVxccmVwb3NpdG9yaWVzXFxsb2ctYXVkaXRvcmlhLnJlcG9zaXRvcnkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBc0U7QUFDdEUsNkNBQW1EO0FBQ25ELHFDQUFxRTtBQUNyRSxpRkFBc0U7QUFJdEUsMkNBQTZCO0FBQzdCLCtCQUFpQztBQUVqQyxxQ0FBcUM7QUFDckMsTUFBTSxTQUFTLEdBQUcsSUFBQSxnQkFBUyxFQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN2QyxNQUFNLFdBQVcsR0FBRyxJQUFBLGdCQUFTLEVBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBRTNDOzs7OztHQUtHO0FBRUksSUFBTSxzQkFBc0IsOEJBQTVCLE1BQU0sc0JBQXNCO0lBT2Q7SUFORixNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsd0JBQXNCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDakQsa0JBQWtCLEdBQVksSUFBSSxDQUFDO0lBQ25DLG9CQUFvQixHQUFXLElBQUksQ0FBQyxDQUFDLE1BQU07SUFFNUQsWUFFbUIsVUFBb0M7UUFBcEMsZUFBVSxHQUFWLFVBQVUsQ0FBMEI7SUFDcEQsQ0FBQztJQUVKOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLE1BQU0sQ0FDVixxQkFBNEM7UUFFNUMsSUFBSSxDQUFDO1lBQ0gsaUNBQWlDO1lBQ2pDLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLHFCQUFxQixDQUFDLENBQUM7WUFFbkUsd0NBQXdDO1lBQ3hDLE1BQU0sSUFBSSxDQUFDLHVCQUF1QixDQUFDLFlBQVksQ0FBQyxDQUFDO1lBRWpELCtEQUErRDtZQUMvRCxNQUFNLFFBQVEsR0FBRyxNQUFNLElB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XFxEZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxtb2R1bGVzXFxhdWRpdG9yaWFcXHJlcG9zaXRvcmllc1xcbG9nLWF1ZGl0b3JpYS5yZXBvc2l0b3J5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIExvZ2dlciwgSW5qZWN0LCBPcHRpb25hbCB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IEluamVjdFJlcG9zaXRvcnkgfSBmcm9tICdAbmVzdGpzL3R5cGVvcm0nO1xuaW1wb3J0IHsgUmVwb3NpdG9yeSwgQmV0d2VlbiwgRmluZE9wdGlvbnNXaGVyZSwgUmF3IH0gZnJvbSAndHlwZW9ybSc7XG5pbXBvcnQgeyBMb2dBdWRpdG9yaWEgfSBmcm9tICcuLi8uLi8uLi9lbnRpdGllcy9sb2ctYXVkaXRvcmlhLmVudGl0eSc7XG5pbXBvcnQgeyBUaXBvT3BlcmFjYW8gfSBmcm9tICcuLi8uLi8uLi9lbnVtcy90aXBvLW9wZXJhY2FvLmVudW0nO1xuaW1wb3J0IHsgQ3JlYXRlTG9nQXVkaXRvcmlhRHRvIH0gZnJvbSAnLi4vZHRvL2NyZWF0ZS1sb2ctYXVkaXRvcmlhLmR0byc7XG5pbXBvcnQgeyBRdWVyeUxvZ0F1ZGl0b3JpYUR0byB9IGZyb20gJy4uL2R0by9xdWVyeS1sb2ctYXVkaXRvcmlhLmR0byc7XG5pbXBvcnQgKiBhcyB6bGliIGZyb20gJ3psaWInO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCc7XG5cbi8vIFByb21pc2lmaWNhciBmdW7Dp8O1ZXMgZGUgY29tcHJlc3PDo29cbmNvbnN0IGd6aXBBc3luYyA9IHByb21pc2lmeSh6bGliLmd6aXApO1xuY29uc3QgZ3VuemlwQXN5bmMgPSBwcm9taXNpZnkoemxpYi5ndW56aXApO1xuXG4vKipcbiAqIFJlcG9zaXTDs3JpbyBwYXJhIGxvZ3MgZGUgYXVkaXRvcmlhXG4gKlxuICogSW1wbGVtZW50YSBvIHBhZHLDo28gUmVwb3NpdG9yeSBwYXJhIG9wZXJhw6fDtWVzIGNvbSBsb2dzIGRlIGF1ZGl0b3JpYSxcbiAqIGluY2x1aW5kbyBzdXBvcnRlIGEgY29tcHJlc3PDo28gZGUgZGFkb3MgZSBwYXJ0aWNpb25hbWVudG8gZGUgdGFiZWxhcy5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIExvZ0F1ZGl0b3JpYVJlcG9zaXRvcnkge1xuICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlciA9IG5ldyBMb2dnZXIoTG9nQXVkaXRvcmlhUmVwb3NpdG9yeS5uYW1lKTtcbiAgcHJpdmF0ZSByZWFkb25seSBjb21wcmVzc2lvbkVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbXByZXNzaW9uVGhyZXNob2xkOiBudW1iZXIgPSAxMDI0OyAvLyAxS0JcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0UmVwb3NpdG9yeShMb2dBdWRpdG9yaWEpXG4gICAgcHJpdmF0ZSByZWFkb25seSByZXBvc2l0b3J5OiBSZXBvc2l0b3J5PExvZ0F1ZGl0b3JpYT4sXG4gICkge31cblxuICAvKipcbiAgICogQ3JpYSB1bSBub3ZvIGxvZyBkZSBhdWRpdG9yaWFcbiAgICpcbiAgICogQHBhcmFtIGNyZWF0ZUxvZ0F1ZGl0b3JpYUR0byBEVE8gY29tIGRhZG9zIGRvIGxvZ1xuICAgKiBAcmV0dXJucyBMb2cgZGUgYXVkaXRvcmlhIGNyaWFkb1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlKFxuICAgIGNyZWF0ZUxvZ0F1ZGl0b3JpYUR0bzogQ3JlYXRlTG9nQXVkaXRvcmlhRHRvLFxuICApOiBQcm9taXNlPExvZ0F1ZGl0b3JpYT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDcmlhciBlbnRpZGFkZSBhIHBhcnRpciBkbyBEVE9cbiAgICAgIGNvbnN0IGxvZ0F1ZGl0b3JpYSA9IHRoaXMucmVwb3NpdG9yeS5jcmVhdGUoY3JlYXRlTG9nQXVkaXRvcmlhRHRvKTtcblxuICAgICAgLy8gQ29tcHJpbWlyIGRhZG9zIGdyYW5kZXMgc2UgbmVjZXNzw6FyaW9cbiAgICAgIGF3YWl0IHRoaXMuY29tcHJlc3NMb2dEYXRhSWZOZWVkZWQobG9nQXVkaXRvcmlhKTtcblxuICAgICAgLy8gU2FsdmFyIG8gbG9nIHNlbSBhc3NpbmF0dXJhIHBhcmEgZXZpdGFyIGRlcGVuZMOqbmNpYSBjaXJjdWxhclxuICAgICAgY29uc3Qgc2F2ZWRMb2cgPSBhd2FpdCB0aGlzLnJlcG9zaXRvcnkuc2F2ZShsb2dBdWRpdG9yaWEpO1xuICAgICAgXG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgTG9nICR7c2F2ZWRMb2cuaWR9IGNyaWFkbyBjb20gc3VjZXNzb2ApO1xuXG4gICAgICByZXR1cm4gc2F2ZWRMb2c7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBgRXJybyBhbyBjcmlhciBsb2cgZGUgYXVkaXRvcmlhOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1c2NhIGxvZ3MgZGUgYXVkaXRvcmlhIGNvbSBmaWx0cm9zIGUgcGFnaW5hw6fDo29cbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5RHRvIERUTyBjb20gZmlsdHJvcyBkZSBidXNjYVxuICAgKiBAcmV0dXJucyBMb2dzIGRlIGF1ZGl0b3JpYSBwYWdpbmFkb3NcbiAgICovXG4gIGFzeW5jIGZpbmRBbGwoXG4gICAgcXVlcnlEdG86IFF1ZXJ5TG9nQXVkaXRvcmlhRHRvLFxuICApOiBQcm9taXNlPHsgaXRlbXM6IExvZ0F1ZGl0b3JpYVtdOyB0b3RhbDogbnVtYmVyIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0aXBvX29wZXJhY2FvLFxuICAgICAgICBlbnRpZGFkZV9hZmV0YWRhLFxuICAgICAgICBlbnRpZGFkZV9pZCxcbiAgICAgICAgdXN1YXJpb19pZCxcbiAgICAgICAgaXBfdXN1YXJpbzogaXBfb3JpZ2VtLFxuICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgbWV0b2RvX2h0dHAsXG4gICAgICAgIGRhdGFfaW5pY2lhbDogZGF0YV9pbmljaW8sXG4gICAgICAgIGRhdGFfZmluYWw6IGRhdGFfZmltLFxuICAgICAgICB0ZXJtb19idXNjYSxcbiAgICAgICAgcGFnaW5hOiBwYWdlID0gMSxcbiAgICAgICAgaXRlbnNfcG9yX3BhZ2luYTogbGltaXQgPSAxMCxcbiAgICAgIH0gPSBxdWVyeUR0bztcblxuICAgICAgLy8gQ29uc3RydWlyIHdoZXJlIGNsYXVzZVxuICAgICAgY29uc3Qgd2hlcmU6IEZpbmRPcHRpb25zV2hlcmU8TG9nQXVkaXRvcmlhPiA9IHt9O1xuXG4gICAgICAvLyBGaWx0cmFyIHBvciB0aXBvIGRlIG9wZXJhw6fDo29cbiAgICAgIGlmICh0aXBvX29wZXJhY2FvKSB7XG4gICAgICAgIHdoZXJlLnRpcG9fb3BlcmFjYW8gPSB0aXBvX29wZXJhY2FvO1xuICAgICAgfVxuXG4gICAgICAvLyBGaWx0cmFyIHBvciBlbnRpZGFkZSBhZmV0YWRhXG4gICAgICBpZiAoZW50aWRhZGVfYWZldGFkYSkge1xuICAgICAgICB3aGVyZS5lbnRpZGFkZV9hZmV0YWRhID0gZW50aWRhZGVfYWZldGFkYTtcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdHJhciBwb3IgdXN1w6FyaW9cbiAgICAgIGlmICh1c3VhcmlvX2lkKSB7XG4gICAgICAgIHdoZXJlLnVzdWFyaW9faWQgPSB1c3VhcmlvX2lkO1xuICAgICAgfVxuXG4gICAgICAvLyBGaWx0cmFyIHBvciBJUCBkZSBvcmlnZW1cbiAgICAgIGlmIChpcF9vcmlnZW0pIHtcbiAgICAgICAgd2hlcmUuaXBfb3JpZ2VtID0gaXBfb3JpZ2VtO1xuICAgICAgfVxuXG4gICAgICAvLyBGaWx0cmFyIHBvciBlbmRwb2ludFxuICAgICAgaWYgKGVuZHBvaW50KSB7XG4gICAgICAgIHdoZXJlLmVuZHBvaW50ID0gUmF3KFxuICAgICAgICAgIChhbGlhcykgPT4gYCgke2FsaWFzfSBJTElLRSAnJSR7ZW5kcG9pbnQucmVwbGFjZSgvJy9nLCBcIicnXCIpfSUnKWAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbHRyYXIgcG9yIG3DqXRvZG8gSFRUUFxuICAgICAgaWYgKG1ldG9kb19odHRwKSB7XG4gICAgICAgIHdoZXJlLm1ldG9kb19odHRwID0gbWV0b2RvX2h0dHA7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbHRyYXIgcG9yIHBlcsOtb2RvXG4gICAgICBpZiAoZGF0YV9pbmljaW8gJiYgZGF0YV9maW0pIHtcbiAgICAgICAgd2hlcmUuY3JlYXRlZF9hdCA9IEJldHdlZW4obmV3IERhdGUoZGF0YV9pbmljaW8pLCBuZXcgRGF0ZShkYXRhX2ZpbSkpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhX2luaWNpbykge1xuICAgICAgICB3aGVyZS5jcmVhdGVkX2F0ID0gUmF3KChhbGlhcykgPT4gYCgke2FsaWFzfSA+PSA6ZGF0YUluaWNpbylgLCB7XG4gICAgICAgICAgZGF0YUluaWNpbzogbmV3IERhdGUoZGF0YV9pbmljaW8pLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YV9maW0pIHtcbiAgICAgICAgd2hlcmUuY3JlYXRlZF9hdCA9IFJhdygoYWxpYXMpID0+IGAoJHthbGlhc30gPD0gOmRhdGFGaW0pYCwge1xuICAgICAgICAgIGRhdGFGaW06IG5ldyBEYXRlKGRhdGFfZmltKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbHRyYXIgcG9yIHByZXNlbsOnYSBkZSBkYWRvcyBzZW5zw612ZWlzXG4gICAgICBpZiAodGVybW9fYnVzY2EpIHtcbiAgICAgICAgd2hlcmUuZGFkb3Nfc2Vuc2l2ZWlzX2FjZXNzYWRvcyA9IFJhdyhcbiAgICAgICAgICAoYWxpYXMpID0+IGAoJHthbGlhc306OnRleHQgSUxJS0UgOnRlcm1vKWAsXG4gICAgICAgICAgeyB0ZXJtbzogYCUke3Rlcm1vX2J1c2NhfSVgIH0sXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGFyIHNraXAgcGFyYSBwYWdpbmHDp8Ojb1xuICAgICAgY29uc3Qgc2tpcCA9IChwYWdlIC0gMSkgKiBsaW1pdDtcblxuICAgICAgLy8gRXhlY3V0YXIgY29uc3VsdGFcbiAgICAgIGNvbnN0IFtpdGVtcywgdG90YWxdID0gYXdhaXQgdGhpcy5yZXBvc2l0b3J5LmZpbmRBbmRDb3VudCh7XG4gICAgICAgIHdoZXJlLFxuICAgICAgICBza2lwLFxuICAgICAgICB0YWtlOiBsaW1pdCxcbiAgICAgICAgb3JkZXI6IHtcbiAgICAgICAgICBjcmVhdGVkX2F0OiAnREVTQycsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gRGVzY29tcHJpbWlyIGRhZG9zIHNlIG5lY2Vzc8OhcmlvXG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWNvbXByZXNzTG9nRGF0YUlmTmVlZGVkKGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBpdGVtcywgdG90YWwgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBFcnJvIGFvIGJ1c2NhciBsb2dzIGRlIGF1ZGl0b3JpYTogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgIGVycm9yLnN0YWNrLFxuICAgICAgKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdXNjYSB1bSBsb2cgZGUgYXVkaXRvcmlhIHBlbG8gSURcbiAgICpcbiAgICogQHBhcmFtIGlkIElEIGRvIGxvZ1xuICAgKiBAcmV0dXJucyBMb2cgZGUgYXVkaXRvcmlhXG4gICAqL1xuICBhc3luYyBmaW5kT25lKGlkOiBzdHJpbmcpOiBQcm9taXNlPExvZ0F1ZGl0b3JpYSB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbG9nID0gYXdhaXQgdGhpcy5yZXBvc2l0b3J5LmZpbmRPbmUoeyB3aGVyZTogeyBpZCB9IH0pO1xuXG4gICAgICBpZiAoIWxvZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gRGVzY29tcHJpbWlyIGRhZG9zIHNlIG5lY2Vzc8OhcmlvXG4gICAgICBhd2FpdCB0aGlzLmRlY29tcHJlc3NMb2dEYXRhSWZOZWVkZWQobG9nKTtcblxuICAgICAgcmV0dXJuIGxvZztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBFcnJvIGFvIGJ1c2NhciBsb2cgZGUgYXVkaXRvcmlhOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1c2NhIGxvZ3MgZGUgYXVkaXRvcmlhIHBvciBlbnRpZGFkZSBlIElEXG4gICAqXG4gICAqIEBwYXJhbSBlbnRpZGFkZSBOb21lIGRhIGVudGlkYWRlXG4gICAqIEBwYXJhbSBlbnRpZGFkZUlkIElEIGRhIGVudGlkYWRlXG4gICAqIEByZXR1cm5zIExvZ3MgZGUgYXVkaXRvcmlhXG4gICAqL1xuICBhc3luYyBmaW5kQnlFbnRpdHkoXG4gICAgZW50aWRhZGU6IHN0cmluZyxcbiAgICBlbnRpZGFkZUlkOiBzdHJpbmcsXG4gICk6IFByb21pc2U8TG9nQXVkaXRvcmlhW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbG9ncyA9IGF3YWl0IHRoaXMucmVwb3NpdG9yeS5maW5kKHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBlbnRpZGFkZV9hZmV0YWRhOiBlbnRpZGFkZSxcbiAgICAgICAgICBlbnRpZGFkZV9pZDogZW50aWRhZGVJZCxcbiAgICAgICAgfSxcbiAgICAgICAgb3JkZXI6IHtcbiAgICAgICAgICBjcmVhdGVkX2F0OiAnREVTQycsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gRGVzY29tcHJpbWlyIGRhZG9zIHNlIG5lY2Vzc8OhcmlvXG4gICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZGVjb21wcmVzc0xvZ0RhdGFJZk5lZWRlZChsb2cpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9ncztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBFcnJvIGFvIGJ1c2NhciBsb2dzIHBvciBlbnRpZGFkZTogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgIGVycm9yLnN0YWNrLFxuICAgICAgKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdXNjYSBsb2dzIGRlIGF1ZGl0b3JpYSBwb3IgdXN1w6FyaW9cbiAgICpcbiAgICogQHBhcmFtIHVzdWFyaW9JZCBJRCBkbyB1c3XDoXJpb1xuICAgKiBAcGFyYW0gbGltaXQgTGltaXRlIGRlIHJlZ2lzdHJvc1xuICAgKiBAcmV0dXJucyBMb2dzIGRlIGF1ZGl0b3JpYVxuICAgKi9cbiAgYXN5bmMgZmluZEJ5VXNlcihcbiAgICB1c3VhcmlvSWQ6IHN0cmluZyxcbiAgICBsaW1pdDogbnVtYmVyID0gMTAwLFxuICApOiBQcm9taXNlPExvZ0F1ZGl0b3JpYVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxvZ3MgPSBhd2FpdCB0aGlzLnJlcG9zaXRvcnkuZmluZCh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgdXN1YXJpb19pZDogdXN1YXJpb0lkLFxuICAgICAgICB9LFxuICAgICAgICBvcmRlcjoge1xuICAgICAgICAgIGNyZWF0ZWRfYXQ6ICdERVNDJyxcbiAgICAgICAgfSxcbiAgICAgICAgdGFrZTogbGltaXQsXG4gICAgICB9KTtcblxuICAgICAgLy8gRGVzY29tcHJpbWlyIGRhZG9zIHNlIG5lY2Vzc8OhcmlvXG4gICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZGVjb21wcmVzc0xvZ0RhdGFJZk5lZWRlZChsb2cpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9ncztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBFcnJvIGFvIGJ1c2NhciBsb2dzIHBvciB1c3XDoXJpbzogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgIGVycm9yLnN0YWNrLFxuICAgICAgKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdXNjYSBsb2dzIGRlIGF1ZGl0b3JpYSBkZSBhY2Vzc28gYSBkYWRvcyBzZW5zw612ZWlzXG4gICAqXG4gICAqIEBwYXJhbSBsaW1pdCBMaW1pdGUgZGUgcmVnaXN0cm9zXG4gICAqIEByZXR1cm5zIExvZ3MgZGUgYXVkaXRvcmlhXG4gICAqL1xuICBhc3luYyBmaW5kU2Vuc2l0aXZlRGF0YUFjY2VzcyhsaW1pdDogbnVtYmVyID0gMTAwKTogUHJvbWlzZTxMb2dBdWRpdG9yaWFbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsb2dzID0gYXdhaXQgdGhpcy5yZXBvc2l0b3J5LmZpbmQoe1xuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIGRhZG9zX3NlbnNpdmVpc19hY2Vzc2Fkb3M6IFJhdyhcbiAgICAgICAgICAgIChhbGlhcykgPT4gYCgke2FsaWFzfSBJUyBOT1QgTlVMTCBBTkQgJHthbGlhc306OnRleHQgIT0gJ1tdJylgLFxuICAgICAgICAgICksXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGVyOiB7XG4gICAgICAgICAgY3JlYXRlZF9hdDogJ0RFU0MnLFxuICAgICAgICB9LFxuICAgICAgICB0YWtlOiBsaW1pdCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBEZXNjb21wcmltaXIgZGFkb3Mgc2UgbmVjZXNzw6FyaW9cbiAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWNvbXByZXNzTG9nRGF0YUlmTmVlZGVkKGxvZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2dzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gYnVzY2FyIGxvZ3MgZGUgYWNlc3NvIGEgZGFkb3Mgc2Vuc8OtdmVpczogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgIGVycm9yLnN0YWNrLFxuICAgICAgKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmltZSBkYWRvcyBncmFuZGVzIG5vIGxvZyBkZSBhdWRpdG9yaWFcbiAgICpcbiAgICogQHBhcmFtIGxvZyBMb2cgZGUgYXVkaXRvcmlhXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNvbXByZXNzTG9nRGF0YUlmTmVlZGVkKGxvZzogTG9nQXVkaXRvcmlhKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmNvbXByZXNzaW9uRW5hYmxlZCkge3JldHVybjt9XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ29tcHJpbWlyIGRhZG9zX2FudGVyaW9yZXMgc2UgZm9yIGdyYW5kZVxuICAgICAgaWYgKGxvZy5kYWRvc19hbnRlcmlvcmVzKSB7XG4gICAgICAgIGNvbnN0IGRhZG9zQW50ZXJpb3Jlc1N0ciA9IEpTT04uc3RyaW5naWZ5KGxvZy5kYWRvc19hbnRlcmlvcmVzKTtcblxuICAgICAgICBpZiAoZGFkb3NBbnRlcmlvcmVzU3RyLmxlbmd0aCA+IHRoaXMuY29tcHJlc3Npb25UaHJlc2hvbGQpIHtcbiAgICAgICAgICBjb25zdCBjb21wcmVzc2VkID0gYXdhaXQgZ3ppcEFzeW5jKEJ1ZmZlci5mcm9tKGRhZG9zQW50ZXJpb3Jlc1N0cikpO1xuICAgICAgICAgIGxvZy5kYWRvc19hbnRlcmlvcmVzID0ge1xuICAgICAgICAgICAgX19jb21wcmVzc2VkOiB0cnVlLFxuICAgICAgICAgICAgZGF0YTogY29tcHJlc3NlZC50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb21wcmltaXIgZGFkb3Nfbm92b3Mgc2UgZm9yIGdyYW5kZVxuICAgICAgaWYgKGxvZy5kYWRvc19ub3Zvcykge1xuICAgICAgICBjb25zdCBkYWRvc05vdm9zU3RyID0gSlNPTi5zdHJpbmdpZnkobG9nLmRhZG9zX25vdm9zKTtcblxuICAgICAgICBpZiAoZGFkb3NOb3Zvc1N0ci5sZW5ndGggPiB0aGlzLmNvbXByZXNzaW9uVGhyZXNob2xkKSB7XG4gICAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IGF3YWl0IGd6aXBBc3luYyhCdWZmZXIuZnJvbShkYWRvc05vdm9zU3RyKSk7XG4gICAgICAgICAgbG9nLmRhZG9zX25vdm9zID0ge1xuICAgICAgICAgICAgX19jb21wcmVzc2VkOiB0cnVlLFxuICAgICAgICAgICAgZGF0YTogY29tcHJlc3NlZC50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBFcnJvIGFvIGNvbXByaW1pciBkYWRvcyBkbyBsb2c6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIC8vIENvbnRpbnVhciBzZW0gY29tcHJlc3PDo28gZW0gY2FzbyBkZSBlcnJvXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2NvbXByaW1lIGRhZG9zIG5vIGxvZyBkZSBhdWRpdG9yaWFcbiAgICpcbiAgICogQHBhcmFtIGxvZyBMb2cgZGUgYXVkaXRvcmlhXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGRlY29tcHJlc3NMb2dEYXRhSWZOZWVkZWQobG9nOiBMb2dBdWRpdG9yaWEpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuY29tcHJlc3Npb25FbmFibGVkKSB7cmV0dXJuO31cblxuICAgIHRyeSB7XG4gICAgICAvLyBEZXNjb21wcmltaXIgZGFkb3NfYW50ZXJpb3JlcyBzZSBlc3RpdmVyIGNvbXByaW1pZG9cbiAgICAgIGlmIChsb2cuZGFkb3NfYW50ZXJpb3JlcyAmJiBsb2cuZGFkb3NfYW50ZXJpb3Jlc1snX19jb21wcmVzc2VkJ10pIHtcbiAgICAgICAgY29uc3QgY29tcHJlc3NlZERhdGEgPSBCdWZmZXIuZnJvbShcbiAgICAgICAgICBsb2cuZGFkb3NfYW50ZXJpb3Jlc1snZGF0YSddLFxuICAgICAgICAgICdiYXNlNjQnLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBkZWNvbXByZXNzZWQgPSBhd2FpdCBndW56aXBBc3luYyhjb21wcmVzc2VkRGF0YSk7XG4gICAgICAgIGxvZy5kYWRvc19hbnRlcmlvcmVzID0gSlNPTi5wYXJzZShkZWNvbXByZXNzZWQudG9TdHJpbmcoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlc2NvbXByaW1pciBkYWRvc19ub3ZvcyBzZSBlc3RpdmVyIGNvbXByaW1pZG9cbiAgICAgIGlmIChsb2cuZGFkb3Nfbm92b3MgJiYgbG9nLmRhZG9zX25vdm9zWydfX2NvbXByZXNzZWQnXSkge1xuICAgICAgICBjb25zdCBjb21wcmVzc2VkRGF0YSA9IEJ1ZmZlci5mcm9tKGxvZy5kYWRvc19ub3Zvc1snZGF0YSddLCAnYmFzZTY0Jyk7XG4gICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZCA9IGF3YWl0IGd1bnppcEFzeW5jKGNvbXByZXNzZWREYXRhKTtcbiAgICAgICAgbG9nLmRhZG9zX25vdm9zID0gSlNPTi5wYXJzZShkZWNvbXByZXNzZWQudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oYEVycm8gYW8gZGVzY29tcHJpbWlyIGRhZG9zIGRvIGxvZzogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgLy8gTWFudGVyIGRhZG9zIGNvbXByaW1pZG9zIGVtIGNhc28gZGUgZXJyb1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmlhIHVtYSBub3ZhIHBhcnRpw6fDo28gbmEgdGFiZWxhIGRlIGxvZ3NcbiAgICpcbiAgICogQHBhcmFtIGRhdGFJbmljaW8gRGF0YSBkZSBpbsOtY2lvIGRhIHBhcnRpw6fDo29cbiAgICogQHBhcmFtIGRhdGFGaW0gRGF0YSBkZSBmaW0gZGEgcGFydGnDp8Ojb1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlUGFydGl0aW9uKGRhdGFJbmljaW86IERhdGUsIGRhdGFGaW06IERhdGUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFydGl0aW9uTmFtZSA9IGBsb2dzX2F1ZGl0b3JpYV8ke2RhdGFJbmljaW8uZ2V0RnVsbFllYXIoKX1fJHsoZGF0YUluaWNpby5nZXRNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XG4gICAgICBjb25zdCBzdGFydERhdGUgPSBkYXRhSW5pY2lvLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICAgIGNvbnN0IGVuZERhdGUgPSBkYXRhRmltLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcblxuICAgICAgLy8gQ3JpYXIgcGFydGnDp8OjbyB1c2FuZG8gU1FMIG5hdGl2b1xuICAgICAgYXdhaXQgdGhpcy5yZXBvc2l0b3J5LnF1ZXJ5KGBcbiAgICAgICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJHtwYXJ0aXRpb25OYW1lfSBQQVJUSVRJT04gT0YgbG9nc19hdWRpdG9yaWFcbiAgICAgICAgRk9SIFZBTFVFUyBGUk9NICgnJHtzdGFydERhdGV9JykgVE8gKCcke2VuZERhdGV9Jyk7XG4gICAgICBgKTtcblxuICAgICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgICBgUGFydGnDp8OjbyAke3BhcnRpdGlvbk5hbWV9IGNyaWFkYSBjb20gc3VjZXNzbyBwYXJhIG8gcGVyw61vZG8gJHtzdGFydERhdGV9IGEgJHtlbmREYXRlfWAsXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gY3JpYXIgcGFydGnDp8OjbzogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgIGVycm9yLnN0YWNrLFxuICAgICAgKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmlhIHBhcnRpw6fDtWVzIHBhcmEgb3MgcHLDs3hpbW9zIG1lc2VzXG4gICAqXG4gICAqIEBwYXJhbSBtZXNlcyBOw7ptZXJvIGRlIG1lc2VzIHBhcmEgY3JpYXIgcGFydGnDp8O1ZXNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVBhcnRpdGlvbnNGb3JOZXh0TW9udGhzKG1lc2VzOiBudW1iZXIgPSAxMik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBob2plID0gbmV3IERhdGUoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNlczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGFJbmljaW8gPSBuZXcgRGF0ZShob2plLmdldEZ1bGxZZWFyKCksIGhvamUuZ2V0TW9udGgoKSArIGksIDEpO1xuICAgICAgICBjb25zdCBkYXRhRmltID0gbmV3IERhdGUoXG4gICAgICAgICAgaG9qZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgIGhvamUuZ2V0TW9udGgoKSArIGkgKyAxLFxuICAgICAgICAgIDEsXG4gICAgICAgICk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVQYXJ0aXRpb24oZGF0YUluaWNpbywgZGF0YUZpbSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgICAgYFBhcnRpw6fDtWVzIGNyaWFkYXMgY29tIHN1Y2Vzc28gcGFyYSBvcyBwcsOzeGltb3MgJHttZXNlc30gbWVzZXNgLFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBFcnJvIGFvIGNyaWFyIHBhcnRpw6fDtWVzOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFycXVpdmEgbG9ncyBhbnRpZ29zIHBhcmEgdGFiZWxhcyBkZSBoaXN0w7NyaWNvXG4gICAqXG4gICAqIEBwYXJhbSBtZXNlc1JldGVuY2FvIE7Dum1lcm8gZGUgbWVzZXMgcGFyYSBtYW50ZXIgbG9ncyBuYSB0YWJlbGEgcHJpbmNpcGFsXG4gICAqL1xuICBhc3luYyBhcmNoaXZlT2xkTG9ncyhtZXNlc1JldGVuY2FvOiBudW1iZXIgPSAxMik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhTGltaXRlID0gbmV3IERhdGUoKTtcbiAgICAgIGRhdGFMaW1pdGUuc2V0TW9udGgoZGF0YUxpbWl0ZS5nZXRNb250aCgpIC0gbWVzZXNSZXRlbmNhbyk7XG5cbiAgICAgIC8vIE1vdmVyIGxvZ3MgYW50aWdvcyBwYXJhIHRhYmVsYSBkZSBoaXN0w7NyaWNvXG4gICAgICBhd2FpdCB0aGlzLnJlcG9zaXRvcnkucXVlcnkoYFxuICAgICAgICBJTlNFUlQgSU5UTyBsb2dzX2F1ZGl0b3JpYV9oaXN0b3JpY29cbiAgICAgICAgU0VMRUNUICogRlJPTSBsb2dzX2F1ZGl0b3JpYVxuICAgICAgICBXSEVSRSBjcmVhdGVkX2F0IDwgJyR7ZGF0YUxpbWl0ZS50b0lTT1N0cmluZygpfSdcbiAgICAgIGApO1xuXG4gICAgICAvLyBSZW1vdmVyIGxvZ3MgYW50aWdvcyBkYSB0YWJlbGEgcHJpbmNpcGFsXG4gICAgICBhd2FpdCB0aGlzLnJlcG9zaXRvcnkucXVlcnkoYFxuICAgICAgICBERUxFVEUgRlJPTSBsb2dzX2F1ZGl0b3JpYVxuICAgICAgICBXSEVSRSBjcmVhdGVkX2F0IDwgJyR7ZGF0YUxpbWl0ZS50b0lTT1N0cmluZygpfSdcbiAgICAgIGApO1xuXG4gICAgICB0aGlzLmxvZ2dlci5sb2coXG4gICAgICAgIGBMb2dzIGFudGVyaW9yZXMgYSAke2RhdGFMaW1pdGUudG9JU09TdHJpbmcoKX0gYXJxdWl2YWRvcyBjb20gc3VjZXNzb2AsXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gYXJxdWl2YXIgbG9ncyBhbnRpZ29zOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG4iXSwidmVyc2lvbiI6M30=