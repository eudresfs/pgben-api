9944585d70c7407df2145a8892ea1747
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MetricasColetaService_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricasColetaService = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const event_emitter_1 = require("@nestjs/event-emitter");
const config_1 = require("@nestjs/config");
const crypto = __importStar(require("crypto"));
const schedule_adapter_service_1 = require("../../../shared/schedule/schedule-adapter.service");
const metrica_definicao_entity_1 = require("../../../entities/metrica-definicao.entity");
const metrica_snapshot_entity_1 = require("../../../entities/metrica-snapshot.entity");
const metrica_configuracao_entity_1 = require("../../../entities/metrica-configuracao.entity");
const metrica_calculo_service_1 = require("./metrica-calculo.service");
/**
 * Serviço responsável pela coleta programada e reativa de métricas
 *
 * Este serviço gerencia o agendamento, coleta e armazenamento de métricas
 * conforme as configurações definidas para cada métrica no sistema.
 */
let MetricasColetaService = MetricasColetaService_1 = class MetricasColetaService {
    metricaDefinicaoRepository;
    metricaSnapshotRepository;
    metricaConfiguracaoRepository;
    calculoService;
    scheduleAdapter;
    eventEmitter;
    configService;
    dataSource;
    logger = new common_1.Logger(MetricasColetaService_1.name);
    constructor(metricaDefinicaoRepository, metricaSnapshotRepository, metricaConfiguracaoRepository, calculoService, scheduleAdapter, eventEmitter, configService, dataSource) {
        this.metricaDefinicaoRepository = metricaDefinicaoRepository;
        this.metricaSnapshotRepository = metricaSnapshotRepository;
        this.metricaConfiguracaoRepository = metricaConfiguracaoRepository;
        this.calculoService = calculoService;
        this.scheduleAdapter = scheduleAdapter;
        this.eventEmitter = eventEmitter;
        this.configService = configService;
        this.dataSource = dataSource;
    }
    /**
     * Inicializa os agendamentos quando o módulo é carregado
     */
    async onModuleInit() {
        // Inicializar verificação de configurações de agendamento a cada hora
        this.scheduleAdapter.scheduleInterval('verificar_configuracoes_agendamento', 3600000, // 1 hora em milissegundos
        () => this.verificarConfiguracoesAgendamento());
        // Inicializar coleta diária de métricas à meia-noite
        this.scheduleAdapter.scheduleDailyTask('coletar_metricas_diarias', 0, // hora (0 = meia-noite)
        0, // minuto
        () => this.coletarMetricasDiarias());
        // Inicializar o serviço de coleta
        await this.inicializar();
    }
    /**
     * Inicializa o serviço de coleta de métricas
     * Configura jobs cron para métricas com agendamento
     */
    async inicializar() {
        this.logger.log('Inicializando serviço de coleta de métricas');
        try {
            // Carregar todas as configurações de métricas ativas com coleta automática
            const configuracoes = await this.metricaConfiguracaoRepository.find({
                where: { coleta_automatica: true },
                relations: ['metrica'],
            });
            this.logger.log(`Encontradas ${configuracoes.length} métricas configuradas para coleta automática`);
            // Configurar agendamentos para cada métrica
            for (const config of configuracoes) {
                // Carregar a entidade metrica para acessar suas propriedades
                const metrica = await config.metrica;
                if (!metrica.ativa) {
                    this.logger.debug(`Métrica ${metrica.codigo} não está ativa, ignorando agendamento`);
                    continue;
                }
                await this.configurarAgendamentoMetrica(config);
            }
            this.logger.log('Serviço de coleta de métricas inicializado com sucesso');
        }
        catch (error) {
            this.logger.error(`Erro ao inicializar serviço de coleta: ${error.message}`, error.stack);
        }
    }
    /**
     * Configura o agendamento para uma métrica específica
     * @param config Configuração da métrica
     */
    async configurarAgendamentoMetrica(config) {
        // Carregar a entidade metrica para acessar suas propriedades
        const metrica = await config.metrica;
        const jobId = `metrica_${metrica.codigo}`;
        try {
            // Cancelar agendamento existente, se houver
            this.scheduleAdapter.cancelInterval(jobId);
            // Configurar novo job conforme o tipo de agendamento
            switch (config.tipo_agendamento) {
                case metrica_configuracao_entity_1.TipoAgendamento.CRON:
                    if (config.expressao_cron) {
                        this.logger.debug(`Configurando job cron para métrica ${metrica.codigo}: ${config.expressao_cron}`);
                        // Usamos o adaptador de agendamento personalizado
                        this.scheduleAdapter.scheduleInterval(jobId, this.calcularIntervaloEmMilissegundos(config.expressao_cron), async () => {
                            try {
                                await this.coletarMetrica(metrica.id);
                            }
                            catch (err) {
                                this.logger.error(`Erro ao coletar métrica ${metrica.codigo}: ${err.message}`);
                            }
                        });
                        this.logger.log(`Agendamento configurado para métrica ${metrica.codigo}`);
                    }
                    break;
                case metrica_configuracao_entity_1.TipoAgendamento.INTERVALO:
                    if (config.intervalo_segundos > 0) {
                        this.logger.debug(`Configurando job de intervalo para métrica ${metrica.codigo}: ${config.intervalo_segundos} segundos`);
                        const intervalo = config.intervalo_segundos * 1000;
                        this.logger.debug(`Configurando job de intervalo para métrica ${metrica.codigo}: ${intervalo}ms`);
                        // Usar o adaptador de agendamento
                        this.scheduleAdapter.scheduleInterval(jobId, intervalo, async () => {
                            try {
                                await this.coletarMetrica(metrica.id);
                            }
                            catch (err) {
                                this.logger.error(`Erro ao coletar métrica ${metrica.codigo}: ${err.message}`);
                            }
                        });
                        this.logger.log(`Agendamento configurado para métrica ${metrica.codigo}`);
                    }
                    break;
                case metrica_configuracao_entity_1.TipoAgendamento.EVENTO:
                    // A configuração para eventos é feita via decorador @OnEvent
                    this.logger.debug(`Métrica ${metrica.codigo} configurada para coleta via evento: ${config.nome_evento}`);
                    break;
                case metrica_configuracao_entity_1.TipoAgendamento.MANUAL:
                    this.logger.debug(`Métrica ${metrica.codigo} configurada para coleta manual`);
                    break;
                default:
                    this.logger.warn(`Tipo de agendamento não suportado para métrica ${metrica.codigo}: ${config.tipo_agendamento}`);
            }
            this.logger.log(`Agendamento configurado com sucesso para métrica: ${metrica.codigo}`);
        }
        catch (error) {
            this.logger.error(`Erro ao configurar agendamento para métrica ${metrica.codigo}: ${error.message}`, error.stack);
        }
    }
    /**
     * Manipulador de eventos para coleta de métricas baseada em eventos
     * @param payload Dados do evento
     */
    async handleEvento(payload) {
        if (!payload || !payload.evento) {
            return;
        }
        const nomeEvento = payload.evento;
        this.logger.debug(`Evento recebido: ${nomeEvento}`);
        try {
            // Buscar métricas configuradas para este evento
            const configuracoes = await this.metricaConfiguracaoRepository.find({
                where: {
                    coleta_automatica: true,
                    tipo_agendamento: metrica_configuracao_entity_1.TipoAgendamento.EVENTO,
                    nome_evento: nomeEvento,
                },
                relations: ['metrica'],
            });
            if (configuracoes.length === 0) {
                return;
            }
            this.logger.debug(`Encontradas ${configuracoes.length} métricas para coleta baseada no evento: ${nomeEvento}`);
            // Coletar cada métrica encontrada
            for (const config of configuracoes) {
                // Carregar a entidade metrica para acessar suas propriedades
                const metrica = await config.metrica;
                if (metrica.ativa) {
                    this.coletarMetrica(metrica.id, payload).catch((err) => this.logger.error(`Erro ao coletar métrica ${metrica.codigo} para evento ${nomeEvento}: ${err.message}`));
                }
            }
        }
        catch (error) {
            this.logger.error(`Erro ao processar evento ${nomeEvento}: ${error.message}`, error.stack);
        }
    }
    /**
     * Coleta dados para uma métrica específica
     * @param metricaId ID da métrica a ser coletada
     * @param contexto Contexto adicional para a coleta (opcional)
     * @returns Snapshot da métrica coletada
     */
    async coletarMetrica(metricaId, contexto) {
        const inicioColeta = Date.now();
        this.logger.debug(`Iniciando coleta para métrica ID: ${metricaId}`);
        try {
            // Buscar definição e configuração da métrica
            const metrica = await this.metricaDefinicaoRepository.findOne({
                where: { id: metricaId, ativa: true },
                relations: ['configuracoes'],
            });
            if (!metrica) {
                throw new Error(`Métrica não encontrada ou inativa: ${metricaId}`);
            }
            const config = metrica.configuracoes[0]; // Usar a primeira configuração disponível
            if (!config) {
                throw new Error(`Configuração não encontrada para métrica: ${metrica.codigo}`);
            }
            // Definir período de referência para a coleta
            const periodoFim = new Date();
            let periodoInicio;
            // Calcular início do período com base na granularidade da métrica
            switch (metrica.granularidade) {
                case 'minuto':
                    periodoInicio = new Date(periodoFim);
                    periodoInicio.setMinutes(periodoInicio.getMinutes() - 1);
                    periodoInicio.setSeconds(0, 0);
                    break;
                case 'hora':
                    periodoInicio = new Date(periodoFim);
                    periodoInicio.setHours(periodoInicio.getHours() - 1);
                    periodoInicio.setMinutes(0, 0, 0);
                    break;
                case 'dia':
                    periodoInicio = new Date(periodoFim);
                    periodoInicio.setDate(periodoInicio.getDate() - 1);
                    periodoInicio.setHours(0, 0, 0, 0);
                    break;
                case 'semana':
                    periodoInicio = new Date(periodoFim);
                    periodoInicio.setDate(periodoInicio.getDate() - 7);
                    periodoInicio.setHours(0, 0, 0, 0);
                    break;
                case 'mes':
                    periodoInicio = new Date(periodoFim);
                    periodoInicio.setMonth(periodoInicio.getMonth() - 1);
                    periodoInicio.setDate(1);
                    periodoInicio.setHours(0, 0, 0, 0);
                    break;
                case 'trimestre':
                    periodoInicio = new Date(periodoFim);
                    periodoInicio.setMonth(periodoInicio.getMonth() - 3);
                    periodoInicio.setDate(1);
                    periodoInicio.setHours(0, 0, 0, 0);
                    break;
                case 'ano':
                    periodoInicio = new Date(periodoFim);
                    periodoInicio.setFullYear(periodoInicio.getFullYear() - 1);
                    periodoInicio.setMonth(0, 1);
                    periodoInicio.setHours(0, 0, 0, 0);
                    break;
                default:
                    // Padrão: um dia
                    periodoInicio = new Date(periodoFim);
                    periodoInicio.setDate(periodoInicio.getDate() - 1);
                    periodoInicio.setHours(0, 0, 0, 0);
            }
            // Definir dimensões e metadados para o snapshot
            const dimensoes = contexto?.dimensoes || {};
            const metadados = {
                origem: 'coleta_automatica',
                job_id: `metrica_${metrica.codigo}`,
                contexto: contexto ? JSON.stringify(contexto).substring(0, 1000) : null,
            };
            // Calcular hash das dimensões para garantir unicidade
            const dimensoesHash = this.gerarHashDimensoes(dimensoes);
            // Verificar se já existe um snapshot para o mesmo período e dimensões
            const snapshotExistente = await this.metricaSnapshotRepository.findOne({
                where: {
                    definicao_id: metrica.id,
                    periodo_inicio: periodoInicio,
                    periodo_fim: periodoFim,
                    dimensoes_hash: dimensoesHash,
                },
            });
            if (snapshotExistente) {
                this.logger.debug(`Snapshot já existe para métrica ${metrica.codigo} no período especificado`);
                return snapshotExistente;
            }
            // Calcular valor da métrica
            const valorCalculado = await this.calculoService.calcularValorMetrica(metrica, periodoInicio, periodoFim, dimensoes);
            // Formatar valor conforme configurações da métrica
            const valorFormatado = this.formatarValorMetrica(valorCalculado, metrica);
            // Criar snapshot
            const snapshot = this.metricaSnapshotRepository.create({
                definicao_id: metrica.id,
                periodo_inicio: periodoInicio,
                periodo_fim: periodoFim,
                granularidade: metrica.granularidade,
                valor: valorCalculado,
                valor_formatado: valorFormatado,
                dimensoes,
                dimensoes_hash: dimensoesHash,
                metadados,
                versao_definicao: metrica.versao,
                duracao_processamento_ms: Date.now() - inicioColeta,
                status_coleta: 'sucesso',
            });
            // Salvar snapshot no banco de dados
            const snapshotSalvo = await this.metricaSnapshotRepository.save(snapshot);
            // Atualizar data da última coleta na definição da métrica
            await this.metricaDefinicaoRepository.update({ id: metrica.id }, { ultima_coleta: new Date() });
            this.logger.log(`Métrica coletada com sucesso: ${metrica.codigo}, valor: ${valorCalculado}`);
            // Verificar se o valor ultrapassa limites configurados para alertas
            await this.verificarAlertas(metrica, config, valorCalculado);
            // Limpar snapshots antigos conforme política de retenção
            this.limparSnapshotsAntigos(metrica.id, config).catch((err) => this.logger.error(`Erro ao limpar snapshots antigos: ${err.message}`));
            return snapshotSalvo;
        }
        catch (error) {
            const duracao = Date.now() - inicioColeta;
            this.logger.error(`Erro ao coletar métrica ${metricaId}: ${error.message}`, error.stack);
            // Registrar snapshot com erro
            try {
                const metrica = await this.metricaDefinicaoRepository.findOne({
                    where: { id: metricaId },
                });
                if (metrica) {
                    const snapshot = this.metricaSnapshotRepository.create({
                        definicao_id: metricaId,
                        periodo_inicio: new Date(),
                        periodo_fim: new Date(),
                        granularidade: metrica.granularidade,
                        valor: 0,
                        valor_formatado: 'ERRO',
                        dimensoes: {},
                        dimensoes_hash: this.gerarHashDimensoes({}),
                        metadados: { erro: error.message },
                        duracao_processamento_ms: duracao,
                        status_coleta: 'erro',
                        mensagem_status: error.message.substring(0, 500),
                    });
                    await this.metricaSnapshotRepository.save(snapshot);
                }
            }
            catch (saveError) {
                this.logger.error(`Erro ao salvar snapshot de erro: ${saveError.message}`);
            }
            throw error;
        }
    }
    /**
     * Verifica se o valor da métrica ultrapassa limites configurados e gera alertas
     * @param metrica Definição da métrica
     * @param config Configuração da métrica
     * @param valor Valor calculado
     */
    async verificarAlertas(metrica, config, valor) {
        if (!config.alertas || config.alertas.length === 0) {
            return;
        }
        for (const alerta of config.alertas) {
            let condicaoAtivada = false;
            // Verificar condição do alerta
            switch (alerta.tipo) {
                case 'valor_maximo':
                    condicaoAtivada = valor > alerta.valor;
                    break;
                case 'valor_minimo':
                    condicaoAtivada = valor < alerta.valor;
                    break;
                case 'valor_igual':
                    condicaoAtivada = valor === alerta.valor;
                    break;
                case 'valor_mudanca_percentual':
                    try {
                        // Buscar snapshot anterior para comparação
                        const snapshotAnterior = await this.metricaSnapshotRepository.findOne({
                            where: {
                                definicao_id: metrica.id,
                                periodo_fim: (0, typeorm_2.MoreThan)(new Date(Date.now() - 86400000)), // Últimas 24h
                            },
                            order: { periodo_fim: 'DESC' },
                        });
                        if (snapshotAnterior) {
                            const variacaoPercentual = ((valor - snapshotAnterior.valor) / snapshotAnterior.valor) *
                                100;
                            condicaoAtivada = Math.abs(variacaoPercentual) > alerta.valor;
                        }
                    }
                    catch (error) {
                        this.logger.error(`Erro ao verificar variação percentual: ${error.message}`);
                    }
                    break;
            }
            // Se a condição for satisfeita, emitir alerta
            if (condicaoAtivada) {
                const mensagem = alerta.mensagem ||
                    `Alerta para métrica ${metrica.codigo}: valor ${valor} ${alerta.tipo === 'valor_maximo' ? 'acima' : 'abaixo'} do limite ${alerta.valor}`;
                this.logger.warn(`[ALERTA] ${mensagem} [Severidade: ${alerta.severidade || 'média'}]`);
                // Emitir evento para ser capturado por outros serviços
                this.eventEmitter.emit('metrica.alerta', {
                    metrica_id: metrica.id,
                    metrica_codigo: metrica.codigo,
                    metrica_nome: metrica.nome,
                    valor,
                    valor_limite: alerta.valor,
                    tipo_alerta: alerta.tipo,
                    mensagem,
                    severidade: alerta.severidade || 'média',
                    timestamp: new Date(),
                });
            }
        }
    }
    /**
     * Limpa snapshots antigos conforme política de retenção
     * @param metricaId ID da métrica
     * @param config Configuração da métrica
     */
    async limparSnapshotsAntigos(metricaId, config) {
        try {
            // Limpar por período de retenção
            if (config.periodo_retencao_dias > 0) {
                const dataLimite = new Date();
                dataLimite.setDate(dataLimite.getDate() - config.periodo_retencao_dias);
                const resultado = await this.metricaSnapshotRepository.delete({
                    definicao_id: metricaId,
                    created_at: (0, typeorm_2.Between)(new Date(0), dataLimite),
                });
                if (resultado.affected && resultado.affected > 0) {
                    this.logger.debug(`Removidos ${resultado.affected} snapshots antigos da métrica ${metricaId}`);
                }
            }
            // Limitar número máximo de snapshots
            if (config.max_snapshots > 0) {
                const count = await this.metricaSnapshotRepository.count({
                    where: { definicao_id: metricaId },
                });
                if (count > config.max_snapshots) {
                    // Buscar IDs mais antigos que excedem o limite
                    const snapshots = await this.metricaSnapshotRepository.find({
                        where: { definicao_id: metricaId },
                        order: { created_at: 'ASC' },
                        take: count - config.max_snapshots,
                        select: ['id'],
                    });
                    if (snapshots.length > 0) {
                        const ids = snapshots.map((s) => s.id);
                        const resultado = await this.metricaSnapshotRepository.delete(ids);
                        if (resultado.affected && resultado.affected > 0) {
                            this.logger.debug(`Removidos ${resultado.affected} snapshots excedentes da métrica ${metricaId}`);
                        }
                    }
                }
            }
        }
        catch (error) {
            this.logger.error(`Erro ao limpar snapshots antigos: ${error.message}`);
        }
    }
    /**
     * Gera um hash único para as dimensões de um snapshot
     * @param dimensoes Objeto de dimensões
     * @returns Hash das dimensões
     */
    gerarHashDimensoes(dimensoes) {
        const stringDimensoes = JSON.stringify(dimensoes || {});
        return crypto.createHash('sha256').update(stringDimensoes).digest('hex');
    }
    /**
     * Formata o valor numérico da métrica conforme configurações
     * @param valor Valor numérico
     * @param metrica Definição da métrica
     * @returns Valor formatado como string
     */
    formatarValorMetrica(valor, metrica) {
        try {
            let valorFormatado = Number(valor).toFixed(metrica.casas_decimais);
            // Adicionar prefixo e sufixo, se definidos
            if (metrica.prefixo) {
                valorFormatado = `${metrica.prefixo}${valorFormatado}`;
            }
            if (metrica.sufixo) {
                valorFormatado = `${valorFormatado}${metrica.sufixo}`;
            }
            return valorFormatado;
        }
        catch (error) {
            this.logger.error(`Erro ao formatar valor: ${error.message}`);
            return valor.toString();
        }
    }
    /**
     * Coleta manual de uma métrica específica
     * @param codigo Código da métrica
     * @param dimensoes Dimensões para filtrar a coleta
     * @returns Snapshot da métrica coletada
     */
    async coletarMetricaManual(codigo, dimensoes) {
        try {
            const metrica = await this.metricaDefinicaoRepository.findOne({
                where: { codigo, ativa: true },
            });
            if (!metrica) {
                throw new Error(`Métrica não encontrada ou inativa: ${codigo}`);
            }
            return this.coletarMetrica(metrica.id, {
                dimensoes,
                metadados: { origem: 'coleta_manual' },
            });
        }
        catch (error) {
            this.logger.error(`Erro na coleta manual da métrica ${codigo}: ${error.message}`);
            throw error;
        }
    }
    /**
     * Agenda a coleta de todas as métricas configuradas para coleta automática
     */
    async verificarConfiguracoesAgendamento() {
        try {
            this.logger.debug('Verificando configurações de agendamento');
            const configuracoes = await this.metricaConfiguracaoRepository.find({
                where: { coleta_automatica: true },
                relations: ['metrica'],
            });
            for (const config of configuracoes) {
                // Carregar a entidade metrica para acessar suas propriedades
                const metrica = await config.metrica;
                if (metrica.ativa) {
                    await this.configurarAgendamentoMetrica(config);
                }
            }
        }
        catch (error) {
            this.logger.error(`Erro ao verificar configurações de agendamento: ${error.message}`);
        }
    }
    /**
     * Coleta programada de métricas diárias (executada uma vez por dia à meia-noite)
     */
    async coletarMetricasDiarias() {
        try {
            this.logger.log('Iniciando coleta diária de métricas');
            const metricas = await this.metricaDefinicaoRepository.find({
                where: {
                    ativa: true,
                    granularidade: 'dia', // Forçando o tipo para evitar erro de incompatibilidade
                },
                relations: ['configuracoes'],
            });
            this.logger.debug(`Encontradas ${metricas.length} métricas diárias para coleta programada`);
            for (const metrica of metricas) {
                // Carregar o relacionamento lazy configuracoes
                const configuracoes = await metrica.configuracoes;
                if (configuracoes.length === 0 || !configuracoes[0].coleta_automatica) {
                    continue;
                }
                this.coletarMetrica(metrica.id).catch((err) => this.logger.error(`Erro ao coletar métrica diária ${metrica.codigo}: ${err.message}`));
            }
        }
        catch (error) {
            this.logger.error(`Erro na coleta diária: ${error.message}`);
        }
    }
    /**
     * Calcula o intervalo em milissegundos a partir de uma expressão cron
     * Esta é uma implementação simplificada que converte expressões cron comuns em intervalos
     * @param cronExpression Expressão cron
     * @returns Intervalo aproximado em milissegundos
     */
    calcularIntervaloEmMilissegundos(cronExpression) {
        // Expressões cron comuns e seus intervalos aproximados
        const intervalos = {
            '0 * * * *': 60 * 60 * 1000, // A cada hora
            '0 0 * * *': 24 * 60 * 60 * 1000, // Diário
            '0 0 * * 0': 7 * 24 * 60 * 60 * 1000, // Semanal
            '0 0 1 * *': 30 * 24 * 60 * 60 * 1000, // Mensal (aproximado)
        };
        return intervalos[cronExpression] || 60 * 60 * 1000; // Padrão: 1 hora
    }
};
exports.MetricasColetaService = MetricasColetaService;
__decorate([
    (0, event_emitter_1.OnEvent)('*'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], MetricasColetaService.prototype, "handleEvento", null);
exports.MetricasColetaService = MetricasColetaService = MetricasColetaService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(metrica_definicao_entity_1.MetricaDefinicao)),
    __param(1, (0, typeorm_1.InjectRepository)(metrica_snapshot_entity_1.MetricaSnapshot)),
    __param(2, (0, typeorm_1.InjectRepository)(metrica_configuracao_entity_1.MetricaConfiguracao)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _c : Object, typeof (_d = typeof metrica_calculo_service_1.MetricaCalculoService !== "undefined" && metrica_calculo_service_1.MetricaCalculoService) === "function" ? _d : Object, typeof (_e = typeof schedule_adapter_service_1.ScheduleAdapterService !== "undefined" && schedule_adapter_service_1.ScheduleAdapterService) === "function" ? _e : Object, typeof (_f = typeof event_emitter_1.EventEmitter2 !== "undefined" && event_emitter_1.EventEmitter2) === "function" ? _f : Object, typeof (_g = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _g : Object, typeof (_h = typeof typeorm_2.DataSource !== "undefined" && typeorm_2.DataSource) === "function" ? _h : Object])
], MetricasColetaService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXG1ldHJpY2FzXFxzZXJ2aWNlc1xcbWV0cmljYXMtY29sZXRhLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBa0U7QUFDbEUsNkNBQW1EO0FBQ25ELHFDQU1pQjtBQUNqQix5REFBK0Q7QUFDL0QsMkNBQStDO0FBQy9DLCtDQUFpQztBQUNqQyxnR0FBMkY7QUFFM0YseUZBR29EO0FBQ3BELHVGQUE0RTtBQUM1RSwrRkFHdUQ7QUFDdkQsdUVBQWtFO0FBRWxFOzs7OztHQUtHO0FBRUksSUFBTSxxQkFBcUIsNkJBQTNCLE1BQU0scUJBQXFCO0lBS2I7SUFHQTtJQUdBO0lBRUE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQWhCRixNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsdUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFakUsWUFFbUIsMEJBQXdELEVBR3hELHlCQUFzRCxFQUd0RCw2QkFBOEQsRUFFOUQsY0FBcUMsRUFDckMsZUFBdUMsRUFDdkMsWUFBMkIsRUFDM0IsYUFBNEIsRUFDNUIsVUFBc0I7UUFadEIsK0JBQTBCLEdBQTFCLDBCQUEwQixDQUE4QjtRQUd4RCw4QkFBeUIsR0FBekIseUJBQXlCLENBQTZCO1FBR3RELGtDQUE2QixHQUE3Qiw2QkFBNkIsQ0FBaUM7UUFFOUQsbUJBQWMsR0FBZCxjQUFjLENBQXVCO1FBQ3JDLG9CQUFlLEdBQWYsZUFBZSxDQUF3QjtRQUN2QyxpQkFBWSxHQUFaLFlBQVksQ0FBZTtRQUMzQixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQUM1QixlQUFVLEdBQVYsVUFBVSxDQUFZO0lBQ3RDLENBQUM7SUFFSjs7T0FFRztJQUNILEtBQUssQ0FBQyxZQUFZO1FBQ2hCLHNFQUFzRTtRQUN0RSxJQUFJLENBQUMs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LG9EQUdOLG9CQUFVLG9CQUFWLG9CQUFVLG9EQUV6QiwrQ0FBcUIsb0JBQXJCLCtDQUFxQixvREFDcEIsaURBQXNCLG9CQUF0QixpREFBc0Isb0RBQ3pCLDZCQUFhLG9CQUFiLDZCQUFhLG9EQUNaLHNCQUFhLG9CQUFiLHNCQUFhLG9EQUNoQixvQkFBVSxvQkFBVixvQkFBVTtHQWpCOUIscUJBQXFCLENBaXVCakMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXG1ldHJpY2FzXFxzZXJ2aWNlc1xcbWV0cmljYXMtY29sZXRhLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTG9nZ2VyLCBPbk1vZHVsZUluaXQgfSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3RSZXBvc2l0b3J5IH0gZnJvbSAnQG5lc3Rqcy90eXBlb3JtJztcbmltcG9ydCB7XG4gIFJlcG9zaXRvcnksXG4gIEVudGl0eU1hbmFnZXIsXG4gIERhdGFTb3VyY2UsXG4gIEJldHdlZW4sXG4gIE1vcmVUaGFuLFxufSBmcm9tICd0eXBlb3JtJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlcjIsIE9uRXZlbnQgfSBmcm9tICdAbmVzdGpzL2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgQ29uZmlnU2VydmljZSB9IGZyb20gJ0BuZXN0anMvY29uZmlnJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgU2NoZWR1bGVBZGFwdGVyU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9zY2hlZHVsZS9zY2hlZHVsZS1hZGFwdGVyLnNlcnZpY2UnO1xuXG5pbXBvcnQge1xuICBNZXRyaWNhRGVmaW5pY2FvLFxuICBUaXBvTWV0cmljYSxcbn0gZnJvbSAnLi4vLi4vLi4vZW50aXRpZXMvbWV0cmljYS1kZWZpbmljYW8uZW50aXR5JztcbmltcG9ydCB7IE1ldHJpY2FTbmFwc2hvdCB9IGZyb20gJy4uLy4uLy4uL2VudGl0aWVzL21ldHJpY2Etc25hcHNob3QuZW50aXR5JztcbmltcG9ydCB7XG4gIE1ldHJpY2FDb25maWd1cmFjYW8sXG4gIFRpcG9BZ2VuZGFtZW50byxcbn0gZnJvbSAnLi4vLi4vLi4vZW50aXRpZXMvbWV0cmljYS1jb25maWd1cmFjYW8uZW50aXR5JztcbmltcG9ydCB7IE1ldHJpY2FDYWxjdWxvU2VydmljZSB9IGZyb20gJy4vbWV0cmljYS1jYWxjdWxvLnNlcnZpY2UnO1xuXG4vKipcbiAqIFNlcnZpw6dvIHJlc3BvbnPDoXZlbCBwZWxhIGNvbGV0YSBwcm9ncmFtYWRhIGUgcmVhdGl2YSBkZSBtw6l0cmljYXNcbiAqXG4gKiBFc3RlIHNlcnZpw6dvIGdlcmVuY2lhIG8gYWdlbmRhbWVudG8sIGNvbGV0YSBlIGFybWF6ZW5hbWVudG8gZGUgbcOpdHJpY2FzXG4gKiBjb25mb3JtZSBhcyBjb25maWd1cmHDp8O1ZXMgZGVmaW5pZGFzIHBhcmEgY2FkYSBtw6l0cmljYSBubyBzaXN0ZW1hLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTWV0cmljYXNDb2xldGFTZXJ2aWNlIGltcGxlbWVudHMgT25Nb2R1bGVJbml0IHtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXIgPSBuZXcgTG9nZ2VyKE1ldHJpY2FzQ29sZXRhU2VydmljZS5uYW1lKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0UmVwb3NpdG9yeShNZXRyaWNhRGVmaW5pY2FvKVxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWV0cmljYURlZmluaWNhb1JlcG9zaXRvcnk6IFJlcG9zaXRvcnk8TWV0cmljYURlZmluaWNhbz4sXG5cbiAgICBASW5qZWN0UmVwb3NpdG9yeShNZXRyaWNhU25hcHNob3QpXG4gICAgcHJpdmF0ZSByZWFkb25seSBtZXRyaWNhU25hcHNob3RSZXBvc2l0b3J5OiBSZXBvc2l0b3J5PE1ldHJpY2FTbmFwc2hvdD4sXG5cbiAgICBASW5qZWN0UmVwb3NpdG9yeShNZXRyaWNhQ29uZmlndXJhY2FvKVxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWV0cmljYUNvbmZpZ3VyYWNhb1JlcG9zaXRvcnk6IFJlcG9zaXRvcnk8TWV0cmljYUNvbmZpZ3VyYWNhbz4sXG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGNhbGN1bG9TZXJ2aWNlOiBNZXRyaWNhQ2FsY3Vsb1NlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzY2hlZHVsZUFkYXB0ZXI6IFNjaGVkdWxlQWRhcHRlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb25maWdTZXJ2aWNlOiBDb25maWdTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGF0YVNvdXJjZTogRGF0YVNvdXJjZSxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBJbmljaWFsaXphIG9zIGFnZW5kYW1lbnRvcyBxdWFuZG8gbyBtw7NkdWxvIMOpIGNhcnJlZ2Fkb1xuICAgKi9cbiAgYXN5bmMgb25Nb2R1bGVJbml0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEluaWNpYWxpemFyIHZlcmlmaWNhw6fDo28gZGUgY29uZmlndXJhw6fDtWVzIGRlIGFnZW5kYW1lbnRvIGEgY2FkYSBob3JhXG4gICAgdGhpcy5zY2hlZHVsZUFkYXB0ZXIuc2NoZWR1bGVJbnRlcnZhbChcbiAgICAgICd2ZXJpZmljYXJfY29uZmlndXJhY29lc19hZ2VuZGFtZW50bycsXG4gICAgICAzNjAwMDAwLCAvLyAxIGhvcmEgZW0gbWlsaXNzZWd1bmRvc1xuICAgICAgKCkgPT4gdGhpcy52ZXJpZmljYXJDb25maWd1cmFjb2VzQWdlbmRhbWVudG8oKSxcbiAgICApO1xuXG4gICAgLy8gSW5pY2lhbGl6YXIgY29sZXRhIGRpw6FyaWEgZGUgbcOpdHJpY2FzIMOgIG1laWEtbm9pdGVcbiAgICB0aGlzLnNjaGVkdWxlQWRhcHRlci5zY2hlZHVsZURhaWx5VGFzayhcbiAgICAgICdjb2xldGFyX21ldHJpY2FzX2RpYXJpYXMnLFxuICAgICAgMCwgLy8gaG9yYSAoMCA9IG1laWEtbm9pdGUpXG4gICAgICAwLCAvLyBtaW51dG9cbiAgICAgICgpID0+IHRoaXMuY29sZXRhck1ldHJpY2FzRGlhcmlhcygpLFxuICAgICk7XG5cbiAgICAvLyBJbmljaWFsaXphciBvIHNlcnZpw6dvIGRlIGNvbGV0YVxuICAgIGF3YWl0IHRoaXMuaW5pY2lhbGl6YXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmljaWFsaXphIG8gc2VydmnDp28gZGUgY29sZXRhIGRlIG3DqXRyaWNhc1xuICAgKiBDb25maWd1cmEgam9icyBjcm9uIHBhcmEgbcOpdHJpY2FzIGNvbSBhZ2VuZGFtZW50b1xuICAgKi9cbiAgYXN5bmMgaW5pY2lhbGl6YXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdJbmljaWFsaXphbmRvIHNlcnZpw6dvIGRlIGNvbGV0YSBkZSBtw6l0cmljYXMnKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBDYXJyZWdhciB0b2RhcyBhcyBjb25maWd1cmHDp8O1ZXMgZGUgbcOpdHJpY2FzIGF0aXZhcyBjb20gY29sZXRhIGF1dG9tw6F0aWNhXG4gICAgICBjb25zdCBjb25maWd1cmFjb2VzID0gYXdhaXQgdGhpcy5tZXRyaWNhQ29uZmlndXJhY2FvUmVwb3NpdG9yeS5maW5kKHtcbiAgICAgICAgd2hlcmU6IHsgY29sZXRhX2F1dG9tYXRpY2E6IHRydWUgfSxcbiAgICAgICAgcmVsYXRpb25zOiBbJ21ldHJpY2EnXSxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmxvZ2dlci5sb2coXG4gICAgICAgIGBFbmNvbnRyYWRhcyAke2NvbmZpZ3VyYWNvZXMubGVuZ3RofSBtw6l0cmljYXMgY29uZmlndXJhZGFzIHBhcmEgY29sZXRhIGF1dG9tw6F0aWNhYCxcbiAgICAgICk7XG5cbiAgICAgIC8vIENvbmZpZ3VyYXIgYWdlbmRhbWVudG9zIHBhcmEgY2FkYSBtw6l0cmljYVxuICAgICAgZm9yIChjb25zdCBjb25maWcgb2YgY29uZmlndXJhY29lcykge1xuICAgICAgICAvLyBDYXJyZWdhciBhIGVudGlkYWRlIG1ldHJpY2EgcGFyYSBhY2Vzc2FyIHN1YXMgcHJvcHJpZWRhZGVzXG4gICAgICAgIGNvbnN0IG1ldHJpY2EgPSBhd2FpdCBjb25maWcubWV0cmljYTtcblxuICAgICAgICBpZiAoIW1ldHJpY2EuYXRpdmEpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgIGBNw6l0cmljYSAke21ldHJpY2EuY29kaWdvfSBuw6NvIGVzdMOhIGF0aXZhLCBpZ25vcmFuZG8gYWdlbmRhbWVudG9gLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0aGlzLmNvbmZpZ3VyYXJBZ2VuZGFtZW50b01ldHJpY2EoY29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2dnZXIubG9nKCdTZXJ2acOnbyBkZSBjb2xldGEgZGUgbcOpdHJpY2FzIGluaWNpYWxpemFkbyBjb20gc3VjZXNzbycpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gaW5pY2lhbGl6YXIgc2VydmnDp28gZGUgY29sZXRhOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmEgbyBhZ2VuZGFtZW50byBwYXJhIHVtYSBtw6l0cmljYSBlc3BlY8OtZmljYVxuICAgKiBAcGFyYW0gY29uZmlnIENvbmZpZ3VyYcOnw6NvIGRhIG3DqXRyaWNhXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNvbmZpZ3VyYXJBZ2VuZGFtZW50b01ldHJpY2EoXG4gICAgY29uZmlnOiBNZXRyaWNhQ29uZmlndXJhY2FvLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBDYXJyZWdhciBhIGVudGlkYWRlIG1ldHJpY2EgcGFyYSBhY2Vzc2FyIHN1YXMgcHJvcHJpZWRhZGVzXG4gICAgY29uc3QgbWV0cmljYSA9IGF3YWl0IGNvbmZpZy5tZXRyaWNhO1xuICAgIGNvbnN0IGpvYklkID0gYG1ldHJpY2FfJHttZXRyaWNhLmNvZGlnb31gO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENhbmNlbGFyIGFnZW5kYW1lbnRvIGV4aXN0ZW50ZSwgc2UgaG91dmVyXG4gICAgICB0aGlzLnNjaGVkdWxlQWRhcHRlci5jYW5jZWxJbnRlcnZhbChqb2JJZCk7XG5cbiAgICAgIC8vIENvbmZpZ3VyYXIgbm92byBqb2IgY29uZm9ybWUgbyB0aXBvIGRlIGFnZW5kYW1lbnRvXG4gICAgICBzd2l0Y2ggKGNvbmZpZy50aXBvX2FnZW5kYW1lbnRvKSB7XG4gICAgICAgIGNhc2UgVGlwb0FnZW5kYW1lbnRvLkNST046XG4gICAgICAgICAgaWYgKGNvbmZpZy5leHByZXNzYW9fY3Jvbikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICAgIGBDb25maWd1cmFuZG8gam9iIGNyb24gcGFyYSBtw6l0cmljYSAke21ldHJpY2EuY29kaWdvfTogJHtjb25maWcuZXhwcmVzc2FvX2Nyb259YCxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFVzYW1vcyBvIGFkYXB0YWRvciBkZSBhZ2VuZGFtZW50byBwZXJzb25hbGl6YWRvXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQWRhcHRlci5zY2hlZHVsZUludGVydmFsKFxuICAgICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhckludGVydmFsb0VtTWlsaXNzZWd1bmRvcyhjb25maWcuZXhwcmVzc2FvX2Nyb24pLFxuICAgICAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29sZXRhck1ldHJpY2EobWV0cmljYS5pZCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYEVycm8gYW8gY29sZXRhciBtw6l0cmljYSAke21ldHJpY2EuY29kaWdvfTogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXG4gICAgICAgICAgICAgIGBBZ2VuZGFtZW50byBjb25maWd1cmFkbyBwYXJhIG3DqXRyaWNhICR7bWV0cmljYS5jb2RpZ299YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgVGlwb0FnZW5kYW1lbnRvLklOVEVSVkFMTzpcbiAgICAgICAgICBpZiAoY29uZmlnLmludGVydmFsb19zZWd1bmRvcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgICBgQ29uZmlndXJhbmRvIGpvYiBkZSBpbnRlcnZhbG8gcGFyYSBtw6l0cmljYSAke21ldHJpY2EuY29kaWdvfTogJHtjb25maWcuaW50ZXJ2YWxvX3NlZ3VuZG9zfSBzZWd1bmRvc2AsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbG8gPSBjb25maWcuaW50ZXJ2YWxvX3NlZ3VuZG9zICogMTAwMDtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgICBgQ29uZmlndXJhbmRvIGpvYiBkZSBpbnRlcnZhbG8gcGFyYSBtw6l0cmljYSAke21ldHJpY2EuY29kaWdvfTogJHtpbnRlcnZhbG99bXNgLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gVXNhciBvIGFkYXB0YWRvciBkZSBhZ2VuZGFtZW50b1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUFkYXB0ZXIuc2NoZWR1bGVJbnRlcnZhbChcbiAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgIGludGVydmFsbyxcbiAgICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNvbGV0YXJNZXRyaWNhKG1ldHJpY2EuaWQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBFcnJvIGFvIGNvbGV0YXIgbcOpdHJpY2EgJHttZXRyaWNhLmNvZGlnb306ICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgICAgICAgICBgQWdlbmRhbWVudG8gY29uZmlndXJhZG8gcGFyYSBtw6l0cmljYSAke21ldHJpY2EuY29kaWdvfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFRpcG9BZ2VuZGFtZW50by5FVkVOVE86XG4gICAgICAgICAgLy8gQSBjb25maWd1cmHDp8OjbyBwYXJhIGV2ZW50b3Mgw6kgZmVpdGEgdmlhIGRlY29yYWRvciBAT25FdmVudFxuICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgYE3DqXRyaWNhICR7bWV0cmljYS5jb2RpZ299IGNvbmZpZ3VyYWRhIHBhcmEgY29sZXRhIHZpYSBldmVudG86ICR7Y29uZmlnLm5vbWVfZXZlbnRvfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFRpcG9BZ2VuZGFtZW50by5NQU5VQUw6XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICBgTcOpdHJpY2EgJHttZXRyaWNhLmNvZGlnb30gY29uZmlndXJhZGEgcGFyYSBjb2xldGEgbWFudWFsYCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICAgIGBUaXBvIGRlIGFnZW5kYW1lbnRvIG7Do28gc3Vwb3J0YWRvIHBhcmEgbcOpdHJpY2EgJHttZXRyaWNhLmNvZGlnb306ICR7Y29uZmlnLnRpcG9fYWdlbmRhbWVudG99YCxcbiAgICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZ2dlci5sb2coXG4gICAgICAgIGBBZ2VuZGFtZW50byBjb25maWd1cmFkbyBjb20gc3VjZXNzbyBwYXJhIG3DqXRyaWNhOiAke21ldHJpY2EuY29kaWdvfWAsXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEVycm8gYW8gY29uZmlndXJhciBhZ2VuZGFtZW50byBwYXJhIG3DqXRyaWNhICR7bWV0cmljYS5jb2RpZ299OiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYW5pcHVsYWRvciBkZSBldmVudG9zIHBhcmEgY29sZXRhIGRlIG3DqXRyaWNhcyBiYXNlYWRhIGVtIGV2ZW50b3NcbiAgICogQHBhcmFtIHBheWxvYWQgRGFkb3MgZG8gZXZlbnRvXG4gICAqL1xuICBAT25FdmVudCgnKicpXG4gIGFzeW5jIGhhbmRsZUV2ZW50byhwYXlsb2FkOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXBheWxvYWQgfHwgIXBheWxvYWQuZXZlbnRvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm9tZUV2ZW50byA9IHBheWxvYWQuZXZlbnRvO1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBFdmVudG8gcmVjZWJpZG86ICR7bm9tZUV2ZW50b31gKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBCdXNjYXIgbcOpdHJpY2FzIGNvbmZpZ3VyYWRhcyBwYXJhIGVzdGUgZXZlbnRvXG4gICAgICBjb25zdCBjb25maWd1cmFjb2VzID0gYXdhaXQgdGhpcy5tZXRyaWNhQ29uZmlndXJhY2FvUmVwb3NpdG9yeS5maW5kKHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBjb2xldGFfYXV0b21hdGljYTogdHJ1ZSxcbiAgICAgICAgICB0aXBvX2FnZW5kYW1lbnRvOiBUaXBvQWdlbmRhbWVudG8uRVZFTlRPLFxuICAgICAgICAgIG5vbWVfZXZlbnRvOiBub21lRXZlbnRvLFxuICAgICAgICB9LFxuICAgICAgICByZWxhdGlvbnM6IFsnbWV0cmljYSddLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjb25maWd1cmFjb2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgRW5jb250cmFkYXMgJHtjb25maWd1cmFjb2VzLmxlbmd0aH0gbcOpdHJpY2FzIHBhcmEgY29sZXRhIGJhc2VhZGEgbm8gZXZlbnRvOiAke25vbWVFdmVudG99YCxcbiAgICAgICk7XG5cbiAgICAgIC8vIENvbGV0YXIgY2FkYSBtw6l0cmljYSBlbmNvbnRyYWRhXG4gICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBjb25maWd1cmFjb2VzKSB7XG4gICAgICAgIC8vIENhcnJlZ2FyIGEgZW50aWRhZGUgbWV0cmljYSBwYXJhIGFjZXNzYXIgc3VhcyBwcm9wcmllZGFkZXNcbiAgICAgICAgY29uc3QgbWV0cmljYSA9IGF3YWl0IGNvbmZpZy5tZXRyaWNhO1xuXG4gICAgICAgIGlmIChtZXRyaWNhLmF0aXZhKSB7XG4gICAgICAgICAgdGhpcy5jb2xldGFyTWV0cmljYShtZXRyaWNhLmlkLCBwYXlsb2FkKS5jYXRjaCgoZXJyKSA9PlxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgIGBFcnJvIGFvIGNvbGV0YXIgbcOpdHJpY2EgJHttZXRyaWNhLmNvZGlnb30gcGFyYSBldmVudG8gJHtub21lRXZlbnRvfTogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBgRXJybyBhbyBwcm9jZXNzYXIgZXZlbnRvICR7bm9tZUV2ZW50b306ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICBlcnJvci5zdGFjayxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGV0YSBkYWRvcyBwYXJhIHVtYSBtw6l0cmljYSBlc3BlY8OtZmljYVxuICAgKiBAcGFyYW0gbWV0cmljYUlkIElEIGRhIG3DqXRyaWNhIGEgc2VyIGNvbGV0YWRhXG4gICAqIEBwYXJhbSBjb250ZXh0byBDb250ZXh0byBhZGljaW9uYWwgcGFyYSBhIGNvbGV0YSAob3BjaW9uYWwpXG4gICAqIEByZXR1cm5zIFNuYXBzaG90IGRhIG3DqXRyaWNhIGNvbGV0YWRhXG4gICAqL1xuICBhc3luYyBjb2xldGFyTWV0cmljYShcbiAgICBtZXRyaWNhSWQ6IHN0cmluZyxcbiAgICBjb250ZXh0bz86IGFueSxcbiAgKTogUHJvbWlzZTxNZXRyaWNhU25hcHNob3Q+IHtcbiAgICBjb25zdCBpbmljaW9Db2xldGEgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBJbmljaWFuZG8gY29sZXRhIHBhcmEgbcOpdHJpY2EgSUQ6ICR7bWV0cmljYUlkfWApO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEJ1c2NhciBkZWZpbmnDp8OjbyBlIGNvbmZpZ3VyYcOnw6NvIGRhIG3DqXRyaWNhXG4gICAgICBjb25zdCBtZXRyaWNhID0gYXdhaXQgdGhpcy5tZXRyaWNhRGVmaW5pY2FvUmVwb3NpdG9yeS5maW5kT25lKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6IG1ldHJpY2FJZCwgYXRpdmE6IHRydWUgfSxcbiAgICAgICAgcmVsYXRpb25zOiBbJ2NvbmZpZ3VyYWNvZXMnXSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW1ldHJpY2EpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNw6l0cmljYSBuw6NvIGVuY29udHJhZGEgb3UgaW5hdGl2YTogJHttZXRyaWNhSWR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbmZpZyA9IG1ldHJpY2EuY29uZmlndXJhY29lc1swXTsgLy8gVXNhciBhIHByaW1laXJhIGNvbmZpZ3VyYcOnw6NvIGRpc3BvbsOtdmVsXG5cbiAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ29uZmlndXJhw6fDo28gbsOjbyBlbmNvbnRyYWRhIHBhcmEgbcOpdHJpY2E6ICR7bWV0cmljYS5jb2RpZ299YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVmaW5pciBwZXLDrW9kbyBkZSByZWZlcsOqbmNpYSBwYXJhIGEgY29sZXRhXG4gICAgICBjb25zdCBwZXJpb2RvRmltID0gbmV3IERhdGUoKTtcbiAgICAgIGxldCBwZXJpb2RvSW5pY2lvOiBEYXRlO1xuXG4gICAgICAvLyBDYWxjdWxhciBpbsOtY2lvIGRvIHBlcsOtb2RvIGNvbSBiYXNlIG5hIGdyYW51bGFyaWRhZGUgZGEgbcOpdHJpY2FcbiAgICAgIHN3aXRjaCAobWV0cmljYS5ncmFudWxhcmlkYWRlKSB7XG4gICAgICAgIGNhc2UgJ21pbnV0byc6XG4gICAgICAgICAgcGVyaW9kb0luaWNpbyA9IG5ldyBEYXRlKHBlcmlvZG9GaW0pO1xuICAgICAgICAgIHBlcmlvZG9JbmljaW8uc2V0TWludXRlcyhwZXJpb2RvSW5pY2lvLmdldE1pbnV0ZXMoKSAtIDEpO1xuICAgICAgICAgIHBlcmlvZG9JbmljaW8uc2V0U2Vjb25kcygwLCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaG9yYSc6XG4gICAgICAgICAgcGVyaW9kb0luaWNpbyA9IG5ldyBEYXRlKHBlcmlvZG9GaW0pO1xuICAgICAgICAgIHBlcmlvZG9JbmljaW8uc2V0SG91cnMocGVyaW9kb0luaWNpby5nZXRIb3VycygpIC0gMSk7XG4gICAgICAgICAgcGVyaW9kb0luaWNpby5zZXRNaW51dGVzKDAsIDAsIDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkaWEnOlxuICAgICAgICAgIHBlcmlvZG9JbmljaW8gPSBuZXcgRGF0ZShwZXJpb2RvRmltKTtcbiAgICAgICAgICBwZXJpb2RvSW5pY2lvLnNldERhdGUocGVyaW9kb0luaWNpby5nZXREYXRlKCkgLSAxKTtcbiAgICAgICAgICBwZXJpb2RvSW5pY2lvLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZW1hbmEnOlxuICAgICAgICAgIHBlcmlvZG9JbmljaW8gPSBuZXcgRGF0ZShwZXJpb2RvRmltKTtcbiAgICAgICAgICBwZXJpb2RvSW5pY2lvLnNldERhdGUocGVyaW9kb0luaWNpby5nZXREYXRlKCkgLSA3KTtcbiAgICAgICAgICBwZXJpb2RvSW5pY2lvLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtZXMnOlxuICAgICAgICAgIHBlcmlvZG9JbmljaW8gPSBuZXcgRGF0ZShwZXJpb2RvRmltKTtcbiAgICAgICAgICBwZXJpb2RvSW5pY2lvLnNldE1vbnRoKHBlcmlvZG9JbmljaW8uZ2V0TW9udGgoKSAtIDEpO1xuICAgICAgICAgIHBlcmlvZG9JbmljaW8uc2V0RGF0ZSgxKTtcbiAgICAgICAgICBwZXJpb2RvSW5pY2lvLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0cmltZXN0cmUnOlxuICAgICAgICAgIHBlcmlvZG9JbmljaW8gPSBuZXcgRGF0ZShwZXJpb2RvRmltKTtcbiAgICAgICAgICBwZXJpb2RvSW5pY2lvLnNldE1vbnRoKHBlcmlvZG9JbmljaW8uZ2V0TW9udGgoKSAtIDMpO1xuICAgICAgICAgIHBlcmlvZG9JbmljaW8uc2V0RGF0ZSgxKTtcbiAgICAgICAgICBwZXJpb2RvSW5pY2lvLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhbm8nOlxuICAgICAgICAgIHBlcmlvZG9JbmljaW8gPSBuZXcgRGF0ZShwZXJpb2RvRmltKTtcbiAgICAgICAgICBwZXJpb2RvSW5pY2lvLnNldEZ1bGxZZWFyKHBlcmlvZG9JbmljaW8uZ2V0RnVsbFllYXIoKSAtIDEpO1xuICAgICAgICAgIHBlcmlvZG9JbmljaW8uc2V0TW9udGgoMCwgMSk7XG4gICAgICAgICAgcGVyaW9kb0luaWNpby5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBQYWRyw6NvOiB1bSBkaWFcbiAgICAgICAgICBwZXJpb2RvSW5pY2lvID0gbmV3IERhdGUocGVyaW9kb0ZpbSk7XG4gICAgICAgICAgcGVyaW9kb0luaWNpby5zZXREYXRlKHBlcmlvZG9JbmljaW8uZ2V0RGF0ZSgpIC0gMSk7XG4gICAgICAgICAgcGVyaW9kb0luaWNpby5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVmaW5pciBkaW1lbnPDtWVzIGUgbWV0YWRhZG9zIHBhcmEgbyBzbmFwc2hvdFxuICAgICAgY29uc3QgZGltZW5zb2VzID0gY29udGV4dG8/LmRpbWVuc29lcyB8fCB7fTtcbiAgICAgIGNvbnN0IG1ldGFkYWRvcyA9IHtcbiAgICAgICAgb3JpZ2VtOiAnY29sZXRhX2F1dG9tYXRpY2EnLFxuICAgICAgICBqb2JfaWQ6IGBtZXRyaWNhXyR7bWV0cmljYS5jb2RpZ299YCxcbiAgICAgICAgY29udGV4dG86IGNvbnRleHRvID8gSlNPTi5zdHJpbmdpZnkoY29udGV4dG8pLnN1YnN0cmluZygwLCAxMDAwKSA6IG51bGwsXG4gICAgICB9O1xuXG4gICAgICAvLyBDYWxjdWxhciBoYXNoIGRhcyBkaW1lbnPDtWVzIHBhcmEgZ2FyYW50aXIgdW5pY2lkYWRlXG4gICAgICBjb25zdCBkaW1lbnNvZXNIYXNoID0gdGhpcy5nZXJhckhhc2hEaW1lbnNvZXMoZGltZW5zb2VzKTtcblxuICAgICAgLy8gVmVyaWZpY2FyIHNlIGrDoSBleGlzdGUgdW0gc25hcHNob3QgcGFyYSBvIG1lc21vIHBlcsOtb2RvIGUgZGltZW5zw7Vlc1xuICAgICAgY29uc3Qgc25hcHNob3RFeGlzdGVudGUgPSBhd2FpdCB0aGlzLm1ldHJpY2FTbmFwc2hvdFJlcG9zaXRvcnkuZmluZE9uZSh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgZGVmaW5pY2FvX2lkOiBtZXRyaWNhLmlkLFxuICAgICAgICAgIHBlcmlvZG9faW5pY2lvOiBwZXJpb2RvSW5pY2lvLFxuICAgICAgICAgIHBlcmlvZG9fZmltOiBwZXJpb2RvRmltLFxuICAgICAgICAgIGRpbWVuc29lc19oYXNoOiBkaW1lbnNvZXNIYXNoLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzbmFwc2hvdEV4aXN0ZW50ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICBgU25hcHNob3QgasOhIGV4aXN0ZSBwYXJhIG3DqXRyaWNhICR7bWV0cmljYS5jb2RpZ299IG5vIHBlcsOtb2RvIGVzcGVjaWZpY2Fkb2AsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdEV4aXN0ZW50ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXIgdmFsb3IgZGEgbcOpdHJpY2FcbiAgICAgIGNvbnN0IHZhbG9yQ2FsY3VsYWRvID0gYXdhaXQgdGhpcy5jYWxjdWxvU2VydmljZS5jYWxjdWxhclZhbG9yTWV0cmljYShcbiAgICAgICAgbWV0cmljYSxcbiAgICAgICAgcGVyaW9kb0luaWNpbyxcbiAgICAgICAgcGVyaW9kb0ZpbSxcbiAgICAgICAgZGltZW5zb2VzLFxuICAgICAgKTtcblxuICAgICAgLy8gRm9ybWF0YXIgdmFsb3IgY29uZm9ybWUgY29uZmlndXJhw6fDtWVzIGRhIG3DqXRyaWNhXG4gICAgICBjb25zdCB2YWxvckZvcm1hdGFkbyA9IHRoaXMuZm9ybWF0YXJWYWxvck1ldHJpY2EodmFsb3JDYWxjdWxhZG8sIG1ldHJpY2EpO1xuXG4gICAgICAvLyBDcmlhciBzbmFwc2hvdFxuICAgICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLm1ldHJpY2FTbmFwc2hvdFJlcG9zaXRvcnkuY3JlYXRlKHtcbiAgICAgICAgZGVmaW5pY2FvX2lkOiBtZXRyaWNhLmlkLFxuICAgICAgICBwZXJpb2RvX2luaWNpbzogcGVyaW9kb0luaWNpbyxcbiAgICAgICAgcGVyaW9kb19maW06IHBlcmlvZG9GaW0sXG4gICAgICAgIGdyYW51bGFyaWRhZGU6IG1ldHJpY2EuZ3JhbnVsYXJpZGFkZSxcbiAgICAgICAgdmFsb3I6IHZhbG9yQ2FsY3VsYWRvLFxuICAgICAgICB2YWxvcl9mb3JtYXRhZG86IHZhbG9yRm9ybWF0YWRvLFxuICAgICAgICBkaW1lbnNvZXMsXG4gICAgICAgIGRpbWVuc29lc19oYXNoOiBkaW1lbnNvZXNIYXNoLFxuICAgICAgICBtZXRhZGFkb3MsXG4gICAgICAgIHZlcnNhb19kZWZpbmljYW86IG1ldHJpY2EudmVyc2FvLFxuICAgICAgICBkdXJhY2FvX3Byb2Nlc3NhbWVudG9fbXM6IERhdGUubm93KCkgLSBpbmljaW9Db2xldGEsXG4gICAgICAgIHN0YXR1c19jb2xldGE6ICdzdWNlc3NvJyxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTYWx2YXIgc25hcHNob3Qgbm8gYmFuY28gZGUgZGFkb3NcbiAgICAgIGNvbnN0IHNuYXBzaG90U2Fsdm8gPSBhd2FpdCB0aGlzLm1ldHJpY2FTbmFwc2hvdFJlcG9zaXRvcnkuc2F2ZShzbmFwc2hvdCk7XG5cbiAgICAgIC8vIEF0dWFsaXphciBkYXRhIGRhIMO6bHRpbWEgY29sZXRhIG5hIGRlZmluacOnw6NvIGRhIG3DqXRyaWNhXG4gICAgICBhd2FpdCB0aGlzLm1ldHJpY2FEZWZpbmljYW9SZXBvc2l0b3J5LnVwZGF0ZShcbiAgICAgICAgeyBpZDogbWV0cmljYS5pZCB9LFxuICAgICAgICB7IHVsdGltYV9jb2xldGE6IG5ldyBEYXRlKCkgfSxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgICAgYE3DqXRyaWNhIGNvbGV0YWRhIGNvbSBzdWNlc3NvOiAke21ldHJpY2EuY29kaWdvfSwgdmFsb3I6ICR7dmFsb3JDYWxjdWxhZG99YCxcbiAgICAgICk7XG5cbiAgICAgIC8vIFZlcmlmaWNhciBzZSBvIHZhbG9yIHVsdHJhcGFzc2EgbGltaXRlcyBjb25maWd1cmFkb3MgcGFyYSBhbGVydGFzXG4gICAgICBhd2FpdCB0aGlzLnZlcmlmaWNhckFsZXJ0YXMobWV0cmljYSwgY29uZmlnLCB2YWxvckNhbGN1bGFkbyk7XG5cbiAgICAgIC8vIExpbXBhciBzbmFwc2hvdHMgYW50aWdvcyBjb25mb3JtZSBwb2zDrXRpY2EgZGUgcmV0ZW7Dp8Ojb1xuICAgICAgdGhpcy5saW1wYXJTbmFwc2hvdHNBbnRpZ29zKG1ldHJpY2EuaWQsIGNvbmZpZykuY2F0Y2goKGVycikgPT5cbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gbGltcGFyIHNuYXBzaG90cyBhbnRpZ29zOiAke2Vyci5tZXNzYWdlfWApLFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHNuYXBzaG90U2Fsdm87XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGR1cmFjYW8gPSBEYXRlLm5vdygpIC0gaW5pY2lvQ29sZXRhO1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBFcnJvIGFvIGNvbGV0YXIgbcOpdHJpY2EgJHttZXRyaWNhSWR9OiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuXG4gICAgICAvLyBSZWdpc3RyYXIgc25hcHNob3QgY29tIGVycm9cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1ldHJpY2EgPSBhd2FpdCB0aGlzLm1ldHJpY2FEZWZpbmljYW9SZXBvc2l0b3J5LmZpbmRPbmUoe1xuICAgICAgICAgIHdoZXJlOiB7IGlkOiBtZXRyaWNhSWQgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1ldHJpY2EpIHtcbiAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMubWV0cmljYVNuYXBzaG90UmVwb3NpdG9yeS5jcmVhdGUoe1xuICAgICAgICAgICAgZGVmaW5pY2FvX2lkOiBtZXRyaWNhSWQsXG4gICAgICAgICAgICBwZXJpb2RvX2luaWNpbzogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHBlcmlvZG9fZmltOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgZ3JhbnVsYXJpZGFkZTogbWV0cmljYS5ncmFudWxhcmlkYWRlLFxuICAgICAgICAgICAgdmFsb3I6IDAsXG4gICAgICAgICAgICB2YWxvcl9mb3JtYXRhZG86ICdFUlJPJyxcbiAgICAgICAgICAgIGRpbWVuc29lczoge30sXG4gICAgICAgICAgICBkaW1lbnNvZXNfaGFzaDogdGhpcy5nZXJhckhhc2hEaW1lbnNvZXMoe30pLFxuICAgICAgICAgICAgbWV0YWRhZG9zOiB7IGVycm86IGVycm9yLm1lc3NhZ2UgfSxcbiAgICAgICAgICAgIGR1cmFjYW9fcHJvY2Vzc2FtZW50b19tczogZHVyYWNhbyxcbiAgICAgICAgICAgIHN0YXR1c19jb2xldGE6ICdlcnJvJyxcbiAgICAgICAgICAgIG1lbnNhZ2VtX3N0YXR1czogZXJyb3IubWVzc2FnZS5zdWJzdHJpbmcoMCwgNTAwKSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGF3YWl0IHRoaXMubWV0cmljYVNuYXBzaG90UmVwb3NpdG9yeS5zYXZlKHNuYXBzaG90KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2F2ZUVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgIGBFcnJvIGFvIHNhbHZhciBzbmFwc2hvdCBkZSBlcnJvOiAke3NhdmVFcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBvIHZhbG9yIGRhIG3DqXRyaWNhIHVsdHJhcGFzc2EgbGltaXRlcyBjb25maWd1cmFkb3MgZSBnZXJhIGFsZXJ0YXNcbiAgICogQHBhcmFtIG1ldHJpY2EgRGVmaW5pw6fDo28gZGEgbcOpdHJpY2FcbiAgICogQHBhcmFtIGNvbmZpZyBDb25maWd1cmHDp8OjbyBkYSBtw6l0cmljYVxuICAgKiBAcGFyYW0gdmFsb3IgVmFsb3IgY2FsY3VsYWRvXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHZlcmlmaWNhckFsZXJ0YXMoXG4gICAgbWV0cmljYTogTWV0cmljYURlZmluaWNhbyxcbiAgICBjb25maWc6IE1ldHJpY2FDb25maWd1cmFjYW8sXG4gICAgdmFsb3I6IG51bWJlcixcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFjb25maWcuYWxlcnRhcyB8fCBjb25maWcuYWxlcnRhcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGFsZXJ0YSBvZiBjb25maWcuYWxlcnRhcykge1xuICAgICAgbGV0IGNvbmRpY2FvQXRpdmFkYSA9IGZhbHNlO1xuXG4gICAgICAvLyBWZXJpZmljYXIgY29uZGnDp8OjbyBkbyBhbGVydGFcbiAgICAgIHN3aXRjaCAoYWxlcnRhLnRpcG8pIHtcbiAgICAgICAgY2FzZSAndmFsb3JfbWF4aW1vJzpcbiAgICAgICAgICBjb25kaWNhb0F0aXZhZGEgPSB2YWxvciA+IGFsZXJ0YS52YWxvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmFsb3JfbWluaW1vJzpcbiAgICAgICAgICBjb25kaWNhb0F0aXZhZGEgPSB2YWxvciA8IGFsZXJ0YS52YWxvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmFsb3JfaWd1YWwnOlxuICAgICAgICAgIGNvbmRpY2FvQXRpdmFkYSA9IHZhbG9yID09PSBhbGVydGEudmFsb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ZhbG9yX211ZGFuY2FfcGVyY2VudHVhbCc6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEJ1c2NhciBzbmFwc2hvdCBhbnRlcmlvciBwYXJhIGNvbXBhcmHDp8Ojb1xuICAgICAgICAgICAgY29uc3Qgc25hcHNob3RBbnRlcmlvciA9XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMubWV0cmljYVNuYXBzaG90UmVwb3NpdG9yeS5maW5kT25lKHtcbiAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgZGVmaW5pY2FvX2lkOiBtZXRyaWNhLmlkLFxuICAgICAgICAgICAgICAgICAgcGVyaW9kb19maW06IE1vcmVUaGFuKG5ldyBEYXRlKERhdGUubm93KCkgLSA4NjQwMDAwMCkpLCAvLyDDmmx0aW1hcyAyNGhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9yZGVyOiB7IHBlcmlvZG9fZmltOiAnREVTQycgfSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzbmFwc2hvdEFudGVyaW9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhcmlhY2FvUGVyY2VudHVhbCA9XG4gICAgICAgICAgICAgICAgKCh2YWxvciAtIHNuYXBzaG90QW50ZXJpb3IudmFsb3IpIC8gc25hcHNob3RBbnRlcmlvci52YWxvcikgKlxuICAgICAgICAgICAgICAgIDEwMDtcbiAgICAgICAgICAgICAgY29uZGljYW9BdGl2YWRhID0gTWF0aC5hYnModmFyaWFjYW9QZXJjZW50dWFsKSA+IGFsZXJ0YS52YWxvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgIGBFcnJvIGFvIHZlcmlmaWNhciB2YXJpYcOnw6NvIHBlcmNlbnR1YWw6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlIGEgY29uZGnDp8OjbyBmb3Igc2F0aXNmZWl0YSwgZW1pdGlyIGFsZXJ0YVxuICAgICAgaWYgKGNvbmRpY2FvQXRpdmFkYSkge1xuICAgICAgICBjb25zdCBtZW5zYWdlbSA9XG4gICAgICAgICAgYWxlcnRhLm1lbnNhZ2VtIHx8XG4gICAgICAgICAgYEFsZXJ0YSBwYXJhIG3DqXRyaWNhICR7bWV0cmljYS5jb2RpZ299OiB2YWxvciAke3ZhbG9yfSAke2FsZXJ0YS50aXBvID09PSAndmFsb3JfbWF4aW1vJyA/ICdhY2ltYScgOiAnYWJhaXhvJ30gZG8gbGltaXRlICR7YWxlcnRhLnZhbG9yfWA7XG5cbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICBgW0FMRVJUQV0gJHttZW5zYWdlbX0gW1NldmVyaWRhZGU6ICR7YWxlcnRhLnNldmVyaWRhZGUgfHwgJ23DqWRpYSd9XWAsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRW1pdGlyIGV2ZW50byBwYXJhIHNlciBjYXB0dXJhZG8gcG9yIG91dHJvcyBzZXJ2acOnb3NcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnbWV0cmljYS5hbGVydGEnLCB7XG4gICAgICAgICAgbWV0cmljYV9pZDogbWV0cmljYS5pZCxcbiAgICAgICAgICBtZXRyaWNhX2NvZGlnbzogbWV0cmljYS5jb2RpZ28sXG4gICAgICAgICAgbWV0cmljYV9ub21lOiBtZXRyaWNhLm5vbWUsXG4gICAgICAgICAgdmFsb3IsXG4gICAgICAgICAgdmFsb3JfbGltaXRlOiBhbGVydGEudmFsb3IsXG4gICAgICAgICAgdGlwb19hbGVydGE6IGFsZXJ0YS50aXBvLFxuICAgICAgICAgIG1lbnNhZ2VtLFxuICAgICAgICAgIHNldmVyaWRhZGU6IGFsZXJ0YS5zZXZlcmlkYWRlIHx8ICdtw6lkaWEnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpbXBhIHNuYXBzaG90cyBhbnRpZ29zIGNvbmZvcm1lIHBvbMOtdGljYSBkZSByZXRlbsOnw6NvXG4gICAqIEBwYXJhbSBtZXRyaWNhSWQgSUQgZGEgbcOpdHJpY2FcbiAgICogQHBhcmFtIGNvbmZpZyBDb25maWd1cmHDp8OjbyBkYSBtw6l0cmljYVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBsaW1wYXJTbmFwc2hvdHNBbnRpZ29zKFxuICAgIG1ldHJpY2FJZDogc3RyaW5nLFxuICAgIGNvbmZpZzogTWV0cmljYUNvbmZpZ3VyYWNhbyxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIExpbXBhciBwb3IgcGVyw61vZG8gZGUgcmV0ZW7Dp8Ojb1xuICAgICAgaWYgKGNvbmZpZy5wZXJpb2RvX3JldGVuY2FvX2RpYXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IGRhdGFMaW1pdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBkYXRhTGltaXRlLnNldERhdGUoZGF0YUxpbWl0ZS5nZXREYXRlKCkgLSBjb25maWcucGVyaW9kb19yZXRlbmNhb19kaWFzKTtcblxuICAgICAgICBjb25zdCByZXN1bHRhZG8gPSBhd2FpdCB0aGlzLm1ldHJpY2FTbmFwc2hvdFJlcG9zaXRvcnkuZGVsZXRlKHtcbiAgICAgICAgICBkZWZpbmljYW9faWQ6IG1ldHJpY2FJZCxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBCZXR3ZWVuKG5ldyBEYXRlKDApLCBkYXRhTGltaXRlKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdGFkby5hZmZlY3RlZCAmJiByZXN1bHRhZG8uYWZmZWN0ZWQgPiAwKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICBgUmVtb3ZpZG9zICR7cmVzdWx0YWRvLmFmZmVjdGVkfSBzbmFwc2hvdHMgYW50aWdvcyBkYSBtw6l0cmljYSAke21ldHJpY2FJZH1gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTGltaXRhciBuw7ptZXJvIG3DoXhpbW8gZGUgc25hcHNob3RzXG4gICAgICBpZiAoY29uZmlnLm1heF9zbmFwc2hvdHMgPiAwKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgdGhpcy5tZXRyaWNhU25hcHNob3RSZXBvc2l0b3J5LmNvdW50KHtcbiAgICAgICAgICB3aGVyZTogeyBkZWZpbmljYW9faWQ6IG1ldHJpY2FJZCB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY291bnQgPiBjb25maWcubWF4X3NuYXBzaG90cykge1xuICAgICAgICAgIC8vIEJ1c2NhciBJRHMgbWFpcyBhbnRpZ29zIHF1ZSBleGNlZGVtIG8gbGltaXRlXG4gICAgICAgICAgY29uc3Qgc25hcHNob3RzID0gYXdhaXQgdGhpcy5tZXRyaWNhU25hcHNob3RSZXBvc2l0b3J5LmZpbmQoe1xuICAgICAgICAgICAgd2hlcmU6IHsgZGVmaW5pY2FvX2lkOiBtZXRyaWNhSWQgfSxcbiAgICAgICAgICAgIG9yZGVyOiB7IGNyZWF0ZWRfYXQ6ICdBU0MnIH0sXG4gICAgICAgICAgICB0YWtlOiBjb3VudCAtIGNvbmZpZy5tYXhfc25hcHNob3RzLFxuICAgICAgICAgICAgc2VsZWN0OiBbJ2lkJ10sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoc25hcHNob3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGlkcyA9IHNuYXBzaG90cy5tYXAoKHMpID0+IHMuaWQpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0YWRvID0gYXdhaXQgdGhpcy5tZXRyaWNhU25hcHNob3RSZXBvc2l0b3J5LmRlbGV0ZShpZHMpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0YWRvLmFmZmVjdGVkICYmIHJlc3VsdGFkby5hZmZlY3RlZCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICAgICAgYFJlbW92aWRvcyAke3Jlc3VsdGFkby5hZmZlY3RlZH0gc25hcHNob3RzIGV4Y2VkZW50ZXMgZGEgbcOpdHJpY2EgJHttZXRyaWNhSWR9YCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gYW8gbGltcGFyIHNuYXBzaG90cyBhbnRpZ29zOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlcmEgdW0gaGFzaCDDum5pY28gcGFyYSBhcyBkaW1lbnPDtWVzIGRlIHVtIHNuYXBzaG90XG4gICAqIEBwYXJhbSBkaW1lbnNvZXMgT2JqZXRvIGRlIGRpbWVuc8O1ZXNcbiAgICogQHJldHVybnMgSGFzaCBkYXMgZGltZW5zw7Vlc1xuICAgKi9cbiAgcHJpdmF0ZSBnZXJhckhhc2hEaW1lbnNvZXMoZGltZW5zb2VzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogc3RyaW5nIHtcbiAgICBjb25zdCBzdHJpbmdEaW1lbnNvZXMgPSBKU09OLnN0cmluZ2lmeShkaW1lbnNvZXMgfHwge30pO1xuICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHN0cmluZ0RpbWVuc29lcykuZGlnZXN0KCdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXRhIG8gdmFsb3IgbnVtw6lyaWNvIGRhIG3DqXRyaWNhIGNvbmZvcm1lIGNvbmZpZ3VyYcOnw7Vlc1xuICAgKiBAcGFyYW0gdmFsb3IgVmFsb3IgbnVtw6lyaWNvXG4gICAqIEBwYXJhbSBtZXRyaWNhIERlZmluacOnw6NvIGRhIG3DqXRyaWNhXG4gICAqIEByZXR1cm5zIFZhbG9yIGZvcm1hdGFkbyBjb21vIHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBmb3JtYXRhclZhbG9yTWV0cmljYShcbiAgICB2YWxvcjogbnVtYmVyLFxuICAgIG1ldHJpY2E6IE1ldHJpY2FEZWZpbmljYW8sXG4gICk6IHN0cmluZyB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB2YWxvckZvcm1hdGFkbyA9IE51bWJlcih2YWxvcikudG9GaXhlZChtZXRyaWNhLmNhc2FzX2RlY2ltYWlzKTtcblxuICAgICAgLy8gQWRpY2lvbmFyIHByZWZpeG8gZSBzdWZpeG8sIHNlIGRlZmluaWRvc1xuICAgICAgaWYgKG1ldHJpY2EucHJlZml4bykge1xuICAgICAgICB2YWxvckZvcm1hdGFkbyA9IGAke21ldHJpY2EucHJlZml4b30ke3ZhbG9yRm9ybWF0YWRvfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRyaWNhLnN1Zml4bykge1xuICAgICAgICB2YWxvckZvcm1hdGFkbyA9IGAke3ZhbG9yRm9ybWF0YWRvfSR7bWV0cmljYS5zdWZpeG99YDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbG9yRm9ybWF0YWRvO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRXJybyBhbyBmb3JtYXRhciB2YWxvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIHZhbG9yLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGV0YSBtYW51YWwgZGUgdW1hIG3DqXRyaWNhIGVzcGVjw61maWNhXG4gICAqIEBwYXJhbSBjb2RpZ28gQ8OzZGlnbyBkYSBtw6l0cmljYVxuICAgKiBAcGFyYW0gZGltZW5zb2VzIERpbWVuc8O1ZXMgcGFyYSBmaWx0cmFyIGEgY29sZXRhXG4gICAqIEByZXR1cm5zIFNuYXBzaG90IGRhIG3DqXRyaWNhIGNvbGV0YWRhXG4gICAqL1xuICBhc3luYyBjb2xldGFyTWV0cmljYU1hbnVhbChcbiAgICBjb2RpZ286IHN0cmluZyxcbiAgICBkaW1lbnNvZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICApOiBQcm9taXNlPE1ldHJpY2FTbmFwc2hvdD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXRyaWNhID0gYXdhaXQgdGhpcy5tZXRyaWNhRGVmaW5pY2FvUmVwb3NpdG9yeS5maW5kT25lKHtcbiAgICAgICAgd2hlcmU6IHsgY29kaWdvLCBhdGl2YTogdHJ1ZSB9LFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghbWV0cmljYSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE3DqXRyaWNhIG7Do28gZW5jb250cmFkYSBvdSBpbmF0aXZhOiAke2NvZGlnb31gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29sZXRhck1ldHJpY2EobWV0cmljYS5pZCwge1xuICAgICAgICBkaW1lbnNvZXMsXG4gICAgICAgIG1ldGFkYWRvczogeyBvcmlnZW06ICdjb2xldGFfbWFudWFsJyB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBgRXJybyBuYSBjb2xldGEgbWFudWFsIGRhIG3DqXRyaWNhICR7Y29kaWdvfTogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFnZW5kYSBhIGNvbGV0YSBkZSB0b2RhcyBhcyBtw6l0cmljYXMgY29uZmlndXJhZGFzIHBhcmEgY29sZXRhIGF1dG9tw6F0aWNhXG4gICAqL1xuICBhc3luYyB2ZXJpZmljYXJDb25maWd1cmFjb2VzQWdlbmRhbWVudG8oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdWZXJpZmljYW5kbyBjb25maWd1cmHDp8O1ZXMgZGUgYWdlbmRhbWVudG8nKTtcblxuICAgICAgY29uc3QgY29uZmlndXJhY29lcyA9IGF3YWl0IHRoaXMubWV0cmljYUNvbmZpZ3VyYWNhb1JlcG9zaXRvcnkuZmluZCh7XG4gICAgICAgIHdoZXJlOiB7IGNvbGV0YV9hdXRvbWF0aWNhOiB0cnVlIH0sXG4gICAgICAgIHJlbGF0aW9uczogWydtZXRyaWNhJ10sXG4gICAgICB9KTtcblxuICAgICAgZm9yIChjb25zdCBjb25maWcgb2YgY29uZmlndXJhY29lcykge1xuICAgICAgICAvLyBDYXJyZWdhciBhIGVudGlkYWRlIG1ldHJpY2EgcGFyYSBhY2Vzc2FyIHN1YXMgcHJvcHJpZWRhZGVzXG4gICAgICAgIGNvbnN0IG1ldHJpY2EgPSBhd2FpdCBjb25maWcubWV0cmljYTtcblxuICAgICAgICBpZiAobWV0cmljYS5hdGl2YSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuY29uZmlndXJhckFnZW5kYW1lbnRvTWV0cmljYShjb25maWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBgRXJybyBhbyB2ZXJpZmljYXIgY29uZmlndXJhw6fDtWVzIGRlIGFnZW5kYW1lbnRvOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGV0YSBwcm9ncmFtYWRhIGRlIG3DqXRyaWNhcyBkacOhcmlhcyAoZXhlY3V0YWRhIHVtYSB2ZXogcG9yIGRpYSDDoCBtZWlhLW5vaXRlKVxuICAgKi9cbiAgYXN5bmMgY29sZXRhck1ldHJpY2FzRGlhcmlhcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdJbmljaWFuZG8gY29sZXRhIGRpw6FyaWEgZGUgbcOpdHJpY2FzJyk7XG5cbiAgICAgIGNvbnN0IG1ldHJpY2FzID0gYXdhaXQgdGhpcy5tZXRyaWNhRGVmaW5pY2FvUmVwb3NpdG9yeS5maW5kKHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBhdGl2YTogdHJ1ZSxcbiAgICAgICAgICBncmFudWxhcmlkYWRlOiAnZGlhJyBhcyBhbnksIC8vIEZvcsOnYW5kbyBvIHRpcG8gcGFyYSBldml0YXIgZXJybyBkZSBpbmNvbXBhdGliaWxpZGFkZVxuICAgICAgICB9LFxuICAgICAgICByZWxhdGlvbnM6IFsnY29uZmlndXJhY29lcyddLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgRW5jb250cmFkYXMgJHttZXRyaWNhcy5sZW5ndGh9IG3DqXRyaWNhcyBkacOhcmlhcyBwYXJhIGNvbGV0YSBwcm9ncmFtYWRhYCxcbiAgICAgICk7XG5cbiAgICAgIGZvciAoY29uc3QgbWV0cmljYSBvZiBtZXRyaWNhcykge1xuICAgICAgICAvLyBDYXJyZWdhciBvIHJlbGFjaW9uYW1lbnRvIGxhenkgY29uZmlndXJhY29lc1xuICAgICAgICBjb25zdCBjb25maWd1cmFjb2VzID0gYXdhaXQgbWV0cmljYS5jb25maWd1cmFjb2VzO1xuXG4gICAgICAgIGlmIChjb25maWd1cmFjb2VzLmxlbmd0aCA9PT0gMCB8fCAhY29uZmlndXJhY29lc1swXS5jb2xldGFfYXV0b21hdGljYSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xldGFyTWV0cmljYShtZXRyaWNhLmlkKS5jYXRjaCgoZXJyKSA9PlxuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgYEVycm8gYW8gY29sZXRhciBtw6l0cmljYSBkacOhcmlhICR7bWV0cmljYS5jb2RpZ299OiAke2Vyci5tZXNzYWdlfWAsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gbmEgY29sZXRhIGRpw6FyaWE6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYSBvIGludGVydmFsbyBlbSBtaWxpc3NlZ3VuZG9zIGEgcGFydGlyIGRlIHVtYSBleHByZXNzw6NvIGNyb25cbiAgICogRXN0YSDDqSB1bWEgaW1wbGVtZW50YcOnw6NvIHNpbXBsaWZpY2FkYSBxdWUgY29udmVydGUgZXhwcmVzc8O1ZXMgY3JvbiBjb211bnMgZW0gaW50ZXJ2YWxvc1xuICAgKiBAcGFyYW0gY3JvbkV4cHJlc3Npb24gRXhwcmVzc8OjbyBjcm9uXG4gICAqIEByZXR1cm5zIEludGVydmFsbyBhcHJveGltYWRvIGVtIG1pbGlzc2VndW5kb3NcbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXJJbnRlcnZhbG9FbU1pbGlzc2VndW5kb3MoY3JvbkV4cHJlc3Npb246IHN0cmluZyk6IG51bWJlciB7XG4gICAgLy8gRXhwcmVzc8O1ZXMgY3JvbiBjb211bnMgZSBzZXVzIGludGVydmFsb3MgYXByb3hpbWFkb3NcbiAgICBjb25zdCBpbnRlcnZhbG9zID0ge1xuICAgICAgJzAgKiAqICogKic6IDYwICogNjAgKiAxMDAwLCAvLyBBIGNhZGEgaG9yYVxuICAgICAgJzAgMCAqICogKic6IDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIERpw6FyaW9cbiAgICAgICcwIDAgKiAqIDAnOiA3ICogMjQgKiA2MCAqIDYwICogMTAwMCwgLy8gU2VtYW5hbFxuICAgICAgJzAgMCAxICogKic6IDMwICogMjQgKiA2MCAqIDYwICogMTAwMCwgLy8gTWVuc2FsIChhcHJveGltYWRvKVxuICAgIH07XG5cbiAgICByZXR1cm4gaW50ZXJ2YWxvc1tjcm9uRXhwcmVzc2lvbl0gfHwgNjAgKiA2MCAqIDEwMDA7IC8vIFBhZHLDo286IDEgaG9yYVxuICB9XG59XG4iXSwidmVyc2lvbiI6M30=