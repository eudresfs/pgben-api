{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\metricas\\services\\metricas-cache.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\metricas\\services\\metricas-cache.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { ConfigService } from '@nestjs/config';\nimport * as crypto from 'crypto';\nimport NodeCache from 'node-cache';\n\nimport { MetricaDefinicao } from '../../../entities/metrica-definicao.entity';\nimport { MetricaConfiguracao } from '../../../entities/metrica-configuracao.entity';\nimport { MetricaSnapshot } from '../../../entities/metrica-snapshot.entity';\n\n/**\n * Serviço responsável pelo cacheamento de métricas\n *\n * Este serviço implementa estratégias de cache para otimizar o desempenho\n * das consultas às métricas, reduzindo a carga no banco de dados.\n */\n@Injectable()\nexport class MetricasCacheService {\n  private readonly logger = new Logger(MetricasCacheService.name);\n  private readonly cache: NodeCache;\n\n  // Prefixos para as chaves de cache\n  private readonly PREFIX_METRICA = 'metrica:';\n  private readonly PREFIX_SNAPSHOT = 'snapshot:';\n  private readonly PREFIX_SERIES = 'serie:';\n\n  constructor(\n    @InjectRepository(MetricaDefinicao)\n    private readonly metricaDefinicaoRepository: Repository<MetricaDefinicao>,\n\n    @InjectRepository(MetricaConfiguracao)\n    private readonly metricaConfiguracaoRepository: Repository<MetricaConfiguracao>,\n\n    @InjectRepository(MetricaSnapshot)\n    private readonly metricaSnapshotRepository: Repository<MetricaSnapshot>,\n\n    private readonly configService: ConfigService,\n  ) {\n    // Inicializar cache com configurações padrão\n    const ttlPadrao =\n      this.configService.get<number>('METRICAS_CACHE_TTL_SEGUNDOS') || 300; // 5 minutos\n\n    this.cache = new NodeCache({\n      stdTTL: ttlPadrao,\n      checkperiod: 60, // Verificar expiração a cada 60 segundos\n      useClones: false, // Economizar memória não clonando objetos\n      deleteOnExpire: true,\n      maxKeys: 10000, // Limitar número de chaves para evitar uso excessivo de memória\n    });\n\n    // Configurar evento para quando uma chave for removida do cache\n    this.cache.on('expired', (key, value) => {\n      this.logger.debug(`Cache expirado: ${key}`);\n    });\n\n    this.logger.log(\n      `Serviço de cache inicializado (TTL padrão: ${ttlPadrao}s)`,\n    );\n  }\n\n  /**\n   * Obter métrica do cache ou do banco de dados\n   * @param codigo Código único da métrica\n   * @returns Definição da métrica\n   */\n  async obterMetrica(codigo: string): Promise<MetricaDefinicao | null> {\n    const cacheKey = `${this.PREFIX_METRICA}${codigo}`;\n\n    // Tentar obter do cache\n    const cachedMetrica = this.cache.get<MetricaDefinicao>(cacheKey);\n\n    if (cachedMetrica) {\n      this.logger.debug(`Cache hit: ${cacheKey}`);\n      return cachedMetrica;\n    }\n\n    // Não encontrado no cache, buscar no banco de dados\n    this.logger.debug(`Cache miss: ${cacheKey}`);\n\n    const metrica = await this.metricaDefinicaoRepository.findOne({\n      where: { codigo, ativa: true },\n      relations: ['configuracoes'],\n    });\n\n    if (metrica) {\n      // Obter configuração para definir o TTL do cache\n      let ttl = 300; // Padrão: 5 minutos\n\n      // Carregar o relacionamento lazy configuracoes\n      const configuracoes = await metrica.configuracoes;\n\n      if (configuracoes.length > 0) {\n        const config = configuracoes[0];\n\n        if (config.cacheamento_habilitado) {\n          ttl = config.cache_ttl || ttl;\n        } else {\n          // Se o cacheamento estiver desabilitado, não armazenar em cache\n          return metrica;\n        }\n      }\n\n      // Armazenar no cache\n      this.cache.set(cacheKey, metrica, ttl);\n    }\n\n    return metrica;\n  }\n\n  /**\n   * Obter último snapshot de uma métrica\n   * @param metricaId ID da métrica\n   * @param dimensoes Dimensões para filtrar o snapshot\n   * @returns Último snapshot disponível\n   */\n  async obterUltimoSnapshot(\n    metricaId: string,\n    dimensoes: Record<string, any> = {},\n  ): Promise<MetricaSnapshot | null> {\n    // Gerar hash das dimensões\n    const dimensoesHash = this.gerarHashDimensoes(dimensoes);\n\n    // Gerar chave de cache\n    const cacheKey = `${this.PREFIX_SNAPSHOT}${metricaId}:${dimensoesHash}`;\n\n    // Tentar obter do cache\n    const cachedSnapshot = this.cache.get<MetricaSnapshot>(cacheKey);\n\n    if (cachedSnapshot) {\n      this.logger.debug(`Cache hit: ${cacheKey}`);\n      return cachedSnapshot;\n    }\n\n    // Não encontrado no cache, buscar no banco de dados\n    this.logger.debug(`Cache miss: ${cacheKey}`);\n\n    // Buscar a métrica e sua configuração para determinar TTL\n    const metrica = await this.metricaDefinicaoRepository.findOne({\n      where: { id: metricaId },\n      relations: ['configuracoes'],\n    });\n\n    // Verificar se o cacheamento está habilitado\n    let ttl = 300; // Padrão: 5 minutos\n    let cacheamentoHabilitado = true;\n\n    // Corrigido: Uso de lazy loading com await\n    if (metrica) {\n      const configuracoes = await metrica.configuracoes;\n\n      if (configuracoes.length > 0) {\n        const config = configuracoes[0];\n\n        if (config.cacheamento_habilitado) {\n          ttl = config.cache_ttl || ttl;\n        } else {\n          cacheamentoHabilitado = false;\n        }\n      }\n    }\n\n    // Buscar snapshot no banco de dados\n    const snapshot = await this.metricaSnapshotRepository.findOne({\n      where: {\n        definicao_id: metricaId,\n        dimensoes_hash: dimensoesHash,\n      },\n      order: {\n        periodo_fim: 'DESC',\n      },\n    });\n\n    if (snapshot && cacheamentoHabilitado) {\n      // Armazenar no cache\n      this.cache.set(cacheKey, snapshot, ttl);\n    }\n\n    // Se não encontrar nenhum snapshot, retornar null em vez de indefinido\n    return snapshot || null;\n  }\n\n  /**\n   * Obter série temporal de snapshots de uma métrica\n   * @param metricaId ID da métrica\n   * @param inicio Data de início do período\n   * @param fim Data de fim do período\n   * @param dimensoes Dimensões para filtrar os snapshots\n   * @returns Lista de snapshots ordenados por período\n   */\n  async obterSerieTemporal(\n    metricaId: string,\n    inicio: Date,\n    fim: Date,\n    dimensoes: Record<string, any> = {},\n  ): Promise<MetricaSnapshot[]> {\n    // Gerar hash das dimensões\n    const dimensoesHash = this.gerarHashDimensoes(dimensoes);\n\n    // Gerar hash do período\n    const periodoHash = `${inicio.toISOString()}_${fim.toISOString()}`;\n\n    // Gerar chave de cache\n    const cacheKey = `${this.PREFIX_SERIES}${metricaId}:${dimensoesHash}:${periodoHash}`;\n\n    // Tentar obter do cache\n    const cachedSerie = this.cache.get<MetricaSnapshot[]>(cacheKey);\n\n    if (cachedSerie) {\n      this.logger.debug(`Cache hit: ${cacheKey}`);\n      return cachedSerie;\n    }\n\n    // Não encontrado no cache, buscar no banco de dados\n    this.logger.debug(`Cache miss: ${cacheKey}`);\n\n    // Buscar a métrica e sua configuração para determinar TTL\n    const metrica = await this.metricaDefinicaoRepository.findOne({\n      where: { id: metricaId },\n      relations: ['configuracoes'],\n    });\n\n    // Verificar se o cacheamento está habilitado\n    let ttl = 300; // Padrão: 5 minutos\n    let cacheamentoHabilitado = true;\n\n    // Corrigido: Uso de lazy loading com await\n    if (metrica) {\n      const configuracoes = await metrica.configuracoes;\n\n      if (configuracoes.length > 0) {\n        const config = configuracoes[0];\n\n        if (config.cacheamento_habilitado) {\n          ttl = config.cache_ttl || ttl;\n        } else {\n          cacheamentoHabilitado = false;\n        }\n      }\n    }\n\n    // Buscar snapshots no banco de dados\n    const snapshots = await this.metricaSnapshotRepository.find({\n      where: {\n        definicao_id: metricaId,\n        dimensoes_hash: dimensoesHash,\n        periodo_inicio: inicio,\n        periodo_fim: fim,\n      },\n      order: {\n        periodo_inicio: 'ASC',\n      },\n    });\n\n    if (snapshots.length > 0 && cacheamentoHabilitado) {\n      // Armazenar no cache\n      this.cache.set(cacheKey, snapshots, ttl);\n    }\n\n    return snapshots;\n  }\n\n  /**\n   * Invalida o cache de uma métrica específica\n   * @param metricaId ID da métrica\n   */\n  invalidarCacheMetrica(metricaId: string): void {\n    // Buscar todas as chaves que correspondem ao padrão\n    const keyPattern = new RegExp(\n      `^(${this.PREFIX_METRICA}|${this.PREFIX_SNAPSHOT}|${this.PREFIX_SERIES}).*${metricaId}`,\n    );\n\n    const chavesParaRemover: string[] = [];\n\n    // Identificar chaves a serem removidas\n    this.cache.keys().forEach((key) => {\n      if (keyPattern.test(key)) {\n        chavesParaRemover.push(key);\n      }\n    });\n\n    if (chavesParaRemover.length > 0) {\n      // Remover chaves do cache\n      chavesParaRemover.forEach((key) => this.cache.del(key));\n      this.logger.debug(\n        `Cache invalidado para métrica ${metricaId}: ${chavesParaRemover.length} chaves removidas`,\n      );\n    }\n  }\n\n  /**\n   * Invalida todo o cache de métricas\n   */\n  limparCacheCompleto(): void {\n    const totalChaves = this.cache.keys().length;\n    this.cache.flushAll();\n    this.logger.log(\n      `Cache completo de métricas limpo: ${totalChaves} chaves removidas`,\n    );\n  }\n\n  /**\n   * Pré-calcula e armazena em cache métricas frequentemente acessadas\n   */\n  async preCalcularMetricasFrequentes(): Promise<void> {\n    try {\n      this.logger.log('Iniciando pré-cálculo de métricas frequentes');\n\n      // Buscar métricas marcadas para exibição em dashboard\n      const configuracoes = await this.metricaConfiguracaoRepository.find({\n        where: { exibir_dashboard: true },\n        relations: ['metrica'],\n        order: { prioridade_dashboard: 'ASC' },\n      });\n\n      if (configuracoes.length === 0) {\n        this.logger.debug('Nenhuma métrica configurada para pré-cálculo');\n        return;\n      }\n\n      this.logger.debug(\n        `Encontradas ${configuracoes.length} métricas para pré-cálculo`,\n      );\n\n      // Obter último snapshot de cada métrica e armazenar em cache\n      for (const config of configuracoes) {\n        // Carregar a entidade metrica para acessar suas propriedades\n        const metrica = await config.metrica;\n\n        if (!metrica.ativa || !config.cacheamento_habilitado) {\n          continue;\n        }\n\n        try {\n          const snapshot = await this.obterUltimoSnapshot(metrica.id);\n\n          if (snapshot) {\n            this.logger.debug(\n              `Métrica pré-calculada: ${metrica.codigo}, valor: ${snapshot.valor}`,\n            );\n          }\n        } catch (error) {\n          this.logger.error(\n            `Erro ao pré-calcular métrica ${metrica.codigo}: ${error.message}`,\n          );\n        }\n      }\n\n      this.logger.log('Pré-cálculo de métricas frequentes concluído');\n    } catch (error) {\n      this.logger.error(`Erro no pré-cálculo de métricas: ${error.message}`);\n    }\n  }\n\n  /**\n   * Gera um hash único para as dimensões\n   * @param dimensoes Objeto de dimensões\n   * @returns Hash das dimensões\n   */\n  private gerarHashDimensoes(dimensoes: Record<string, any>): string {\n    const stringDimensoes = JSON.stringify(dimensoes || {});\n    return crypto.createHash('sha256').update(stringDimensoes).digest('hex');\n  }\n\n  /**\n   * Obtém estatísticas de uso do cache\n   * @returns Estatísticas do cache\n   */\n  obterEstatisticas(): Record<string, any> {\n    const estatisticas = this.cache.getStats();\n\n    return {\n      keys: this.cache.keys().length,\n      hits: estatisticas.hits,\n      misses: estatisticas.misses,\n      hit_rate:\n        estatisticas.hits / (estatisticas.hits + estatisticas.misses || 1),\n      keys_by_type: {\n        metrica: this.cache\n          .keys()\n          .filter((k) => k.startsWith(this.PREFIX_METRICA)).length,\n        snapshot: this.cache\n          .keys()\n          .filter((k) => k.startsWith(this.PREFIX_SNAPSHOT)).length,\n        serie: this.cache.keys().filter((k) => k.startsWith(this.PREFIX_SERIES))\n          .length,\n      },\n    };\n  }\n}\n"],"version":3}