288c22d5f90fc48462dd88502a9000bf
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MetricaCalculoService_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricaCalculoService = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const config_1 = require("@nestjs/config");
const mathjs = __importStar(require("mathjs"));
const metrica_definicao_entity_1 = require("../../../entities/metrica-definicao.entity");
const metrica_snapshot_entity_1 = require("../../../entities/metrica-snapshot.entity");
/**
 * Serviço responsável pelo cálculo de valores de métricas
 *
 * Este serviço implementa algoritmos para calcular valores de métricas
 * conforme seu tipo, fonte de dados e fórmulas definidas.
 */
let MetricaCalculoService = MetricaCalculoService_1 = class MetricaCalculoService {
    metricaDefinicaoRepository;
    metricaSnapshotRepository;
    configService;
    dataSource;
    logger = new common_1.Logger(MetricaCalculoService_1.name);
    mathParser;
    constructor(metricaDefinicaoRepository, metricaSnapshotRepository, configService, dataSource) {
        this.metricaDefinicaoRepository = metricaDefinicaoRepository;
        this.metricaSnapshotRepository = metricaSnapshotRepository;
        this.configService = configService;
        this.dataSource = dataSource;
        // Inicializar o parser matemático para cálculo de fórmulas
        this.mathParser = mathjs.parser();
    }
    /**
     * Calcula o valor de uma métrica conforme sua definição e tipo
     *
     * @param metrica Definição da métrica
     * @param periodoInicio Data de início do período
     * @param periodoFim Data de fim do período
     * @param dimensoes Dimensões para filtrar o cálculo
     * @returns Valor numérico da métrica
     */
    async calcularValorMetrica(metrica, periodoInicio, periodoFim, dimensoes = {}) {
        this.logger.debug(`Calculando valor para métrica: ${metrica.codigo}`);
        try {
            switch (metrica.tipo) {
                case metrica_definicao_entity_1.TipoMetrica.CONTAGEM:
                    return this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);
                case metrica_definicao_entity_1.TipoMetrica.SOMA:
                    return this.calcularSoma(metrica, periodoInicio, periodoFim, dimensoes);
                case metrica_definicao_entity_1.TipoMetrica.MEDIA:
                    return this.calcularMedia(metrica, periodoInicio, periodoFim, dimensoes);
                case metrica_definicao_entity_1.TipoMetrica.MINIMO:
                    return this.calcularMinimo(metrica, periodoInicio, periodoFim, dimensoes);
                case metrica_definicao_entity_1.TipoMetrica.MAXIMO:
                    return this.calcularMaximo(metrica, periodoInicio, periodoFim, dimensoes);
                case metrica_definicao_entity_1.TipoMetrica.PERCENTIL:
                    const percentil = metrica.parametros_especificos?.percentil || 90;
                    return this.calcularPercentil(metrica, periodoInicio, periodoFim, dimensoes, percentil);
                case metrica_definicao_entity_1.TipoMetrica.CARDINALIDADE:
                    return this.calcularCardinalidade(metrica, periodoInicio, periodoFim, dimensoes);
                case metrica_definicao_entity_1.TipoMetrica.TAXA_VARIACAO:
                    return this.calcularTaxaVariacao(metrica, periodoInicio, periodoFim, dimensoes);
                case metrica_definicao_entity_1.TipoMetrica.COMPOSTA:
                    return this.calcularMetricaComposta(metrica, periodoInicio, periodoFim, dimensoes);
                default:
                    throw new Error(`Tipo de métrica não suportado: ${metrica.tipo}`);
            }
        }
        catch (error) {
            this.logger.error(`Erro ao calcular métrica ${metrica.codigo}: ${error.message}`, error.stack);
            throw error;
        }
    }
    /**
     * Calcula métrica do tipo CONTAGEM
     */
    async calcularContagem(metrica, periodoInicio, periodoFim, dimensoes) {
        if (!metrica.sql_consulta) {
            throw new Error(`Consulta SQL não definida para métrica ${metrica.codigo}`);
        }
        const sqlOriginal = metrica.sql_consulta;
        // Substituir placeholders de período
        let sql = sqlOriginal
            .replace(/\$\{PERIODO_INICIO\}/g, `'${periodoInicio.toISOString()}'`)
            .replace(/\$\{PERIODO_FIM\}/g, `'${periodoFim.toISOString()}'`);
        // Substituir placeholders de dimensões
        for (const [chave, valor] of Object.entries(dimensoes)) {
            const placeholder = `\${DIMENSAO.${chave}}`;
            sql = sql.replace(new RegExp(placeholder, 'g'), typeof valor === 'string' ? `'${valor}'` : String(valor));
        }
        try {
            // Executar consulta SQL
            const resultado = await this.dataSource.query(sql);
            if (!resultado || resultado.length === 0) {
                return 0;
            }
            // Obter o primeiro valor da primeira linha
            const primeiraLinha = resultado[0];
            const primeiraColuna = Object.values(primeiraLinha)[0];
            return Number(primeiraColuna) || 0;
        }
        catch (error) {
            this.logger.error(`Erro na execução da consulta SQL: ${error.message}`);
            throw new Error(`Erro ao executar consulta para métrica ${metrica.codigo}: ${error.message}`);
        }
    }
    /**
     * Calcula métrica do tipo SOMA
     */
    async calcularSoma(metrica, periodoInicio, periodoFim, dimensoes) {
        // A implementação é similar à contagem, pois a diferença está na consulta SQL
        return this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);
    }
    /**
     * Calcula métrica do tipo MEDIA
     */
    async calcularMedia(metrica, periodoInicio, periodoFim, dimensoes) {
        // A implementação é similar à contagem, pois a diferença está na consulta SQL
        return this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);
    }
    /**
     * Calcula métrica do tipo MINIMO
     */
    async calcularMinimo(metrica, periodoInicio, periodoFim, dimensoes) {
        // A implementação é similar à contagem, pois a diferença está na consulta SQL
        return this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);
    }
    /**
     * Calcula métrica do tipo MAXIMO
     */
    async calcularMaximo(metrica, periodoInicio, periodoFim, dimensoes) {
        // A implementação é similar à contagem, pois a diferença está na consulta SQL
        return this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);
    }
    /**
     * Calcula métrica do tipo PERCENTIL
     */
    async calcularPercentil(metrica, periodoInicio, periodoFim, dimensoes, percentil) {
        if (!metrica.sql_consulta) {
            throw new Error(`Consulta SQL não definida para métrica ${metrica.codigo}`);
        }
        // Substituir placeholder de percentil na consulta
        let sql = metrica.sql_consulta
            .replace(/\$\{PERIODO_INICIO\}/g, `'${periodoInicio.toISOString()}'`)
            .replace(/\$\{PERIODO_FIM\}/g, `'${periodoFim.toISOString()}'`)
            .replace(/\$\{PERCENTIL\}/g, percentil.toString());
        // Substituir placeholders de dimensões
        for (const [chave, valor] of Object.entries(dimensoes)) {
            const placeholder = `\${DIMENSAO.${chave}}`;
            sql = sql.replace(new RegExp(placeholder, 'g'), typeof valor === 'string' ? `'${valor}'` : String(valor));
        }
        try {
            // Executar consulta SQL
            const resultado = await this.dataSource.query(sql);
            if (!resultado || resultado.length === 0) {
                return 0;
            }
            // Obter o primeiro valor da primeira linha
            const primeiraLinha = resultado[0];
            const primeiraColuna = Object.values(primeiraLinha)[0];
            return Number(primeiraColuna) || 0;
        }
        catch (error) {
            this.logger.error(`Erro na execução da consulta SQL: ${error.message}`);
            throw new Error(`Erro ao executar consulta para métrica ${metrica.codigo}: ${error.message}`);
        }
    }
    /**
     * Calcula métrica do tipo CARDINALIDADE
     */
    async calcularCardinalidade(metrica, periodoInicio, periodoFim, dimensoes) {
        // A implementação é similar à contagem, pois a diferença está na consulta SQL
        return this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);
    }
    /**
     * Calcula métrica do tipo TAXA_VARIACAO
     */
    async calcularTaxaVariacao(metrica, periodoInicio, periodoFim, dimensoes) {
        // Calcular valor atual
        const valorAtual = await this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);
        // Calcular valor do período anterior
        const periodoDuracao = periodoFim.getTime() - periodoInicio.getTime();
        const periodoAnteriorFim = new Date(periodoInicio.getTime());
        const periodoAnteriorInicio = new Date(periodoInicio.getTime() - periodoDuracao);
        let valorAnterior;
        try {
            valorAnterior = await this.calcularContagem(metrica, periodoAnteriorInicio, periodoAnteriorFim, dimensoes);
        }
        catch (error) {
            this.logger.warn(`Erro ao calcular valor anterior para taxa de variação: ${error.message}`);
            valorAnterior = 0;
        }
        // Evitar divisão por zero
        if (valorAnterior === 0) {
            // Se o valor anterior for zero e o atual não for, temos 100% de aumento
            return valorAtual > 0 ? 100 : 0;
        }
        // Calcular taxa de variação percentual
        const taxaVariacao = ((valorAtual - valorAnterior) / Math.abs(valorAnterior)) * 100;
        return Number(taxaVariacao.toFixed(2));
    }
    /**
     * Calcula métrica do tipo COMPOSTA
     */
    async calcularMetricaComposta(metrica, periodoInicio, periodoFim, dimensoes) {
        if (!metrica.formula_calculo) {
            throw new Error(`Fórmula de cálculo não definida para métrica composta ${metrica.codigo}`);
        }
        if (!metrica.metricas_dependentes ||
            metrica.metricas_dependentes.length === 0) {
            throw new Error(`Métricas dependentes não definidas para métrica composta ${metrica.codigo}`);
        }
        // Obter valores de todas as métricas dependentes
        const valoresMetricas = {};
        for (const codigoMetrica of metrica.metricas_dependentes) {
            try {
                // Buscar definição da métrica dependente
                const metricaDependente = await this.metricaDefinicaoRepository.findOne({
                    where: { codigo: codigoMetrica, ativa: true },
                });
                if (!metricaDependente) {
                    throw new Error(`Métrica dependente não encontrada ou inativa: ${codigoMetrica}`);
                }
                // Calcular valor da métrica dependente
                const valor = await this.calcularValorMetrica(metricaDependente, periodoInicio, periodoFim, dimensoes);
                valoresMetricas[codigoMetrica] = valor;
            }
            catch (error) {
                this.logger.error(`Erro ao calcular métrica dependente ${codigoMetrica}: ${error.message}`);
                throw new Error(`Erro ao calcular métrica dependente ${codigoMetrica}: ${error.message}`);
            }
        }
        // Avaliar a fórmula de cálculo com os valores obtidos
        try {
            // Limpar o contexto do parser
            this.mathParser.clear();
            // Definir variáveis com os valores das métricas dependentes
            for (const [codigo, valor] of Object.entries(valoresMetricas)) {
                this.mathParser.set(codigo, valor);
            }
            // Avaliar a fórmula
            const resultado = this.mathParser.evaluate(metrica.formula_calculo);
            if (isNaN(resultado)) {
                throw new Error(`Resultado do cálculo é NaN`);
            }
            return Number(resultado);
        }
        catch (error) {
            this.logger.error(`Erro ao avaliar fórmula para métrica ${metrica.codigo}: ${error.message}`);
            throw new Error(`Erro ao avaliar fórmula para métrica ${metrica.codigo}: ${error.message}`);
        }
    }
};
exports.MetricaCalculoService = MetricaCalculoService;
exports.MetricaCalculoService = MetricaCalculoService = MetricaCalculoService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, typeorm_1.InjectRepository)(metrica_definicao_entity_1.MetricaDefinicao)),
    __param(1, (0, typeorm_1.InjectRepository)(metrica_snapshot_entity_1.MetricaSnapshot)),
    __metadata("design:paramtypes", [typeof (_a = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _a : Object, typeof (_b = typeof typeorm_2.Repository !== "undefined" && typeorm_2.Repository) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object, typeof (_d = typeof typeorm_2.DataSource !== "undefined" && typeorm_2.DataSource) === "function" ? _d : Object])
], MetricaCalculoService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxldWRyZVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2pldG9zXFxwZ2JlblxccGdiZW4tc2VydmVyXFxzcmNcXG1vZHVsZXNcXG1ldHJpY2FzXFxzZXJ2aWNlc1xcbWV0cmljYS1jYWxjdWxvLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBb0Q7QUFDcEQsNkNBQW1EO0FBQ25ELHFDQUFpRDtBQUNqRCwyQ0FBK0M7QUFDL0MsK0NBQWlDO0FBRWpDLHlGQUdvRDtBQUNwRCx1RkFBNEU7QUFFNUU7Ozs7O0dBS0c7QUFFSSxJQUFNLHFCQUFxQiw2QkFBM0IsTUFBTSxxQkFBcUI7SUFNYjtJQUdBO0lBRUE7SUFDQTtJQVhGLE1BQU0sR0FBRyxJQUFJLGVBQU0sQ0FBQyx1QkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRCxVQUFVLENBQWdCO0lBRTNDLFlBRW1CLDBCQUF3RCxFQUd4RCx5QkFBc0QsRUFFdEQsYUFBNEIsRUFDNUIsVUFBc0I7UUFOdEIsK0JBQTBCLEdBQTFCLDBCQUEwQixDQUE4QjtRQUd4RCw4QkFBeUIsR0FBekIseUJBQXlCLENBQTZCO1FBRXRELGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBQzVCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFFdkMsMkRBQTJEO1FBQzNELElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILEtBQUssQ0FBQyxvQkFBb0IsQ0FDeEIsT0FBeUIsRUFDekIsYUFBbUIsRUFDbkIsVUFBZ0IsRUFDaEIsWUFBaUMsRUFBRTtRQUVuQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxrQ0FBa0MsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFFdEUsSUFBSSxDQUFDO1lBQ0gsUUFBUSxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7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QUFDLENBQUM7WUFDckMsQ0FBQztZQUVELG9CQUFvQjtZQUNwQixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7WUFFcEUsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztnQkFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1lBQ2hELENBQUM7WUFFRCxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMzQixDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUNmLHdDQUF3QyxPQUFPLENBQUMsTUFBTSxLQUFLLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FDM0UsQ0FBQztZQUNGLE1BQU0sSUFBSSxLQUFLLENBQ2Isd0NBQXdDLE9BQU8sQ0FBQyxNQUFNLEtBQUssS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUMzRSxDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7Q0FDRixDQUFBO0FBaGJZLHNEQUFxQjtnQ0FBckIscUJBQXFCO0lBRGpDLElBQUEsbUJBQVUsR0FBRTtJQU1SLFdBQUEsSUFBQSwwQkFBZ0IsRUFBQywyQ0FBZ0IsQ0FBQyxDQUFBO0lBR2xDLFdBQUEsSUFBQSwwQkFBZ0IsRUFBQyx5Q0FBZSxDQUFDLENBQUE7eURBRlcsb0JBQVUsb0JBQVYsb0JBQVUsb0RBR1gsb0JBQVUsb0JBQVYsb0JBQVUsb0RBRXRCLHNCQUFhLG9CQUFiLHNCQUFhLG9EQUNoQixvQkFBVSxvQkFBVixvQkFBVTtHQVo5QixxQkFBcUIsQ0FnYmpDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZXVkcmVcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZXRvc1xccGdiZW5cXHBnYmVuLXNlcnZlclxcc3JjXFxtb2R1bGVzXFxtZXRyaWNhc1xcc2VydmljZXNcXG1ldHJpY2EtY2FsY3Vsby5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIExvZ2dlciB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IEluamVjdFJlcG9zaXRvcnkgfSBmcm9tICdAbmVzdGpzL3R5cGVvcm0nO1xuaW1wb3J0IHsgUmVwb3NpdG9yeSwgRGF0YVNvdXJjZSB9IGZyb20gJ3R5cGVvcm0nO1xuaW1wb3J0IHsgQ29uZmlnU2VydmljZSB9IGZyb20gJ0BuZXN0anMvY29uZmlnJztcbmltcG9ydCAqIGFzIG1hdGhqcyBmcm9tICdtYXRoanMnO1xuXG5pbXBvcnQge1xuICBNZXRyaWNhRGVmaW5pY2FvLFxuICBUaXBvTWV0cmljYSxcbn0gZnJvbSAnLi4vLi4vLi4vZW50aXRpZXMvbWV0cmljYS1kZWZpbmljYW8uZW50aXR5JztcbmltcG9ydCB7IE1ldHJpY2FTbmFwc2hvdCB9IGZyb20gJy4uLy4uLy4uL2VudGl0aWVzL21ldHJpY2Etc25hcHNob3QuZW50aXR5JztcblxuLyoqXG4gKiBTZXJ2acOnbyByZXNwb25zw6F2ZWwgcGVsbyBjw6FsY3VsbyBkZSB2YWxvcmVzIGRlIG3DqXRyaWNhc1xuICpcbiAqIEVzdGUgc2VydmnDp28gaW1wbGVtZW50YSBhbGdvcml0bW9zIHBhcmEgY2FsY3VsYXIgdmFsb3JlcyBkZSBtw6l0cmljYXNcbiAqIGNvbmZvcm1lIHNldSB0aXBvLCBmb250ZSBkZSBkYWRvcyBlIGbDs3JtdWxhcyBkZWZpbmlkYXMuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNZXRyaWNhQ2FsY3Vsb1NlcnZpY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlciA9IG5ldyBMb2dnZXIoTWV0cmljYUNhbGN1bG9TZXJ2aWNlLm5hbWUpO1xuICBwcml2YXRlIHJlYWRvbmx5IG1hdGhQYXJzZXI6IG1hdGhqcy5QYXJzZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdFJlcG9zaXRvcnkoTWV0cmljYURlZmluaWNhbylcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1ldHJpY2FEZWZpbmljYW9SZXBvc2l0b3J5OiBSZXBvc2l0b3J5PE1ldHJpY2FEZWZpbmljYW8+LFxuXG4gICAgQEluamVjdFJlcG9zaXRvcnkoTWV0cmljYVNuYXBzaG90KVxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWV0cmljYVNuYXBzaG90UmVwb3NpdG9yeTogUmVwb3NpdG9yeTxNZXRyaWNhU25hcHNob3Q+LFxuXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb25maWdTZXJ2aWNlOiBDb25maWdTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGF0YVNvdXJjZTogRGF0YVNvdXJjZSxcbiAgKSB7XG4gICAgLy8gSW5pY2lhbGl6YXIgbyBwYXJzZXIgbWF0ZW3DoXRpY28gcGFyYSBjw6FsY3VsbyBkZSBmw7NybXVsYXNcbiAgICB0aGlzLm1hdGhQYXJzZXIgPSBtYXRoanMucGFyc2VyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYSBvIHZhbG9yIGRlIHVtYSBtw6l0cmljYSBjb25mb3JtZSBzdWEgZGVmaW5pw6fDo28gZSB0aXBvXG4gICAqXG4gICAqIEBwYXJhbSBtZXRyaWNhIERlZmluacOnw6NvIGRhIG3DqXRyaWNhXG4gICAqIEBwYXJhbSBwZXJpb2RvSW5pY2lvIERhdGEgZGUgaW7DrWNpbyBkbyBwZXLDrW9kb1xuICAgKiBAcGFyYW0gcGVyaW9kb0ZpbSBEYXRhIGRlIGZpbSBkbyBwZXLDrW9kb1xuICAgKiBAcGFyYW0gZGltZW5zb2VzIERpbWVuc8O1ZXMgcGFyYSBmaWx0cmFyIG8gY8OhbGN1bG9cbiAgICogQHJldHVybnMgVmFsb3IgbnVtw6lyaWNvIGRhIG3DqXRyaWNhXG4gICAqL1xuICBhc3luYyBjYWxjdWxhclZhbG9yTWV0cmljYShcbiAgICBtZXRyaWNhOiBNZXRyaWNhRGVmaW5pY2FvLFxuICAgIHBlcmlvZG9JbmljaW86IERhdGUsXG4gICAgcGVyaW9kb0ZpbTogRGF0ZSxcbiAgICBkaW1lbnNvZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbiAgKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgQ2FsY3VsYW5kbyB2YWxvciBwYXJhIG3DqXRyaWNhOiAke21ldHJpY2EuY29kaWdvfWApO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAobWV0cmljYS50aXBvKSB7XG4gICAgICAgIGNhc2UgVGlwb01ldHJpY2EuQ09OVEFHRU06XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXJDb250YWdlbShcbiAgICAgICAgICAgIG1ldHJpY2EsXG4gICAgICAgICAgICBwZXJpb2RvSW5pY2lvLFxuICAgICAgICAgICAgcGVyaW9kb0ZpbSxcbiAgICAgICAgICAgIGRpbWVuc29lcyxcbiAgICAgICAgICApO1xuXG4gICAgICAgIGNhc2UgVGlwb01ldHJpY2EuU09NQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhclNvbWEoXG4gICAgICAgICAgICBtZXRyaWNhLFxuICAgICAgICAgICAgcGVyaW9kb0luaWNpbyxcbiAgICAgICAgICAgIHBlcmlvZG9GaW0sXG4gICAgICAgICAgICBkaW1lbnNvZXMsXG4gICAgICAgICAgKTtcblxuICAgICAgICBjYXNlIFRpcG9NZXRyaWNhLk1FRElBOlxuICAgICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGFyTWVkaWEoXG4gICAgICAgICAgICBtZXRyaWNhLFxuICAgICAgICAgICAgcGVyaW9kb0luaWNpbyxcbiAgICAgICAgICAgIHBlcmlvZG9GaW0sXG4gICAgICAgICAgICBkaW1lbnNvZXMsXG4gICAgICAgICAgKTtcblxuICAgICAgICBjYXNlIFRpcG9NZXRyaWNhLk1JTklNTzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhck1pbmltbyhcbiAgICAgICAgICAgIG1ldHJpY2EsXG4gICAgICAgICAgICBwZXJpb2RvSW5pY2lvLFxuICAgICAgICAgICAgcGVyaW9kb0ZpbSxcbiAgICAgICAgICAgIGRpbWVuc29lcyxcbiAgICAgICAgICApO1xuXG4gICAgICAgIGNhc2UgVGlwb01ldHJpY2EuTUFYSU1POlxuICAgICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGFyTWF4aW1vKFxuICAgICAgICAgICAgbWV0cmljYSxcbiAgICAgICAgICAgIHBlcmlvZG9JbmljaW8sXG4gICAgICAgICAgICBwZXJpb2RvRmltLFxuICAgICAgICAgICAgZGltZW5zb2VzLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgY2FzZSBUaXBvTWV0cmljYS5QRVJDRU5USUw6XG4gICAgICAgICAgY29uc3QgcGVyY2VudGlsID0gbWV0cmljYS5wYXJhbWV0cm9zX2VzcGVjaWZpY29zPy5wZXJjZW50aWwgfHwgOTA7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXJQZXJjZW50aWwoXG4gICAgICAgICAgICBtZXRyaWNhLFxuICAgICAgICAgICAgcGVyaW9kb0luaWNpbyxcbiAgICAgICAgICAgIHBlcmlvZG9GaW0sXG4gICAgICAgICAgICBkaW1lbnNvZXMsXG4gICAgICAgICAgICBwZXJjZW50aWwsXG4gICAgICAgICAgKTtcblxuICAgICAgICBjYXNlIFRpcG9NZXRyaWNhLkNBUkRJTkFMSURBREU6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXJDYXJkaW5hbGlkYWRlKFxuICAgICAgICAgICAgbWV0cmljYSxcbiAgICAgICAgICAgIHBlcmlvZG9JbmljaW8sXG4gICAgICAgICAgICBwZXJpb2RvRmltLFxuICAgICAgICAgICAgZGltZW5zb2VzLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgY2FzZSBUaXBvTWV0cmljYS5UQVhBX1ZBUklBQ0FPOlxuICAgICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGFyVGF4YVZhcmlhY2FvKFxuICAgICAgICAgICAgbWV0cmljYSxcbiAgICAgICAgICAgIHBlcmlvZG9JbmljaW8sXG4gICAgICAgICAgICBwZXJpb2RvRmltLFxuICAgICAgICAgICAgZGltZW5zb2VzLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgY2FzZSBUaXBvTWV0cmljYS5DT01QT1NUQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhck1ldHJpY2FDb21wb3N0YShcbiAgICAgICAgICAgIG1ldHJpY2EsXG4gICAgICAgICAgICBwZXJpb2RvSW5pY2lvLFxuICAgICAgICAgICAgcGVyaW9kb0ZpbSxcbiAgICAgICAgICAgIGRpbWVuc29lcyxcbiAgICAgICAgICApO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaXBvIGRlIG3DqXRyaWNhIG7Do28gc3Vwb3J0YWRvOiAke21ldHJpY2EudGlwb31gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBFcnJvIGFvIGNhbGN1bGFyIG3DqXRyaWNhICR7bWV0cmljYS5jb2RpZ299OiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3RhY2ssXG4gICAgICApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGEgbcOpdHJpY2EgZG8gdGlwbyBDT05UQUdFTVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjYWxjdWxhckNvbnRhZ2VtKFxuICAgIG1ldHJpY2E6IE1ldHJpY2FEZWZpbmljYW8sXG4gICAgcGVyaW9kb0luaWNpbzogRGF0ZSxcbiAgICBwZXJpb2RvRmltOiBEYXRlLFxuICAgIGRpbWVuc29lczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBpZiAoIW1ldHJpY2Euc3FsX2NvbnN1bHRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb25zdWx0YSBTUUwgbsOjbyBkZWZpbmlkYSBwYXJhIG3DqXRyaWNhICR7bWV0cmljYS5jb2RpZ299YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3FsT3JpZ2luYWwgPSBtZXRyaWNhLnNxbF9jb25zdWx0YTtcblxuICAgIC8vIFN1YnN0aXR1aXIgcGxhY2Vob2xkZXJzIGRlIHBlcsOtb2RvXG4gICAgbGV0IHNxbCA9IHNxbE9yaWdpbmFsXG4gICAgICAucmVwbGFjZSgvXFwkXFx7UEVSSU9ET19JTklDSU9cXH0vZywgYCcke3BlcmlvZG9JbmljaW8udG9JU09TdHJpbmcoKX0nYClcbiAgICAgIC5yZXBsYWNlKC9cXCRcXHtQRVJJT0RPX0ZJTVxcfS9nLCBgJyR7cGVyaW9kb0ZpbS50b0lTT1N0cmluZygpfSdgKTtcblxuICAgIC8vIFN1YnN0aXR1aXIgcGxhY2Vob2xkZXJzIGRlIGRpbWVuc8O1ZXNcbiAgICBmb3IgKGNvbnN0IFtjaGF2ZSwgdmFsb3JdIG9mIE9iamVjdC5lbnRyaWVzKGRpbWVuc29lcykpIHtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gYFxcJHtESU1FTlNBTy4ke2NoYXZlfX1gO1xuICAgICAgc3FsID0gc3FsLnJlcGxhY2UoXG4gICAgICAgIG5ldyBSZWdFeHAocGxhY2Vob2xkZXIsICdnJyksXG4gICAgICAgIHR5cGVvZiB2YWxvciA9PT0gJ3N0cmluZycgPyBgJyR7dmFsb3J9J2AgOiBTdHJpbmcodmFsb3IpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gRXhlY3V0YXIgY29uc3VsdGEgU1FMXG4gICAgICBjb25zdCByZXN1bHRhZG8gPSBhd2FpdCB0aGlzLmRhdGFTb3VyY2UucXVlcnkoc3FsKTtcblxuICAgICAgaWYgKCFyZXN1bHRhZG8gfHwgcmVzdWx0YWRvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgLy8gT2J0ZXIgbyBwcmltZWlybyB2YWxvciBkYSBwcmltZWlyYSBsaW5oYVxuICAgICAgY29uc3QgcHJpbWVpcmFMaW5oYSA9IHJlc3VsdGFkb1swXTtcbiAgICAgIGNvbnN0IHByaW1laXJhQ29sdW5hID0gT2JqZWN0LnZhbHVlcyhwcmltZWlyYUxpbmhhKVswXTtcblxuICAgICAgcmV0dXJuIE51bWJlcihwcmltZWlyYUNvbHVuYSkgfHwgMDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm8gbmEgZXhlY3XDp8OjbyBkYSBjb25zdWx0YSBTUUw6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEVycm8gYW8gZXhlY3V0YXIgY29uc3VsdGEgcGFyYSBtw6l0cmljYSAke21ldHJpY2EuY29kaWdvfTogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhIG3DqXRyaWNhIGRvIHRpcG8gU09NQVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjYWxjdWxhclNvbWEoXG4gICAgbWV0cmljYTogTWV0cmljYURlZmluaWNhbyxcbiAgICBwZXJpb2RvSW5pY2lvOiBEYXRlLFxuICAgIHBlcmlvZG9GaW06IERhdGUsXG4gICAgZGltZW5zb2VzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICApOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIC8vIEEgaW1wbGVtZW50YcOnw6NvIMOpIHNpbWlsYXIgw6AgY29udGFnZW0sIHBvaXMgYSBkaWZlcmVuw6dhIGVzdMOhIG5hIGNvbnN1bHRhIFNRTFxuICAgIHJldHVybiB0aGlzLmNhbGN1bGFyQ29udGFnZW0obWV0cmljYSwgcGVyaW9kb0luaWNpbywgcGVyaW9kb0ZpbSwgZGltZW5zb2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhIG3DqXRyaWNhIGRvIHRpcG8gTUVESUFcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY2FsY3VsYXJNZWRpYShcbiAgICBtZXRyaWNhOiBNZXRyaWNhRGVmaW5pY2FvLFxuICAgIHBlcmlvZG9JbmljaW86IERhdGUsXG4gICAgcGVyaW9kb0ZpbTogRGF0ZSxcbiAgICBkaW1lbnNvZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgLy8gQSBpbXBsZW1lbnRhw6fDo28gw6kgc2ltaWxhciDDoCBjb250YWdlbSwgcG9pcyBhIGRpZmVyZW7Dp2EgZXN0w6EgbmEgY29uc3VsdGEgU1FMXG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXJDb250YWdlbShtZXRyaWNhLCBwZXJpb2RvSW5pY2lvLCBwZXJpb2RvRmltLCBkaW1lbnNvZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGEgbcOpdHJpY2EgZG8gdGlwbyBNSU5JTU9cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY2FsY3VsYXJNaW5pbW8oXG4gICAgbWV0cmljYTogTWV0cmljYURlZmluaWNhbyxcbiAgICBwZXJpb2RvSW5pY2lvOiBEYXRlLFxuICAgIHBlcmlvZG9GaW06IERhdGUsXG4gICAgZGltZW5zb2VzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICApOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIC8vIEEgaW1wbGVtZW50YcOnw6NvIMOpIHNpbWlsYXIgw6AgY29udGFnZW0sIHBvaXMgYSBkaWZlcmVuw6dhIGVzdMOhIG5hIGNvbnN1bHRhIFNRTFxuICAgIHJldHVybiB0aGlzLmNhbGN1bGFyQ29udGFnZW0obWV0cmljYSwgcGVyaW9kb0luaWNpbywgcGVyaW9kb0ZpbSwgZGltZW5zb2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhIG3DqXRyaWNhIGRvIHRpcG8gTUFYSU1PXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNhbGN1bGFyTWF4aW1vKFxuICAgIG1ldHJpY2E6IE1ldHJpY2FEZWZpbmljYW8sXG4gICAgcGVyaW9kb0luaWNpbzogRGF0ZSxcbiAgICBwZXJpb2RvRmltOiBEYXRlLFxuICAgIGRpbWVuc29lczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAvLyBBIGltcGxlbWVudGHDp8OjbyDDqSBzaW1pbGFyIMOgIGNvbnRhZ2VtLCBwb2lzIGEgZGlmZXJlbsOnYSBlc3TDoSBuYSBjb25zdWx0YSBTUUxcbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhckNvbnRhZ2VtKG1ldHJpY2EsIHBlcmlvZG9JbmljaW8sIHBlcmlvZG9GaW0sIGRpbWVuc29lcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYSBtw6l0cmljYSBkbyB0aXBvIFBFUkNFTlRJTFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjYWxjdWxhclBlcmNlbnRpbChcbiAgICBtZXRyaWNhOiBNZXRyaWNhRGVmaW5pY2FvLFxuICAgIHBlcmlvZG9JbmljaW86IERhdGUsXG4gICAgcGVyaW9kb0ZpbTogRGF0ZSxcbiAgICBkaW1lbnNvZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgcGVyY2VudGlsOiBudW1iZXIsXG4gICk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgaWYgKCFtZXRyaWNhLnNxbF9jb25zdWx0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ29uc3VsdGEgU1FMIG7Do28gZGVmaW5pZGEgcGFyYSBtw6l0cmljYSAke21ldHJpY2EuY29kaWdvfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFN1YnN0aXR1aXIgcGxhY2Vob2xkZXIgZGUgcGVyY2VudGlsIG5hIGNvbnN1bHRhXG4gICAgbGV0IHNxbCA9IG1ldHJpY2Euc3FsX2NvbnN1bHRhXG4gICAgICAucmVwbGFjZSgvXFwkXFx7UEVSSU9ET19JTklDSU9cXH0vZywgYCcke3BlcmlvZG9JbmljaW8udG9JU09TdHJpbmcoKX0nYClcbiAgICAgIC5yZXBsYWNlKC9cXCRcXHtQRVJJT0RPX0ZJTVxcfS9nLCBgJyR7cGVyaW9kb0ZpbS50b0lTT1N0cmluZygpfSdgKVxuICAgICAgLnJlcGxhY2UoL1xcJFxce1BFUkNFTlRJTFxcfS9nLCBwZXJjZW50aWwudG9TdHJpbmcoKSk7XG5cbiAgICAvLyBTdWJzdGl0dWlyIHBsYWNlaG9sZGVycyBkZSBkaW1lbnPDtWVzXG4gICAgZm9yIChjb25zdCBbY2hhdmUsIHZhbG9yXSBvZiBPYmplY3QuZW50cmllcyhkaW1lbnNvZXMpKSB7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGBcXCR7RElNRU5TQU8uJHtjaGF2ZX19YDtcbiAgICAgIHNxbCA9IHNxbC5yZXBsYWNlKFxuICAgICAgICBuZXcgUmVnRXhwKHBsYWNlaG9sZGVyLCAnZycpLFxuICAgICAgICB0eXBlb2YgdmFsb3IgPT09ICdzdHJpbmcnID8gYCcke3ZhbG9yfSdgIDogU3RyaW5nKHZhbG9yKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEV4ZWN1dGFyIGNvbnN1bHRhIFNRTFxuICAgICAgY29uc3QgcmVzdWx0YWRvID0gYXdhaXQgdGhpcy5kYXRhU291cmNlLnF1ZXJ5KHNxbCk7XG5cbiAgICAgIGlmICghcmVzdWx0YWRvIHx8IHJlc3VsdGFkby5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIE9idGVyIG8gcHJpbWVpcm8gdmFsb3IgZGEgcHJpbWVpcmEgbGluaGFcbiAgICAgIGNvbnN0IHByaW1laXJhTGluaGEgPSByZXN1bHRhZG9bMF07XG4gICAgICBjb25zdCBwcmltZWlyYUNvbHVuYSA9IE9iamVjdC52YWx1ZXMocHJpbWVpcmFMaW5oYSlbMF07XG5cbiAgICAgIHJldHVybiBOdW1iZXIocHJpbWVpcmFDb2x1bmEpIHx8IDA7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvIG5hIGV4ZWN1w6fDo28gZGEgY29uc3VsdGEgU1FMOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFcnJvIGFvIGV4ZWN1dGFyIGNvbnN1bHRhIHBhcmEgbcOpdHJpY2EgJHttZXRyaWNhLmNvZGlnb306ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYSBtw6l0cmljYSBkbyB0aXBvIENBUkRJTkFMSURBREVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY2FsY3VsYXJDYXJkaW5hbGlkYWRlKFxuICAgIG1ldHJpY2E6IE1ldHJpY2FEZWZpbmljYW8sXG4gICAgcGVyaW9kb0luaWNpbzogRGF0ZSxcbiAgICBwZXJpb2RvRmltOiBEYXRlLFxuICAgIGRpbWVuc29lczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAvLyBBIGltcGxlbWVudGHDp8OjbyDDqSBzaW1pbGFyIMOgIGNvbnRhZ2VtLCBwb2lzIGEgZGlmZXJlbsOnYSBlc3TDoSBuYSBjb25zdWx0YSBTUUxcbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhckNvbnRhZ2VtKG1ldHJpY2EsIHBlcmlvZG9JbmljaW8sIHBlcmlvZG9GaW0sIGRpbWVuc29lcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYSBtw6l0cmljYSBkbyB0aXBvIFRBWEFfVkFSSUFDQU9cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY2FsY3VsYXJUYXhhVmFyaWFjYW8oXG4gICAgbWV0cmljYTogTWV0cmljYURlZmluaWNhbyxcbiAgICBwZXJpb2RvSW5pY2lvOiBEYXRlLFxuICAgIHBlcmlvZG9GaW06IERhdGUsXG4gICAgZGltZW5zb2VzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICApOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIC8vIENhbGN1bGFyIHZhbG9yIGF0dWFsXG4gICAgY29uc3QgdmFsb3JBdHVhbCA9IGF3YWl0IHRoaXMuY2FsY3VsYXJDb250YWdlbShcbiAgICAgIG1ldHJpY2EsXG4gICAgICBwZXJpb2RvSW5pY2lvLFxuICAgICAgcGVyaW9kb0ZpbSxcbiAgICAgIGRpbWVuc29lcyxcbiAgICApO1xuXG4gICAgLy8gQ2FsY3VsYXIgdmFsb3IgZG8gcGVyw61vZG8gYW50ZXJpb3JcbiAgICBjb25zdCBwZXJpb2RvRHVyYWNhbyA9IHBlcmlvZG9GaW0uZ2V0VGltZSgpIC0gcGVyaW9kb0luaWNpby5nZXRUaW1lKCk7XG4gICAgY29uc3QgcGVyaW9kb0FudGVyaW9yRmltID0gbmV3IERhdGUocGVyaW9kb0luaWNpby5nZXRUaW1lKCkpO1xuICAgIGNvbnN0IHBlcmlvZG9BbnRlcmlvckluaWNpbyA9IG5ldyBEYXRlKFxuICAgICAgcGVyaW9kb0luaWNpby5nZXRUaW1lKCkgLSBwZXJpb2RvRHVyYWNhbyxcbiAgICApO1xuXG4gICAgbGV0IHZhbG9yQW50ZXJpb3I6IG51bWJlcjtcblxuICAgIHRyeSB7XG4gICAgICB2YWxvckFudGVyaW9yID0gYXdhaXQgdGhpcy5jYWxjdWxhckNvbnRhZ2VtKFxuICAgICAgICBtZXRyaWNhLFxuICAgICAgICBwZXJpb2RvQW50ZXJpb3JJbmljaW8sXG4gICAgICAgIHBlcmlvZG9BbnRlcmlvckZpbSxcbiAgICAgICAgZGltZW5zb2VzLFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgYEVycm8gYW8gY2FsY3VsYXIgdmFsb3IgYW50ZXJpb3IgcGFyYSB0YXhhIGRlIHZhcmlhw6fDo286ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICAgIHZhbG9yQW50ZXJpb3IgPSAwO1xuICAgIH1cblxuICAgIC8vIEV2aXRhciBkaXZpc8OjbyBwb3IgemVyb1xuICAgIGlmICh2YWxvckFudGVyaW9yID09PSAwKSB7XG4gICAgICAvLyBTZSBvIHZhbG9yIGFudGVyaW9yIGZvciB6ZXJvIGUgbyBhdHVhbCBuw6NvIGZvciwgdGVtb3MgMTAwJSBkZSBhdW1lbnRvXG4gICAgICByZXR1cm4gdmFsb3JBdHVhbCA+IDAgPyAxMDAgOiAwO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGFyIHRheGEgZGUgdmFyaWHDp8OjbyBwZXJjZW50dWFsXG4gICAgY29uc3QgdGF4YVZhcmlhY2FvID1cbiAgICAgICgodmFsb3JBdHVhbCAtIHZhbG9yQW50ZXJpb3IpIC8gTWF0aC5hYnModmFsb3JBbnRlcmlvcikpICogMTAwO1xuICAgIHJldHVybiBOdW1iZXIodGF4YVZhcmlhY2FvLnRvRml4ZWQoMikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGEgbcOpdHJpY2EgZG8gdGlwbyBDT01QT1NUQVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjYWxjdWxhck1ldHJpY2FDb21wb3N0YShcbiAgICBtZXRyaWNhOiBNZXRyaWNhRGVmaW5pY2FvLFxuICAgIHBlcmlvZG9JbmljaW86IERhdGUsXG4gICAgcGVyaW9kb0ZpbTogRGF0ZSxcbiAgICBkaW1lbnNvZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgaWYgKCFtZXRyaWNhLmZvcm11bGFfY2FsY3Vsbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRsOzcm11bGEgZGUgY8OhbGN1bG8gbsOjbyBkZWZpbmlkYSBwYXJhIG3DqXRyaWNhIGNvbXBvc3RhICR7bWV0cmljYS5jb2RpZ299YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIW1ldHJpY2EubWV0cmljYXNfZGVwZW5kZW50ZXMgfHxcbiAgICAgIG1ldHJpY2EubWV0cmljYXNfZGVwZW5kZW50ZXMubGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNw6l0cmljYXMgZGVwZW5kZW50ZXMgbsOjbyBkZWZpbmlkYXMgcGFyYSBtw6l0cmljYSBjb21wb3N0YSAke21ldHJpY2EuY29kaWdvfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIE9idGVyIHZhbG9yZXMgZGUgdG9kYXMgYXMgbcOpdHJpY2FzIGRlcGVuZGVudGVzXG4gICAgY29uc3QgdmFsb3Jlc01ldHJpY2FzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGNvZGlnb01ldHJpY2Egb2YgbWV0cmljYS5tZXRyaWNhc19kZXBlbmRlbnRlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQnVzY2FyIGRlZmluacOnw6NvIGRhIG3DqXRyaWNhIGRlcGVuZGVudGVcbiAgICAgICAgY29uc3QgbWV0cmljYURlcGVuZGVudGUgPSBhd2FpdCB0aGlzLm1ldHJpY2FEZWZpbmljYW9SZXBvc2l0b3J5LmZpbmRPbmUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgd2hlcmU6IHsgY29kaWdvOiBjb2RpZ29NZXRyaWNhLCBhdGl2YTogdHJ1ZSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFtZXRyaWNhRGVwZW5kZW50ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBNw6l0cmljYSBkZXBlbmRlbnRlIG7Do28gZW5jb250cmFkYSBvdSBpbmF0aXZhOiAke2NvZGlnb01ldHJpY2F9YCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXIgdmFsb3IgZGEgbcOpdHJpY2EgZGVwZW5kZW50ZVxuICAgICAgICBjb25zdCB2YWxvciA9IGF3YWl0IHRoaXMuY2FsY3VsYXJWYWxvck1ldHJpY2EoXG4gICAgICAgICAgbWV0cmljYURlcGVuZGVudGUsXG4gICAgICAgICAgcGVyaW9kb0luaWNpbyxcbiAgICAgICAgICBwZXJpb2RvRmltLFxuICAgICAgICAgIGRpbWVuc29lcyxcbiAgICAgICAgKTtcblxuICAgICAgICB2YWxvcmVzTWV0cmljYXNbY29kaWdvTWV0cmljYV0gPSB2YWxvcjtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgIGBFcnJvIGFvIGNhbGN1bGFyIG3DqXRyaWNhIGRlcGVuZGVudGUgJHtjb2RpZ29NZXRyaWNhfTogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXJybyBhbyBjYWxjdWxhciBtw6l0cmljYSBkZXBlbmRlbnRlICR7Y29kaWdvTWV0cmljYX06ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEF2YWxpYXIgYSBmw7NybXVsYSBkZSBjw6FsY3VsbyBjb20gb3MgdmFsb3JlcyBvYnRpZG9zXG4gICAgdHJ5IHtcbiAgICAgIC8vIExpbXBhciBvIGNvbnRleHRvIGRvIHBhcnNlclxuICAgICAgdGhpcy5tYXRoUGFyc2VyLmNsZWFyKCk7XG5cbiAgICAgIC8vIERlZmluaXIgdmFyacOhdmVpcyBjb20gb3MgdmFsb3JlcyBkYXMgbcOpdHJpY2FzIGRlcGVuZGVudGVzXG4gICAgICBmb3IgKGNvbnN0IFtjb2RpZ28sIHZhbG9yXSBvZiBPYmplY3QuZW50cmllcyh2YWxvcmVzTWV0cmljYXMpKSB7XG4gICAgICAgIHRoaXMubWF0aFBhcnNlci5zZXQoY29kaWdvLCB2YWxvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEF2YWxpYXIgYSBmw7NybXVsYVxuICAgICAgY29uc3QgcmVzdWx0YWRvID0gdGhpcy5tYXRoUGFyc2VyLmV2YWx1YXRlKG1ldHJpY2EuZm9ybXVsYV9jYWxjdWxvKTtcblxuICAgICAgaWYgKGlzTmFOKHJlc3VsdGFkbykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXN1bHRhZG8gZG8gY8OhbGN1bG8gw6kgTmFOYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBOdW1iZXIocmVzdWx0YWRvKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBFcnJvIGFvIGF2YWxpYXIgZsOzcm11bGEgcGFyYSBtw6l0cmljYSAke21ldHJpY2EuY29kaWdvfTogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXJybyBhbyBhdmFsaWFyIGbDs3JtdWxhIHBhcmEgbcOpdHJpY2EgJHttZXRyaWNhLmNvZGlnb306ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==