{"file":"C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\metricas\\services\\metrica-calculo.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\eudre\\OneDrive\\Desktop\\Projetos\\pgben\\pgben-server\\src\\modules\\metricas\\services\\metrica-calculo.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, DataSource } from 'typeorm';\nimport { ConfigService } from '@nestjs/config';\nimport * as mathjs from 'mathjs';\n\nimport {\n  MetricaDefinicao,\n  TipoMetrica,\n} from '../../../entities/metrica-definicao.entity';\nimport { MetricaSnapshot } from '../../../entities/metrica-snapshot.entity';\n\n/**\n * Serviço responsável pelo cálculo de valores de métricas\n *\n * Este serviço implementa algoritmos para calcular valores de métricas\n * conforme seu tipo, fonte de dados e fórmulas definidas.\n */\n@Injectable()\nexport class MetricaCalculoService {\n  private readonly logger = new Logger(MetricaCalculoService.name);\n  private readonly mathParser: mathjs.Parser;\n\n  constructor(\n    @InjectRepository(MetricaDefinicao)\n    private readonly metricaDefinicaoRepository: Repository<MetricaDefinicao>,\n\n    @InjectRepository(MetricaSnapshot)\n    private readonly metricaSnapshotRepository: Repository<MetricaSnapshot>,\n\n    private readonly configService: ConfigService,\n    private readonly dataSource: DataSource,\n  ) {\n    // Inicializar o parser matemático para cálculo de fórmulas\n    this.mathParser = mathjs.parser();\n  }\n\n  /**\n   * Calcula o valor de uma métrica conforme sua definição e tipo\n   *\n   * @param metrica Definição da métrica\n   * @param periodoInicio Data de início do período\n   * @param periodoFim Data de fim do período\n   * @param dimensoes Dimensões para filtrar o cálculo\n   * @returns Valor numérico da métrica\n   */\n  async calcularValorMetrica(\n    metrica: MetricaDefinicao,\n    periodoInicio: Date,\n    periodoFim: Date,\n    dimensoes: Record<string, any> = {},\n  ): Promise<number> {\n    this.logger.debug(`Calculando valor para métrica: ${metrica.codigo}`);\n\n    try {\n      switch (metrica.tipo) {\n        case TipoMetrica.CONTAGEM:\n          return this.calcularContagem(\n            metrica,\n            periodoInicio,\n            periodoFim,\n            dimensoes,\n          );\n\n        case TipoMetrica.SOMA:\n          return this.calcularSoma(\n            metrica,\n            periodoInicio,\n            periodoFim,\n            dimensoes,\n          );\n\n        case TipoMetrica.MEDIA:\n          return this.calcularMedia(\n            metrica,\n            periodoInicio,\n            periodoFim,\n            dimensoes,\n          );\n\n        case TipoMetrica.MINIMO:\n          return this.calcularMinimo(\n            metrica,\n            periodoInicio,\n            periodoFim,\n            dimensoes,\n          );\n\n        case TipoMetrica.MAXIMO:\n          return this.calcularMaximo(\n            metrica,\n            periodoInicio,\n            periodoFim,\n            dimensoes,\n          );\n\n        case TipoMetrica.PERCENTIL:\n          const percentil = metrica.parametros_especificos?.percentil || 90;\n          return this.calcularPercentil(\n            metrica,\n            periodoInicio,\n            periodoFim,\n            dimensoes,\n            percentil,\n          );\n\n        case TipoMetrica.CARDINALIDADE:\n          return this.calcularCardinalidade(\n            metrica,\n            periodoInicio,\n            periodoFim,\n            dimensoes,\n          );\n\n        case TipoMetrica.TAXA_VARIACAO:\n          return this.calcularTaxaVariacao(\n            metrica,\n            periodoInicio,\n            periodoFim,\n            dimensoes,\n          );\n\n        case TipoMetrica.COMPOSTA:\n          return this.calcularMetricaComposta(\n            metrica,\n            periodoInicio,\n            periodoFim,\n            dimensoes,\n          );\n\n        default:\n          throw new Error(`Tipo de métrica não suportado: ${metrica.tipo}`);\n      }\n    } catch (error) {\n      this.logger.error(\n        `Erro ao calcular métrica ${metrica.codigo}: ${error.message}`,\n        error.stack,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Calcula métrica do tipo CONTAGEM\n   */\n  private async calcularContagem(\n    metrica: MetricaDefinicao,\n    periodoInicio: Date,\n    periodoFim: Date,\n    dimensoes: Record<string, any>,\n  ): Promise<number> {\n    if (!metrica.sql_consulta) {\n      throw new Error(\n        `Consulta SQL não definida para métrica ${metrica.codigo}`,\n      );\n    }\n\n    const sqlOriginal = metrica.sql_consulta;\n\n    // Substituir placeholders de período\n    let sql = sqlOriginal\n      .replace(/\\$\\{PERIODO_INICIO\\}/g, `'${periodoInicio.toISOString()}'`)\n      .replace(/\\$\\{PERIODO_FIM\\}/g, `'${periodoFim.toISOString()}'`);\n\n    // Substituir placeholders de dimensões\n    for (const [chave, valor] of Object.entries(dimensoes)) {\n      const placeholder = `\\${DIMENSAO.${chave}}`;\n      sql = sql.replace(\n        new RegExp(placeholder, 'g'),\n        typeof valor === 'string' ? `'${valor}'` : String(valor),\n      );\n    }\n\n    try {\n      // Executar consulta SQL\n      const resultado = await this.dataSource.query(sql);\n\n      if (!resultado || resultado.length === 0) {\n        return 0;\n      }\n\n      // Obter o primeiro valor da primeira linha\n      const primeiraLinha = resultado[0];\n      const primeiraColuna = Object.values(primeiraLinha)[0];\n\n      return Number(primeiraColuna) || 0;\n    } catch (error) {\n      this.logger.error(`Erro na execução da consulta SQL: ${error.message}`);\n      throw new Error(\n        `Erro ao executar consulta para métrica ${metrica.codigo}: ${error.message}`,\n      );\n    }\n  }\n\n  /**\n   * Calcula métrica do tipo SOMA\n   */\n  private async calcularSoma(\n    metrica: MetricaDefinicao,\n    periodoInicio: Date,\n    periodoFim: Date,\n    dimensoes: Record<string, any>,\n  ): Promise<number> {\n    // A implementação é similar à contagem, pois a diferença está na consulta SQL\n    return this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);\n  }\n\n  /**\n   * Calcula métrica do tipo MEDIA\n   */\n  private async calcularMedia(\n    metrica: MetricaDefinicao,\n    periodoInicio: Date,\n    periodoFim: Date,\n    dimensoes: Record<string, any>,\n  ): Promise<number> {\n    // A implementação é similar à contagem, pois a diferença está na consulta SQL\n    return this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);\n  }\n\n  /**\n   * Calcula métrica do tipo MINIMO\n   */\n  private async calcularMinimo(\n    metrica: MetricaDefinicao,\n    periodoInicio: Date,\n    periodoFim: Date,\n    dimensoes: Record<string, any>,\n  ): Promise<number> {\n    // A implementação é similar à contagem, pois a diferença está na consulta SQL\n    return this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);\n  }\n\n  /**\n   * Calcula métrica do tipo MAXIMO\n   */\n  private async calcularMaximo(\n    metrica: MetricaDefinicao,\n    periodoInicio: Date,\n    periodoFim: Date,\n    dimensoes: Record<string, any>,\n  ): Promise<number> {\n    // A implementação é similar à contagem, pois a diferença está na consulta SQL\n    return this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);\n  }\n\n  /**\n   * Calcula métrica do tipo PERCENTIL\n   */\n  private async calcularPercentil(\n    metrica: MetricaDefinicao,\n    periodoInicio: Date,\n    periodoFim: Date,\n    dimensoes: Record<string, any>,\n    percentil: number,\n  ): Promise<number> {\n    if (!metrica.sql_consulta) {\n      throw new Error(\n        `Consulta SQL não definida para métrica ${metrica.codigo}`,\n      );\n    }\n\n    // Substituir placeholder de percentil na consulta\n    let sql = metrica.sql_consulta\n      .replace(/\\$\\{PERIODO_INICIO\\}/g, `'${periodoInicio.toISOString()}'`)\n      .replace(/\\$\\{PERIODO_FIM\\}/g, `'${periodoFim.toISOString()}'`)\n      .replace(/\\$\\{PERCENTIL\\}/g, percentil.toString());\n\n    // Substituir placeholders de dimensões\n    for (const [chave, valor] of Object.entries(dimensoes)) {\n      const placeholder = `\\${DIMENSAO.${chave}}`;\n      sql = sql.replace(\n        new RegExp(placeholder, 'g'),\n        typeof valor === 'string' ? `'${valor}'` : String(valor),\n      );\n    }\n\n    try {\n      // Executar consulta SQL\n      const resultado = await this.dataSource.query(sql);\n\n      if (!resultado || resultado.length === 0) {\n        return 0;\n      }\n\n      // Obter o primeiro valor da primeira linha\n      const primeiraLinha = resultado[0];\n      const primeiraColuna = Object.values(primeiraLinha)[0];\n\n      return Number(primeiraColuna) || 0;\n    } catch (error) {\n      this.logger.error(`Erro na execução da consulta SQL: ${error.message}`);\n      throw new Error(\n        `Erro ao executar consulta para métrica ${metrica.codigo}: ${error.message}`,\n      );\n    }\n  }\n\n  /**\n   * Calcula métrica do tipo CARDINALIDADE\n   */\n  private async calcularCardinalidade(\n    metrica: MetricaDefinicao,\n    periodoInicio: Date,\n    periodoFim: Date,\n    dimensoes: Record<string, any>,\n  ): Promise<number> {\n    // A implementação é similar à contagem, pois a diferença está na consulta SQL\n    return this.calcularContagem(metrica, periodoInicio, periodoFim, dimensoes);\n  }\n\n  /**\n   * Calcula métrica do tipo TAXA_VARIACAO\n   */\n  private async calcularTaxaVariacao(\n    metrica: MetricaDefinicao,\n    periodoInicio: Date,\n    periodoFim: Date,\n    dimensoes: Record<string, any>,\n  ): Promise<number> {\n    // Calcular valor atual\n    const valorAtual = await this.calcularContagem(\n      metrica,\n      periodoInicio,\n      periodoFim,\n      dimensoes,\n    );\n\n    // Calcular valor do período anterior\n    const periodoDuracao = periodoFim.getTime() - periodoInicio.getTime();\n    const periodoAnteriorFim = new Date(periodoInicio.getTime());\n    const periodoAnteriorInicio = new Date(\n      periodoInicio.getTime() - periodoDuracao,\n    );\n\n    let valorAnterior: number;\n\n    try {\n      valorAnterior = await this.calcularContagem(\n        metrica,\n        periodoAnteriorInicio,\n        periodoAnteriorFim,\n        dimensoes,\n      );\n    } catch (error) {\n      this.logger.warn(\n        `Erro ao calcular valor anterior para taxa de variação: ${error.message}`,\n      );\n      valorAnterior = 0;\n    }\n\n    // Evitar divisão por zero\n    if (valorAnterior === 0) {\n      // Se o valor anterior for zero e o atual não for, temos 100% de aumento\n      return valorAtual > 0 ? 100 : 0;\n    }\n\n    // Calcular taxa de variação percentual\n    const taxaVariacao =\n      ((valorAtual - valorAnterior) / Math.abs(valorAnterior)) * 100;\n    return Number(taxaVariacao.toFixed(2));\n  }\n\n  /**\n   * Calcula métrica do tipo COMPOSTA\n   */\n  private async calcularMetricaComposta(\n    metrica: MetricaDefinicao,\n    periodoInicio: Date,\n    periodoFim: Date,\n    dimensoes: Record<string, any>,\n  ): Promise<number> {\n    if (!metrica.formula_calculo) {\n      throw new Error(\n        `Fórmula de cálculo não definida para métrica composta ${metrica.codigo}`,\n      );\n    }\n\n    if (\n      !metrica.metricas_dependentes ||\n      metrica.metricas_dependentes.length === 0\n    ) {\n      throw new Error(\n        `Métricas dependentes não definidas para métrica composta ${metrica.codigo}`,\n      );\n    }\n\n    // Obter valores de todas as métricas dependentes\n    const valoresMetricas: Record<string, number> = {};\n\n    for (const codigoMetrica of metrica.metricas_dependentes) {\n      try {\n        // Buscar definição da métrica dependente\n        const metricaDependente = await this.metricaDefinicaoRepository.findOne(\n          {\n            where: { codigo: codigoMetrica, ativa: true },\n          },\n        );\n\n        if (!metricaDependente) {\n          throw new Error(\n            `Métrica dependente não encontrada ou inativa: ${codigoMetrica}`,\n          );\n        }\n\n        // Calcular valor da métrica dependente\n        const valor = await this.calcularValorMetrica(\n          metricaDependente,\n          periodoInicio,\n          periodoFim,\n          dimensoes,\n        );\n\n        valoresMetricas[codigoMetrica] = valor;\n      } catch (error) {\n        this.logger.error(\n          `Erro ao calcular métrica dependente ${codigoMetrica}: ${error.message}`,\n        );\n        throw new Error(\n          `Erro ao calcular métrica dependente ${codigoMetrica}: ${error.message}`,\n        );\n      }\n    }\n\n    // Avaliar a fórmula de cálculo com os valores obtidos\n    try {\n      // Limpar o contexto do parser\n      this.mathParser.clear();\n\n      // Definir variáveis com os valores das métricas dependentes\n      for (const [codigo, valor] of Object.entries(valoresMetricas)) {\n        this.mathParser.set(codigo, valor);\n      }\n\n      // Avaliar a fórmula\n      const resultado = this.mathParser.evaluate(metrica.formula_calculo);\n\n      if (isNaN(resultado)) {\n        throw new Error(`Resultado do cálculo é NaN`);\n      }\n\n      return Number(resultado);\n    } catch (error) {\n      this.logger.error(\n        `Erro ao avaliar fórmula para métrica ${metrica.codigo}: ${error.message}`,\n      );\n      throw new Error(\n        `Erro ao avaliar fórmula para métrica ${metrica.codigo}: ${error.message}`,\n      );\n    }\n  }\n}\n"],"version":3}